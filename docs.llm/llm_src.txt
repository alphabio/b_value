Excluding patterns: 
Documentation for LLMs
Excluding patterns: 
Excluding patterns: -not -path */__pycache__/* -not -path */.venv/* -not -path */.next/* -not -path */venv/* -not -path */node_modules/* -not -path */build/* -not -path */dist/* -not -path */.git/* -not -path */.idea/* -not -path */.vscode/*
=== File: src/core/index.ts ===
// b_path:: src/core/index.ts

export * as Keyword from "./keywords";
export * from "./result";
export * as Type from "./types";
export * as Unit from "./units";


=== File: src/core/keywords/align-content-keywords.ts ===
// b_path:: src/core/keywords/align-content-keywords.ts
import { z } from "zod";

/**
 * CSS `align-content` property keyword values.
 *
 * The align-content property sets the distribution of space between and around
 * content items along a flexbox's cross-axis or a grid's block axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-content}
 *
 * @example
 * ```typescript
 * import { alignContentKeywordsSchema } from "@/core/keywords/align-content-keywords";
 *
 * const keyword = alignContentKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const alignContentKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items packed at start of cross axis"),
		z.literal("flex-end").describe("items packed at end of cross axis"),
		z.literal("center").describe("items centered along cross axis"),
		z.literal("space-between").describe("items evenly distributed, first/last at edges"),
		z.literal("space-around").describe("items evenly distributed with equal space around"),
		z.literal("space-evenly").describe("items evenly distributed with equal space between"),
		z.literal("stretch").describe("items stretched to fill container"),
		z.literal("start").describe("items packed at start of writing mode direction"),
		z.literal("end").describe("items packed at end of writing mode direction"),
	])
	.describe("CSS align-content property keyword values");

/**
 * Array of all align-content keyword values.
 *
 * @public
 */
export const ALIGN_CONTENT_KEYWORDS = alignContentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-content keywords.
 *
 * @public
 */
export type AlignContentKeyword = z.infer<typeof alignContentKeywordsSchema>;

/**
 * Metadata for align-content keyword options.
 *
 * @public
 */
export const alignContentKeywordOptions = alignContentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-content keyword options metadata.
 *
 * @public
 */
export type AlignContentKeywordOptions = typeof alignContentKeywordOptions;


=== File: src/core/keywords/align-items-keywords.ts ===
// b_path:: src/core/keywords/align-items-keywords.ts
import { z } from "zod";

/**
 * CSS `align-items` property keyword values.
 *
 * The align-items property sets the align-self value on all direct children as a group.
 * In flexbox, it controls the alignment of items on the cross axis. In grid layout,
 * it controls the alignment of items on the block axis within their grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-items}
 *
 * @example
 * ```typescript
 * import { alignItemsKeywordsSchema } from "@/core/keywords/align-items-keywords";
 *
 * const keyword = alignItemsKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const alignItemsKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items aligned at start of cross axis"),
		z.literal("flex-end").describe("items aligned at end of cross axis"),
		z.literal("center").describe("items centered along cross axis"),
		z.literal("baseline").describe("items aligned along their baselines"),
		z.literal("stretch").describe("items stretched to fill container"),
		z.literal("start").describe("items aligned at start of writing mode direction"),
		z.literal("end").describe("items aligned at end of writing mode direction"),
		z.literal("self-start").describe("items aligned at start of their own writing mode"),
		z.literal("self-end").describe("items aligned at end of their own writing mode"),
	])
	.describe("CSS align-items property keyword values");

/**
 * Array of all align-items keyword values.
 *
 * @public
 */
export const ALIGN_ITEMS_KEYWORDS = alignItemsKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-items keywords.
 *
 * @public
 */
export type AlignItemsKeyword = z.infer<typeof alignItemsKeywordsSchema>;

/**
 * Metadata for align-items keyword options.
 *
 * @public
 */
export const alignItemsKeywordOptions = alignItemsKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-items keyword options metadata.
 *
 * @public
 */
export type AlignItemsKeywordOptions = typeof alignItemsKeywordOptions;


=== File: src/core/keywords/align-self-keywords.ts ===
// b_path:: src/core/keywords/align-self-keywords.ts
import { z } from "zod";

/**
 * CSS `align-self` property keyword values.
 *
 * The align-self property overrides a grid or flex item's align-items value.
 * In grid layout, it aligns the item inside the grid area on the block axis (vertical).
 * In flexbox, it aligns the item on the cross axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-self}
 *
 * @example
 * ```typescript
 * import { alignSelfKeywordsSchema } from "@/core/keywords/align-self-keywords";
 *
 * const keyword = alignSelfKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const alignSelfKeywordsSchema = z
	.union([
		z.literal("auto").describe("uses parent's align-items value"),
		z.literal("start").describe("item aligned at start of writing mode direction"),
		z.literal("end").describe("item aligned at end of writing mode direction"),
		z.literal("center").describe("item centered along block axis"),
		z.literal("stretch").describe("item stretched to fill container"),
		z.literal("baseline").describe("item aligned along its baseline"),
		z.literal("flex-start").describe("item aligned at start of flex direction"),
		z.literal("flex-end").describe("item aligned at end of flex direction"),
		z.literal("self-start").describe("item aligned at start of its own writing mode"),
		z.literal("self-end").describe("item aligned at end of its own writing mode"),
	])
	.describe("CSS align-self property keyword values");

/**
 * Array of all align-self keyword values.
 *
 * @public
 */
export const ALIGN_SELF_KEYWORDS = alignSelfKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-self keywords.
 *
 * @public
 */
export type AlignSelfKeyword = z.infer<typeof alignSelfKeywordsSchema>;

/**
 * Metadata for align-self keyword options.
 *
 * @public
 */
export const alignSelfKeywordOptions = alignSelfKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-self keyword options metadata.
 *
 * @public
 */
export type AlignSelfKeywordOptions = typeof alignSelfKeywordOptions;


=== File: src/core/keywords/animation.ts ===
// b_path:: src/core/keywords/animation.ts

/**
 * CSS Animation Direction Keywords
 *
 * Keywords for the animation-direction property.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-direction}
 *
 * @public
 */
export const ANIMATION_DIRECTION_KEYWORDS = ["normal", "reverse", "alternate", "alternate-reverse"] as const;

/**
 * CSS Animation Direction Keyword Type
 *
 * @public
 */
export type AnimationDirectionKeyword = (typeof ANIMATION_DIRECTION_KEYWORDS)[number];

/**
 * CSS Animation Fill Mode Keywords
 *
 * Keywords for the animation-fill-mode property.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-fill-mode}
 *
 * @public
 */
export const ANIMATION_FILL_MODE_KEYWORDS = ["none", "forwards", "backwards", "both"] as const;

/**
 * CSS Animation Fill Mode Keyword Type
 *
 * @public
 */
export type AnimationFillModeKeyword = (typeof ANIMATION_FILL_MODE_KEYWORDS)[number];

/**
 * CSS Animation Play State Keywords
 *
 * Keywords for the animation-play-state property.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-play-state}
 *
 * @public
 */
export const ANIMATION_PLAY_STATE_KEYWORDS = ["running", "paused"] as const;

/**
 * CSS Animation Play State Keyword Type
 *
 * @public
 */
export type AnimationPlayStateKeyword = (typeof ANIMATION_PLAY_STATE_KEYWORDS)[number];

/**
 * CSS Easing Function Keywords
 *
 * Keyword values for easing functions (animation-timing-function, transition-timing-function).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function}
 * @see {@link https://www.w3.org/TR/css-easing-1/#easing-functions}
 *
 * @public
 */
export const EASING_KEYWORD_KEYWORDS = [
	"ease",
	"ease-in",
	"ease-out",
	"ease-in-out",
	"linear",
	"step-start",
	"step-end",
] as const;

/**
 * CSS Easing Function Keyword Type
 *
 * @public
 */
export type EasingKeywordKeyword = (typeof EASING_KEYWORD_KEYWORDS)[number];

/**
 * CSS Step Position Keywords
 *
 * Keywords for the step position parameter in steps() easing function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#steps}
 * @see {@link https://www.w3.org/TR/css-easing-1/#step-easing-functions}
 *
 * @public
 */
export const STEP_POSITION_KEYWORDS = ["jump-start", "jump-end", "jump-none", "jump-both", "start", "end"] as const;

/**
 * CSS Step Position Keyword Type
 *
 * @public
 */
export type StepPositionKeyword = (typeof STEP_POSITION_KEYWORDS)[number];


=== File: src/core/keywords/auto-keyword.ts ===
// b_path:: src/core/keywords/auto-keyword.ts
import { z } from "zod";

/**
 * CSS `auto` keyword.
 *
 * The `auto` keyword is used across many CSS properties to indicate
 * automatic calculation or default behavior. Context determines exact meaning.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/auto}
 *
 * @example
 * ```typescript
 * import { autoKeywordSchema } from "@/core/keywords/auto-keyword";
 *
 * // Parse and validate
 * const keyword = autoKeywordSchema.parse("auto"); // "auto"
 *
 * // Use in property values
 * const width = "auto";
 * ```
 *
 * @public
 */
export const autoKeywordSchema = z.literal("auto").describe("automatic calculation or default behavior");

/**
 * TypeScript type for the `auto` keyword.
 *
 * @public
 */
export type AutoKeyword = z.infer<typeof autoKeywordSchema>;

/**
 * Constant for the `auto` keyword value.
 *
 * @example
 * ```typescript
 * import { AUTO_KEYWORD } from "@/core/keywords/auto-keyword";
 *
 * if (value === AUTO_KEYWORD) {
 *   // Handle auto value
 * }
 * ```
 *
 * @public
 */
export const AUTO_KEYWORD = "auto" as const;

/**
 * Metadata for the `auto` keyword.
 *
 * Provides description for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { autoKeywordMetadata } from "@/core/keywords/auto-keyword";
 *
 * // Display in UI
 * <Option value="auto" description={autoKeywordMetadata.description} />
 * ```
 *
 * @public
 */
export const autoKeywordMetadata = {
	value: "auto",
	description: "automatic calculation or default behavior",
} as const;

/**
 * Type for auto keyword metadata.
 *
 * @public
 */
export type AutoKeywordMetadata = typeof autoKeywordMetadata;


=== File: src/core/keywords/background-attachment-keywords.ts ===
// b_path:: src/core/keywords/background-attachment-keywords.ts
import { z } from "zod";

/**
 * CSS background-attachment keywords.
 *
 * The background-attachment property sets whether a background image's position
 * is fixed within the viewport, or scrolls with its containing block.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment}
 *
 * @example
 * ```typescript
 * import { backgroundAttachmentKeywordsSchema } from "@/core/keywords/background-attachment-keywords";
 *
 * const keyword = backgroundAttachmentKeywordsSchema.parse("fixed"); // "fixed"
 * ```
 *
 * @public
 */
export const backgroundAttachmentKeywordsSchema = z
	.union([
		z
			.literal("scroll")
			.describe("background is fixed relative to the element itself and does not scroll with its contents"),
		z.literal("fixed").describe("background is fixed relative to the viewport"),
		z.literal("local").describe("background is fixed relative to the element's contents and scrolls with them"),
	])
	.describe(
		"Background attachment keywords control whether a background image scrolls with the page or is fixed. " +
			"Used in the background-attachment property.",
	);

/**
 * Array of all background-attachment keyword values.
 *
 * @example
 * ```typescript
 * import { BACKGROUND_ATTACHMENT_KEYWORDS } from "@/core/keywords/background-attachment-keywords";
 *
 * console.log(BACKGROUND_ATTACHMENT_KEYWORDS); // ["scroll", "fixed", "local"]
 * ```
 *
 * @public
 */
export const BACKGROUND_ATTACHMENT_KEYWORDS = backgroundAttachmentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for background-attachment keywords.
 *
 * @public
 */
export type BackgroundAttachmentKeyword = z.infer<typeof backgroundAttachmentKeywordsSchema>;

/**
 * Metadata for background-attachment keyword options.
 *
 * Provides value and description for each background-attachment keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { backgroundAttachmentKeywordOptions } from "@/core/keywords/background-attachment-keywords";
 *
 * backgroundAttachmentKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const backgroundAttachmentKeywordOptions = backgroundAttachmentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for background-attachment keyword options metadata.
 *
 * @public
 */
export type BackgroundAttachmentKeywordOptions = typeof backgroundAttachmentKeywordOptions;


=== File: src/core/keywords/basic-color-keywords.ts ===
// b_path:: src/core/keywords/basic-color-keywords.ts
import { z } from "zod";

/**
 * CSS basic named colors (22 colors).
 *
 * Common subset of named colors for basic use cases.
 * These are the most commonly used color names in CSS.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const basicNamedColorKeywordsSchema = z
	.union([
		z.literal("black").describe("Pure black color (#000000)"),
		z.literal("white").describe("Pure white color (#FFFFFF)"),
		z.literal("red").describe("Pure red color (#FF0000)"),
		z.literal("green").describe("Pure green color (#008000)"),
		z.literal("blue").describe("Pure blue color (#0000FF)"),
		z.literal("yellow").describe("Pure yellow color (#FFFF00)"),
		z.literal("orange").describe("Orange color (#FFA500)"),
		z.literal("purple").describe("Purple color (#800080)"),
		z.literal("pink").describe("Pink color (#FFC0CB)"),
		z.literal("brown").describe("Brown color (#A52A2A)"),
		z.literal("gray").describe("Gray color (#808080)"),
		z.literal("grey").describe("Alternative spelling of gray"),
		z.literal("silver").describe("Silver color (#C0C0C0)"),
		z.literal("gold").describe("Gold color (#FFD700)"),
		z.literal("navy").describe("Navy blue color (#000080)"),
		z.literal("teal").describe("Teal color (#008080)"),
		z.literal("lime").describe("Lime color (#00FF00)"),
		z.literal("aqua").describe("Aqua color (#00FFFF)"),
		z.literal("fuchsia").describe("Fuchsia color (#FF00FF)"),
		z.literal("maroon").describe("Maroon color (#800000)"),
		z.literal("olive").describe("Olive color (#808000)"),
		z.literal("cyan").describe("Cyan color (#00FFFF)"),
	])
	.describe("CSS basic named colors");

/**
 * Array of all basic named color keyword values.
 *
 * @example
 * ```typescript
 * import { BASIC_NAMED_COLOR_KEYWORDS } from "@/core/keywords/basic-color-keywords";
 *
 * console.log(BASIC_NAMED_COLOR_KEYWORDS); // ["black", "white", "red", ...]
 * ```
 *
 * @public
 */
export const BASIC_NAMED_COLOR_KEYWORDS = basicNamedColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for basic named color keywords.
 *
 * @public
 */
export type BasicNamedColorKeyword = z.infer<typeof basicNamedColorKeywordsSchema>;

/**
 * Metadata for basic named color keyword options.
 *
 * Provides value and description for each basic named color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { basicNamedColorKeywordOptions } from "@/core/keywords/basic-color-keywords";
 *
 * basicNamedColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const basicNamedColorKeywordOptions = basicNamedColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for basic named color keyword options metadata.
 *
 * @public
 */
export type BasicNamedColorKeywordOptions = typeof basicNamedColorKeywordOptions;


=== File: src/core/keywords/blend-mode-keywords.ts ===
// b_path:: src/core/keywords/blend-mode-keywords.ts
import { z } from "zod";

/**
 * CSS blend mode keywords.
 *
 * Blend modes describe how colors should appear when elements overlap.
 * Each mode defines a different way to combine the top and bottom colors.
 *
 * Used in:
 * - `background-blend-mode` - Blending between background layers
 * - `mix-blend-mode` - Blending an element with its backdrop
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/blend-mode}
 *
 * @example
 * ```typescript
 * import { blendModeKeywordsSchema } from "@/core/keywords/blend-mode-keywords";
 *
 * const keyword = blendModeKeywordsSchema.parse("multiply"); // "multiply"
 * ```
 *
 * @public
 */
export const blendModeKeywordsSchema = z
	.union([
		z.literal("normal").describe("top color, regardless of bottom color"),
		z.literal("multiply").describe("result of multiplying top and bottom colors"),
		z.literal("screen").describe("result of inverting colors, multiplying, and inverting"),
		z.literal("overlay").describe("multiply if bottom darker, screen if bottom lighter"),
		z.literal("darken").describe("darkest values of each color channel"),
		z.literal("lighten").describe("lightest values of each color channel"),
		z.literal("color-dodge").describe("dividing bottom color by inverse of top color"),
		z.literal("color-burn").describe("inverting bottom, dividing by top, inverting result"),
		z.literal("hard-light").describe("multiply if top darker, screen if top lighter"),
		z.literal("soft-light").describe("similar to hard-light but softer"),
		z.literal("difference").describe("subtracting darker color from lighter"),
		z.literal("exclusion").describe("similar to difference but with less contrast"),
		z.literal("hue").describe("hue of top color, saturation and luminosity of bottom"),
		z.literal("saturation").describe("saturation of top color, hue and luminosity of bottom"),
		z.literal("color").describe("hue and saturation of top, luminosity of bottom"),
		z.literal("luminosity").describe("luminosity of top, hue and saturation of bottom"),
	])
	.describe(
		"Blend modes describe how colors should appear when elements overlap. " +
			"Used in background-blend-mode and mix-blend-mode properties.",
	);

/**
 * Array of all blend mode keyword values.
 *
 * @example
 * ```typescript
 * import { BLEND_MODE_KEYWORDS } from "@/core/keywords/blend-mode-keywords";
 *
 * console.log(BLEND_MODE_KEYWORDS);
 * // ["normal", "multiply", "screen", "overlay", "darken", "lighten", ...]
 * ```
 *
 * @public
 */
export const BLEND_MODE_KEYWORDS = blendModeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for blend mode keywords.
 *
 * @public
 */
export type BlendModeKeyword = z.infer<typeof blendModeKeywordsSchema>;

/**
 * Metadata for blend mode keyword options.
 *
 * Provides value and description for each blend mode keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { blendModeKeywordOptions } from "@/core/keywords/blend-mode-keywords";
 *
 * blendModeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const blendModeKeywordOptions = blendModeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for blend mode keyword options metadata.
 *
 * @public
 */
export type BlendModeKeywordOptions = typeof blendModeKeywordOptions;


=== File: src/core/keywords/border-style-keywords.ts ===
// b_path:: src/core/keywords/border-style-keywords.ts
import { z } from "zod";

/**
 * CSS border-style keywords.
 *
 * Defines the style of the border line for all four sides of an element's border.
 * These keywords control how the border appears visually.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style}
 *
 * @example
 * ```typescript
 * import { borderStyleKeywordsSchema } from "@/core/keywords/border-style-keywords";
 *
 * const keyword = borderStyleKeywordsSchema.parse("solid"); // "solid"
 * ```
 *
 * @public
 */
export const borderStyleKeywordsSchema = z
	.union([
		z.literal("none").describe("No border"),
		z.literal("hidden").describe("Same as none, but with different behavior in table elements"),
		z.literal("dotted").describe("Series of round dots"),
		z.literal("dashed").describe("Series of short square-ended dashes"),
		z.literal("solid").describe("Single, straight, solid line"),
		z.literal("double").describe("Two straight lines that add up to the pixel size defined by border-width"),
		z.literal("groove").describe("Carved effect - opposite of ridge"),
		z.literal("ridge").describe("Extruded effect - opposite of groove"),
		z.literal("inset").describe("Border makes element appear embedded"),
		z.literal("outset").describe("Border makes element appear raised"),
	])
	.describe("CSS border style keywords");

/**
 * Array of all border-style keyword values.
 *
 * @example
 * ```typescript
 * import { BORDER_STYLE_KEYWORDS } from "@/core/keywords/border-style-keywords";
 *
 * console.log(BORDER_STYLE_KEYWORDS); // ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
 * ```
 *
 * @public
 */
export const BORDER_STYLE_KEYWORDS = borderStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for border-style keywords.
 *
 * @public
 */
export type BorderStyleKeyword = z.infer<typeof borderStyleKeywordsSchema>;

/**
 * Metadata for border-style keyword options.
 *
 * Provides value and description for each border-style keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { borderStyleKeywordOptions } from "@/core/keywords/border-style-keywords";
 *
 * borderStyleKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const borderStyleKeywordOptions = borderStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for border-style keyword options metadata.
 *
 * @public
 */
export type BorderStyleKeywordOptions = typeof borderStyleKeywordOptions;


=== File: src/core/keywords/border-width-keywords.ts ===
// b_path:: src/core/keywords/border-width-keywords.ts
import { z } from "zod";
import type * as Type from "../types";

/**
 * CSS border-width keywords.
 *
 * Predefined border width values that correspond to specific thickness levels.
 * These keywords provide a convenient way to specify common border widths without
 * needing to specify exact measurements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width}
 *
 * @example
 * ```typescript
 * import { borderWidthKeywordsSchema } from "@/core/keywords/border-width-keywords";
 *
 * const keyword = borderWidthKeywordsSchema.parse("medium"); // "medium"
 * ```
 *
 * @public
 */
export const borderWidthKeywordsSchema = z
	.union([
		z.literal("thin").describe("A thin border (typically 1px)"),
		z.literal("medium").describe("A medium border (typically 3px)"),
		z.literal("thick").describe("A thick border (typically 5px)"),
	])
	.describe("Predefined border width keywords");

/**
 * Array of all border-width keyword values.
 *
 * @example
 * ```typescript
 * import { BORDER_WIDTH_KEYWORDS } from "@/core/keywords/border-width-keywords";
 *
 * console.log(BORDER_WIDTH_KEYWORDS); // ["thin", "medium", "thick"]
 * ```
 *
 * @public
 */
export const BORDER_WIDTH_KEYWORDS = borderWidthKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for border-width keywords.
 *
 * @public
 */
export type BorderWidthKeyword = z.infer<typeof borderWidthKeywordsSchema>;

/**
 * TypeScript type for border-width values (keywords or length).
 *
 * @public
 */
export type BorderWidthValue = z.infer<typeof borderWidthKeywordsSchema> | Type.Length;

/**
 * Metadata for border-width keyword options.
 *
 * Provides value and description for each border-width keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { borderWidthKeywordOptions } from "@/core/keywords/border-width-keywords";
 *
 * borderWidthKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const borderWidthKeywordOptions = borderWidthKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for border-width keyword options metadata.
 *
 * @public
 */
export type BorderWidthKeywordOptions = typeof borderWidthKeywordOptions;


=== File: src/core/keywords/box-edge-keywords.ts ===
// b_path:: src/core/keywords/box-edge-keywords.ts
import { z } from "zod";
import { visualBoxKeywords } from "./geometry-box";

/**
 * CSS box edge keywords.
 *
 * Box edge keywords define reference boxes for positioning, clipping, and layout.
 * Used in properties like clip-path, shape-outside, background-clip, and background-origin.
 *
 * Note: For spec-compliant visual-box, shape-box, and geometry-box hierarchies,
 * see geometry-box.ts which follows the CSS specification exactly.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-edge}
 *
 * @example
 * ```typescript
 * import { boxEdgeKeywordsSchema } from "@/core/keywords/box-edge-keywords";
 *
 * const keyword = boxEdgeKeywordsSchema.parse("border-box"); // "border-box"
 * ```
 *
 * @public
 */
export const boxEdgeKeywordsSchema = z
	.union([
		// Visual box (content, padding, border)
		z
			.literal("content-box")
			.describe("outer edge of the box's content area"),
		z.literal("padding-box").describe("outer edge of the padding of the box"),
		z.literal("border-box").describe("outer edge of the border of the box"),

		// Layout box (includes margin)
		z
			.literal("margin-box")
			.describe("outer edge of the margin of the box"),

		// SVG-specific boxes
		z
			.literal("fill-box")
			.describe("object bounding box in SVG"),
		z.literal("stroke-box").describe("stroke bounding box in SVG"),
		z.literal("view-box").describe("nearest SVG viewport element's origin box"),
	])
	.describe(
		"Box edge keywords define reference boxes for positioning, clipping, and layout. " +
			"Used in properties like clip-path, shape-outside, background-clip, and background-origin.",
	);

/**
 * Array of all box edge keyword values.
 *
 * @example
 * ```typescript
 * import { BOX_EDGE_KEYWORDS } from "@/core/keywords/box-edge-keywords";
 *
 * console.log(BOX_EDGE_KEYWORDS);
 * // ["content-box", "padding-box", "border-box", "margin-box", "fill-box", "stroke-box", "view-box"]
 * ```
 *
 * @public
 */
export const BOX_EDGE_KEYWORDS = boxEdgeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for box edge keywords.
 *
 * @public
 */
export type BoxEdgeKeyword = z.infer<typeof boxEdgeKeywordsSchema>;

/**
 * Metadata for box edge keyword options.
 *
 * Provides value and description for each box edge keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { boxEdgeKeywordOptions } from "@/core/keywords/box-edge-keywords";
 *
 * boxEdgeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const boxEdgeKeywordOptions = boxEdgeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for box edge keyword options metadata.
 *
 * @public
 */
export type BoxEdgeKeywordOptions = typeof boxEdgeKeywordOptions;

/**
 * CSS background-clip keywords.
 *
 * Extends visual box keywords with the 'text' keyword which is specific to background-clip.
 * The 'text' keyword clips the background to the foreground text (WebKit prefixed in practice).
 *
 * Uses visual box keywords from geometry-box.ts for spec compliance.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip}
 *
 * @example
 * ```typescript
 * import { backgroundClipKeywordsSchema } from "@/core/keywords/box-edge-keywords";
 *
 * const keyword = backgroundClipKeywordsSchema.parse("text"); // "text"
 * ```
 *
 * @public
 */
export const backgroundClipKeywordsSchema = z
	.enum([...visualBoxKeywords, "text"] as const)
	.describe("Background-clip keywords: visual box keywords plus 'text' for clipping to foreground text.");

/**
 * Array of background-clip keyword values.
 *
 * @public
 */
export const BACKGROUND_CLIP_KEYWORDS = ["content-box", "padding-box", "border-box", "text"] as const;

/**
 * TypeScript type for background-clip keywords.
 *
 * @public
 */
export type BackgroundClipKeyword = z.infer<typeof backgroundClipKeywordsSchema>;


=== File: src/core/keywords/color-interpolation-keywords.ts ===
// b_path:: src/core/keywords/color-interpolation-keywords.ts
import { z } from "zod";

/**
 * Rectangular color space keywords for color interpolation.
 *
 * Rectangular (Cartesian) color spaces use perpendicular axes
 * for each color channel. Used for color interpolation in gradients,
 * animations, and color-mix() function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 * @public
 */
export const rectangularColorSpaceKeywordsSchema = z
	.union([
		z.literal("srgb").describe("sRGB color space"),
		z.literal("srgb-linear").describe("linear sRGB color space"),
		z.literal("display-p3").describe("Display P3 color space"),
		z.literal("display-p3-linear").describe("linear Display P3 color space"),
		z.literal("a98-rgb").describe("Adobe RGB (1998) color space"),
		z.literal("prophoto-rgb").describe("ProPhoto RGB color space"),
		z.literal("rec2020").describe("Rec. 2020 color space"),
		z.literal("lab").describe("CIE LAB color space"),
		z.literal("oklab").describe("OKLab color space"),
		z.literal("xyz").describe("CIE XYZ color space"),
		z.literal("xyz-d50").describe("CIE XYZ color space with D50 white point"),
		z.literal("xyz-d65").describe("CIE XYZ color space with D65 white point"),
	])
	.describe("Rectangular color spaces for color interpolation");

/**
 * Polar color space keywords for color interpolation.
 *
 * Polar (cylindrical) color spaces use hue as a circular component
 * and other attributes as radial distances. Used for color interpolation
 * in gradients, animations, and color-mix() function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 * @public
 */
export const polarColorSpaceKeywordsSchema = z
	.union([
		z.literal("hsl").describe("HSL color space"),
		z.literal("hwb").describe("HWB color space"),
		z.literal("lch").describe("CIE LCH color space"),
		z.literal("oklch").describe("OKLCh color space"),
	])
	.describe("Polar color spaces for color interpolation");

/**
 * Hue interpolation method keywords for polar color spaces.
 *
 * When using polar color spaces, hue can be interpolated in different ways
 * around the color wheel. These keywords control that interpolation.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/hue-interpolation-method}
 * @public
 */
export const hueInterpolationMethodKeywordsSchema = z
	.union([
		z.literal("shorter").describe("shorter hue interpolation (default)"),
		z.literal("longer").describe("longer hue interpolation"),
		z.literal("increasing").describe("increasing hue interpolation"),
		z.literal("decreasing").describe("decreasing hue interpolation"),
	])
	.describe("Hue interpolation methods for polar color spaces");

/**
 * CSS color interpolation keywords.
 *
 * Color interpolation methods specify how colors are interpolated
 * in gradients, animations, and the color-mix() function.
 *
 * Includes:
 * - Rectangular color spaces (sRGB, Display P3, LAB, etc.)
 * - Polar color spaces (HSL, HWB, LCH, OKLCH)
 * - Hue interpolation methods (shorter, longer, increasing, decreasing)
 *
 * Used in:
 * - CSS gradients with `in` keyword
 * - color-mix() function
 * - CSS animations and transitions
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 *
 * @example
 * ```typescript
 * import { colorInterpolationKeywordsSchema } from "@/core/keywords/color-interpolation-keywords";
 *
 * const keyword = colorInterpolationKeywordsSchema.parse("oklch"); // "oklch"
 * ```
 *
 * @public
 */
export const colorInterpolationKeywordsSchema = z
	.union([
		// Rectangular color spaces
		z
			.literal("srgb")
			.describe("sRGB color space"),
		z.literal("srgb-linear").describe("linear sRGB color space"),
		z.literal("display-p3").describe("Display P3 color space"),
		z.literal("display-p3-linear").describe("linear Display P3 color space"),
		z.literal("a98-rgb").describe("Adobe RGB (1998) color space"),
		z.literal("prophoto-rgb").describe("ProPhoto RGB color space"),
		z.literal("rec2020").describe("Rec. 2020 color space"),
		z.literal("lab").describe("CIE LAB color space"),
		z.literal("oklab").describe("OKLab color space"),
		z.literal("xyz").describe("CIE XYZ color space"),
		z.literal("xyz-d50").describe("CIE XYZ color space with D50 white point"),
		z.literal("xyz-d65").describe("CIE XYZ color space with D65 white point"),

		// Polar color spaces
		z
			.literal("hsl")
			.describe("HSL color space"),
		z.literal("hwb").describe("HWB color space"),
		z.literal("lch").describe("CIE LCH color space"),
		z.literal("oklch").describe("OKLCh color space"),

		// Hue interpolation methods
		z
			.literal("shorter")
			.describe("shorter hue interpolation (default)"),
		z.literal("longer").describe("longer hue interpolation"),
		z.literal("increasing").describe("increasing hue interpolation"),
		z.literal("decreasing").describe("decreasing hue interpolation"),
	])
	.describe(
		"Color interpolation methods specify how colors are interpolated in gradients and animations. " +
			"Can use rectangular or polar color spaces with optional hue interpolation.",
	);

/**
 * Array of all color interpolation keyword values.
 *
 * @example
 * ```typescript
 * import { COLOR_INTERPOLATION_KEYWORDS } from "@/core/keywords/color-interpolation-keywords";
 *
 * console.log(COLOR_INTERPOLATION_KEYWORDS);
 * // ["srgb", "srgb-linear", "display-p3", "hsl", "hwb", "shorter", ...]
 * ```
 *
 * @public
 */
export const COLOR_INTERPOLATION_KEYWORDS = colorInterpolationKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for color interpolation keywords.
 *
 * @public
 */
export type ColorInterpolationKeyword = z.infer<typeof colorInterpolationKeywordsSchema>;

/**
 * Metadata for color interpolation keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { colorInterpolationKeywordOptions } from "@/core/keywords/color-interpolation-keywords";
 *
 * colorInterpolationKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const colorInterpolationKeywordOptions = colorInterpolationKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for color interpolation keyword options metadata.
 *
 * @public
 */
export type ColorInterpolationKeywordOptions = typeof colorInterpolationKeywordOptions;


=== File: src/core/keywords/color-keywords.ts ===
// b_path:: src/core/keywords/color-keywords.ts
import { z } from "zod";

/**
 * CSS special color keywords.
 *
 * These keywords have special meaning in CSS color contexts.
 * - `transparent`: Fully transparent color
 * - `currentcolor`: Uses the current text color
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @public
 */
export const specialColorKeywordsSchema = z
	.union([
		z.literal("transparent").describe("Fully transparent color"),
		z.literal("currentcolor").describe("Uses the current text color value"),
	])
	.describe("CSS special color keywords");

/**
 * Array of all special color keyword values.
 *
 * @example
 * ```typescript
 * import { SPECIAL_COLOR_KEYWORDS } from "@/core/keywords/color-keywords";
 *
 * console.log(SPECIAL_COLOR_KEYWORDS); // ["transparent", "currentcolor"]
 * ```
 *
 * @public
 */
export const SPECIAL_COLOR_KEYWORDS = specialColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for special color keywords.
 *
 * @public
 */
export type SpecialColorKeyword = z.infer<typeof specialColorKeywordsSchema>;

/**
 * Metadata for special color keyword options.
 *
 * Provides value and description for each special color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { specialColorKeywordOptions } from "@/core/keywords/color-keywords";
 *
 * specialColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const specialColorKeywordOptions = specialColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for special color keyword options metadata.
 *
 * @public
 */
export type SpecialColorKeywordOptions = typeof specialColorKeywordOptions;


=== File: src/core/keywords/color-value-keywords.ts ===
// b_path:: src/core/keywords/color-value-keywords.ts
import { z } from "zod";

/**
 * CSS hex color pattern.
 *
 * Matches 3, 4, 6, or 8 digit hex colors with # prefix.
 * Supports alpha channel (4 and 8 digit formats).
 *
 * @example
 * ```typescript
 * "#f00"      // 3-digit
 * "#ff0000"   // 6-digit
 * "#f00f"     // 4-digit with alpha
 * "#ff0000ff" // 8-digit with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color}
 * @public
 */
export const hexColorKeywordsSchema = z
	.string()
	.regex(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/)
	.describe("CSS hex color");

/**
 * CSS rgb() or rgba() function pattern.
 *
 * Simplified pattern for rgb() and rgba() functions.
 * Supports both legacy comma syntax and modern space syntax.
 *
 * @example
 * ```typescript
 * "rgb(255, 0, 0)"          // Legacy comma syntax
 * "rgba(255, 0, 0, 0.5)"    // Legacy with alpha
 * "rgb(255 0 0)"            // Modern space syntax
 * "rgb(255 0 0 / 0.5)"      // Modern with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb}
 * @public
 */
export const rgbColorKeywordsSchema = z
	.string()
	.regex(/^rgba?\(\s*\d+\s*(?:,\s*\d+\s*,\s*\d+|[\s]+\d+[\s]+\d+)\s*(?:[,/]\s*[\d.]+\s*)?\)$/)
	.describe("CSS rgb() or rgba() function");

/**
 * CSS hsl() or hsla() function pattern.
 *
 * Simplified pattern for hsl() and hsla() functions.
 * Supports both legacy comma syntax and modern space syntax.
 *
 * @example
 * ```typescript
 * "hsl(0, 100%, 50%)"       // Legacy comma syntax
 * "hsla(0, 100%, 50%, 0.5)" // Legacy with alpha
 * "hsl(0 100% 50%)"         // Modern space syntax
 * "hsl(0 100% 50% / 0.5)"   // Modern with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl}
 * @public
 */
export const hslColorKeywordsSchema = z
	.string()
	.regex(/^hsla?\(\s*\d+\s*(?:,\s*\d+%\s*,\s*\d+%|[\s]+\d+%[\s]+\d+%)\s*(?:[,/]\s*[\d.]+\s*)?\)$/)
	.describe("CSS hsl() or hsla() function");

/**
 * All CSS named colors (special + basic + extended = ~148 colors).
 *
 * Complete set of named colors supported in CSS Color Module Level 4.
 * Colors are case-insensitive in CSS - normalize to lowercase before validation.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#named-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const namedColorKeywordsSchema = z
	.union([
		z.literal("transparent"),
		z.literal("currentcolor"),
		z.literal("black"),
		z.literal("white"),
		z.literal("red"),
		z.literal("green"),
		z.literal("blue"),
		z.literal("yellow"),
		z.literal("orange"),
		z.literal("purple"),
		z.literal("pink"),
		z.literal("brown"),
		z.literal("gray"),
		z.literal("grey"),
		z.literal("silver"),
		z.literal("gold"),
		z.literal("navy"),
		z.literal("teal"),
		z.literal("lime"),
		z.literal("aqua"),
		z.literal("fuchsia"),
		z.literal("maroon"),
		z.literal("olive"),
		z.literal("cyan"),
		z.literal("aliceblue"),
		z.literal("antiquewhite"),
		z.literal("aquamarine"),
		z.literal("azure"),
		z.literal("beige"),
		z.literal("bisque"),
		z.literal("blanchedalmond"),
		z.literal("blueviolet"),
		z.literal("burlywood"),
		z.literal("cadetblue"),
		z.literal("chartreuse"),
		z.literal("chocolate"),
		z.literal("coral"),
		z.literal("cornflowerblue"),
		z.literal("cornsilk"),
		z.literal("crimson"),
		z.literal("darkblue"),
		z.literal("darkcyan"),
		z.literal("darkgoldenrod"),
		z.literal("darkgray"),
		z.literal("darkgrey"),
		z.literal("darkgreen"),
		z.literal("darkkhaki"),
		z.literal("darkmagenta"),
		z.literal("darkolivegreen"),
		z.literal("darkorange"),
		z.literal("darkorchid"),
		z.literal("darkred"),
		z.literal("darksalmon"),
		z.literal("darkseagreen"),
		z.literal("darkslateblue"),
		z.literal("darkslategray"),
		z.literal("darkslategrey"),
		z.literal("darkturquoise"),
		z.literal("darkviolet"),
		z.literal("deeppink"),
		z.literal("deepskyblue"),
		z.literal("dimgray"),
		z.literal("dimgrey"),
		z.literal("dodgerblue"),
		z.literal("firebrick"),
		z.literal("floralwhite"),
		z.literal("forestgreen"),
		z.literal("gainsboro"),
		z.literal("ghostwhite"),
		z.literal("goldenrod"),
		z.literal("greenyellow"),
		z.literal("honeydew"),
		z.literal("hotpink"),
		z.literal("indianred"),
		z.literal("indigo"),
		z.literal("ivory"),
		z.literal("khaki"),
		z.literal("lavender"),
		z.literal("lavenderblush"),
		z.literal("lawngreen"),
		z.literal("lemonchiffon"),
		z.literal("lightblue"),
		z.literal("lightcoral"),
		z.literal("lightcyan"),
		z.literal("lightgoldenrodyellow"),
		z.literal("lightgray"),
		z.literal("lightgrey"),
		z.literal("lightgreen"),
		z.literal("lightpink"),
		z.literal("lightsalmon"),
		z.literal("lightseagreen"),
		z.literal("lightskyblue"),
		z.literal("lightslategray"),
		z.literal("lightslategrey"),
		z.literal("lightsteelblue"),
		z.literal("lightyellow"),
		z.literal("limegreen"),
		z.literal("linen"),
		z.literal("magenta"),
		z.literal("mediumaquamarine"),
		z.literal("mediumblue"),
		z.literal("mediumorchid"),
		z.literal("mediumpurple"),
		z.literal("mediumseagreen"),
		z.literal("mediumslateblue"),
		z.literal("mediumspringgreen"),
		z.literal("mediumturquoise"),
		z.literal("mediumvioletred"),
		z.literal("midnightblue"),
		z.literal("mintcream"),
		z.literal("mistyrose"),
		z.literal("moccasin"),
		z.literal("navajowhite"),
		z.literal("oldlace"),
		z.literal("olivedrab"),
		z.literal("orangered"),
		z.literal("orchid"),
		z.literal("palegoldenrod"),
		z.literal("palegreen"),
		z.literal("paleturquoise"),
		z.literal("palevioletred"),
		z.literal("papayawhip"),
		z.literal("peachpuff"),
		z.literal("peru"),
		z.literal("plum"),
		z.literal("powderblue"),
		z.literal("rebeccapurple"),
		z.literal("rosybrown"),
		z.literal("royalblue"),
		z.literal("saddlebrown"),
		z.literal("salmon"),
		z.literal("sandybrown"),
		z.literal("seagreen"),
		z.literal("seashell"),
		z.literal("sienna"),
		z.literal("skyblue"),
		z.literal("slateblue"),
		z.literal("slategray"),
		z.literal("slategrey"),
		z.literal("snow"),
		z.literal("springgreen"),
		z.literal("steelblue"),
		z.literal("tan"),
		z.literal("thistle"),
		z.literal("tomato"),
		z.literal("turquoise"),
		z.literal("violet"),
		z.literal("wheat"),
		z.literal("whitesmoke"),
		z.literal("yellowgreen"),
	])
	.describe("CSS named colors");

/**
 * Complete CSS color value.
 *
 * Supports all common CSS color formats:
 * - Named colors (transparent, currentColor, red, etc.)
 * - Hex colors (#RGB, #RRGGBB, with optional alpha)
 * - RGB/RGBA functions
 * - HSL/HSLA functions
 *
 * Note: Modern color spaces (lab, lch, oklab, oklch, color()) are not yet supported.
 *
 * @example
 * ```typescript
 * import { colorValueKeywordsSchema } from "@/core/keywords/color-value-keywords";
 *
 * const color1 = colorValueKeywordsSchema.parse("red");
 * const color2 = colorValueKeywordsSchema.parse("#ff0000");
 * const color3 = colorValueKeywordsSchema.parse("rgb(255, 0, 0)");
 * const color4 = colorValueKeywordsSchema.parse("hsl(0, 100%, 50%)");
 * const color5 = colorValueKeywordsSchema.parse("transparent");
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @public
 */
export const colorValueKeywordsSchema = z
	.union([namedColorKeywordsSchema, hexColorKeywordsSchema, rgbColorKeywordsSchema, hslColorKeywordsSchema])
	.describe("CSS color value");

/**
 * TypeScript types for color values.
 *
 * @public
 */
export type HexColorKeyword = z.infer<typeof hexColorKeywordsSchema>;
export type RgbColorKeyword = z.infer<typeof rgbColorKeywordsSchema>;
export type HslColorKeyword = z.infer<typeof hslColorKeywordsSchema>;
export type NamedColorKeyword = z.infer<typeof namedColorKeywordsSchema>;
export type ColorValueKeyword = z.infer<typeof colorValueKeywordsSchema>;

/**
 * Combined array of all named color keywords.
 *
 * This is a convenience export that combines all color categories.
 *
 * @example
 * ```typescript
 * import { ALL_NAMED_COLOR_KEYWORDS } from "@/core/keywords/color-value-keywords";
 *
 * console.log(ALL_NAMED_COLOR_KEYWORDS.length); // 148
 * ```
 *
 * @public
 */
export const ALL_NAMED_COLOR_KEYWORDS = [
	"transparent",
	"currentcolor",
	"black",
	"white",
	"red",
	"green",
	"blue",
	"yellow",
	"orange",
	"purple",
	"pink",
	"brown",
	"gray",
	"grey",
	"silver",
	"gold",
	"navy",
	"teal",
	"lime",
	"aqua",
	"fuchsia",
	"maroon",
	"olive",
	"cyan",
	"aliceblue",
	"antiquewhite",
	"aquamarine",
	"azure",
	"beige",
	"bisque",
	"blanchedalmond",
	"blueviolet",
	"burlywood",
	"cadetblue",
	"chartreuse",
	"chocolate",
	"coral",
	"cornflowerblue",
	"cornsilk",
	"crimson",
	"darkblue",
	"darkcyan",
	"darkgoldenrod",
	"darkgray",
	"darkgrey",
	"darkgreen",
	"darkkhaki",
	"darkmagenta",
	"darkolivegreen",
	"darkorange",
	"darkorchid",
	"darkred",
	"darksalmon",
	"darkseagreen",
	"darkslateblue",
	"darkslategray",
	"darkslategrey",
	"darkturquoise",
	"darkviolet",
	"deeppink",
	"deepskyblue",
	"dimgray",
	"dimgrey",
	"dodgerblue",
	"firebrick",
	"floralwhite",
	"forestgreen",
	"gainsboro",
	"ghostwhite",
	"goldenrod",
	"greenyellow",
	"honeydew",
	"hotpink",
	"indianred",
	"indigo",
	"ivory",
	"khaki",
	"lavender",
	"lavenderblush",
	"lawngreen",
	"lemonchiffon",
	"lightblue",
	"lightcoral",
	"lightcyan",
	"lightgoldenrodyellow",
	"lightgray",
	"lightgrey",
	"lightgreen",
	"lightpink",
	"lightsalmon",
	"lightseagreen",
	"lightskyblue",
	"lightslategray",
	"lightslategrey",
	"lightsteelblue",
	"lightyellow",
	"limegreen",
	"linen",
	"magenta",
	"mediumaquamarine",
	"mediumblue",
	"mediumorchid",
	"mediumpurple",
	"mediumseagreen",
	"mediumslateblue",
	"mediumspringgreen",
	"mediumturquoise",
	"mediumvioletred",
	"midnightblue",
	"mintcream",
	"mistyrose",
	"moccasin",
	"navajowhite",
	"oldlace",
	"olivedrab",
	"orangered",
	"orchid",
	"palegoldenrod",
	"palegreen",
	"paleturquoise",
	"palevioletred",
	"papayawhip",
	"peachpuff",
	"peru",
	"plum",
	"powderblue",
	"rebeccapurple",
	"rosybrown",
	"royalblue",
	"saddlebrown",
	"salmon",
	"sandybrown",
	"seagreen",
	"seashell",
	"sienna",
	"skyblue",
	"slateblue",
	"slategray",
	"slategrey",
	"snow",
	"springgreen",
	"steelblue",
	"tan",
	"thistle",
	"tomato",
	"turquoise",
	"violet",
	"wheat",
	"whitesmoke",
	"yellowgreen",
] as const;

/**
 * Metadata for color values.
 *
 * @public
 */
export const colorKeywordsMetadata = {
	totalNamedColors: ALL_NAMED_COLOR_KEYWORDS.length,
	hexPattern: "#RGB, #RRGGBB, #RGBA, #RRGGBBAA",
	rgbPattern: "rgb(r, g, b) or rgba(r, g, b, a)",
	hslPattern: "hsl(h, s%, l%) or hsla(h, s%, l%, a)",
} as const;

/**
 * Type for color keywords metadata.
 *
 * @public
 */
export type ColorKeywordsMetadata = typeof colorKeywordsMetadata;


=== File: src/core/keywords/content-distribution-keywords.ts ===
// b_path:: src/core/keywords/content-distribution-keywords.ts
import { z } from "zod";

/**
 * CSS content distribution keywords.
 *
 * Content distribution values control how extra space is distributed
 * among flex items or grid tracks within their alignment container.
 *
 * Used in:
 * - `justify-content` - Alignment along main axis
 * - `align-content` - Alignment along cross axis
 * - `place-content` - Shorthand for both axes
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Alignment#content_distribution}
 *
 * @example
 * ```typescript
 * import { contentDistributionKeywordsSchema } from "@/core/keywords/content-distribution-keywords";
 *
 * const keyword = contentDistributionKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const contentDistributionKeywordsSchema = z
	.union([
		z.literal("space-between").describe("evenly distributes items with first/last flush to edges"),
		z.literal("space-around").describe("evenly distributes items with half-size space on ends"),
		z.literal("space-evenly").describe("evenly distributes items with full-size space on ends"),
		z.literal("stretch").describe("grows items equally to fill container"),
	])
	.describe(
		"Content distribution values control how extra space is distributed among alignment subjects. " +
			"Used in justify-content, align-content, and place-content properties.",
	);

/**
 * Array of all content distribution keyword values.
 *
 * @example
 * ```typescript
 * import { CONTENT_DISTRIBUTION_KEYWORDS } from "@/core/keywords/content-distribution-keywords";
 *
 * console.log(CONTENT_DISTRIBUTION_KEYWORDS);
 * // ["space-between", "space-around", "space-evenly", "stretch"]
 * ```
 *
 * @public
 */
export const CONTENT_DISTRIBUTION_KEYWORDS = contentDistributionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for content distribution keywords.
 *
 * @public
 */
export type ContentDistributionKeyword = z.infer<typeof contentDistributionKeywordsSchema>;

/**
 * Metadata for content distribution keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { contentDistributionKeywordOptions } from "@/core/keywords/content-distribution-keywords";
 *
 * contentDistributionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const contentDistributionKeywordOptions = contentDistributionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for content distribution keyword options metadata.
 *
 * @public
 */
export type ContentDistributionKeywordOptions = typeof contentDistributionKeywordOptions;


=== File: src/core/keywords/content-position-keywords.ts ===
// b_path:: src/core/keywords/content-position-keywords.ts
import { z } from "zod";

/**
 * CSS content position keywords.
 *
 * Content position values align the box's contents within itself
 * along a single axis (main or cross axis for flex, inline or block for grid).
 *
 * Used in:
 * - `justify-content` - Alignment along main/inline axis
 * - `align-content` - Alignment along cross/block axis
 * - `place-content` - Shorthand for both axes
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Alignment#positional_alignment}
 *
 * @example
 * ```typescript
 * import { contentPositionKeywordsSchema } from "@/core/keywords/content-position-keywords";
 *
 * const keyword = contentPositionKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const contentPositionKeywordsSchema = z
	.union([
		z.literal("center").describe("centers the alignment subject within its alignment container"),
		z.literal("start").describe("aligns the alignment subject flush with the alignment container's start edge"),
		z.literal("end").describe("aligns the alignment subject flush with the alignment container's end edge"),
		z.literal("flex-start").describe("aligns flush with flex container's main-start or cross-start side"),
		z.literal("flex-end").describe("aligns flush with flex container's main-end or cross-end side"),
	])
	.describe(
		"Content position values align the box's contents within itself. " +
			"Used in justify-content, align-content, and place-content properties.",
	);

/**
 * Array of all content position keyword values.
 *
 * @example
 * ```typescript
 * import { CONTENT_POSITION_KEYWORDS } from "@/core/keywords/content-position-keywords";
 *
 * console.log(CONTENT_POSITION_KEYWORDS);
 * // ["center", "start", "end", "flex-start", "flex-end"]
 * ```
 *
 * @public
 */
export const CONTENT_POSITION_KEYWORDS = contentPositionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for content position keywords.
 *
 * @public
 */
export type ContentPositionKeyword = z.infer<typeof contentPositionKeywordsSchema>;

/**
 * Metadata for content position keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { contentPositionKeywordOptions } from "@/core/keywords/content-position-keywords";
 *
 * contentPositionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const contentPositionKeywordOptions = contentPositionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for content position keyword options metadata.
 *
 * @public
 */
export type ContentPositionKeywordOptions = typeof contentPositionKeywordOptions;


=== File: src/core/keywords/corner-shape-keywords.ts ===
// b_path:: src/core/keywords/corner-shape-keywords.ts
import { z } from "zod";

/**
 * CSS corner-shape keyword values.
 *
 * Corner shape values describe the shape of container corners.
 * Used in corner-shape property to specify custom corner shapes beyond standard border-radius.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/corner-shape}
 *
 * @example
 * ```typescript
 * import { cornerShapeKeywordsSchema } from "@/core/keywords/corner-shape-keywords";
 *
 * const keyword = cornerShapeKeywordsSchema.parse("round");
 * ```
 *
 * @public
 */
export const cornerShapeKeywordsSchema = z
	.union([
		z.literal("round").describe("convex ordinary ellipse (default rounded corner)"),
		z.literal("scoop").describe("concave ordinary ellipse"),
		z.literal("bevel").describe("straight diagonal corner (neither convex nor concave)"),
		z.literal("notch").describe("90-degree concave square corner"),
		z.literal("square").describe("90-degree convex square corner"),
		z.literal("squircle").describe("convex curve between round and square"),
	])
	.describe(
		"Corner shape values describe the shape of container corners. " +
			"Used in corner-shape property to specify custom corner shapes beyond standard border-radius.",
	);

/**
 * Array of all corner-shape keyword values.
 *
 * @public
 */
export const CORNER_SHAPE_KEYWORDS = cornerShapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for corner-shape keywords.
 *
 * @public
 */
export type CornerShapeKeyword = z.infer<typeof cornerShapeKeywordsSchema>;

/**
 * Metadata for corner-shape keyword options.
 *
 * @public
 */
export const cornerShapeKeywordOptions = cornerShapeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for corner-shape keyword options metadata.
 *
 * @public
 */
export type CornerShapeKeywordOptions = typeof cornerShapeKeywordOptions;


=== File: src/core/keywords/cursor-keywords.ts ===
// b_path:: src/core/keywords/cursor-keywords.ts
import { z } from "zod";

/**
 * CSS cursor keyword values.
 *
 * The cursor property sets the mouse cursor to display when the mouse pointer is over an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}
 *
 * @example
 * ```typescript
 * import { cursorKeywordsSchema } from "@/core/keywords/cursor-keywords";
 *
 * const keyword = cursorKeywordsSchema.parse("pointer");
 * ```
 *
 * @public
 */
export const cursorKeywordsSchema = z
	.union([
		z.literal("auto").describe("browser determines cursor based on context"),
		z.literal("default").describe("platform-dependent default cursor (usually arrow)"),
		z.literal("none").describe("no cursor is rendered"),
		z.literal("context-menu").describe("context menu is available"),
		z.literal("help").describe("help information is available"),
		z.literal("pointer").describe("link or clickable element (usually hand)"),
		z.literal("progress").describe("program is busy but user can still interact"),
		z.literal("wait").describe("program is busy"),
		z.literal("cell").describe("cell or set of cells can be selected"),
		z.literal("crosshair").describe("simple crosshair"),
		z.literal("text").describe("text can be selected (usually I-beam)"),
		z.literal("vertical-text").describe("vertical text can be selected"),
		z.literal("alias").describe("alias or shortcut is to be created"),
		z.literal("copy").describe("something is to be copied"),
		z.literal("move").describe("something is to be moved"),
		z.literal("no-drop").describe("drop is not allowed at current location"),
		z.literal("not-allowed").describe("requested action will not be executed"),
		z.literal("grab").describe("something can be grabbed"),
		z.literal("grabbing").describe("something is being grabbed"),
		z.literal("e-resize").describe("edge is to be moved east"),
		z.literal("n-resize").describe("edge is to be moved north"),
		z.literal("ne-resize").describe("edge is to be moved northeast"),
		z.literal("nw-resize").describe("edge is to be moved northwest"),
		z.literal("s-resize").describe("edge is to be moved south"),
		z.literal("se-resize").describe("edge is to be moved southeast"),
		z.literal("sw-resize").describe("edge is to be moved southwest"),
		z.literal("w-resize").describe("edge is to be moved west"),
		z.literal("ew-resize").describe("bidirectional resize cursor (east-west)"),
		z.literal("ns-resize").describe("bidirectional resize cursor (north-south)"),
		z.literal("nesw-resize").describe("bidirectional resize cursor (northeast-southwest)"),
		z.literal("nwse-resize").describe("bidirectional resize cursor (northwest-southeast)"),
		z.literal("col-resize").describe("column can be resized horizontally"),
		z.literal("row-resize").describe("row can be resized vertically"),
		z.literal("all-scroll").describe("scrolling in any direction"),
		z.literal("zoom-in").describe("something can be zoomed in"),
		z.literal("zoom-out").describe("something can be zoomed out"),
	])
	.describe("CSS cursor property keyword values");

/**
 * Array of all cursor keyword values.
 *
 * @public
 */
export const CURSOR_KEYWORDS = cursorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for cursor keywords.
 *
 * @public
 */
export type CursorKeyword = z.infer<typeof cursorKeywordsSchema>;

/**
 * Metadata for cursor keyword options.
 *
 * @public
 */
export const cursorKeywordOptions = cursorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for cursor keyword options metadata.
 *
 * @public
 */
export type CursorKeywordOptions = typeof cursorKeywordOptions;


=== File: src/core/keywords/display-keywords.ts ===
// b_path:: src/core/keywords/display-keywords.ts
import { z } from "zod";

/**
 * CSS display box keywords.
 *
 * Display box values control whether an element generates a box at all.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#box}
 * @public
 */
export const displayBoxKeywordsSchema = z
	.union([
		z.literal("contents").describe("element doesn't produce a specific box by itself"),
		z.literal("none").describe("turns off the display of an element"),
	])
	.describe("Display box values that control whether an element generates a box");

/**
 * CSS display inside keywords.
 *
 * Display inside values specify the element's inner display type,
 * which defines how its contents are laid out.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#inside}
 * @public
 */
export const displayInsideKeywordsSchema = z
	.union([
		z.literal("flow").describe("element lays out its contents using flow layout"),
		z.literal("flow-root").describe("generates a block element box that establishes a new block formatting context"),
		z.literal("table").describe("behaves like HTML table elements"),
		z.literal("flex").describe("behaves like a block element and lays out content according to the flexbox model"),
		z.literal("grid").describe("behaves like a block element and lays out content according to the grid model"),
		z
			.literal("ruby")
			.describe("behaves like an inline element and lays out content according to the ruby formatting model"),
	])
	.describe("Display inside values that specify the element's inner display type");

/**
 * CSS display internal keywords.
 *
 * Display internal values are for complex layout models like table and ruby.
 * These elements have internal structures with specific roles.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#internal}
 * @public
 */
export const displayInternalKeywordsSchema = z
	.union([
		z.literal("table-row-group").describe("behaves like tbody HTML elements"),
		z.literal("table-header-group").describe("behaves like thead HTML elements"),
		z.literal("table-footer-group").describe("behaves like tfoot HTML elements"),
		z.literal("table-row").describe("behaves like tr HTML elements"),
		z.literal("table-cell").describe("behaves like td HTML elements"),
		z.literal("table-column-group").describe("behaves like colgroup HTML elements"),
		z.literal("table-column").describe("behaves like col HTML elements"),
		z.literal("table-caption").describe("behaves like caption HTML elements"),
		z.literal("ruby-base").describe("behaves like rb HTML elements"),
		z.literal("ruby-text").describe("behaves like rt HTML elements"),
		z.literal("ruby-base-container").describe("generated as anonymous boxes"),
		z.literal("ruby-text-container").describe("behaves like rtc HTML elements"),
	])
	.describe("Display internal values for complex layout models like table and ruby");

/**
 * CSS display legacy keywords.
 *
 * Display legacy values are from CSS 2 single-keyword syntax.
 * These combine outer and inner display types in a single keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#legacy}
 * @public
 */
export const displayLegacyKeywordsSchema = z
	.union([
		z.literal("inline-block").describe("generates a block element box flowed with surrounding content as inline"),
		z.literal("inline-table").describe("behaves like HTML table element but as an inline box"),
		z.literal("inline-flex").describe("behaves like an inline element and lays out content according to flexbox model"),
		z.literal("inline-grid").describe("behaves like an inline element and lays out content according to grid model"),
	])
	.describe("Display legacy values from CSS 2 single-keyword syntax");

/**
 * CSS display outside keywords.
 *
 * Display outside values specify the element's outer display type,
 * which determines how it participates in flow layout.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#outside}
 * @public
 */
export const displayOutsideKeywordsSchema = z
	.union([
		z.literal("block").describe("generates a block element box with line breaks before and after"),
		z.literal("inline").describe("generates inline element boxes without line breaks"),
		z.literal("run-in").describe("element runs into the next block if possible"),
	])
	.describe("Display outside values that specify the element's outer display type");

/**
 * CSS display list-item keyword.
 *
 * The list-item keyword makes an element behave like a list item,
 * generating both a principal box and a marker box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#list-item}
 * @public
 */
export const displayListItemKeywordsSchema = z.literal("list-item").describe("element behaves like a list item");

/**
 * CSS display keywords.
 *
 * The display property controls how an element is displayed in the layout,
 * including its box generation, inner layout type, and outer display type.
 *
 * This schema includes all valid display values:
 * - Box values (contents, none)
 * - Inside values (flow, flex, grid, table, etc.)
 * - Internal values (table-row, table-cell, etc.)
 * - Legacy values (inline-block, inline-flex, etc.)
 * - Outside values (block, inline, run-in)
 * - List item
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display}
 *
 * @example
 * ```typescript
 * import { displayKeywordsSchema } from "@/core/keywords/display-keywords";
 *
 * const keyword = displayKeywordsSchema.parse("flex"); // "flex"
 * ```
 *
 * @public
 */
export const displayKeywordsSchema = z
	.union([
		// Display Box
		z
			.literal("contents")
			.describe("element doesn't produce a specific box by itself"),
		z.literal("none").describe("turns off the display of an element"),

		// Display Inside
		z
			.literal("flow")
			.describe("element lays out its contents using flow layout"),
		z.literal("flow-root").describe("generates a block element box that establishes a new block formatting context"),
		z.literal("table").describe("behaves like HTML table elements"),
		z.literal("flex").describe("behaves like a block element and lays out content according to the flexbox model"),
		z.literal("grid").describe("behaves like a block element and lays out content according to the grid model"),
		z
			.literal("ruby")
			.describe("behaves like an inline element and lays out content according to the ruby formatting model"),

		// Display Internal
		z
			.literal("table-row-group")
			.describe("behaves like tbody HTML elements"),
		z.literal("table-header-group").describe("behaves like thead HTML elements"),
		z.literal("table-footer-group").describe("behaves like tfoot HTML elements"),
		z.literal("table-row").describe("behaves like tr HTML elements"),
		z.literal("table-cell").describe("behaves like td HTML elements"),
		z.literal("table-column-group").describe("behaves like colgroup HTML elements"),
		z.literal("table-column").describe("behaves like col HTML elements"),
		z.literal("table-caption").describe("behaves like caption HTML elements"),
		z.literal("ruby-base").describe("behaves like rb HTML elements"),
		z.literal("ruby-text").describe("behaves like rt HTML elements"),
		z.literal("ruby-base-container").describe("generated as anonymous boxes"),
		z.literal("ruby-text-container").describe("behaves like rtc HTML elements"),

		// Display Legacy
		z
			.literal("inline-block")
			.describe("generates a block element box flowed with surrounding content as inline"),
		z.literal("inline-table").describe("behaves like HTML table element but as an inline box"),
		z.literal("inline-flex").describe("behaves like an inline element and lays out content according to flexbox model"),
		z.literal("inline-grid").describe("behaves like an inline element and lays out content according to grid model"),

		// Display Outside
		z
			.literal("block")
			.describe("generates a block element box with line breaks before and after"),
		z.literal("inline").describe("generates inline element boxes without line breaks"),
		z.literal("run-in").describe("element runs into the next block if possible"),

		// List Item
		z
			.literal("list-item")
			.describe("element behaves like a list item"),
	])
	.describe("CSS display property values that control how an element is displayed");

/**
 * Array of all display keyword values.
 *
 * @example
 * ```typescript
 * import { DISPLAY_KEYWORDS } from "@/core/keywords/display-keywords";
 *
 * console.log(DISPLAY_KEYWORDS);
 * // ["contents", "none", "flow", "flex", "grid", "block", "inline", ...]
 * ```
 *
 * @public
 */
export const DISPLAY_KEYWORDS = displayKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for display keywords.
 *
 * @public
 */
export type DisplayKeyword = z.infer<typeof displayKeywordsSchema>;

/**
 * Metadata for display keyword options.
 *
 * Provides value and description for each display keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { displayKeywordOptions } from "@/core/keywords/display-keywords";
 *
 * displayKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const displayKeywordOptions = displayKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for display keyword options metadata.
 *
 * @public
 */
export type DisplayKeywordOptions = typeof displayKeywordOptions;


=== File: src/core/keywords/extended-color-keywords.ts ===
// b_path:: src/core/keywords/extended-color-keywords.ts
import { z } from "zod";

/**
 * CSS extended named colors (~125 colors).
 *
 * Full X11/SVG color set from CSS Color Module Level 4.
 * These are additional named colors beyond the basic set.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#named-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const extendedNamedColorKeywordsSchema = z
	.union([
		z.literal("aliceblue").describe("Alice blue color (#F0F8FF)"),
		z.literal("antiquewhite").describe("Antique white color (#FAEBD7)"),
		z.literal("aquamarine").describe("Aquamarine color (#7FFFD4)"),
		z.literal("azure").describe("Azure color (#F0FFFF)"),
		z.literal("beige").describe("Beige color (#F5F5DC)"),
		z.literal("bisque").describe("Bisque color (#FFE4C4)"),
		z.literal("blanchedalmond").describe("Blanched almond color (#FFEBCD)"),
		z.literal("blueviolet").describe("Blue violet color (#8A2BE2)"),
		z.literal("burlywood").describe("Burlywood color (#DEB887)"),
		z.literal("cadetblue").describe("Cadet blue color (#5F9EA0)"),
		z.literal("chartreuse").describe("Chartreuse color (#7FFF00)"),
		z.literal("chocolate").describe("Chocolate color (#D2691E)"),
		z.literal("coral").describe("Coral color (#FF7F50)"),
		z.literal("cornflowerblue").describe("Cornflower blue color (#6495ED)"),
		z.literal("cornsilk").describe("Cornsilk color (#FFF8DC)"),
		z.literal("crimson").describe("Crimson color (#DC143C)"),
		z.literal("darkblue").describe("Dark blue color (#00008B)"),
		z.literal("darkcyan").describe("Dark cyan color (#008B8B)"),
		z.literal("darkgoldenrod").describe("Dark goldenrod color (#B8860B)"),
		z.literal("darkgray").describe("Dark gray color (#A9A9A9)"),
		z.literal("darkgrey").describe("Alternative spelling of darkgray"),
		z.literal("darkgreen").describe("Dark green color (#006400)"),
		z.literal("darkkhaki").describe("Dark khaki color (#BDB76B)"),
		z.literal("darkmagenta").describe("Dark magenta color (#8B008B)"),
		z.literal("darkolivegreen").describe("Dark olive green color (#556B2F)"),
		z.literal("darkorange").describe("Dark orange color (#FF8C00)"),
		z.literal("darkorchid").describe("Dark orchid color (#9932CC)"),
		z.literal("darkred").describe("Dark red color (#8B0000)"),
		z.literal("darksalmon").describe("Dark salmon color (#E9967A)"),
		z.literal("darkseagreen").describe("Dark sea green color (#8FBC8F)"),
		z.literal("darkslateblue").describe("Dark slate blue color (#483D8B)"),
		z.literal("darkslategray").describe("Dark slate gray color (#2F4F4F)"),
		z.literal("darkslategrey").describe("Alternative spelling of darkslategray"),
		z.literal("darkturquoise").describe("Dark turquoise color (#00CED1)"),
		z.literal("darkviolet").describe("Dark violet color (#9400D3)"),
		z.literal("deeppink").describe("Deep pink color (#FF1493)"),
		z.literal("deepskyblue").describe("Deep sky blue color (#00BFFF)"),
		z.literal("dimgray").describe("Dim gray color (#696969)"),
		z.literal("dimgrey").describe("Alternative spelling of dimgrey"),
		z.literal("dodgerblue").describe("Dodger blue color (#1E90FF)"),
		z.literal("firebrick").describe("Fire brick color (#B22222)"),
		z.literal("floralwhite").describe("Floral white color (#FFFAF0)"),
		z.literal("forestgreen").describe("Forest green color (#228B22)"),
		z.literal("gainsboro").describe("Gainsboro color (#DCDCDC)"),
		z.literal("ghostwhite").describe("Ghost white color (#F8F8FF)"),
		z.literal("goldenrod").describe("Goldenrod color (#DAA520)"),
		z.literal("greenyellow").describe("Green yellow color (#ADFF2F)"),
		z.literal("honeydew").describe("Honeydew color (#F0FFF0)"),
		z.literal("hotpink").describe("Hot pink color (#FF69B4)"),
		z.literal("indianred").describe("Indian red color (#CD5C5C)"),
		z.literal("indigo").describe("Indigo color (#4B0082)"),
		z.literal("ivory").describe("Ivory color (#FFFFF0)"),
		z.literal("khaki").describe("Khaki color (#F0E68C)"),
		z.literal("lavender").describe("Lavender color (#E6E6FA)"),
		z.literal("lavenderblush").describe("Lavender blush color (#FFF0F5)"),
		z.literal("lawngreen").describe("Lawn green color (#7CFC00)"),
		z.literal("lemonchiffon").describe("Lemon chiffon color (#FFFACD)"),
		z.literal("lightblue").describe("Light blue color (#ADD8E6)"),
		z.literal("lightcoral").describe("Light coral color (#F08080)"),
		z.literal("lightcyan").describe("Light cyan color (#E0FFFF)"),
		z.literal("lightgoldenrodyellow").describe("Light goldenrod yellow color (#FAFAD2)"),
		z.literal("lightgray").describe("Light gray color (#D3D3D3)"),
		z.literal("lightgrey").describe("Alternative spelling of lightgrey"),
		z.literal("lightgreen").describe("Light green color (#90EE90)"),
		z.literal("lightpink").describe("Light pink color (#FFB6C1)"),
		z.literal("lightsalmon").describe("Light salmon color (#FFA07A)"),
		z.literal("lightseagreen").describe("Light sea green color (#20B2AA)"),
		z.literal("lightskyblue").describe("Light sky blue color (#87CEFA)"),
		z.literal("lightslategray").describe("Light slate gray color (#778899)"),
		z.literal("lightslategrey").describe("Alternative spelling of lightslategrey"),
		z.literal("lightsteelblue").describe("Light steel blue color (#B0C4DE)"),
		z.literal("lightyellow").describe("Light yellow color (#FFFFE0)"),
		z.literal("limegreen").describe("Lime green color (#32CD32)"),
		z.literal("linen").describe("Linen color (#FAF0E6)"),
		z.literal("magenta").describe("Magenta color (#FF00FF)"),
		z.literal("mediumaquamarine").describe("Medium aquamarine color (#66CDAA)"),
		z.literal("mediumblue").describe("Medium blue color (#0000CD)"),
		z.literal("mediumorchid").describe("Medium orchid color (#BA55D3)"),
		z.literal("mediumpurple").describe("Medium purple color (#9370DB)"),
		z.literal("mediumseagreen").describe("Medium sea green color (#3CB371)"),
		z.literal("mediumslateblue").describe("Medium slate blue color (#7B68EE)"),
		z.literal("mediumspringgreen").describe("Medium spring green color (#00FA9A)"),
		z.literal("mediumturquoise").describe("Medium turquoise color (#48D1CC)"),
		z.literal("mediumvioletred").describe("Medium violet red color (#C71585)"),
		z.literal("midnightblue").describe("Midnight blue color (#191970)"),
		z.literal("mintcream").describe("Mint cream color (#F5FFFA)"),
		z.literal("mistyrose").describe("Misty rose color (#FFE4E1)"),
		z.literal("moccasin").describe("Moccasin color (#FFE4B5)"),
		z.literal("navajowhite").describe("Navajo white color (#FFDEAD)"),
		z.literal("oldlace").describe("Old lace color (#FDF5E6)"),
		z.literal("olivedrab").describe("Olive drab color (#6B8E23)"),
		z.literal("orangered").describe("Orange red color (#FF4500)"),
		z.literal("orchid").describe("Orchid color (#DA70D6)"),
		z.literal("palegoldenrod").describe("Pale goldenrod color (#EEE8AA)"),
		z.literal("palegreen").describe("Pale green color (#98FB98)"),
		z.literal("paleturquoise").describe("Pale turquoise color (#AFEEEE)"),
		z.literal("palevioletred").describe("Pale violet red color (#DB7093)"),
		z.literal("papayawhip").describe("Papaya whip color (#FFEFD5)"),
		z.literal("peachpuff").describe("Peach puff color (#FFDAB9)"),
		z.literal("peru").describe("Peru color (#CD853F)"),
		z.literal("plum").describe("Plum color (#DDA0DD)"),
		z.literal("powderblue").describe("Powder blue color (#B0E0E6)"),
		z.literal("rebeccapurple").describe("Rebecca purple color (#663399)"),
		z.literal("rosybrown").describe("Rosy brown color (#BC8F8F)"),
		z.literal("royalblue").describe("Royal blue color (#4169E1)"),
		z.literal("saddlebrown").describe("Saddle brown color (#8B4513)"),
		z.literal("salmon").describe("Salmon color (#FA8072)"),
		z.literal("sandybrown").describe("Sandy brown color (#F4A460)"),
		z.literal("seagreen").describe("Sea green color (#2E8B57)"),
		z.literal("seashell").describe("Seashell color (#FFF5EE)"),
		z.literal("sienna").describe("Sienna color (#A0522D)"),
		z.literal("skyblue").describe("Sky blue color (#87CEEB)"),
		z.literal("slateblue").describe("Slate blue color (#6A5ACD)"),
		z.literal("slategray").describe("Slate gray color (#708090)"),
		z.literal("slategrey").describe("Alternative spelling of slategray"),
		z.literal("snow").describe("Snow color (#FFFAFA)"),
		z.literal("springgreen").describe("Spring green color (#00FF7F)"),
		z.literal("steelblue").describe("Steel blue color (#4682B4)"),
		z.literal("tan").describe("Tan color (#D2B48C)"),
		z.literal("thistle").describe("Thistle color (#D8BFD8)"),
		z.literal("tomato").describe("Tomato color (#FF6347)"),
		z.literal("turquoise").describe("Turquoise color (#40E0D0)"),
		z.literal("violet").describe("Violet color (#EE82EE)"),
		z.literal("wheat").describe("Wheat color (#F5DEB3)"),
		z.literal("whitesmoke").describe("White smoke color (#F5F5F5)"),
		z.literal("yellowgreen").describe("Yellow green color (#9ACD32)"),
	])
	.describe("CSS extended named colors");

/**
 * Array of all extended named color keyword values.
 *
 * @example
 * ```typescript
 * import { EXTENDED_NAMED_COLOR_KEYWORDS } from "@/core/keywords/extended-color-keywords";
 *
 * console.log(EXTENDED_NAMED_COLOR_KEYWORDS.length); // 125
 * ```
 *
 * @public
 */
export const EXTENDED_NAMED_COLOR_KEYWORDS = extendedNamedColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for extended named color keywords.
 *
 * @public
 */
export type ExtendedNamedColorKeyword = z.infer<typeof extendedNamedColorKeywordsSchema>;

/**
 * Metadata for extended named color keyword options.
 *
 * Provides value and description for each extended named color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { extendedNamedColorKeywordOptions } from "@/core/keywords/extended-color-keywords";
 *
 * extendedNamedColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const extendedNamedColorKeywordOptions = extendedNamedColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for extended named color keyword options metadata.
 *
 * @public
 */
export type ExtendedNamedColorKeywordOptions = typeof extendedNamedColorKeywordOptions;


=== File: src/core/keywords/flex-direction-keywords.ts ===
// b_path:: src/core/keywords/flex-direction-keywords.ts
import { z } from "zod";

/**
 * CSS `flex-direction` property keyword values.
 *
 * The flex-direction property sets how flex items are placed in the flex container,
 * defining the main axis and the direction (normal or reversed).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction}
 *
 * @example
 * ```typescript
 * import { flexDirectionKeywordsSchema } from "@/core/keywords/flex-direction-keywords";
 *
 * const keyword = flexDirectionKeywordsSchema.parse("row");
 * ```
 *
 * @public
 */
export const flexDirectionKeywordsSchema = z
	.union([
		z.literal("row").describe("horizontal direction in left-to-right layout"),
		z.literal("row-reverse").describe("horizontal direction reversed"),
		z.literal("column").describe("vertical direction from top to bottom"),
		z.literal("column-reverse").describe("vertical direction reversed"),
	])
	.describe("CSS flex-direction property keyword values");

/**
 * Array of all flex-direction keyword values.
 *
 * @public
 */
export const FLEX_DIRECTION_KEYWORDS = flexDirectionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for flex-direction keywords.
 *
 * @public
 */
export type FlexDirectionKeyword = z.infer<typeof flexDirectionKeywordsSchema>;

/**
 * Metadata for flex-direction keyword options.
 *
 * @public
 */
export const flexDirectionKeywordOptions = flexDirectionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for flex-direction keyword options metadata.
 *
 * @public
 */
export type FlexDirectionKeywordOptions = typeof flexDirectionKeywordOptions;


=== File: src/core/keywords/flex-wrap-keywords.ts ===
// b_path:: src/core/keywords/flex-wrap-keywords.ts
import { z } from "zod";

/**
 * CSS `flex-wrap` property keyword values.
 *
 * The flex-wrap property sets whether flex items are forced onto one line
 * or can wrap onto multiple lines.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap}
 *
 * @example
 * ```typescript
 * import { flexWrapKeywordsSchema } from "@/core/keywords/flex-wrap-keywords";
 *
 * const keyword = flexWrapKeywordsSchema.parse("wrap");
 * ```
 *
 * @public
 */
export const flexWrapKeywordsSchema = z
	.union([
		z.literal("nowrap").describe("items laid out in single line (may overflow)"),
		z.literal("wrap").describe("items wrap onto multiple lines top to bottom"),
		z.literal("wrap-reverse").describe("items wrap onto multiple lines bottom to top"),
	])
	.describe("CSS flex-wrap property keyword values");

/**
 * Array of all flex-wrap keyword values.
 *
 * @public
 */
export const FLEX_WRAP_KEYWORDS = flexWrapKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for flex-wrap keywords.
 *
 * @public
 */
export type FlexWrapKeyword = z.infer<typeof flexWrapKeywordsSchema>;

/**
 * Metadata for flex-wrap keyword options.
 *
 * @public
 */
export const flexWrapKeywordOptions = flexWrapKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for flex-wrap keyword options metadata.
 *
 * @public
 */
export type FlexWrapKeywordOptions = typeof flexWrapKeywordOptions;


=== File: src/core/keywords/font-size-keywords.ts ===
// b_path:: src/core/keywords/font-size-keywords.ts
import { z } from "zod";

/**
 * CSS font-size absolute size keywords.
 *
 * Absolute size keywords are mapped to font sizes computed and kept by the browser.
 * These values scale relative to each other based on the user's preferred font size (medium).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size#absolute-size}
 * @public
 */
export const fontSizeAbsoluteKeywordsSchema = z
	.union([
		z.literal("xx-small").describe("absolute size 60% the size of medium"),
		z.literal("x-small").describe("absolute size 75% the size of medium"),
		z.literal("small").describe("absolute size 89% the size of medium"),
		z.literal("medium").describe("user's preferred font size (reference middle value)"),
		z.literal("large").describe("absolute size 20% larger than medium"),
		z.literal("x-large").describe("absolute size 50% larger than medium"),
		z.literal("xx-large").describe("absolute size twice the size of medium"),
		z.literal("xxx-large").describe("absolute size three times the size of medium"),
	])
	.describe(
		"Absolute size keywords for font sizing. " +
			"Used in font shorthand and font-size properties, mapped to deprecated HTML size attributes.",
	);

/**
 * CSS font-size relative size keywords.
 *
 * Relative size keywords scale relative to the parent element's computed font size.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size#relative-size}
 * @public
 */
export const fontSizeRelativeKeywordsSchema = z
	.union([
		z.literal("smaller").describe("one relative size smaller than parent element"),
		z.literal("larger").describe("one relative size larger than parent element"),
	])
	.describe("Relative size keywords scale relative to the parent element's font size.");

/**
 * CSS font-size keywords (all absolute and relative values).
 *
 * The font-size property sets the size of the font. Can be specified using
 * absolute size keywords (xx-small through xxx-large) or relative keywords (smaller, larger).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size}
 *
 * @example
 * ```typescript
 * import { fontSizeKeywordsSchema } from "@/core/keywords/font-size-keywords";
 *
 * const keyword = fontSizeKeywordsSchema.parse("medium"); // "medium"
 * ```
 *
 * @public
 */
export const fontSizeKeywordsSchema = z
	.union([
		// Absolute sizes
		z
			.literal("xx-small")
			.describe("absolute size 60% the size of medium"),
		z.literal("x-small").describe("absolute size 75% the size of medium"),
		z.literal("small").describe("absolute size 89% the size of medium"),
		z.literal("medium").describe("user's preferred font size (reference middle value)"),
		z.literal("large").describe("absolute size 20% larger than medium"),
		z.literal("x-large").describe("absolute size 50% larger than medium"),
		z.literal("xx-large").describe("absolute size twice the size of medium"),
		z.literal("xxx-large").describe("absolute size three times the size of medium"),

		// Relative sizes
		z
			.literal("smaller")
			.describe("one relative size smaller than parent element"),
		z.literal("larger").describe("one relative size larger than parent element"),
	])
	.describe("CSS font-size keywords (absolute and relative)");

/**
 * Array of all absolute font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_ABSOLUTE_KEYWORDS } from "@/core/keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_ABSOLUTE_KEYWORDS);
 * // ["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_ABSOLUTE_KEYWORDS = fontSizeAbsoluteKeywordsSchema.options.map((option) => option.value);

/**
 * Array of all relative font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_RELATIVE_KEYWORDS } from "@/core/keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_RELATIVE_KEYWORDS); // ["smaller", "larger"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_RELATIVE_KEYWORDS = fontSizeRelativeKeywordsSchema.options.map((option) => option.value);

/**
 * Array of all font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_KEYWORDS } from "@/core/keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_KEYWORDS);
 * // ["xx-small", "x-small", ..., "smaller", "larger"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_KEYWORDS = fontSizeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-size keywords.
 *
 * @public
 */
export type FontSizeKeyword = z.infer<typeof fontSizeKeywordsSchema>;

/**
 * TypeScript type for absolute font-size keywords.
 *
 * @public
 */
export type FontSizeAbsoluteKeyword = z.infer<typeof fontSizeAbsoluteKeywordsSchema>;

/**
 * TypeScript type for relative font-size keywords.
 *
 * @public
 */
export type FontSizeRelativeKeyword = z.infer<typeof fontSizeRelativeKeywordsSchema>;

/**
 * Metadata for font-size keyword options.
 *
 * Provides value and description for each font-size keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { fontSizeKeywordOptions } from "@/core/keywords/font-size-keywords";
 *
 * fontSizeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const fontSizeKeywordOptions = fontSizeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeKeywordOptions = typeof fontSizeKeywordOptions;

/**
 * Metadata for absolute font-size keyword options.
 *
 * @public
 */
export const fontSizeAbsoluteKeywordOptions = fontSizeAbsoluteKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for absolute font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeAbsoluteKeywordOptions = typeof fontSizeAbsoluteKeywordOptions;

/**
 * Metadata for relative font-size keyword options.
 *
 * @public
 */
export const fontSizeRelativeKeywordOptions = fontSizeRelativeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for relative font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeRelativeKeywordOptions = typeof fontSizeRelativeKeywordOptions;


=== File: src/core/keywords/font-style-keywords.ts ===
// b_path:: src/core/keywords/font-style-keywords.ts
import { z } from "zod";

/**
 * CSS font-style keyword values.
 *
 * The font-style property sets whether a font should be styled with a normal, italic,
 * or oblique face from its font-family.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style}
 *
 * @example
 * ```typescript
 * import { fontStyleKeywordsSchema } from "@/core/keywords/font-style-keywords";
 *
 * const keyword = fontStyleKeywordsSchema.parse("italic");
 * ```
 *
 * @public
 */
export const fontStyleKeywordsSchema = z
	.union([
		z.literal("normal").describe("normal font style"),
		z.literal("italic").describe("italic font style using dedicated italic font face"),
		z.literal("oblique").describe("oblique font style using slanted version of normal font"),
	])
	.describe("CSS font-style property keyword values");

/**
 * Array of all font-style keyword values.
 *
 * @public
 */
export const FONT_STYLE_KEYWORDS = fontStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-style keywords.
 *
 * @public
 */
export type FontStyleKeyword = z.infer<typeof fontStyleKeywordsSchema>;

/**
 * Metadata for font-style keyword options.
 *
 * @public
 */
export const fontStyleKeywordOptions = fontStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-style keyword options metadata.
 *
 * @public
 */
export type FontStyleKeywordOptions = typeof fontStyleKeywordOptions;


=== File: src/core/keywords/font-weight-keywords.ts ===
// b_path:: src/core/keywords/font-weight-keywords.ts
import { z } from "zod";

/**
 * CSS font-weight keyword values.
 *
 * The font-weight property sets the weight (or boldness) of the font.
 * These keyword values are relative to the inherited weight or absolute weights.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight}
 *
 * @example
 * ```typescript
 * import { fontWeightKeywordsSchema } from "@/core/keywords/font-weight-keywords";
 *
 * const keyword = fontWeightKeywordsSchema.parse("bold");
 * ```
 *
 * @public
 */
export const fontWeightKeywordsSchema = z
	.union([
		z.literal("normal").describe("normal font weight (equivalent to 400)"),
		z.literal("bold").describe("bold font weight (equivalent to 700)"),
		z.literal("lighter").describe("one relative font weight lighter than parent"),
		z.literal("bolder").describe("one relative font weight bolder than parent"),
	])
	.describe("CSS font-weight property keyword values");

/**
 * Array of all font-weight keyword values.
 *
 * @public
 */
export const FONT_WEIGHT_KEYWORDS = fontWeightKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-weight keywords.
 *
 * @public
 */
export type FontWeightKeyword = z.infer<typeof fontWeightKeywordsSchema>;

/**
 * Metadata for font-weight keyword options.
 *
 * @public
 */
export const fontWeightKeywordOptions = fontWeightKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-weight keyword options metadata.
 *
 * @public
 */
export type FontWeightKeywordOptions = typeof fontWeightKeywordOptions;


=== File: src/core/keywords/geometry-box.ts ===
// b_path:: src/core/keywords/geometry-box.ts

import { z } from "zod";

/**
 * Visual box keywords used in layout and clipping contexts.
 *
 * Defines the box model edges for visual rendering:
 * - content-box: Content area only
 * - padding-box: Content + padding
 * - border-box: Content + padding + border
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-edge}
 *
 * @public
 */
export const visualBoxKeywords = ["content-box", "padding-box", "border-box"] as const;

export const visualBoxKeywordsSchema = z.enum(visualBoxKeywords);
export type VisualBoxKeyword = z.infer<typeof visualBoxKeywordsSchema>;

/**
 * Shape box keywords extend visual box with margin-box.
 *
 * Used for shape-outside and clip-path to define the reference box
 * for shape positioning.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-edge}
 *
 * @public
 */
export const shapeBoxKeywords = [...visualBoxKeywords, "margin-box"] as const;

export const shapeBoxKeywordsSchema = z.enum(shapeBoxKeywords);
export type ShapeBoxKeyword = z.infer<typeof shapeBoxKeywordsSchema>;

/**
 * Geometry box keywords extend shape box with SVG-specific keywords.
 *
 * Used for clip-path to define the clipping region reference box.
 * SVG keywords (fill-box, stroke-box, view-box) only apply in SVG context.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path#geometry-box}
 *
 * @public
 */
export const geometryBoxKeywords = [...shapeBoxKeywords, "fill-box", "stroke-box", "view-box"] as const;

export const geometryBoxKeywordsSchema = z.enum(geometryBoxKeywords);
export type GeometryBoxKeyword = z.infer<typeof geometryBoxKeywordsSchema>;


=== File: src/core/keywords/grid-auto-flow-keywords.ts ===
// b_path:: src/core/keywords/grid-auto-flow-keywords.ts
import { z } from "zod";

/**
 * CSS `grid-auto-flow` property keyword values.
 *
 * The grid-auto-flow property controls how auto-placed items get inserted into the grid.
 * It determines whether to place items by filling rows or columns, and whether to use
 * dense packing to fill holes.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow}
 *
 * @example
 * ```typescript
 * import { gridAutoFlowKeywordsSchema } from "@/core/keywords/grid-auto-flow-keywords";
 *
 * const keyword = gridAutoFlowKeywordsSchema.parse("row");
 * ```
 *
 * @public
 */
export const gridAutoFlowKeywordsSchema = z
	.union([
		z.literal("row").describe("auto-placed items fill rows"),
		z.literal("column").describe("auto-placed items fill columns"),
		z.literal("dense").describe("use dense packing algorithm to fill holes"),
		z.literal("row dense").describe("auto-placed items fill rows with dense packing"),
		z.literal("column dense").describe("auto-placed items fill columns with dense packing"),
	])
	.describe("CSS grid-auto-flow property keyword values");

/**
 * Array of all grid-auto-flow keyword values.
 *
 * @public
 */
export const GRID_AUTO_FLOW_KEYWORDS = gridAutoFlowKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for grid-auto-flow keywords.
 *
 * @public
 */
export type GridAutoFlowKeyword = z.infer<typeof gridAutoFlowKeywordsSchema>;

/**
 * Metadata for grid-auto-flow keyword options.
 *
 * @public
 */
export const gridAutoFlowKeywordOptions = gridAutoFlowKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for grid-auto-flow keyword options metadata.
 *
 * @public
 */
export type GridAutoFlowKeywordOptions = typeof gridAutoFlowKeywordOptions;


=== File: src/core/keywords/index.ts ===
// b_path:: src/core/keywords/index.ts

export * from "./align-content-keywords";
export * from "./align-items-keywords";
export * from "./align-self-keywords";
export * from "./animation";
export * from "./auto-keyword";
export * from "./background-attachment-keywords";
export * from "./basic-color-keywords";
export * from "./blend-mode-keywords";
export * from "./border-style-keywords";
export * from "./border-width-keywords";
export * from "./box-edge-keywords";
export * from "./color-interpolation-keywords";
export * from "./color-keywords";
export * from "./color-value-keywords";
export * from "./content-distribution-keywords";
export * from "./content-position-keywords";
export * from "./corner-shape-keywords";
export * from "./cursor-keywords";
export * from "./display-keywords";
export * from "./extended-color-keywords";
export * from "./flex-direction-keywords";
export * from "./flex-wrap-keywords";
export * from "./font-size-keywords";
export * from "./font-style-keywords";
export * from "./font-weight-keywords";
export * from "./geometry-box";
export * from "./grid-auto-flow-keywords";
export * from "./justify-content-keywords";
export * from "./justify-items-keywords";
export * from "./justify-items-keywords";
export * from "./justify-self-keywords";
export * from "./outline-style-keywords";
export * from "./overflow-keywords";
export * from "./overflow-wrap-keywords";
export * from "./position-keywords";
export * from "./position-property-keywords";
export * from "./repeat-keywords";
export * from "./shape-keywords";
export * from "./sizing-keywords";
export * from "./text-align-keywords";
export * from "./text-decoration-line-keywords";
export * from "./text-decoration-style-keywords";
export * from "./text-decoration-thickness-keywords";
export * from "./text-transform-keywords";
export * from "./transform-keywords";
export * from "./vertical-align-keywords";
export * from "./visibility-keywords";
export * from "./white-space-keywords";
export * from "./width-height-keywords";
export * from "./word-break-keywords";


=== File: src/core/keywords/justify-content-keywords.ts ===
// b_path:: src/core/keywords/justify-content-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-content` property keyword values.
 *
 * The justify-content property defines how the browser distributes space between
 * and around content items along the main-axis of a flex container, and the inline
 * axis of a grid container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content}
 *
 * @example
 * ```typescript
 * import { justifyContentKeywordsSchema } from "@/core/keywords/justify-content-keywords";
 *
 * const keyword = justifyContentKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const justifyContentKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items packed at start of flex direction"),
		z.literal("flex-end").describe("items packed at end of flex direction"),
		z.literal("center").describe("items centered along main axis"),
		z.literal("space-between").describe("items evenly distributed, first/last at edges"),
		z.literal("space-around").describe("items evenly distributed with equal space around"),
		z.literal("space-evenly").describe("items evenly distributed with equal space between"),
		z.literal("start").describe("items packed at start of writing mode direction"),
		z.literal("end").describe("items packed at end of writing mode direction"),
		z.literal("left").describe("items packed toward left edge"),
		z.literal("right").describe("items packed toward right edge"),
	])
	.describe("CSS justify-content property keyword values");

/**
 * Array of all justify-content keyword values.
 *
 * @public
 */
export const JUSTIFY_CONTENT_KEYWORDS = justifyContentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-content keywords.
 *
 * @public
 */
export type JustifyContentKeyword = z.infer<typeof justifyContentKeywordsSchema>;

/**
 * Metadata for justify-content keyword options.
 *
 * @public
 */
export const justifyContentKeywordOptions = justifyContentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-content keyword options metadata.
 *
 * @public
 */
export type JustifyContentKeywordOptions = typeof justifyContentKeywordOptions;


=== File: src/core/keywords/justify-items-keywords.ts ===
// b_path:: src/core/keywords/justify-items-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-items` property keyword values.
 *
 * The justify-items property defines the default justify-self for all items of the box,
 * giving them all a default way of justifying each box along the appropriate axis.
 * In grid layout, it controls the inline axis (horizontal) alignment of items within their grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items}
 *
 * @example
 * ```typescript
 * import { justifyItemsKeywordsSchema } from "@/core/keywords/justify-items-keywords";
 *
 * const keyword = justifyItemsKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const justifyItemsKeywordsSchema = z
	.union([
		z.literal("start").describe("items aligned at start of writing mode direction"),
		z.literal("end").describe("items aligned at end of writing mode direction"),
		z.literal("center").describe("items centered along inline axis"),
		z.literal("stretch").describe("items stretched to fill grid area"),
		z.literal("baseline").describe("items aligned along their baselines"),
		z.literal("flex-start").describe("items aligned at start of flex direction"),
		z.literal("flex-end").describe("items aligned at end of flex direction"),
		z.literal("self-start").describe("items aligned at start of their own writing mode"),
		z.literal("self-end").describe("items aligned at end of their own writing mode"),
		z.literal("left").describe("items aligned to left edge"),
		z.literal("right").describe("items aligned to right edge"),
	])
	.describe("CSS justify-items property keyword values");

/**
 * Array of all justify-items keyword values.
 *
 * @public
 */
export const JUSTIFY_ITEMS_KEYWORDS = justifyItemsKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-items keywords.
 *
 * @public
 */
export type JustifyItemsKeyword = z.infer<typeof justifyItemsKeywordsSchema>;

/**
 * Metadata for justify-items keyword options.
 *
 * @public
 */
export const justifyItemsKeywordOptions = justifyItemsKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-items keyword options metadata.
 *
 * @public
 */
export type JustifyItemsKeywordOptions = typeof justifyItemsKeywordOptions;


=== File: src/core/keywords/justify-self-keywords.ts ===
// b_path:: src/core/keywords/justify-self-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-self` property keyword values.
 *
 * The justify-self property sets the way a box is justified inside its alignment container
 * along the appropriate axis. In grid layout, it controls the inline axis (horizontal)
 * alignment of a single item within its grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self}
 *
 * @example
 * ```typescript
 * import { justifySelfKeywordsSchema } from "@/core/keywords/justify-self-keywords";
 *
 * const keyword = justifySelfKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const justifySelfKeywordsSchema = z
	.union([
		z.literal("auto").describe("uses parent's justify-items value"),
		z.literal("start").describe("item aligned at start of writing mode direction"),
		z.literal("end").describe("item aligned at end of writing mode direction"),
		z.literal("center").describe("item centered along inline axis"),
		z.literal("stretch").describe("item stretched to fill grid area"),
		z.literal("baseline").describe("item aligned along its baseline"),
		z.literal("flex-start").describe("item aligned at start of flex direction"),
		z.literal("flex-end").describe("item aligned at end of flex direction"),
		z.literal("self-start").describe("item aligned at start of its own writing mode"),
		z.literal("self-end").describe("item aligned at end of its own writing mode"),
		z.literal("left").describe("item aligned to left edge"),
		z.literal("right").describe("item aligned to right edge"),
	])
	.describe("CSS justify-self property keyword values");

/**
 * Array of all justify-self keyword values.
 *
 * @public
 */
export const JUSTIFY_SELF_KEYWORDS = justifySelfKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-self keywords.
 *
 * @public
 */
export type JustifySelfKeyword = z.infer<typeof justifySelfKeywordsSchema>;

/**
 * Metadata for justify-self keyword options.
 *
 * @public
 */
export const justifySelfKeywordOptions = justifySelfKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-self keyword options metadata.
 *
 * @public
 */
export type JustifySelfKeywordOptions = typeof justifySelfKeywordOptions;


=== File: src/core/keywords/outline-style-keywords.ts ===
// b_path:: src/core/keywords/outline-style-keywords.ts
import { z } from "zod";

/**
 * CSS outline-style keyword values.
 *
 * The outline-style property sets the style of an element's outline.
 * Includes 'auto' which is outline-specific, plus all border-style values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style}
 *
 * @public
 */
export const outlineStyleKeywordsSchema = z
	.union([
		z.literal("auto").describe("browser determines outline style"),
		z.literal("none").describe("no outline"),
		z.literal("hidden").describe("same as none, but with different behavior in table elements"),
		z.literal("dotted").describe("series of round dots"),
		z.literal("dashed").describe("series of short square-ended dashes"),
		z.literal("solid").describe("single, straight, solid line"),
		z.literal("double").describe("two straight lines that add up to the pixel size"),
		z.literal("groove").describe("carved effect - opposite of ridge"),
		z.literal("ridge").describe("extruded effect - opposite of groove"),
		z.literal("inset").describe("outline makes element appear embedded"),
		z.literal("outset").describe("outline makes element appear raised"),
	])
	.describe("CSS outline-style property keyword values");

/**
 * Array of all outline-style keyword values.
 *
 * @public
 */
export const OUTLINE_STYLE_KEYWORDS = outlineStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for outline-style keywords.
 *
 * @public
 */
export type OutlineStyleKeyword = z.infer<typeof outlineStyleKeywordsSchema>;

/**
 * Metadata for outline-style keyword options.
 *
 * @public
 */
export const outlineStyleKeywordOptions = outlineStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for outline-style keyword options metadata.
 *
 * @public
 */
export type OutlineStyleKeywordOptions = typeof outlineStyleKeywordOptions;


=== File: src/core/keywords/overflow-keywords.ts ===
// b_path:: src/core/keywords/overflow-keywords.ts
import { z } from "zod";

/**
 * CSS overflow keyword values.
 *
 * The overflow, overflow-x, and overflow-y properties control what happens when content
 * overflows an element's box. These properties apply to block containers, flex containers,
 * and grid containers.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow}
 * @see {@link https://www.w3.org/TR/css-overflow-3/#overflow-properties}
 *
 * @example
 * ```typescript
 * import { overflowKeywordsSchema } from "@/core/keywords/overflow-keywords";
 *
 * const keyword = overflowKeywordsSchema.parse("hidden");
 * ```
 *
 * @public
 */
export const overflowKeywordsSchema = z
	.union([
		z.literal("visible").describe("content is not clipped and may overflow the element's box"),
		z.literal("hidden").describe("content is clipped and no scrollbars are provided"),
		z.literal("clip").describe("content is clipped at the overflow clip edge, no scrollbars"),
		z.literal("scroll").describe("content is clipped and scrollbars are always shown"),
		z.literal("auto").describe("content is clipped and scrollbars shown only when needed"),
	])
	.describe("CSS overflow property keyword values");

/**
 * Array of all overflow keyword values.
 *
 * @public
 */
export const OVERFLOW_KEYWORDS = overflowKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for overflow keywords.
 *
 * @public
 */
export type OverflowKeyword = z.infer<typeof overflowKeywordsSchema>;

/**
 * Metadata for overflow keyword options.
 *
 * @public
 */
export const overflowKeywordOptions = overflowKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for overflow keyword options metadata.
 *
 * @public
 */
export type OverflowKeywordOptions = typeof overflowKeywordOptions;


=== File: src/core/keywords/overflow-wrap-keywords.ts ===
// b_path:: src/core/keywords/overflow-wrap-keywords.ts
import { z } from "zod";

/**
 * CSS overflow-wrap keyword values.
 *
 * The overflow-wrap property applies to inline elements, setting whether the browser
 * should insert line breaks within an otherwise unbreakable string to prevent text
 * from overflowing its line box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap}
 *
 * @example
 * ```typescript
 * import { overflowWrapKeywordsSchema } from "@/core/keywords/overflow-wrap-keywords";
 *
 * const keyword = overflowWrapKeywordsSchema.parse("break-word");
 * ```
 *
 * @public
 */
export const overflowWrapKeywordsSchema = z
	.union([
		z.literal("normal").describe("lines break only at normal break points"),
		z.literal("anywhere").describe("breaks at any character if no acceptable break point"),
		z.literal("break-word").describe("like anywhere but affects min-content size"),
	])
	.describe("CSS overflow-wrap property keyword values");

/**
 * Array of all overflow-wrap keyword values.
 *
 * @public
 */
export const OVERFLOW_WRAP_KEYWORDS = overflowWrapKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for overflow-wrap keywords.
 *
 * @public
 */
export type OverflowWrapKeyword = z.infer<typeof overflowWrapKeywordsSchema>;

/**
 * Metadata for overflow-wrap keyword options.
 *
 * @public
 */
export const overflowWrapKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Lines break only at normal break points",
	},
	anywhere: {
		value: "anywhere" as const,
		description: "Breaks at any character if no acceptable break point",
	},
	"break-word": {
		value: "break-word" as const,
		description: "Like anywhere but affects min-content size",
	},
} as const;


=== File: src/core/keywords/position-keywords.ts ===
// b_path:: src/core/keywords/position-keywords.ts
import { z } from "zod";

/**
 * CSS position keywords.
 *
 * Position keywords specify locations along horizontal and vertical axes.
 * Used extensively in properties like background-position, object-position,
 * transform-origin, and perspective-origin.
 *
 * Keywords can be combined in various ways:
 * - Single keyword: `center` (applies to both axes)
 * - Horizontal + vertical: `left top`, `center bottom`
 * - Edge + offset: `left 10px top 20px`
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionKeywordsSchema } from "@/core/keywords/position-keywords";
 *
 * const keyword = positionKeywordsSchema.parse("center"); // "center"
 * ```
 *
 * @public
 */
export const positionKeywordsSchema = z
	.union([
		z.literal("center").describe("centered on both axes (50% 50%)"),
		z.literal("left").describe("left edge (0% on horizontal axis)"),
		z.literal("right").describe("right edge (100% on horizontal axis)"),
		z.literal("top").describe("top edge (0% on vertical axis)"),
		z.literal("bottom").describe("bottom edge (100% on vertical axis)"),
	])
	.describe(
		"Position keywords specify locations along horizontal and vertical axes. " +
			"Used in background-position, object-position, transform-origin, etc.",
	);

/**
 * Array of all position keyword values.
 *
 * @example
 * ```typescript
 * import { POSITION_KEYWORDS } from "@/core/keywords/position-keywords";
 *
 * console.log(POSITION_KEYWORDS);
 * // ["center", "left", "right", "top", "bottom"]
 * ```
 *
 * @public
 */
export const POSITION_KEYWORDS = positionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for position keywords.
 *
 * @public
 */
export type PositionKeyword = z.infer<typeof positionKeywordsSchema>;

/**
 * Metadata for position keyword options.
 *
 * Provides value and description for each position keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { positionKeywordOptions } from "@/core/keywords/position-keywords";
 *
 * positionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const positionKeywordOptions = positionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for position keyword options metadata.
 *
 * @public
 */
export type PositionKeywordOptions = typeof positionKeywordOptions;

/**
 * CSS horizontal edge position keywords.
 *
 * Subset of position keywords that specify horizontal edges.
 * Used in four-value syntax for properties like background-position:
 * `right 10px bottom 20px` (edge + offset pairs)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionHorizontalEdgeKeywordsSchema } from "@/core/keywords/position-keywords";
 *
 * const edge = positionHorizontalEdgeKeywordsSchema.parse("left"); // "left"
 * ```
 *
 * @public
 */
export const positionHorizontalEdgeKeywordsSchema = z
	.union([z.literal("left").describe("left horizontal edge"), z.literal("right").describe("right horizontal edge")])
	.describe("Horizontal edge position keywords (left, right) for edge+offset syntax.");

/**
 * Array of horizontal edge position keywords.
 *
 * @public
 */
export const POSITION_HORIZONTAL_EDGE_KEYWORDS = positionHorizontalEdgeKeywordsSchema.options.map(
	(option) => option.value,
);

/**
 * TypeScript type for horizontal edge position keywords.
 *
 * @public
 */
export type PositionHorizontalEdgeKeyword = z.infer<typeof positionHorizontalEdgeKeywordsSchema>;

/**
 * CSS vertical edge position keywords.
 *
 * Subset of position keywords that specify vertical edges.
 * Used in four-value syntax for properties like background-position:
 * `right 10px bottom 20px` (edge + offset pairs)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionVerticalEdgeKeywordsSchema } from "@/core/keywords/position-keywords";
 *
 * const edge = positionVerticalEdgeKeywordsSchema.parse("top"); // "top"
 * ```
 *
 * @public
 */
export const positionVerticalEdgeKeywordsSchema = z
	.union([z.literal("top").describe("top vertical edge"), z.literal("bottom").describe("bottom vertical edge")])
	.describe("Vertical edge position keywords (top, bottom) for edge+offset syntax.");

/**
 * Array of vertical edge position keywords.
 *
 * @public
 */
export const POSITION_VERTICAL_EDGE_KEYWORDS = positionVerticalEdgeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for vertical edge position keywords.
 *
 * @public
 */
export type PositionVerticalEdgeKeyword = z.infer<typeof positionVerticalEdgeKeywordsSchema>;


=== File: src/core/keywords/position-property-keywords.ts ===
// b_path:: src/core/keywords/position-property-keywords.ts
import { z } from "zod";

/**
 * CSS position property keyword values.
 *
 * The position property sets how an element is positioned in a document.
 * The top, right, bottom, and left properties determine the final location
 * of positioned elements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position}
 * @see {@link https://www.w3.org/TR/css-position-3/#position-property}
 *
 * @example
 * ```typescript
 * import { positionPropertyKeywordsSchema } from "@/core/keywords/position-property-keywords";
 *
 * const keyword = positionPropertyKeywordsSchema.parse("absolute");
 * ```
 *
 * @public
 */
export const positionPropertyKeywordsSchema = z
	.union([
		z.literal("static").describe("positioned according to normal flow (default)"),
		z.literal("relative").describe("positioned relative to its normal position"),
		z.literal("absolute").describe("positioned relative to nearest positioned ancestor"),
		z.literal("fixed").describe("positioned relative to the viewport"),
		z.literal("sticky").describe("positioned based on scroll position (hybrid of relative and fixed)"),
	])
	.describe("CSS position property keyword values");

/**
 * Array of all position property keyword values.
 *
 * @public
 */
export const POSITION_PROPERTY_KEYWORDS = positionPropertyKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for position property keywords.
 *
 * @public
 */
export type PositionPropertyKeyword = z.infer<typeof positionPropertyKeywordsSchema>;

/**
 * Metadata for position property keyword options.
 *
 * @public
 */
export const positionPropertyKeywordOptions = positionPropertyKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for position property keyword options metadata.
 *
 * @public
 */
export type PositionPropertyKeywordOptions = typeof positionPropertyKeywordOptions;


=== File: src/core/keywords/repeat-keywords.ts ===
// b_path:: src/core/keywords/repeat-keywords.ts
import { z } from "zod";

/**
 * CSS background-repeat single value keywords.
 *
 * These keywords control how background images repeat along both axes.
 * Used in the single-value syntax of background-repeat.
 *
 * - `repeat`: Images repeat in both directions (tiles to fill area)
 * - `repeat-x`: Images repeat horizontally only (shorthand for `repeat no-repeat`)
 * - `repeat-y`: Images repeat vertically only (shorthand for `no-repeat repeat`)
 * - `no-repeat`: Images don't repeat (displayed once)
 * - `space`: Images repeat with spacing between them to fill area exactly
 * - `round`: Images repeat and scale to fill area without clipping
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat}
 *
 * @example
 * ```typescript
 * import { repeatKeywordsSchema } from "@/core/keywords/repeat-keywords";
 *
 * const keyword = repeatKeywordsSchema.parse("repeat-x"); // "repeat-x"
 * ```
 *
 * @public
 */
export const repeatKeywordsSchema = z
	.union([
		z.literal("repeat").describe("repeat in both directions"),
		z.literal("repeat-x").describe("repeat horizontally only"),
		z.literal("repeat-y").describe("repeat vertically only"),
		z.literal("no-repeat").describe("do not repeat"),
		z.literal("space").describe("repeat with spacing to fill area exactly"),
		z.literal("round").describe("repeat and scale to fill area without clipping"),
	])
	.describe(
		"Keywords for background-repeat single value syntax. " + "Controls how background images repeat along both axes.",
	);

/**
 * Array of all repeat keyword values.
 *
 * @example
 * ```typescript
 * import { REPEAT_KEYWORDS } from "@/core/keywords/repeat-keywords";
 *
 * console.log(REPEAT_KEYWORDS);
 * // ["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"]
 * ```
 *
 * @public
 */
export const REPEAT_KEYWORDS = repeatKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for repeat keywords.
 *
 * @public
 */
export type RepeatKeyword = z.infer<typeof repeatKeywordsSchema>;

/**
 * Metadata for repeat keyword options.
 *
 * Provides value and description for each repeat keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { repeatKeywordOptions } from "@/core/keywords/repeat-keywords";
 *
 * repeatKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const repeatKeywordOptions = repeatKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for repeat keyword options metadata.
 *
 * @public
 */
export type RepeatKeywordOptions = typeof repeatKeywordOptions;

/**
 * CSS background-repeat two-value keywords.
 *
 * Subset of repeat keywords valid in two-value syntax.
 * Used to specify separate horizontal and vertical repeat behavior.
 *
 * Note: `repeat-x` and `repeat-y` are NOT valid in two-value syntax
 * as they are themselves shorthand for two-value combinations:
 * - `repeat-x` = `repeat no-repeat`
 * - `repeat-y` = `no-repeat repeat`
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat}
 *
 * @example
 * ```typescript
 * import { repeatTwoValueKeywordsSchema } from "@/core/keywords/repeat-keywords";
 *
 * // Valid in two-value syntax
 * const horizontal = repeatTwoValueKeywordsSchema.parse("repeat"); // "repeat"
 * const vertical = repeatTwoValueKeywordsSchema.parse("space"); // "space"
 *
 * // Invalid in two-value syntax (would fail validation)
 * // repeatTwoValueKeywordsSchema.parse("repeat-x"); // Error!
 * ```
 *
 * @public
 */
export const repeatTwoValueKeywordsSchema = z
	.union([
		z.literal("repeat").describe("repeat along axis"),
		z.literal("space").describe("repeat with spacing along axis"),
		z.literal("round").describe("repeat and scale along axis"),
		z.literal("no-repeat").describe("do not repeat along axis"),
	])
	.describe(
		"Keywords for background-repeat two-value syntax (horizontal/vertical). " +
			"Note: repeat-x and repeat-y are not valid in two-value syntax.",
	);

/**
 * Array of two-value repeat keywords.
 *
 * @public
 */
export const REPEAT_TWO_VALUE_KEYWORDS = repeatTwoValueKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for two-value repeat keywords.
 *
 * @public
 */
export type RepeatTwoValueKeyword = z.infer<typeof repeatTwoValueKeywordsSchema>;

/**
 * Metadata for two-value repeat keyword options.
 *
 * @public
 */
export const repeatTwoValueKeywordOptions = repeatTwoValueKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for two-value repeat keyword options metadata.
 *
 * @public
 */
export type RepeatTwoValueKeywordOptions = typeof repeatTwoValueKeywordOptions;


=== File: src/core/keywords/shape-keywords.ts ===
// b_path:: src/core/keywords/shape-keywords.ts
import { z } from "zod";

/**
 * CSS shape radius keywords for circles and ellipses.
 *
 * Shape radius keywords specify the radius of circles and ellipses relative to the reference box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape}
 * @public
 */
export const shapeRadiusKeywordsSchema = z
	.union([
		z.literal("closest-side").describe("length from center to closest side of reference box"),
		z.literal("farthest-side").describe("length from center to farthest side of reference box"),
	])
	.describe("Shape radius keywords for circles and ellipses");

/**
 * Array of all shape radius keyword values.
 *
 * @public
 */
export const SHAPE_RADIUS_KEYWORDS = shapeRadiusKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for shape radius keywords.
 *
 * @public
 */
export type ShapeRadiusKeyword = z.infer<typeof shapeRadiusKeywordsSchema>;

/**
 * CSS fill-rule keywords.
 *
 * Fill rule determines how the interior of shapes is filled.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule}
 * @public
 */
export const fillRuleKeywordsSchema = z
	.union([
		z.literal("nonzero").describe("nonzero winding rule (default)"),
		z.literal("evenodd").describe("even-odd winding rule"),
	])
	.describe("Fill rule determines how interior of shapes is filled");

/**
 * Array of all fill-rule keyword values.
 *
 * @public
 */
export const FILL_RULE_KEYWORDS = fillRuleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for fill-rule keywords.
 *
 * @public
 */
export type FillRuleKeyword = z.infer<typeof fillRuleKeywordsSchema>;

/**
 * CSS basic shape function keywords.
 *
 * Basic shape functions create geometric shapes for use in clip-path, shape-outside,
 * and other CSS properties.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape}
 * @public
 */
export const basicShapeKeywordsSchema = z
	.union([
		z.literal("inset").describe("rectangle by container inset"),
		z.literal("circle").describe("circular shape"),
		z.literal("ellipse").describe("elliptical shape"),
		z.literal("polygon").describe("polygonal shape with multiple points"),
		z.literal("path").describe("custom path shape"),
		z.literal("rect").describe("rectangle by coordinates"),
		z.literal("xywh").describe("rectangle by x, y, width, height"),
	])
	.describe(
		"Basic shape functions for creating geometric shapes. " +
			"Used in clip-path, shape-outside, and other CSS properties.",
	);

/**
 * Array of all basic shape keyword values.
 *
 * @public
 */
export const BASIC_SHAPE_KEYWORDS = basicShapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for basic shape keywords.
 *
 * @public
 */
export type BasicShapeKeyword = z.infer<typeof basicShapeKeywordsSchema>;

/**
 * Combined CSS shape keywords.
 *
 * Includes basic shapes, shape radius keywords, and fill rules.
 *
 * @public
 */
export const shapeKeywordsSchema = z
	.union([
		// Basic shapes
		z
			.literal("inset")
			.describe("rectangle by container inset"),
		z.literal("circle").describe("circular shape"),
		z.literal("ellipse").describe("elliptical shape"),
		z.literal("polygon").describe("polygonal shape with multiple points"),
		z.literal("path").describe("custom path shape"),
		z.literal("rect").describe("rectangle by coordinates"),
		z.literal("xywh").describe("rectangle by x, y, width, height"),

		// Shape radius
		z
			.literal("closest-side")
			.describe("length from center to closest side of reference box"),
		z.literal("farthest-side").describe("length from center to farthest side of reference box"),

		// Fill rules
		z
			.literal("nonzero")
			.describe("nonzero winding rule (default)"),
		z.literal("evenodd").describe("even-odd winding rule"),
	])
	.describe("CSS shape-related keywords");

/**
 * Array of all shape keyword values.
 *
 * @public
 */
export const SHAPE_KEYWORDS = shapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for shape keywords.
 *
 * @public
 */
export type ShapeKeyword = z.infer<typeof shapeKeywordsSchema>;

/**
 * Metadata for shape keyword options.
 *
 * @public
 */
export const shapeKeywordOptions = shapeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for shape keyword options metadata.
 *
 * @public
 */
export type ShapeKeywordOptions = typeof shapeKeywordOptions;


=== File: src/core/keywords/sizing-keywords.ts ===
// b_path:: src/core/keywords/sizing-keywords.ts
import { z } from "zod";

/**
 * CSS sizing keywords for properties like `background-size`, `object-fit`, etc.
 *
 * These keywords control how content is sized to fit its container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit}
 *
 * @example
 * ```typescript
 * import { sizingKeywordsSchema } from "@/core/keywords/sizing-keywords";
 *
 * // Parse and validate
 * const size = sizingKeywordsSchema.parse("cover"); // "cover"
 *
 * // Use in background-size
 * const backgroundSize = "contain";
 * ```
 *
 * @public
 */
export const sizingKeywordsSchema = z
	.union([
		z.literal("cover").describe("scale content to cover container (may crop to maintain aspect ratio)"),
		z
			.literal("contain")
			.describe("scale content to fit inside container (maintains aspect ratio, may have empty space)"),
	])
	.describe("sizing keywords that control how content is sized to fit its container");

/**
 * TypeScript type for sizing keywords.
 *
 * @public
 */
export type SizingKeyword = z.infer<typeof sizingKeywordsSchema>;

/**
 * Array of all valid sizing keyword values.
 *
 * Extracted from the schema for runtime iteration.
 *
 * @example
 * ```typescript
 * import { SIZING_KEYWORDS } from "@/core/keywords/sizing-keywords";
 *
 * // Iterate over keywords
 * SIZING_KEYWORDS.forEach(keyword => {
 *   console.log(keyword); // "cover", "contain"
 * });
 *
 * // Check if value is valid
 * if (SIZING_KEYWORDS.includes(input)) {
 *   // Valid sizing keyword
 * }
 * ```
 *
 * @public
 */
export const SIZING_KEYWORDS = sizingKeywordsSchema.options.map((option) => option.value);

/**
 * Metadata for sizing keywords including descriptions.
 *
 * Provides both value and description for each keyword option,
 * useful for generating Studio UI select menus or documentation.
 *
 * @example
 * ```typescript
 * import { sizingKeywordOptions } from "@/core/keywords/sizing-keywords";
 *
 * // Generate UI options
 * sizingKeywordOptions.forEach(({ value, description }) => {
 *   <Option value={value} tooltip={description} />
 * });
 * ```
 *
 * @public
 */
export const sizingKeywordOptions = sizingKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for sizing keyword options metadata array.
 *
 * @public
 */
export type SizingKeywordOptions = typeof sizingKeywordOptions;


=== File: src/core/keywords/system-color-keywords.ts ===
// b_path:: src/core/keywords/system-color-keywords.ts
import { z } from "zod";

/**
 * CSS system color keywords (CSS Color Module Level 4).
 *
 * System colors represent colors from the user's operating system or browser theme.
 * These allow web content to integrate with the user's system appearance.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#css-system-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/system-color}
 * @public
 */
export const systemColorKeywordsSchema = z
	.union([
		z.literal("AccentColor").describe("Accent color from the user's system"),
		z.literal("AccentColorText").describe("Text color on accent color backgrounds"),
		z.literal("ActiveText").describe("Text color of active links"),
		z.literal("ButtonBorder").describe("Border color of controls"),
		z.literal("ButtonFace").describe("Background color of controls"),
		z.literal("ButtonText").describe("Text color of controls"),
		z.literal("Canvas").describe("Background color of application content or documents"),
		z.literal("CanvasText").describe("Text color in application content or documents"),
		z.literal("Field").describe("Background color of input fields"),
		z.literal("FieldText").describe("Text color in input fields"),
		z.literal("GrayText").describe("Text color for disabled items"),
		z.literal("Highlight").describe("Background color of selected items"),
		z.literal("HighlightText").describe("Text color of selected items"),
		z.literal("LinkText").describe("Text color of non-active, non-visited links"),
		z.literal("Mark").describe("Background color of marked/highlighted text"),
		z.literal("MarkText").describe("Text color of marked/highlighted text"),
		z.literal("SelectedItem").describe("Background color of selected items"),
		z.literal("SelectedItemText").describe("Text color of selected items"),
		z.literal("VisitedText").describe("Text color of visited links"),
	])
	.describe("CSS system color keywords");

/**
 * Array of all system color keyword values.
 *
 * @example
 * ```typescript
 * import { SYSTEM_COLOR_KEYWORDS } from "@/core/keywords/system-color-keywords";
 *
 * console.log(SYSTEM_COLOR_KEYWORDS);
 * // ["AccentColor", "AccentColorText", "ActiveText", ...]
 * ```
 *
 * @public
 */
export const SYSTEM_COLOR_KEYWORDS = systemColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for system color keywords.
 *
 * @public
 */
export type SystemColorKeyword = z.infer<typeof systemColorKeywordsSchema>;

/**
 * Metadata for system color keyword options.
 *
 * Provides value and description for each system color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { systemColorKeywordOptions } from "@/core/keywords/system-color-keywords";
 *
 * systemColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const systemColorKeywordOptions = systemColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for system color keyword options metadata.
 *
 * @public
 */
export type SystemColorKeywordOptions = typeof systemColorKeywordOptions;


=== File: src/core/keywords/text-align-keywords.ts ===
// b_path:: src/core/keywords/text-align-keywords.ts
import { z } from "zod";

/**
 * CSS text-align keyword values.
 *
 * The text-align property sets the horizontal alignment of the inline-level content
 * inside a block element or table-cell box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-align}
 *
 * @example
 * ```typescript
 * import { textAlignKeywordsSchema } from "@/core/keywords/text-align-keywords";
 *
 * const keyword = textAlignKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const textAlignKeywordsSchema = z
	.union([
		z.literal("left").describe("inline contents aligned to left edge"),
		z.literal("right").describe("inline contents aligned to right edge"),
		z.literal("center").describe("inline contents centered"),
		z.literal("justify").describe("inline contents justified (text spaced to fill line)"),
		z.literal("start").describe("aligned to start edge of writing mode direction"),
		z.literal("end").describe("aligned to end edge of writing mode direction"),
	])
	.describe("CSS text-align property keyword values");

/**
 * Array of all text-align keyword values.
 *
 * @public
 */
export const TEXT_ALIGN_KEYWORDS = textAlignKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-align keywords.
 *
 * @public
 */
export type TextAlignKeyword = z.infer<typeof textAlignKeywordsSchema>;

/**
 * Metadata for text-align keyword options.
 *
 * @public
 */
export const textAlignKeywordOptions = textAlignKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-align keyword options metadata.
 *
 * @public
 */
export type TextAlignKeywordOptions = typeof textAlignKeywordOptions;


=== File: src/core/keywords/text-decoration-line-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-line-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-line keyword values.
 *
 * The text-decoration-line property sets the kind of decoration that is used on text
 * in an element, such as an underline or overline.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-line}
 *
 * @example
 * ```typescript
 * import { textDecorationLineKeywordsSchema } from "@/core/keywords/text-decoration-line-keywords";
 *
 * const keyword = textDecorationLineKeywordsSchema.parse("underline");
 * ```
 *
 * @public
 */
export const textDecorationLineKeywordsSchema = z
	.union([
		z.literal("none").describe("no text decoration"),
		z.literal("underline").describe("line below the text"),
		z.literal("overline").describe("line above the text"),
		z.literal("line-through").describe("line through the middle of the text"),
	])
	.describe("CSS text-decoration-line property keyword values");

/**
 * Array of all text-decoration-line keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_LINE_KEYWORDS = textDecorationLineKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-decoration-line keywords.
 *
 * @public
 */
export type TextDecorationLineKeyword = z.infer<typeof textDecorationLineKeywordsSchema>;

/**
 * Metadata for text-decoration-line keyword options.
 *
 * @public
 */
export const textDecorationLineKeywordOptions = textDecorationLineKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-line keyword options metadata.
 *
 * @public
 */
export type TextDecorationLineKeywordOptions = typeof textDecorationLineKeywordOptions;


=== File: src/core/keywords/text-decoration-style-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-style-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-style keyword values.
 *
 * The text-decoration-style property sets the style of the lines specified
 * by text-decoration-line.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-style}
 *
 * @public
 */
export const textDecorationStyleKeywordsSchema = z
	.union([
		z.literal("solid").describe("single line"),
		z.literal("double").describe("double line"),
		z.literal("dotted").describe("dotted line"),
		z.literal("dashed").describe("dashed line"),
		z.literal("wavy").describe("wavy line"),
	])
	.describe("CSS text-decoration-style property keyword values");

/**
 * Array of all text-decoration-style keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_STYLE_KEYWORDS = textDecorationStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-decoration-style keywords.
 *
 * @public
 */
export type TextDecorationStyleKeyword = z.infer<typeof textDecorationStyleKeywordsSchema>;

/**
 * Metadata for text-decoration-style keyword options.
 *
 * @public
 */
export const textDecorationStyleKeywordOptions = textDecorationStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-style keyword options metadata.
 *
 * @public
 */
export type TextDecorationStyleKeywordOptions = typeof textDecorationStyleKeywordOptions;


=== File: src/core/keywords/text-decoration-thickness-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-thickness-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-thickness keyword values.
 *
 * The text-decoration-thickness property sets the thickness of the decoration
 * line used on text.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-thickness}
 *
 * @public
 */
export const textDecorationThicknessKeywordsSchema = z
	.union([
		z.literal("auto").describe("browser chooses thickness"),
		z.literal("from-font").describe("use thickness from font file"),
	])
	.describe("CSS text-decoration-thickness property keyword values");

/**
 * Array of all text-decoration-thickness keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_THICKNESS_KEYWORDS = textDecorationThicknessKeywordsSchema.options.map(
	(option) => option.value,
);

/**
 * TypeScript type for text-decoration-thickness keywords.
 *
 * @public
 */
export type TextDecorationThicknessKeyword = z.infer<typeof textDecorationThicknessKeywordsSchema>;

/**
 * Metadata for text-decoration-thickness keyword options.
 *
 * @public
 */
export const textDecorationThicknessKeywordOptions = textDecorationThicknessKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-thickness keyword options metadata.
 *
 * @public
 */
export type TextDecorationThicknessKeywordOptions = typeof textDecorationThicknessKeywordOptions;


=== File: src/core/keywords/text-transform-keywords.ts ===
// b_path:: src/core/keywords/text-transform-keywords.ts
import { z } from "zod";

/**
 * CSS text-transform keyword values.
 *
 * The text-transform property specifies how to capitalize an element's text.
 * It can be used to make text appear in all-uppercase or all-lowercase, or with
 * each word capitalized.
 *
 * Includes CSS Text Level 4 values for CJK (Chinese/Japanese/Korean) typography support.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform}
 * @see {@link https://www.w3.org/TR/css-text-4/#text-transform-property}
 *
 * @example
 * ```typescript
 * import { textTransformKeywordsSchema } from "@/core/keywords/text-transform-keywords";
 *
 * const keyword = textTransformKeywordsSchema.parse("uppercase");
 * ```
 *
 * @public
 */
export const textTransformKeywordsSchema = z
	.union([
		z.literal("none").describe("no capitalization, text renders as is"),
		z.literal("capitalize").describe("first letter of each word capitalized"),
		z.literal("uppercase").describe("all characters converted to uppercase"),
		z.literal("lowercase").describe("all characters converted to lowercase"),
		z.literal("full-width").describe("transforms characters to their fullwidth forms (CJK typography)"),
		z.literal("full-size-kana").describe("converts small Kana to full-size characters (Japanese typography)"),
	])
	.describe("CSS text-transform property keyword values (includes CSS Text Level 4 values)");

/**
 * Array of all text-transform keyword values.
 *
 * @public
 */
export const TEXT_TRANSFORM_KEYWORDS = textTransformKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-transform keywords.
 *
 * @public
 */
export type TextTransformKeyword = z.infer<typeof textTransformKeywordsSchema>;

/**
 * Metadata for text-transform keyword options.
 *
 * @public
 */
export const textTransformKeywordOptions = textTransformKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-transform keyword options metadata.
 *
 * @public
 */
export type TextTransformKeywordOptions = typeof textTransformKeywordOptions;


=== File: src/core/keywords/transform-keywords.ts ===
// b_path:: src/core/keywords/transform-keywords.ts

/**
 * CSS transform function names.
 *
 * All valid CSS transform function identifiers used in the transform property.
 * These are the canonical lowercase names as they appear in CSS.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function}
 *
 * @public
 */
export const TRANSFORM_FUNCTION_NAMES = [
	"translate",
	"translatex",
	"translatey",
	"translatez",
	"translate3d",
	"rotate",
	"rotatex",
	"rotatey",
	"rotatez",
	"rotate3d",
	"scale",
	"scalex",
	"scaley",
	"scalez",
	"scale3d",
	"skew",
	"skewx",
	"skewy",
	"matrix",
	"matrix3d",
	"perspective",
] as const;

/**
 * Type representing valid CSS transform function names.
 * @public
 */
export type TransformFunctionName = (typeof TRANSFORM_FUNCTION_NAMES)[number];

/**
 * Check if a string is a valid transform function name.
 *
 * @param name - String to check (case-insensitive)
 * @returns True if the name is a valid transform function
 *
 * @public
 */
export function isTransformFunctionName(name: string): name is TransformFunctionName {
	return TRANSFORM_FUNCTION_NAMES.includes(name.toLowerCase() as TransformFunctionName);
}


=== File: src/core/keywords/vertical-align-keywords.ts ===
// b_path:: src/core/keywords/vertical-align-keywords.ts
import { z } from "zod";

/**
 * CSS vertical-align keyword values.
 *
 * The vertical-align property sets vertical alignment of an inline, inline-block
 * or table-cell box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align}
 *
 * @public
 */
export const verticalAlignKeywordsSchema = z
	.union([
		z.literal("baseline").describe("align baseline with parent baseline"),
		z.literal("sub").describe("align baseline with parent subscript baseline"),
		z.literal("super").describe("align baseline with parent superscript baseline"),
		z.literal("text-top").describe("align top with parent font top"),
		z.literal("text-bottom").describe("align bottom with parent font bottom"),
		z.literal("middle").describe("align middle with parent baseline plus half x-height"),
		z.literal("top").describe("align top with line top"),
		z.literal("bottom").describe("align bottom with line bottom"),
	])
	.describe("CSS vertical-align property keyword values");

/**
 * Array of all vertical-align keyword values.
 *
 * @public
 */
export const VERTICAL_ALIGN_KEYWORDS = verticalAlignKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for vertical-align keywords.
 *
 * @public
 */
export type VerticalAlignKeyword = z.infer<typeof verticalAlignKeywordsSchema>;

/**
 * Metadata for vertical-align keyword options.
 *
 * @public
 */
export const verticalAlignKeywordOptions = verticalAlignKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for vertical-align keyword options metadata.
 *
 * @public
 */
export type VerticalAlignKeywordOptions = typeof verticalAlignKeywordOptions;


=== File: src/core/keywords/visibility-keywords.ts ===
// b_path:: src/core/keywords/visibility-keywords.ts
import { z } from "zod";

/**
 * CSS visibility keywords.
 *
 * The visibility property controls whether an element is visible or hidden.
 * Unlike display: none, visibility: hidden elements still take up space in the layout.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility}
 *
 * @example
 * ```typescript
 * import { visibilityKeywordsSchema } from "@/core/keywords/visibility-keywords";
 *
 * const keyword = visibilityKeywordsSchema.parse("hidden"); // "hidden"
 * ```
 *
 * @public
 */
export const visibilityKeywordsSchema = z
	.union([
		z.literal("visible").describe("element is visible"),
		z.literal("hidden").describe("element is invisible but still takes up space"),
		z.literal("collapse").describe("for table elements, removes row/column without affecting layout"),
	])
	.describe("CSS visibility property values that control element visibility");

/**
 * Array of all visibility keyword values.
 *
 * @example
 * ```typescript
 * import { VISIBILITY_KEYWORDS } from "@/core/keywords/visibility-keywords";
 *
 * console.log(VISIBILITY_KEYWORDS); // ["visible", "hidden", "collapse"]
 * ```
 *
 * @public
 */
export const VISIBILITY_KEYWORDS = visibilityKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for visibility keywords.
 *
 * @public
 */
export type VisibilityKeyword = z.infer<typeof visibilityKeywordsSchema>;

/**
 * Metadata for visibility keyword options.
 *
 * Provides value and description for each visibility keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { visibilityKeywordOptions } from "@/core/keywords/visibility-keywords";
 *
 * visibilityKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const visibilityKeywordOptions = visibilityKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for visibility keyword options metadata.
 *
 * @public
 */
export type VisibilityKeywordOptions = typeof visibilityKeywordOptions;


=== File: src/core/keywords/white-space-keywords.ts ===
// b_path:: src/core/keywords/white-space-keywords.ts
import { z } from "zod";

/**
 * CSS white-space keyword values.
 *
 * The white-space property sets how white space inside an element is handled.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space}
 *
 * @example
 * ```typescript
 * import { whiteSpaceKeywordsSchema } from "@/core/keywords/white-space-keywords";
 *
 * const keyword = whiteSpaceKeywordsSchema.parse("nowrap");
 * ```
 *
 * @public
 */
export const whiteSpaceKeywordsSchema = z
	.union([
		z.literal("normal").describe("sequences of whitespace collapsed, newlines ignored"),
		z.literal("nowrap").describe("collapses whitespace, prevents wrapping"),
		z.literal("pre").describe("preserves whitespace and newlines, no wrapping"),
		z.literal("pre-wrap").describe("preserves whitespace and newlines, wraps normally"),
		z.literal("pre-line").describe("collapses whitespace, preserves newlines, wraps normally"),
		z.literal("break-spaces").describe("like pre-wrap but preserves sequences of spaces"),
	])
	.describe("CSS white-space property keyword values");

/**
 * Array of all white-space keyword values.
 *
 * @public
 */
export const WHITE_SPACE_KEYWORDS = whiteSpaceKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for white-space keywords.
 *
 * @public
 */
export type WhiteSpaceKeyword = z.infer<typeof whiteSpaceKeywordsSchema>;

/**
 * Metadata for white-space keyword options.
 *
 * @public
 */
export const whiteSpaceKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Sequences of whitespace collapsed, newlines ignored",
	},
	nowrap: {
		value: "nowrap" as const,
		description: "Collapses whitespace, prevents wrapping",
	},
	pre: {
		value: "pre" as const,
		description: "Preserves whitespace and newlines, no wrapping",
	},
	"pre-wrap": {
		value: "pre-wrap" as const,
		description: "Preserves whitespace and newlines, wraps normally",
	},
	"pre-line": {
		value: "pre-line" as const,
		description: "Collapses whitespace, preserves newlines, wraps normally",
	},
	"break-spaces": {
		value: "break-spaces" as const,
		description: "Like pre-wrap but preserves sequences of spaces",
	},
} as const;


=== File: src/core/keywords/width-height-keywords.ts ===
// b_path:: src/core/keywords/width-height-keywords.ts
import { z } from "zod";

/**
 * CSS width/height intrinsic sizing keywords.
 *
 * These keywords represent intrinsic sizes based on content.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#sizing-values}
 *
 * @example
 * ```typescript
 * import { widthHeightKeywordsSchema } from "@/core/keywords/width-height-keywords";
 *
 * const size = widthHeightKeywordsSchema.parse("min-content");
 * ```
 *
 * @public
 */
export const widthHeightKeywordsSchema = z
	.union([
		z.literal("min-content").describe("intrinsic minimum width/height"),
		z.literal("max-content").describe("intrinsic preferred width/height"),
		z.literal("fit-content").describe("use available space but not more than max-content"),
	])
	.describe("intrinsic sizing keywords for width/height properties");

/**
 * TypeScript type for width/height keywords.
 *
 * @public
 */
export type WidthHeightKeyword = z.infer<typeof widthHeightKeywordsSchema>;

/**
 * Array of all valid width/height keyword values.
 *
 * @public
 */
export const WIDTH_HEIGHT_KEYWORDS = widthHeightKeywordsSchema.options.map((option) => option.value);


=== File: src/core/keywords/word-break-keywords.ts ===
// b_path:: src/core/keywords/word-break-keywords.ts
import { z } from "zod";

/**
 * CSS word-break keyword values.
 *
 * The word-break property sets whether line breaks appear wherever the text would
 * otherwise overflow its content box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/word-break}
 *
 * @example
 * ```typescript
 * import { wordBreakKeywordsSchema } from "@/core/keywords/word-break-keywords";
 *
 * const keyword = wordBreakKeywordsSchema.parse("break-all");
 * ```
 *
 * @public
 */
export const wordBreakKeywordsSchema = z
	.union([
		z.literal("normal").describe("default line break rules"),
		z.literal("break-all").describe("breaks can be inserted between any characters"),
		z.literal("keep-all").describe("breaks prohibited between CJK characters"),
		z.literal("break-word").describe("like word-break: normal with overflow-wrap: anywhere"),
	])
	.describe("CSS word-break property keyword values");

/**
 * Array of all word-break keyword values.
 *
 * @public
 */
export const WORD_BREAK_KEYWORDS = wordBreakKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for word-break keywords.
 *
 * @public
 */
export type WordBreakKeyword = z.infer<typeof wordBreakKeywordsSchema>;

/**
 * Metadata for word-break keyword options.
 *
 * @public
 */
export const wordBreakKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Default line break rules",
	},
	"break-all": {
		value: "break-all" as const,
		description: "Breaks can be inserted between any characters",
	},
	"keep-all": {
		value: "keep-all" as const,
		description: "Breaks prohibited between CJK characters",
	},
	"break-word": {
		value: "break-word" as const,
		description: "Like word-break: normal with overflow-wrap: anywhere",
	},
} as const;


=== File: src/core/result.test.ts ===
// b_path:: src/core/result.test.ts

import { describe, expect, it } from "vitest";
import { andThen, err, fromZod, map, ok, unwrap, unwrapOr } from "./result";

describe("Result utilities", () => {
	describe("ok()", () => {
		it("should create successful result", () => {
			const result = ok(42);
			expect(result.ok).toBe(true);
			expect(result.value).toBe(42);
			expect(result.error).toBeUndefined();
		});

		it("should work with complex types", () => {
			const result = ok({ name: "test", count: 5 });
			expect(result.ok).toBe(true);
			expect(result.value).toEqual({ name: "test", count: 5 });
		});
	});

	describe("err()", () => {
		it("should create error result with string", () => {
			const result = err("Something failed");
			expect(result.ok).toBe(false);
			expect(result.error).toBe("Something failed");
			expect(result.value).toBeUndefined();
		});

		it("should create error result with Error object", () => {
			const error = new Error("Test error");
			const result = err(error);
			expect(result.ok).toBe(false);
			expect(result.error).toBe(error);
		});
	});

	describe("fromZod()", () => {
		it("should convert successful Zod parse to ok result", () => {
			const zodResult = { success: true as const, data: 42 };
			const result = fromZod(zodResult);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe(42);
			}
		});

		it("should convert failed Zod parse to err result", () => {
			const zodError = new Error("Validation failed");
			const zodResult = { success: false as const, error: zodError };
			const result = fromZod(zodResult);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe(zodError);
			}
		});
	});

	describe("unwrap()", () => {
		it("should return value for ok result", () => {
			const result = ok(42);
			expect(unwrap(result)).toBe(42);
		});

		it("should throw Error for err result with Error", () => {
			const error = new Error("Test error");
			const result = err(error);
			expect(() => unwrap(result)).toThrow(error);
		});

		it("should throw Error for err result with string", () => {
			const result = err("Failed");
			expect(() => unwrap(result)).toThrow("Failed");
		});

		it("should throw Error for err result with other types", () => {
			const result = err(123);
			expect(() => unwrap(result)).toThrow("123");
		});
	});

	describe("unwrapOr()", () => {
		it("should return value for ok result", () => {
			const result = ok(42);
			expect(unwrapOr(result, 0)).toBe(42);
		});

		it("should return default value for err result", () => {
			const result = err("Failed");
			expect(unwrapOr(result, 0)).toBe(0);
		});

		it("should work with complex default values", () => {
			const result = err("Failed");
			const defaultValue = { name: "default", count: 0 };
			expect(unwrapOr(result, defaultValue)).toEqual(defaultValue);
		});
	});

	describe("map()", () => {
		it("should transform ok result value", () => {
			const result = ok(2);
			const doubled = map(result, (x) => x * 2);
			expect(doubled.ok).toBe(true);
			if (doubled.ok) {
				expect(doubled.value).toBe(4);
			}
		});

		it("should preserve err result", () => {
			const result = err("Failed");
			const mapped = map(result, (x: number) => x * 2);
			expect(mapped.ok).toBe(false);
			if (!mapped.ok) {
				expect(mapped.error).toBe("Failed");
			}
		});

		it("should allow type transformation", () => {
			const result = ok(42);
			const stringResult = map(result, (x) => `Value: ${x}`);
			expect(stringResult.ok).toBe(true);
			if (stringResult.ok) {
				expect(stringResult.value).toBe("Value: 42");
			}
		});
	});

	describe("andThen()", () => {
		it("should chain successful results", () => {
			const result = ok(2);
			const doubled = andThen(result, (x) => ok(x * 2));
			expect(doubled.ok).toBe(true);
			if (doubled.ok) {
				expect(doubled.value).toBe(4);
			}
		});

		it("should short-circuit on error", () => {
			const result = err("Initial error");
			const chained = andThen(result, (x: number) => ok(x * 2));
			expect(chained.ok).toBe(false);
			if (!chained.ok) {
				expect(chained.error).toBe("Initial error");
			}
		});

		it("should propagate errors from chained function", () => {
			const result = ok(0);
			const chained = andThen(result, (x) => (x > 0 ? ok(x * 2) : err("Must be positive")));
			expect(chained.ok).toBe(false);
			if (!chained.ok) {
				expect(chained.error).toBe("Must be positive");
			}
		});

		it("should allow type transformation", () => {
			const result = ok(42);
			const stringResult = andThen(result, (x) => ok(`Value: ${x}`));
			expect(stringResult.ok).toBe(true);
			if (stringResult.ok) {
				expect(stringResult.value).toBe("Value: 42");
			}
		});
	});
});


=== File: src/core/result.ts ===
// b_path:: src/core/result.ts

/**
 * Result type for operations that may fail.
 *
 * Provides a type-safe way to handle errors without throwing exceptions.
 * Inspired by Rust's Result<T, E> and functional programming patterns.
 *
 * Supports destructuring for convenient access:
 * - `ok: true` → `value` is available, `error` is undefined
 * - `ok: false` → `error` is available, `value` is undefined
 *
 * @example
 * ```typescript
 * import { Result, ok, err } from "@/core/result";
 *
 * function divide(a: number, b: number): Result<number, string> {
 *   if (b === 0) return err("Division by zero");
 *   return ok(a / b);
 * }
 *
 * const { ok, value, error } = divide(10, 2);
 * if (ok) {
 *   console.log(value); // 5 (type: number)
 * } else {
 *   console.error(error); // string
 * }
 * ```
 *
 * @public
 */
export type Result<T, E = Error> = { ok: true; value: T; error: undefined } | { ok: false; value: undefined; error: E };

/**
 * Create a successful result.
 *
 * @example
 * ```typescript
 * const result = ok(42);
 * console.log(result.ok); // true
 * console.log(result.value); // 42
 * console.log(result.error); // undefined
 * ```
 *
 * @public
 */
export function ok<T>(value: T): Result<T, never> {
	return { ok: true, value, error: undefined };
}

/**
 * Create an error result.
 *
 * @example
 * ```typescript
 * const result = err("Something went wrong");
 * console.log(result.ok); // false
 * console.log(result.error); // "Something went wrong"
 * console.log(result.value); // undefined
 * ```
 *
 * @public
 */
export function err<E>(error: E): Result<never, E> {
	return { ok: false, value: undefined, error };
}

/**
 * Convert a Zod SafeParseReturnType to a Result.
 *
 * @example
 * ```typescript
 * import { z } from "zod";
 * import { fromZod } from "@/core/result";
 *
 * const schema = z.number();
 * const zodResult = schema.safeParse("not a number");
 * const result = fromZod(zodResult);
 *
 * if (!result.ok) {
 *   console.error(result.error); // ZodError
 * }
 * ```
 *
 * @public
 */
export function fromZod<T, E = unknown>(
	zodResult: { success: true; data: T } | { success: false; error: E },
): Result<T, E> {
	if (zodResult.success) {
		return ok(zodResult.data);
	}
	return err(zodResult.error);
}

/**
 * Unwrap a result, throwing if it's an error.
 * Use sparingly - prefer explicit error handling.
 *
 * @example
 * ```typescript
 * const result = ok(42);
 * const value = unwrap(result); // 42
 *
 * const errorResult = err("Failed");
 * unwrap(errorResult); // throws Error("Failed")
 * ```
 *
 * @public
 */
export function unwrap<T, E>(result: Result<T, E>): T {
	if (result.ok) {
		return result.value;
	}
	throw result.error instanceof Error ? result.error : new Error(String(result.error));
}

/**
 * Get the value or a default if error.
 *
 * @example
 * ```typescript
 * const result = err("Failed");
 * const value = unwrapOr(result, 42); // 42
 * ```
 *
 * @public
 */
export function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {
	return result.ok ? result.value : defaultValue;
}

/**
 * Map over a successful result.
 *
 * @example
 * ```typescript
 * const result = ok(2);
 * const doubled = map(result, x => x * 2);
 * console.log(doubled.value); // 4
 * ```
 *
 * @public
 */
export function map<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E> {
	return result.ok ? ok(fn(result.value)) : result;
}

/**
 * Chain results together (flatMap).
 *
 * @example
 * ```typescript
 * const result = ok(2);
 * const doubled = andThen(result, x =>
 *   x > 0 ? ok(x * 2) : err("Must be positive")
 * );
 * ```
 *
 * @public
 */
export function andThen<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E> {
	return result.ok ? fn(result.value) : result;
}

// ============================================================================
// ParseResult and GenerateResult - Public API Types
// ============================================================================

/**
 * Longhand CSS property names - properties supported by b_value.
 * @public
 */
export type CSSLonghandProperty =
	// Color
	| "color"
	| "background-color"
	| "border-color"
	| "border-top-color"
	| "border-right-color"
	| "border-bottom-color"
	| "border-left-color"
	| "outline-color"
	| "text-decoration-color"
	// Clip-path
	| "clip-path"
	// Background
	| "background-image"
	| "background-position"
	| "background-size"
	| "background-repeat"
	| "background-attachment"
	| "background-clip"
	| "background-origin"
	// Filter
	| "filter"
	| "backdrop-filter"
	// Transform
	| "transform"
	| "transform-origin"
	// Shadow
	| "box-shadow"
	| "text-shadow"
	// Border
	| "border-width"
	| "border-top-width"
	| "border-right-width"
	| "border-bottom-width"
	| "border-left-width"
	| "border-style"
	| "border-top-style"
	| "border-right-style"
	| "border-bottom-style"
	| "border-left-style"
	| "border-top-left-radius"
	| "border-top-right-radius"
	| "border-bottom-right-radius"
	| "border-bottom-left-radius"
	// Outline
	| "outline-width"
	| "outline-style"
	| "outline-offset"
	// Animation
	| "animation-name"
	| "animation-duration"
	| "animation-timing-function"
	| "animation-delay"
	| "animation-iteration-count"
	| "animation-direction"
	| "animation-fill-mode"
	| "animation-play-state"
	// Transition
	| "transition-property"
	| "transition-duration"
	| "transition-timing-function"
	| "transition-delay"
	// Layout
	| "width"
	| "height"
	| "min-width"
	| "min-height"
	| "max-width"
	| "max-height"
	| "top"
	| "right"
	| "bottom"
	| "left"
	| "position"
	| "display"
	| "overflow-x"
	| "overflow-y"
	| "visibility"
	| "z-index"
	| "opacity"
	| "cursor"
	// Text decoration
	| "text-decoration-line"
	| "text-decoration-style"
	| "text-decoration-thickness";

/**
 * Shorthand CSS property names - NOT supported by b_value, but detected for helpful errors.
 * @public
 */
export type CSSShorthandProperty =
	| "border"
	| "border-top"
	| "border-right"
	| "border-bottom"
	| "border-left"
	| "border-radius"
	| "margin"
	| "padding"
	| "background"
	| "font"
	| "text-decoration"
	| "animation"
	| "transition"
	| "outline"
	| "overflow"
	| "flex"
	| "grid"
	| "gap"
	| "inset";

/**
 * All CSS property names (longhand + shorthand for detection).
 * @public
 */
export type CSSPropertyName = CSSLonghandProperty | CSSShorthandProperty;

/**
 * Issue codes for categorization and filtering.
 * @public
 */
export type IssueCode =
	// Parse errors
	| "invalid-value"
	| "unknown-property"
	| "shorthand-not-supported"
	| "invalid-syntax"
	| "missing-value"
	// Parse warnings
	| "duplicate-property"
	| "deprecated-syntax"
	| "legacy-syntax"
	// Generate errors
	| "invalid-ir"
	| "missing-required-field"
	| "unsupported-kind";

/**
 * Issue reported during parsing or generation.
 * All fields are strongly typed for type safety and IDE autocomplete.
 *
 * @public
 */
export type Issue = {
	/** Issue code for categorization and filtering */
	code: IssueCode;
	/** Property name that caused the issue (strongly typed) */
	property?: CSSPropertyName;
	/** Severity level */
	severity: "error" | "warning" | "info";
	/** Human-readable message */
	message: string;
	/** Optional suggestion for fixing the issue */
	suggestion?: string;
	/** Optional action to take (e.g., "use modern syntax") */
	action?: string;
	/** Optional location in input string */
	location?: {
		offset: number;
		length: number;
	};
};

/**
 * Result of parsing CSS to intermediate representation.
 *
 * Used by Module API (e.g., Parse.Color.parse()) and Universal API (e.g., parse()).
 *
 * @example
 * ```typescript
 * const result = Parse.Color.parse("#ff0000");
 * if (result.ok) {
 *   console.log(result.value);  // Color IR
 * } else {
 *   console.error(result.issues[0].message);
 *   console.log(result.issues[0].suggestion);
 * }
 * ```
 *
 * @public
 */
export type ParseResult<T = unknown> = {
	/** Success flag */
	ok: boolean;
	/** Parsed value (present when ok=true) */
	value?: T;
	/** Property name from CSS declaration (Module API: undefined, Universal API: present) */
	property?: string;
	/** Issues encountered (always present, empty array if none) */
	issues: Issue[];
};

/**
 * Result of generating CSS from intermediate representation.
 *
 * Used by Module API (e.g., Generate.Color.generate()) and Universal API.
 *
 * @example
 * ```typescript
 * const result = Generate.Color.generate(colorIR);
 * if (result.ok) {
 *   console.log(result.value);  // "#ff0000"
 * }
 * ```
 *
 * @public
 */
export type GenerateResult = {
	/** Success flag */
	ok: boolean;
	/** Generated CSS string (present when ok=true) */
	value?: string;
	/** Property name when generating declarations */
	property?: string;
	/** Issues encountered (always present, empty array if none) */
	issues: Issue[];
};

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Create a successful ParseResult.
 *
 * @example
 * ```typescript
 * return parseOk(colorIR);
 * return parseOk(colorIR, "background-color");  // with property
 * ```
 *
 * @public
 */
export function parseOk<T>(value: T, property?: string): ParseResult<T> {
	const result: ParseResult<T> = {
		ok: true,
		value,
		issues: [],
	};
	if (property !== undefined) {
		result.property = property;
	}
	return result;
}

/**
 * Create a failed ParseResult.
 *
 * @example
 * ```typescript
 * return parseErr("invalid-value", "Invalid color format");
 * return parseErr("invalid-value", "Invalid hex color", {
 *   suggestion: "Use #RRGGBB format",
 *   property: "color"
 * });
 * ```
 *
 * @public
 */
export function parseErr<T = never>(
	code: IssueCode,
	message: string,
	options?: {
		suggestion?: string;
		action?: string;
		location?: { offset: number; length: number };
		property?: CSSPropertyName;
	},
): ParseResult<T> {
	const issue: Issue = {
		code,
		severity: "error",
		message,
	};
	if (options?.suggestion !== undefined) issue.suggestion = options.suggestion;
	if (options?.action !== undefined) issue.action = options.action;
	if (options?.location !== undefined) issue.location = options.location;
	if (options?.property !== undefined) issue.property = options.property;

	const result: ParseResult<T> = {
		ok: false,
		issues: [issue],
	};
	if (options?.property !== undefined) {
		result.property = options.property;
	}
	return result;
}

/**
 * Create a successful GenerateResult.
 *
 * @example
 * ```typescript
 * return generateOk("#ff0000");
 * return generateOk("#ff0000", "color");  // with property
 * ```
 *
 * @public
 */
export function generateOk(value: string, property?: string): GenerateResult {
	const result: GenerateResult = {
		ok: true,
		value,
		issues: [],
	};
	if (property !== undefined) {
		result.property = property;
	}
	return result;
}

/**
 * Create a failed GenerateResult.
 *
 * @example
 * ```typescript
 * return generateErr("invalid-ir", "Invalid IR structure");
 * return generateErr("missing-required-field", "Missing 'kind' field", {
 *   suggestion: "Add 'kind' field",
 *   property: "color"
 * });
 * ```
 *
 * @public
 */
export function generateErr(
	code: IssueCode,
	message: string,
	options?: {
		suggestion?: string;
		action?: string;
		property?: CSSPropertyName;
	},
): GenerateResult {
	const issue: Issue = {
		code,
		severity: "error",
		message,
	};
	if (options?.suggestion !== undefined) issue.suggestion = options.suggestion;
	if (options?.action !== undefined) issue.action = options.action;
	if (options?.property !== undefined) issue.property = options.property;

	const result: GenerateResult = {
		ok: false,
		issues: [issue],
	};
	if (options?.property !== undefined) {
		result.property = options.property;
	}
	return result;
}

/**
 * Add an issue to a ParseResult (preserves success state).
 *
 * @example
 * ```typescript
 * let result = parseOk(colorIR);
 * result = addIssue(result, {
 *   severity: "warning",
 *   message: "Legacy syntax",
 *   suggestion: "Use modern syntax"
 * });
 * ```
 *
 * @public
 */
export function addIssue<T>(result: ParseResult<T>, issue: Issue): ParseResult<T> {
	return {
		...result,
		issues: [...result.issues, issue],
	};
}

/**
 * Add a warning to a ParseResult (preserves success state).
 *
 * @example
 * ```typescript
 * return withWarning(parseOk(colorIR), "deprecated-syntax", "Legacy comma syntax");
 * ```
 *
 * @public
 */
export function withWarning<T>(
	result: ParseResult<T>,
	code: IssueCode,
	message: string,
	suggestion?: string,
): ParseResult<T> {
	const issue: Issue = {
		code,
		severity: "warning",
		message,
	};
	if (suggestion !== undefined) issue.suggestion = suggestion;
	return addIssue(result, issue);
}

// ============================================================================
// Issue Creation Helpers
// ============================================================================

/**
 * Predefined issue creators for common error cases.
 * Provides type-safe, consistent issue creation with standardized messages.
 *
 * @example
 * ```typescript
 * // In parseAll()
 * if (duplicateCount > 1) {
 *   issues.push(Issues.duplicateProperty("color", duplicateCount));
 * }
 *
 * if (!result.ok) {
 *   issues.push(Issues.invalidValue("width", "not-a-number"));
 * }
 * ```
 *
 * @public
 */
export const Issues = {
	/**
	 * Create issue for duplicate property declaration (warning).
	 */
	duplicateProperty(property: CSSLonghandProperty, count: number): Issue {
		return {
			code: "duplicate-property",
			severity: "warning",
			property,
			message: `Duplicate property '${property}' declared ${count} times - using last value`,
		};
	},

	/**
	 * Create issue for invalid property value (error).
	 */
	invalidValue(property: CSSLonghandProperty, value: string): Issue {
		return {
			code: "invalid-value",
			severity: "error",
			property,
			message: `Invalid value '${value}' for property '${property}'`,
		};
	},

	/**
	 * Create issue for shorthand property detection (error with b_short promotion).
	 */
	shorthandNotSupported(property: CSSShorthandProperty, longhands: string[]): Issue {
		return {
			code: "shorthand-not-supported",
			severity: "error",
			property,
			message: `Shorthand property '${property}' is not supported in b_value. Use longhand properties: ${longhands.join(", ")}. For shorthand support, use the 'b_short' library.`,
			suggestion: "Use b_short to expand shorthands first",
		};
	},

	/**
	 * Create issue for unknown CSS property (error).
	 */
	unknownProperty(property: string): Issue {
		return {
			code: "unknown-property",
			severity: "error",
			message: `Unknown CSS property '${property}'`,
		};
	},

	/**
	 * Create issue for invalid syntax (error).
	 */
	invalidSyntax(message: string, location?: { offset: number; length: number }): Issue {
		const issue: Issue = {
			code: "invalid-syntax",
			severity: "error",
			message,
		};
		if (location !== undefined) {
			issue.location = location;
		}
		return issue;
	},

	/**
	 * Create issue for deprecated syntax (warning).
	 */
	deprecatedSyntax(property: CSSLonghandProperty, message: string, suggestion?: string): Issue {
		const issue: Issue = {
			code: "deprecated-syntax",
			severity: "warning",
			property,
			message,
		};
		if (suggestion !== undefined) {
			issue.suggestion = suggestion;
		}
		return issue;
	},

	/**
	 * Create issue for legacy syntax (warning).
	 */
	legacySyntax(property: CSSLonghandProperty, message: string, suggestion?: string): Issue {
		const issue: Issue = {
			code: "legacy-syntax",
			severity: "warning",
			property,
			message,
		};
		if (suggestion !== undefined) {
			issue.suggestion = suggestion;
		}
		return issue;
	},
};

/**
 * Combine multiple ParseResults into one (for layer/list parsing).
 *
 * @example
 * ```typescript
 * const results = [parseOk(color1), parseOk(color2)];
 * const combined = combineResults(results);
 * // { ok: true, value: [color1, color2], issues: [] }
 * ```
 *
 * @public
 */
export function combineResults<T>(results: ParseResult<T>[]): ParseResult<T[]> {
	const allOk = results.every((r) => r.ok);
	const values = results.map((r) => r.value).filter((v): v is T => v !== undefined);
	const allIssues = results.flatMap((r) => r.issues);

	if (allOk && values.length === results.length) {
		return {
			ok: true,
			value: values,
			issues: allIssues,
		};
	}

	return {
		ok: false,
		issues: allIssues,
	};
}

/**
 * Convert internal Result<T, string> to public ParseResult<T>.
 *
 * @internal
 */
export function toParseResult<T>(result: Result<T, string>, property?: CSSPropertyName): ParseResult<T> {
	if (result.ok) {
		return parseOk(result.value, property);
	}
	// Use generic invalid-value code for Result<T, string> conversions
	return parseErr("invalid-value", result.error, property ? { property } : undefined);
}


=== File: src/core/types/angle.ts ===
// b_path:: src/core/types/angle.ts
import { z } from "zod";
import * as Unit from "../units";

/**
 * CSS `<angle>` dimension.
 *
 * An angle is a rotation measurement consisting of a number and an angle unit.
 * Used in transforms, gradients, and other CSS properties requiring angular measurements.
 *
 * Per CSS Values & Units Module Level 4 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/angle}
 * @see {@link https://www.w3.org/TR/css-values-4/#angles}
 *
 * @example
 * ```typescript
 * import { angleSchema } from "@/core/types/angle";
 *
 * const rotation: Angle = { value: 45, unit: "deg" };
 * const fullCircle: Angle = { value: 360, unit: "deg" };
 * const radians: Angle = { value: 1.57, unit: "rad" };
 * ```
 *
 * @public
 */
export const angleSchema = z.object({
	value: z.number(),
	unit: Unit.angleUnitSchema,
});

/**
 * TypeScript type for `<angle>` dimension.
 *
 * @public
 */
export type Angle = z.infer<typeof angleSchema>;


=== File: src/core/types/animation.ts ===
// b_path:: src/core/types/animation.ts
import { z } from "zod";
import * as Keyword from "../keywords/animation";
import { timeSchema } from "./time";

/**
 * CSS animation-delay property IR.
 *
 * Specifies when an animation should start.
 * Comma-separated list of time values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-delay}
 *
 * @public
 */
export const animationDelaySchema = z.object({
	kind: z.literal("animation-delay"),
	delays: z.array(timeSchema).min(1),
});

/**
 * CSS animation-delay type.
 *
 * @public
 */
export type AnimationDelay = z.infer<typeof animationDelaySchema>;

/**
 * CSS animation-duration property IR.
 *
 * Specifies how long an animation should take to complete one cycle.
 * Comma-separated list of time values or 'auto'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-duration}
 *
 * @public
 */
export const animationDurationSchema = z.object({
	kind: z.literal("animation-duration"),
	durations: z
		.array(z.union([z.object({ type: z.literal("auto") }), timeSchema.extend({ type: z.literal("time") })]))
		.min(1),
});

/**
 * CSS animation-duration type.
 *
 * @public
 */
export type AnimationDuration = z.infer<typeof animationDurationSchema>;

/**
 * CSS animation-iteration-count property IR.
 *
 * Specifies the number of times an animation should repeat.
 * Comma-separated list of numbers or 'infinite'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-iteration-count}
 *
 * @public
 */
export const animationIterationCountSchema = z.object({
	kind: z.literal("animation-iteration-count"),
	counts: z
		.array(
			z.union([
				z.object({ type: z.literal("infinite") }),
				z.object({ type: z.literal("number"), value: z.number().nonnegative() }),
			]),
		)
		.min(1),
});

/**
 * CSS animation-iteration-count type.
 *
 * @public
 */
export type AnimationIterationCount = z.infer<typeof animationIterationCountSchema>;

/**
 * CSS animation-direction property IR.
 *
 * Specifies whether an animation should play forwards, backwards, or alternate.
 * Comma-separated list of direction keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-direction}
 *
 * @public
 */
export const animationDirectionSchema = z.object({
	kind: z.literal("animation-direction"),
	directions: z.array(z.enum(Keyword.ANIMATION_DIRECTION_KEYWORDS)).min(1),
});

/**
 * CSS animation-direction type.
 *
 * @public
 */
export type AnimationDirection = z.infer<typeof animationDirectionSchema>;

/**
 * CSS animation-fill-mode property IR.
 *
 * Specifies how styles are applied before/after animation execution.
 * Comma-separated list of fill mode keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-fill-mode}
 *
 * @public
 */
export const animationFillModeSchema = z.object({
	kind: z.literal("animation-fill-mode"),
	modes: z.array(z.enum(Keyword.ANIMATION_FILL_MODE_KEYWORDS)).min(1),
});

/**
 * CSS animation-fill-mode type.
 *
 * @public
 */
export type AnimationFillMode = z.infer<typeof animationFillModeSchema>;

/**
 * CSS animation-play-state property IR.
 *
 * Specifies whether an animation is running or paused.
 * Comma-separated list of play state keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-play-state}
 *
 * @public
 */
export const animationPlayStateSchema = z.object({
	kind: z.literal("animation-play-state"),
	states: z.array(z.enum(Keyword.ANIMATION_PLAY_STATE_KEYWORDS)).min(1),
});

/**
 * CSS animation-play-state type.
 *
 * @public
 */
export type AnimationPlayState = z.infer<typeof animationPlayStateSchema>;

/**
 * CSS animation-name property IR.
 *
 * Specifies the names of @keyframes at-rules.
 * Comma-separated list of identifiers or 'none'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-name}
 *
 * @public
 */
export const animationNameSchema = z.object({
	kind: z.literal("animation-name"),
	names: z
		.array(
			z.union([z.object({ type: z.literal("none") }), z.object({ type: z.literal("identifier"), value: z.string() })]),
		)
		.min(1),
});

/**
 * CSS animation-name type.
 *
 * @public
 */
export type AnimationName = z.infer<typeof animationNameSchema>;

/**
 * CSS cubic-bezier() easing function IR.
 *
 * Defines a cubic Bezier curve for easing.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#cubic-bezier}
 * @see {@link https://www.w3.org/TR/css-easing-1/#cubic-bezier-easing-functions}
 *
 * @public
 */
export const cubicBezierSchema = z.object({
	type: z.literal("cubic-bezier"),
	x1: z.number(),
	y1: z.number(),
	x2: z.number(),
	y2: z.number(),
});

/**
 * CSS cubic-bezier() type.
 *
 * @public
 */
export type CubicBezier = z.infer<typeof cubicBezierSchema>;

/**
 * CSS steps() easing function IR.
 *
 * Defines a step easing function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#steps}
 * @see {@link https://www.w3.org/TR/css-easing-1/#step-easing-functions}
 *
 * @public
 */
export const stepsSchema = z.object({
	type: z.literal("steps"),
	steps: z.number().positive().int(),
	position: z.enum(Keyword.STEP_POSITION_KEYWORDS).optional(),
});

/**
 * CSS steps() type.
 *
 * @public
 */
export type Steps = z.infer<typeof stepsSchema>;

/**
 * CSS linear() stop IR.
 *
 * A single stop in a linear() easing function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#linear}
 * @see {@link https://www.w3.org/TR/css-easing-1/#linear-easing-function}
 *
 * @public
 */
export const linearStopSchema = z.object({
	output: z.number(),
	input: z.number().min(0).max(1).optional(),
});

/**
 * CSS linear() stop type.
 *
 * @public
 */
export type LinearStop = z.infer<typeof linearStopSchema>;

/**
 * CSS linear() easing function IR.
 *
 * Defines a piecewise linear easing function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#linear}
 * @see {@link https://www.w3.org/TR/css-easing-1/#linear-easing-function}
 *
 * @public
 */
export const linearEasingSchema = z.object({
	type: z.literal("linear"),
	stops: z.array(linearStopSchema).min(1),
});

/**
 * CSS linear() type.
 *
 * @public
 */
export type LinearEasing = z.infer<typeof linearEasingSchema>;

/**
 * CSS easing function IR.
 *
 * Union of all easing function types: keywords, cubic-bezier(), steps(), linear().
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function}
 * @see {@link https://www.w3.org/TR/css-easing-1/#easing-functions}
 *
 * @public
 */
export const easingFunctionSchema = z.union([
	z.enum(Keyword.EASING_KEYWORD_KEYWORDS),
	cubicBezierSchema,
	stepsSchema,
	linearEasingSchema,
]);

/**
 * CSS easing function type.
 *
 * @public
 */
export type EasingFunction = z.infer<typeof easingFunctionSchema>;

/**
 * CSS animation-timing-function property IR.
 *
 * Specifies the timing function for animations.
 * Comma-separated list of easing functions.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-timing-function}
 *
 * @public
 */
export const animationTimingFunctionSchema = z.object({
	kind: z.literal("animation-timing-function"),
	functions: z.array(easingFunctionSchema).min(1),
});

/**
 * CSS animation-timing-function type.
 *
 * @public
 */
export type AnimationTimingFunction = z.infer<typeof animationTimingFunctionSchema>;


=== File: src/core/types/border.ts ===
// b_path:: src/core/types/border.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthPercentageSchema, lengthSchema } from "./length-percentage";

/**
 * CSS <border-width> data type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width}
 * @public
 */
export const borderWidthSchema = z.union([lengthSchema, Keyword.borderWidthKeywordsSchema]);

/**
 * CSS <border-style> data type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style}
 * @public
 */
export const borderStyleSchema = Keyword.borderStyleKeywordsSchema;

/**
 * CSS <color> data type for borders.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color}
 * @public
 */
export const borderColorSchema = Keyword.colorValueKeywordsSchema;

/**
 * Side specification for multi-side operations.
 * Optional - when omitted, applies to all sides.
 *
 * @public
 */
export const borderSidesSchema = z.array(z.enum(["top", "right", "bottom", "left"])).optional();

/**
 * Unified border specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying complete borders to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { width: { value: 1, unit: "px" }, style: "solid", color: "red" }
 *
 * // Specific sides
 * { sides: ["top"], width: { value: 2, unit: "px" }, style: "dashed", color: "blue" }
 * ```
 *
 * @public
 */
export const unifiedBorderSchema = z.object({
	sides: borderSidesSchema,
	width: borderWidthSchema,
	style: borderStyleSchema,
	color: borderColorSchema,
});

export type BorderWidth = z.infer<typeof borderWidthSchema>;
export type BorderStyle = z.infer<typeof borderStyleSchema>;
export type BorderColor = z.infer<typeof borderColorSchema>;
export type BorderSides = z.infer<typeof borderSidesSchema>;
export type UnifiedBorder = z.infer<typeof unifiedBorderSchema>;

/**
 * CSS border-width property IR.
 *
 * Specifies the width of the border.
 * Single length value or keyword (thin, medium, thick).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-width}
 *
 * @public
 */
export const borderWidthValueSchema = z.object({
	kind: z.literal("border-width"),
	width: borderWidthSchema,
});

/**
 * CSS border-width property type.
 *
 * @public
 */
export type BorderWidthValue = z.infer<typeof borderWidthValueSchema>;

/**
 * CSS border-style property IR.
 *
 * Specifies the style of the border line.
 * Single style keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-style}
 *
 * @public
 */
export const borderStyleValueSchema = z.object({
	kind: z.literal("border-style"),
	style: borderStyleSchema,
});

/**
 * CSS border-style property type.
 *
 * @public
 */
export type BorderStyleValue = z.infer<typeof borderStyleValueSchema>;

/**
 * CSS border-color property IR.
 *
 * Specifies the color of the border.
 * Single color value or keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-color}
 *
 * @public
 */
export const borderColorValueSchema = z.object({
	kind: z.literal("border-color"),
	color: borderColorSchema,
});

/**
 * CSS border-color property type.
 *
 * @public
 */
export type BorderColorValue = z.infer<typeof borderColorValueSchema>;

/**
 * CSS border-radius property IR.
 *
 * Specifies the radius of the border corners.
 * Single length-percentage value.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-radius}
 *
 * @public
 */
export const borderRadiusValueSchema = z.object({
	kind: z.literal("border-radius"),
	radius: lengthPercentageSchema,
});

/**
 * CSS border-radius property type.
 *
 * @public
 */
export type BorderRadiusValue = z.infer<typeof borderRadiusValueSchema>;


=== File: src/core/types/box-model.ts ===
// b_path:: src/core/types/box-model.ts
import { z } from "zod";
import { lengthPercentageAutoSchema, lengthPercentageSchema } from "./length-percentage";

/**
 * Side specification for multi-side operations.
 * Optional - when omitted, applies to all sides.
 *
 * @public
 */
export const boxSidesSchema = z.array(z.enum(["top", "right", "bottom", "left"])).optional();

/**
 * Unified margin specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying margins to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { value: 10, unit: "px" }
 *
 * // Specific sides
 * { sides: ["top", "bottom"], value: 20, unit: "px" }
 * ```
 *
 * @public
 */
export const unifiedMarginSchema = z.object({
	sides: boxSidesSchema,
	value: lengthPercentageAutoSchema,
});

/**
 * Unified padding specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying padding to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { value: 10, unit: "px" }
 *
 * // Specific sides
 * { sides: ["left", "right"], value: 15, unit: "px" }
 * ```
 *
 * @public
 */
export const unifiedPaddingSchema = z.object({
	sides: boxSidesSchema,
	value: lengthPercentageSchema,
});

export type BoxSides = z.infer<typeof boxSidesSchema>;
export type UnifiedMargin = z.infer<typeof unifiedMarginSchema>;
export type UnifiedPadding = z.infer<typeof unifiedPaddingSchema>;


=== File: src/core/types/clip-path.ts ===
// b_path:: src/core/types/clip-path.ts

import { z } from "zod";
import type { GeometryBoxKeyword } from "@/core/keywords/geometry-box";
import { lengthPercentageSchema } from "./length-percentage";
import { position2DSchema } from "./position";
import type { Url } from "./url";

/**
 * CSS clip-path value.
 *
 * Defines the visible region of an element by clipping.
 * Can be a URL reference to SVG clipPath, geometry-box keyword, basic shape, or 'none'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @public
 */
export type ClipPathValue =
	| Url
	| ClipPathNone
	| ClipPathGeometryBox
	| ClipPathInset
	| ClipPathCircle
	| ClipPathEllipse
	| ClipPathPolygon
	| ClipPathRect
	| ClipPathXywh
	| ClipPathPath;

/**
 * 'none' keyword for clip-path.
 *
 * No clipping is applied; the element is fully visible.
 *
 * @public
 */
export const clipPathNoneSchema = z.object({
	kind: z.literal("clip-path-none"),
});

export type ClipPathNone = z.infer<typeof clipPathNoneSchema>;

/**
 * Geometry box keyword for clip-path.
 *
 * Defines the reference box for clipping. Can be a visual box
 * (content-box, padding-box, border-box), shape box (adds margin-box),
 * or SVG-specific box (fill-box, stroke-box, view-box).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path#geometry-box}
 *
 * @public
 */
export const clipPathGeometryBoxSchema = z.object({
	kind: z.literal("clip-path-geometry-box"),
	value: z.custom<GeometryBoxKeyword>(),
});

export type ClipPathGeometryBox = z.infer<typeof clipPathGeometryBoxSchema>;

/**
 * Border-radius shorthand for inset() shapes.
 *
 * Simplified version without elliptical corners.
 * All corners use same radius for horizontal and vertical.
 *
 * @public
 */
export type InsetBorderRadius = {
	topLeft: z.infer<typeof lengthPercentageSchema>;
	topRight: z.infer<typeof lengthPercentageSchema>;
	bottomRight: z.infer<typeof lengthPercentageSchema>;
	bottomLeft: z.infer<typeof lengthPercentageSchema>;
};

/**
 * inset() basic shape function.
 *
 * Defines an inset rectangle by specifying offsets from each edge.
 * Optionally accepts rounded corners via border-radius syntax.
 *
 * Syntax: inset( <length-percentage>{1,4} [ round <border-radius> ]? )
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/inset}
 *
 * @public
 */
export const clipPathInsetSchema = z.object({
	kind: z.literal("clip-path-inset"),
	top: lengthPercentageSchema,
	right: lengthPercentageSchema,
	bottom: lengthPercentageSchema,
	left: lengthPercentageSchema,
	borderRadius: z
		.object({
			topLeft: lengthPercentageSchema,
			topRight: lengthPercentageSchema,
			bottomRight: lengthPercentageSchema,
			bottomLeft: lengthPercentageSchema,
		})
		.optional(),
});

export type ClipPathInset = z.infer<typeof clipPathInsetSchema>;

/**
 * circle() basic shape function.
 *
 * Defines a circular clipping region with an optional radius and center position.
 *
 * Syntax: circle( <length-percentage>? [ at <position> ]? )
 *
 * Defaults: radius = "closest-side", position = center
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/circle}
 *
 * @public
 */
export const clipPathCircleSchema = z.object({
	kind: z.literal("clip-path-circle"),
	radius: z.union([lengthPercentageSchema, z.enum(["closest-side", "farthest-side"])]).optional(),
	position: position2DSchema.optional(),
});

export type ClipPathCircle = z.infer<typeof clipPathCircleSchema>;

/**
 * ellipse() basic shape function.
 *
 * Defines an elliptical clipping region with optional horizontal/vertical radii and center position.
 *
 * Syntax: ellipse( <radial-size>{2}? [ at <position> ]? )
 *
 * Defaults: radiusX = "closest-side", radiusY = "closest-side", position = center
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/ellipse}
 *
 * @public
 */
export const clipPathEllipseSchema = z.object({
	kind: z.literal("clip-path-ellipse"),
	radiusX: z.union([lengthPercentageSchema, z.enum(["closest-side", "farthest-side"])]).optional(),
	radiusY: z.union([lengthPercentageSchema, z.enum(["closest-side", "farthest-side"])]).optional(),
	position: position2DSchema.optional(),
});

export type ClipPathEllipse = z.infer<typeof clipPathEllipseSchema>;

/**
 * polygon() basic shape function.
 *
 * Defines a polygonal clipping region from a list of coordinate pairs.
 * Optionally accepts a fill-rule to determine interior points.
 *
 * Syntax: polygon( <fill-rule>? , <shape-arg># )
 *
 * Default: fillRule = "nonzero" (per CSS spec)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/polygon}
 *
 * @public
 */
export const clipPathPolygonSchema = z.object({
	kind: z.literal("clip-path-polygon"),
	fillRule: z.enum(["nonzero", "evenodd"]).optional(),
	points: z.array(
		z.object({
			x: lengthPercentageSchema,
			y: lengthPercentageSchema,
		}),
	),
});

export type ClipPathPolygon = z.infer<typeof clipPathPolygonSchema>;

/**
 * rect() basic shape function.
 *
 * Defines a rectangle using edge offsets (TRBL).
 * Each edge can be a length-percentage or 'auto'.
 * Optionally accepts rounded corners via border-radius syntax.
 *
 * Syntax: rect( [<length-percentage> | auto]{1,4} [ round <border-radius> ]? )
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/rect}
 *
 * @public
 */
export const clipPathRectSchema = z.object({
	kind: z.literal("clip-path-rect"),
	top: z.union([lengthPercentageSchema, z.literal("auto")]),
	right: z.union([lengthPercentageSchema, z.literal("auto")]),
	bottom: z.union([lengthPercentageSchema, z.literal("auto")]),
	left: z.union([lengthPercentageSchema, z.literal("auto")]),
	borderRadius: z
		.object({
			topLeft: lengthPercentageSchema,
			topRight: lengthPercentageSchema,
			bottomRight: lengthPercentageSchema,
			bottomLeft: lengthPercentageSchema,
		})
		.optional(),
});

export type ClipPathRect = z.infer<typeof clipPathRectSchema>;

/**
 * xywh() basic shape function.
 *
 * Defines a rectangle using position (x, y) and dimensions (width, height).
 * All values are length-percentages. Width and height must be non-negative.
 * Optionally accepts rounded corners via border-radius syntax.
 *
 * Syntax: xywh( <length-percentage>{4} [ round <border-radius> ]? )
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/xywh}
 *
 * @public
 */
export const clipPathXywhSchema = z.object({
	kind: z.literal("clip-path-xywh"),
	x: lengthPercentageSchema,
	y: lengthPercentageSchema,
	width: lengthPercentageSchema,
	height: lengthPercentageSchema,
	borderRadius: z
		.object({
			topLeft: lengthPercentageSchema,
			topRight: lengthPercentageSchema,
			bottomRight: lengthPercentageSchema,
			bottomLeft: lengthPercentageSchema,
		})
		.optional(),
});

export type ClipPathXywh = z.infer<typeof clipPathXywhSchema>;

/**
 * path() basic shape function.
 *
 * Defines a clipping region using SVG path data.
 * Optionally accepts a fill-rule to determine interior points.
 *
 * Syntax: path( [<fill-rule>,]? <string> )
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/path}
 *
 * @public
 */
export const clipPathPathSchema = z.object({
	kind: z.literal("clip-path-path"),
	fillRule: z.enum(["nonzero", "evenodd"]).optional(),
	pathData: z.string(),
});

export type ClipPathPath = z.infer<typeof clipPathPathSchema>;


=== File: src/core/types/color-stop.ts ===
// b_path:: src/core/types/color-stop.ts
import { z } from "zod";
import { angleSchema } from "./angle";
import { colorSchema } from "./color";
import { lengthPercentageSchema } from "./length-percentage";

/**
 * CSS color stop value.
 *
 * A color stop consists of a color value and an optional position.
 * Used in CSS gradients and other color-based properties.
 *
 * Per CSS spec:
 * - For linear/radial gradients: <color-stop> = <color> [ <length-percentage> ]?
 * - For conic gradients: <color-stop> = <color> [ <angle> | <percentage> ]?
 *
 * This type supports both length-percentage and angle units to accommodate all gradient types.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient}
 *
 * @example
 * ```typescript
 * import { colorStopSchema } from "@/core/types/color-stop";
 *
 * // Color only
 * const stop1: ColorStop = {
 *   color: { kind: "named", name: "red" }
 * };
 *
 * // Color with percentage position (all gradient types)
 * const stop2: ColorStop = {
 *   color: { kind: "named", name: "blue" },
 *   position: { value: 50, unit: "%" }
 * };
 *
 * // Color with length position (linear/radial gradients)
 * const stop3: ColorStop = {
 *   color: { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 },
 *   position: { value: 10, unit: "px" }
 * };
 *
 * // Color with angle position (conic gradients)
 * const stop4: ColorStop = {
 *   color: { kind: "named", name: "green" },
 *   position: { value: 45, unit: "deg" }
 * };
 * ```
 *
 * @public
 */
export const colorStopSchema = z.object({
	color: colorSchema.describe("color value for the stop"),
	position: z
		.union([lengthPercentageSchema, angleSchema])
		.optional()
		.describe(
			"optional position of the color stop (length-percentage for linear/radial, angle or percentage for conic)",
		),
});

/**
 * TypeScript type for color stop.
 * @public
 */
export type ColorStop = z.infer<typeof colorStopSchema>;

/**
 * CSS color stop list.
 *
 * An array of color stops used in gradients and other multi-stop color properties.
 * Must contain at least 2 color stops for valid gradients.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient}
 *
 * @example
 * ```typescript
 * import { colorStopListSchema } from "@/core/types/color-stop";
 *
 * const stops: ColorStopList = [
 *   { color: { kind: "named", name: "red" } },
 *   { color: { kind: "named", name: "yellow" }, position: { value: 50, unit: "%" } },
 *   { color: { kind: "named", name: "blue" } }
 * ];
 * ```
 *
 * @public
 */
export const colorStopListSchema = z
	.array(colorStopSchema)
	.min(2, "Color stop list must contain at least 2 stops")
	.describe("array of color stops for gradients and multi-stop color properties");

/**
 * TypeScript type for color stop list.
 * @public
 */
export type ColorStopList = z.infer<typeof colorStopListSchema>;


=== File: src/core/types/color.ts ===
// b_path:: src/core/types/color.ts
import { z } from "zod";

/**
 * CSS hex color value.
 *
 * Represents a color in hexadecimal notation: #RGB, #RRGGBB, #RGBA, or #RRGGBBAA.
 * Values are always normalized to uppercase #RRGGBB or #RRGGBBAA format.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color}
 *
 * @example
 * ```typescript
 * import type { HexColor } from "@/core/types/color";
 *
 * const color1: HexColor = { kind: "hex", value: "#FF5733" };
 * const color2: HexColor = { kind: "hex", value: "#FF573380" }; // with alpha
 * ```
 *
 * @public
 */
export const hexColorSchema = z.object({
	kind: z.literal("hex"),
	value: z.string().regex(/^#[0-9A-F]{6}([0-9A-F]{2})?$/), // #RRGGBB or #RRGGBBAA (uppercase)
});

/**
 * TypeScript type for hex color.
 * @public
 */
export type HexColor = z.infer<typeof hexColorSchema>;

/**
 * CSS named color value.
 *
 * Represents a color using a CSS color keyword name.
 * Includes basic colors (red, blue, etc.) and extended X11/SVG colors.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 *
 * @example
 * ```typescript
 * import type { NamedColor } from "@/core/types/color";
 *
 * const color1: NamedColor = { kind: "named", name: "red" };
 * const color2: NamedColor = { kind: "named", name: "cornflowerblue" };
 * ```
 *
 * @public
 */
export const namedColorSchema = z.object({
	kind: z.literal("named"),
	name: z.string(), // validated against keyword list at parse time
});

/**
 * TypeScript type for named color.
 * @public
 */
export type NamedColor = z.infer<typeof namedColorSchema>;

/**
 * CSS RGB color value.
 *
 * Represents a color in RGB (Red, Green, Blue) color space.
 * Supports optional alpha channel for transparency.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb}
 *
 * @example
 * ```typescript
 * import type { RGBColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: RGBColor = { kind: "rgb", r: 255, g: 87, b: 51 };
 *
 * // With alpha
 * const color2: RGBColor = { kind: "rgb", r: 255, g: 87, b: 51, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const rgbColorSchema = z.object({
	kind: z.literal("rgb"),
	r: z.number().min(0).max(255),
	g: z.number().min(0).max(255),
	b: z.number().min(0).max(255),
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for RGB color.
 * @public
 */
export type RGBColor = z.infer<typeof rgbColorSchema>;

/**
 * CSS HSL color value.
 *
 * Represents a color in HSL (Hue, Saturation, Lightness) color space.
 * Hue is normalized to 0-360 degrees. Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl}
 *
 * @example
 * ```typescript
 * import type { HSLColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: HSLColor = { kind: "hsl", h: 120, s: 100, l: 50 };
 *
 * // With alpha
 * const color2: HSLColor = { kind: "hsl", h: 120, s: 100, l: 50, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const hslColorSchema = z.object({
	kind: z.literal("hsl"),
	h: z.number(), // degrees 0-360 (wraps around)
	s: z.number().min(0).max(100), // saturation percentage
	l: z.number().min(0).max(100), // lightness percentage
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for HSL color.
 * @public
 */
export type HSLColor = z.infer<typeof hslColorSchema>;

/**
 * CSS HWB color value.
 *
 * Represents a color in HWB (Hue, Whiteness, Blackness) color space.
 * Hue is normalized to 0-360 degrees. Whiteness and blackness are percentages.
 * Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb}
 *
 * @example
 * ```typescript
 * import type { HWBColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: HWBColor = { kind: "hwb", h: 120, w: 20, b: 30 };
 *
 * // With alpha
 * const color2: HWBColor = { kind: "hwb", h: 120, w: 20, b: 30, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const hwbColorSchema = z.object({
	kind: z.literal("hwb"),
	h: z.number(), // degrees 0-360 (wraps around)
	w: z.number().min(0).max(100), // whiteness percentage
	b: z.number().min(0).max(100), // blackness percentage
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for HWB color.
 * @public
 */
export type HWBColor = z.infer<typeof hwbColorSchema>;

/**
 * CSS LAB color value.
 *
 * Represents a color in CIE LAB (Lightness, a, b) color space.
 * LAB is a perceptual color space where distances correspond to perceived color differences.
 * Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lab}
 *
 * @example
 * ```typescript
 * import type { LABColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: LABColor = { kind: "lab", l: 50, a: -20, b: 30 };
 *
 * // With alpha
 * const color2: LABColor = { kind: "lab", l: 50, a: -20, b: 30, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const labColorSchema = z.object({
	kind: z.literal("lab"),
	l: z.number().min(0).max(100), // lightness percentage
	a: z.number().min(-125).max(125), // green-red axis
	b: z.number().min(-125).max(125), // blue-yellow axis
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for LAB color.
 * @public
 */
export type LABColor = z.infer<typeof labColorSchema>;

/**
 * CSS LCH color value.
 *
 * Represents a color in CIE LCH (Lightness, Chroma, Hue) color space.
 * LCH is the cylindrical representation of LAB color space.
 * Hue is normalized to 0-360 degrees. Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lch}
 *
 * @example
 * ```typescript
 * import type { LCHColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: LCHColor = { kind: "lch", l: 50, c: 50, h: 180 };
 *
 * // With alpha
 * const color2: LCHColor = { kind: "lch", l: 50, c: 50, h: 180, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const lchColorSchema = z.object({
	kind: z.literal("lch"),
	l: z.number().min(0).max(100), // lightness percentage
	c: z.number().min(0).max(150), // chroma
	h: z.number(), // hue degrees 0-360 (wraps around)
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for LCH color.
 * @public
 */
export type LCHColor = z.infer<typeof lchColorSchema>;

/**
 * CSS OKLab color value.
 *
 * Represents a color in OKLab (Oklab Lightness, a, b) color space.
 * OKLab is a perceptual color space designed for better perceptual uniformity than CIE LAB.
 * Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklab}
 *
 * @example
 * ```typescript
 * import type { OKLabColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: OKLabColor = { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 };
 *
 * // With alpha
 * const color2: OKLabColor = { kind: "oklab", l: 0.5, a: -0.2, b: 0.3, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const oklabColorSchema = z.object({
	kind: z.literal("oklab"),
	l: z.number().min(0).max(1), // lightness 0-1 (or 0-100% at parse time)
	a: z.number().min(-0.4).max(0.4), // green-red axis
	b: z.number().min(-0.4).max(0.4), // blue-yellow axis
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for OKLab color.
 * @public
 */
export type OKLabColor = z.infer<typeof oklabColorSchema>;

/**
 * CSS OKLCH color value.
 *
 * Represents a color in OKLCH (Oklab Lightness, Chroma, Hue) color space.
 * OKLCH is the cylindrical representation of OKLab color space.
 * Hue is normalized to 0-360 degrees. Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklch}
 *
 * @example
 * ```typescript
 * import type { OKLCHColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: OKLCHColor = { kind: "oklch", l: 0.5, c: 0.2, h: 180 };
 *
 * // With alpha
 * const color2: OKLCHColor = { kind: "oklch", l: 0.5, c: 0.2, h: 180, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const oklchColorSchema = z.object({
	kind: z.literal("oklch"),
	l: z.number().min(0).max(1), // lightness 0-1 (or 0-100% at parse time)
	c: z.number().min(0).max(0.4), // chroma
	h: z.number(), // hue degrees 0-360 (wraps around)
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for OKLCH color.
 * @public
 */
export type OKLCHColor = z.infer<typeof oklchColorSchema>;

/**
 * CSS system color value.
 *
 * Represents a system color using a CSS system color keyword.
 * System colors integrate with the user's operating system or browser theme.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#css-system-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/system-color}
 *
 * @example
 * ```typescript
 * import type { SystemColor } from "@/core/types/color";
 *
 * const color1: SystemColor = { kind: "system", keyword: "ButtonText" };
 * const color2: SystemColor = { kind: "system", keyword: "Canvas" };
 * ```
 *
 * @public
 */
export const systemColorSchema = z.object({
	kind: z.literal("system"),
	keyword: z.string(), // validated against system color keyword list at parse time
});

/**
 * TypeScript type for system color.
 * @public
 */
export type SystemColor = z.infer<typeof systemColorSchema>;

/**
 * CSS special color value.
 *
 * Represents special CSS color keywords with unique behavior.
 * - `transparent`: Fully transparent color (rgba(0, 0, 0, 0))
 * - `currentcolor`: Uses the current value of the color property
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 *
 * @example
 * ```typescript
 * import type { SpecialColor } from "@/core/types/color";
 *
 * const color1: SpecialColor = { kind: "special", keyword: "transparent" };
 * const color2: SpecialColor = { kind: "special", keyword: "currentcolor" };
 * ```
 *
 * @public
 */
export const specialColorSchema = z.object({
	kind: z.literal("special"),
	keyword: z.enum(["transparent", "currentcolor"]),
});

/**
 * TypeScript type for special color.
 * @public
 */
export type SpecialColor = z.infer<typeof specialColorSchema>;

/**
 * CSS color() function with explicit color space.
 *
 * Represents a color in a specific color space with explicit channel values.
 * Supports wide-gamut color spaces like display-p3 and professional spaces.
 *
 * Syntax: color(colorspace c1 c2 c3 [ / alpha ]?)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color}
 *
 * @example
 * ```typescript
 * import type { ColorFunction } from "@/core/types/color";
 *
 * // Display P3 color
 * const color1: ColorFunction = {
 *   kind: "color",
 *   colorSpace: "display-p3",
 *   channels: [0.928, 0.322, 0.203],
 *   alpha: 0.8
 * };
 *
 * // sRGB linear
 * const color2: ColorFunction = {
 *   kind: "color",
 *   colorSpace: "srgb-linear",
 *   channels: [0.5, 0.2, 0.8]
 * };
 * ```
 *
 * @public
 */
export const colorFunctionSchema = z.object({
	kind: z.literal("color"),
	colorSpace: z.enum([
		"srgb",
		"srgb-linear",
		"display-p3",
		"a98-rgb",
		"prophoto-rgb",
		"rec2020",
		"xyz",
		"xyz-d50",
		"xyz-d65",
	]),
	channels: z.tuple([z.number(), z.number(), z.number()]),
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for color() function.
 * @public
 */
export type ColorFunction = z.infer<typeof colorFunctionSchema>;

/**
 * CSS color value.
 *
 * Discriminated union of all supported CSS color formats.
 * Supports hex, named, RGB, HSL, HWB, LAB, LCH, OKLab, OKLCH, system, special, and color() function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 *
 * @example
 * ```typescript
 * import type { Color } from "@/core/types/color";
 *
 * const hex: Color = { kind: "hex", value: "#FF5733" };
 * const named: Color = { kind: "named", name: "red" };
 * const rgb: Color = { kind: "rgb", r: 255, g: 87, b: 51 };
 * const hsl: Color = { kind: "hsl", h: 120, s: 100, l: 50 };
 * const hwb: Color = { kind: "hwb", h: 120, w: 20, b: 30 };
 * const lab: Color = { kind: "lab", l: 50, a: -20, b: 30 };
 * const lch: Color = { kind: "lch", l: 50, c: 50, h: 180 };
 * const oklab: Color = { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 };
 * const oklch: Color = { kind: "oklch", l: 0.5, c: 0.2, h: 180 };
 * const system: Color = { kind: "system", keyword: "ButtonText" };
 * const special: Color = { kind: "special", keyword: "transparent" };
 * const colorFn: Color = { kind: "color", colorSpace: "display-p3", channels: [0.928, 0.322, 0.203] };
 * ```
 *
 * @public
 */
export const colorSchema = z.union([
	hexColorSchema,
	namedColorSchema,
	rgbColorSchema,
	hslColorSchema,
	hwbColorSchema,
	labColorSchema,
	lchColorSchema,
	oklabColorSchema,
	oklchColorSchema,
	systemColorSchema,
	specialColorSchema,
	colorFunctionSchema,
]);

/**
 * TypeScript type for color value.
 * @public
 */
export type Color = z.infer<typeof colorSchema>;


=== File: src/core/types/css-value.ts ===
// b_path:: src/core/types/css-value.ts

/**
 * Union of all CSS value types that can be parsed/generated by b_value.
 *
 * This type represents the complete set of intermediate representations (IR)
 * for all supported CSS longhand properties. Used by `parseAll()` and `generateAll()`
 * for batch processing of CSS declarations.
 *
 * @module
 * @public
 */

import type * as Type from "./index";

/**
 * Union of all CSS value IR types supported by b_value.
 *
 * Includes all color, gradient, filter, transform, position, layout,
 * animation, transition, border, outline, and shadow value types.
 *
 * @example
 * ```typescript
 * import type { CSSValue } from "b_value";
 *
 * const color: CSSValue = { kind: "hex", value: "#FF0000" };
 * const length: CSSValue = { kind: "length", value: 10, unit: "px" };
 * ```
 *
 * @public
 */
export type CSSValue =
	// Color values
	| Type.HexColor
	| Type.RGBColor
	| Type.HSLColor
	| Type.HWBColor
	| Type.LABColor
	| Type.LCHColor
	| Type.OKLabColor
	| Type.OKLCHColor
	| Type.NamedColor
	| Type.ColorFunction
	// Clip-path values
	| Type.ClipPathCircle
	| Type.ClipPathEllipse
	| Type.ClipPathPolygon
	| Type.ClipPathInset
	| Type.ClipPathRect
	| Type.ClipPathXywh
	| Type.ClipPathPath
	| Type.ClipPathNone
	// Gradient values
	| Type.LinearGradient
	| Type.RadialGradient
	| Type.ConicGradient
	// Filter values
	| Type.FilterFunction
	// Shadow values
	| Type.BoxShadow
	| Type.TextShadow
	// Transform values
	| Type.Transform
	// Position values
	| Type.Position2D
	// Border values
	| Type.BorderWidth
	| Type.BorderStyle
	| Type.BorderColor
	| Type.BorderRadiusValue
	// Outline values
	| Type.OutlineWidthValue
	| Type.OutlineStyleValue
	| Type.OutlineColorValue
	| Type.OutlineOffsetValue
	// Animation values
	| Type.AnimationName
	| Type.AnimationDuration
	| Type.AnimationTimingFunction
	| Type.AnimationDelay
	| Type.AnimationIterationCount
	| Type.AnimationDirection
	| Type.AnimationFillMode
	| Type.AnimationPlayState
	// Transition values
	| Type.TransitionProperty
	| Type.TransitionDuration
	| Type.TransitionTimingFunction
	| Type.TransitionDelay
	// Layout values
	| Type.LengthPercentage
	| Type.Display
	| Type.PositionProperty
	| Type.OverflowX
	| Type.OverflowY
	| Type.ZIndex
	| Type.Width
	| Type.Height
	| Type.Top
	| Type.Right
	| Type.Bottom
	| Type.Left
	| Type.Opacity
	| Type.Visibility
	| Type.Cursor
	// Angle, Time primitives
	| Type.Angle
	| Type.Time;

/**
 * Type guard to check if a value is a CSSValue (parsed IR).
 *
 * @param value - Value to check
 * @returns True if value is a parsed CSS value (IR object with 'kind' field)
 *
 * @example
 * ```typescript
 * if (isCSSValue(value)) {
 *   console.log(value.kind); // Safe to access kind field
 * }
 * ```
 *
 * @public
 */
export function isCSSValue(value: unknown): value is CSSValue {
	return typeof value === "object" && value !== null && "kind" in value;
}

/**
 * Type guard to check if a value is an unparsed string.
 *
 * @param value - Value to check (CSSValue or string)
 * @returns True if value is a string (unparsed CSS)
 *
 * @example
 * ```typescript
 * if (isUnparsedString(value)) {
 *   console.log("Raw CSS:", value); // It's a string
 * }
 * ```
 *
 * @public
 */
export function isUnparsedString(value: CSSValue | string): value is string {
	return typeof value === "string";
}


=== File: src/core/types/filter.ts ===
// b_path:: src/core/types/filter.ts
import { z } from "zod";
import type { Angle } from "./angle";
import type { Color } from "./color";
import type { Length } from "./length-percentage";

/**
 * CSS blur() filter function.
 *
 * Applies a Gaussian blur to the element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur}
 *
 * @example
 * ```typescript
 * import type { BlurFilter } from "@/core/types/filter";
 *
 * const filter: BlurFilter = { kind: "blur", radius: { value: 5, unit: "px" } };
 * // CSS: blur(5px)
 * ```
 *
 * @public
 */
export const blurFilterSchema = z.object({
	kind: z.literal("blur"),
	radius: z.custom<Length>(),
});

/**
 * TypeScript type for blur filter.
 * @public
 */
export type BlurFilter = z.infer<typeof blurFilterSchema>;

/**
 * CSS brightness() filter function.
 *
 * Applies a linear multiplier to the element, making it appear brighter or darker.
 * Values: number (1 = 100%) or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness}
 *
 * @example
 * ```typescript
 * import type { BrightnessFilter } from "@/core/types/filter";
 *
 * const filter1: BrightnessFilter = { kind: "brightness", value: 1.5 }; // 150%
 * const filter2: BrightnessFilter = { kind: "brightness", value: 0.5 }; // 50%
 * // CSS: brightness(1.5) or brightness(0.5)
 * ```
 *
 * @public
 */
export const brightnessFilterSchema = z.object({
	kind: z.literal("brightness"),
	value: z.number().nonnegative(), // 0 to infinity, 1 = 100%
});

/**
 * TypeScript type for brightness filter.
 * @public
 */
export type BrightnessFilter = z.infer<typeof brightnessFilterSchema>;

/**
 * CSS contrast() filter function.
 *
 * Adjusts the contrast of the element.
 * Values: number (1 = 100%) or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast}
 *
 * @example
 * ```typescript
 * import type { ContrastFilter } from "@/core/types/filter";
 *
 * const filter: ContrastFilter = { kind: "contrast", value: 1.2 }; // 120%
 * // CSS: contrast(1.2)
 * ```
 *
 * @public
 */
export const contrastFilterSchema = z.object({
	kind: z.literal("contrast"),
	value: z.number().nonnegative(), // 0 to infinity, 1 = 100%
});

/**
 * TypeScript type for contrast filter.
 * @public
 */
export type ContrastFilter = z.infer<typeof contrastFilterSchema>;

/**
 * CSS grayscale() filter function.
 *
 * Converts the element to grayscale.
 * Values: number (0-1, where 1 = 100%) or percentage (0-100%).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale}
 *
 * @example
 * ```typescript
 * import type { GrayscaleFilter } from "@/core/types/filter";
 *
 * const filter: GrayscaleFilter = { kind: "grayscale", value: 0.5 }; // 50%
 * // CSS: grayscale(0.5)
 * ```
 *
 * @public
 */
export const grayscaleFilterSchema = z.object({
	kind: z.literal("grayscale"),
	value: z.number().min(0).max(1), // 0 to 1, where 1 = 100%
});

/**
 * TypeScript type for grayscale filter.
 * @public
 */
export type GrayscaleFilter = z.infer<typeof grayscaleFilterSchema>;

/**
 * CSS hue-rotate() filter function.
 *
 * Rotates the hue of the element.
 * Value: angle (deg, grad, rad, turn).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate}
 *
 * @example
 * ```typescript
 * import type { HueRotateFilter } from "@/core/types/filter";
 *
 * const filter: HueRotateFilter = { kind: "hue-rotate", angle: { value: 90, unit: "deg" } };
 * // CSS: hue-rotate(90deg)
 * ```
 *
 * @public
 */
export const hueRotateFilterSchema = z.object({
	kind: z.literal("hue-rotate"),
	angle: z.custom<Angle>(),
});

/**
 * TypeScript type for hue-rotate filter.
 * @public
 */
export type HueRotateFilter = z.infer<typeof hueRotateFilterSchema>;

/**
 * CSS invert() filter function.
 *
 * Inverts the colors of the element.
 * Values: number (0-1, where 1 = 100%) or percentage (0-100%).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert}
 *
 * @example
 * ```typescript
 * import type { InvertFilter } from "@/core/types/filter";
 *
 * const filter: InvertFilter = { kind: "invert", value: 1 }; // 100%
 * // CSS: invert(1)
 * ```
 *
 * @public
 */
export const invertFilterSchema = z.object({
	kind: z.literal("invert"),
	value: z.number().min(0).max(1), // 0 to 1, where 1 = 100%
});

/**
 * TypeScript type for invert filter.
 * @public
 */
export type InvertFilter = z.infer<typeof invertFilterSchema>;

/**
 * CSS opacity() filter function.
 *
 * Applies transparency to the element.
 * Values: number (0-1, where 1 = 100%) or percentage (0-100%).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/opacity}
 *
 * @example
 * ```typescript
 * import type { OpacityFilter } from "@/core/types/filter";
 *
 * const filter: OpacityFilter = { kind: "opacity", value: 0.5 }; // 50%
 * // CSS: opacity(0.5)
 * ```
 *
 * @public
 */
export const opacityFilterSchema = z.object({
	kind: z.literal("opacity"),
	value: z.number().min(0).max(1), // 0 to 1, where 1 = 100%
});

/**
 * TypeScript type for opacity filter.
 * @public
 */
export type OpacityFilter = z.infer<typeof opacityFilterSchema>;

/**
 * CSS saturate() filter function.
 *
 * Adjusts the saturation of the element.
 * Values: number (1 = 100%) or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate}
 *
 * @example
 * ```typescript
 * import type { SaturateFilter } from "@/core/types/filter";
 *
 * const filter: SaturateFilter = { kind: "saturate", value: 2 }; // 200%
 * // CSS: saturate(2)
 * ```
 *
 * @public
 */
export const saturateFilterSchema = z.object({
	kind: z.literal("saturate"),
	value: z.number().nonnegative(), // 0 to infinity, 1 = 100%
});

/**
 * TypeScript type for saturate filter.
 * @public
 */
export type SaturateFilter = z.infer<typeof saturateFilterSchema>;

/**
 * CSS sepia() filter function.
 *
 * Converts the element to sepia.
 * Values: number (0-1, where 1 = 100%) or percentage (0-100%).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia}
 *
 * @example
 * ```typescript
 * import type { SepiaFilter } from "@/core/types/filter";
 *
 * const filter: SepiaFilter = { kind: "sepia", value: 0.8 }; // 80%
 * // CSS: sepia(0.8)
 * ```
 *
 * @public
 */
export const sepiaFilterSchema = z.object({
	kind: z.literal("sepia"),
	value: z.number().min(0).max(1), // 0 to 1, where 1 = 100%
});

/**
 * TypeScript type for sepia filter.
 * @public
 */
export type SepiaFilter = z.infer<typeof sepiaFilterSchema>;

/**
 * CSS drop-shadow() filter function.
 *
 * Applies a drop shadow effect to the element.
 * Syntax: drop-shadow(offset-x offset-y blur-radius color)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow}
 *
 * @example
 * ```typescript
 * import type { DropShadowFilter } from "@/core/types/filter";
 *
 * const filter: DropShadowFilter = {
 *   kind: "drop-shadow",
 *   offsetX: { value: 2, unit: "px" },
 *   offsetY: { value: 2, unit: "px" },
 *   blurRadius: { value: 4, unit: "px" },
 *   color: { kind: "named", name: "black" }
 * };
 * // CSS: drop-shadow(2px 2px 4px black)
 * ```
 *
 * @public
 */
export const dropShadowFilterSchema = z.object({
	kind: z.literal("drop-shadow"),
	offsetX: z.custom<Length>(),
	offsetY: z.custom<Length>(),
	blurRadius: z.custom<Length>().optional(),
	color: z.custom<Color>().optional(),
});

/**
 * TypeScript type for drop-shadow filter.
 * @public
 */
export type DropShadowFilter = z.infer<typeof dropShadowFilterSchema>;

/**
 * CSS url() filter function.
 *
 * References an SVG filter element by URL.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/url}
 *
 * @example
 * ```typescript
 * import type { UrlFilter } from "@/core/types/filter";
 *
 * const filter: UrlFilter = { kind: "url", url: "#my-filter" };
 * // CSS: url(#my-filter)
 * ```
 *
 * @public
 */
export const urlFilterSchema = z.object({
	kind: z.literal("url"),
	url: z.string(),
});

/**
 * TypeScript type for url filter.
 * @public
 */
export type UrlFilter = z.infer<typeof urlFilterSchema>;

/**
 * Union of all CSS filter function types.
 *
 * Represents any valid CSS filter function with a discriminated union
 * on the `kind` field for type-safe narrowing.
 *
 * @example
 * ```typescript
 * import type { FilterFunction } from "@/core/types/filter";
 *
 * const filter: FilterFunction = { kind: "blur", radius: { value: 5, unit: "px" } };
 *
 * // Type narrowing with discriminated union
 * if (filter.kind === "blur") {
 *   console.log(filter.radius); // TypeScript knows this is BlurFilter
 * }
 * ```
 *
 * @public
 */
export type FilterFunction =
	| BlurFilter
	| BrightnessFilter
	| ContrastFilter
	| GrayscaleFilter
	| HueRotateFilter
	| InvertFilter
	| OpacityFilter
	| SaturateFilter
	| SepiaFilter
	| DropShadowFilter
	| UrlFilter;


=== File: src/core/types/gradient/conic.ts ===
// b_path:: src/core/types/gradient/conic.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import { angleSchema } from "../angle";
import { colorStopListSchema } from "../color-stop";
import { position2DSchema } from "../position";

/**
 * CSS conic gradient value.
 *
 * A conic gradient transitions colors progressively around a center point.
 * The gradient sweeps in a circular arc, starting from a specified angle.
 * It can have optional starting angle, position, color interpolation method,
 * and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 4 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient}
 * @see {@link https://www.w3.org/TR/css-images-4/#conic-gradients}
 *
 * @example
 * ```typescript
 * import { conicGradientSchema } from "@/core/types/gradient/conic";
 *
 * // Simple conic gradient (defaults to starting from top, center position)
 * const grad1: ConicGradient = {
 *   kind: "conic",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With starting angle
 * const grad2: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 45, unit: "deg" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // At specific position
 * const grad3: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 0, unit: "deg" },
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With color interpolation
 * const grad4: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 90, unit: "deg" },
 *   position: { horizontal: "center", vertical: "center" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "yellow", position: { value: 120, unit: "deg" } },
 *     { color: "blue", position: { value: 240, unit: "deg" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating conic gradient
 * const grad5: ConicGradient = {
 *   kind: "conic",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 45, unit: "deg" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const conicGradientSchema = z.object({
	kind: z.literal("conic"),
	fromAngle: angleSchema.optional().describe("starting angle (default: 0deg from top)"),
	position: position2DSchema.optional().describe("gradient center position (default: center)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for conic gradient.
 *
 * @public
 */
export type ConicGradient = z.infer<typeof conicGradientSchema>;


=== File: src/core/types/gradient/direction.ts ===
// b_path:: src/core/types/gradient/direction.ts
import { z } from "zod";
import * as Type from "../../types";

/**
 * CSS gradient direction value.
 *
 * Specifies the direction of a linear gradient. Can be an angle,
 * a side keyword (to top, to right, etc.), or a corner keyword
 * (to top left, to bottom right, etc.).
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients}
 *
 * @example
 * ```typescript
 * import { gradientDirectionSchema } from "@/core/types/gradient/direction";
 *
 * // Angle direction
 * const dir1: GradientDirection = {
 *   kind: "angle",
 *   value: { value: 45, unit: "deg" }
 * };
 *
 * // Side direction
 * const dir2: GradientDirection = {
 *   kind: "to-side",
 *   value: "right"
 * };
 *
 * // Corner direction
 * const dir3: GradientDirection = {
 *   kind: "to-corner",
 *   value: "top right"
 * };
 * ```
 *
 * @public
 */
export const gradientDirectionSchema = z.union([
	z.object({
		kind: z.literal("angle"),
		value: Type.angleSchema,
	}),
	z.object({
		kind: z.literal("to-side"),
		value: z.union([z.literal("top"), z.literal("right"), z.literal("bottom"), z.literal("left")]),
	}),
	z.object({
		kind: z.literal("to-corner"),
		value: z.union([
			z.literal("top left"),
			z.literal("top right"),
			z.literal("bottom left"),
			z.literal("bottom right"),
		]),
	}),
]);

/**
 * TypeScript type for gradient direction.
 *
 * @public
 */
export type GradientDirection = z.infer<typeof gradientDirectionSchema>;


=== File: src/core/types/gradient/index.ts ===
// b_path:: src/core/types/gradient/index.ts

export * from "./conic";
export * from "./direction";
export * from "./linear";
export * from "./radial";
export * from "./radial-shape";
export * from "./radial-size";

import type { ConicGradient } from "./conic";
import type { LinearGradient } from "./linear";
import type { RadialGradient } from "./radial";

/**
 * Union type for all gradient types.
 *
 * @public
 */
export type Gradient = LinearGradient | RadialGradient | ConicGradient;


=== File: src/core/types/gradient/linear.ts ===
// b_path:: src/core/types/gradient/linear.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import * as Type from "../../types";
import { gradientDirectionSchema } from "./direction";

/**
 * CSS linear gradient value.
 *
 * A linear gradient transitions colors progressively along a straight line.
 * The gradient can have an optional direction (angle or side/corner keyword),
 * optional color interpolation method, and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients}
 *
 * @example
 * ```typescript
 * import { linearGradientSchema } from "@/core/types/gradient/linear";
 *
 * // Simple gradient (defaults to top to bottom)
 * const grad1: LinearGradient = {
 *   kind: "linear",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With angle direction
 * const grad2: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With color interpolation
 * const grad3: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "to-side", value: "right" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating gradient
 * const grad4: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const linearGradientSchema = z.object({
	kind: z.literal("linear"),
	direction: gradientDirectionSchema.optional().describe("gradient direction (default: to bottom)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: Type.colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for linear gradient.
 *
 * @public
 */
export type LinearGradient = z.infer<typeof linearGradientSchema>;


=== File: src/core/types/gradient/radial-shape.ts ===
// b_path:: src/core/types/gradient/radial-shape.ts
import { z } from "zod";

/**
 * CSS radial gradient shape value.
 *
 * Specifies the shape of a radial gradient. Can be either a circle or an ellipse.
 * If omitted in CSS, the shape is inferred from the size specification.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients}
 *
 * @example
 * ```typescript
 * import { radialGradientShapeSchema } from "@/core/types/gradient/radial-shape";
 *
 * const shape1: RadialGradientShape = "circle";
 * const shape2: RadialGradientShape = "ellipse";
 * ```
 *
 * @public
 */
export const radialGradientShapeSchema = z.union([z.literal("circle"), z.literal("ellipse")]);

/**
 * TypeScript type for radial gradient shape.
 *
 * @public
 */
export type RadialGradientShape = z.infer<typeof radialGradientShapeSchema>;


=== File: src/core/types/gradient/radial-size.ts ===
// b_path:: src/core/types/gradient/radial-size.ts
import { z } from "zod";
import { lengthPercentageSchema } from "../length-percentage";

/**
 * CSS radial gradient size value.
 *
 * Specifies the size of a radial gradient. Can be a keyword describing
 * the ending shape's size relative to the gradient box, or explicit lengths.
 *
 * Per CSS Images Module Level 3 specification:
 * - closest-side: gradient ends at the side of the box closest to the gradient's center
 * - farthest-side: gradient ends at the side of the box farthest from the gradient's center
 * - closest-corner: gradient ends at the corner of the box closest to the gradient's center
 * - farthest-corner: gradient ends at the corner of the box farthest from the gradient's center (default)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-size-circle}
 *
 * @example
 * ```typescript
 * import { radialGradientSizeSchema } from "@/core/types/gradient/radial-size";
 *
 * // Keyword size
 * const size1: RadialGradientSize = {
 *   kind: "keyword",
 *   value: "closest-side"
 * };
 *
 * // Explicit circle size (single length)
 * const size2: RadialGradientSize = {
 *   kind: "circle-explicit",
 *   radius: { value: 100, unit: "px" }
 * };
 *
 * // Explicit ellipse size (two length-percentage values)
 * const size3: RadialGradientSize = {
 *   kind: "ellipse-explicit",
 *   radiusX: { value: 50, unit: "%" },
 *   radiusY: { value: 100, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const radialGradientSizeSchema = z.union([
	z.object({
		kind: z.literal("keyword"),
		value: z.union([
			z.literal("closest-side"),
			z.literal("farthest-side"),
			z.literal("closest-corner"),
			z.literal("farthest-corner"),
		]),
	}),
	z.object({
		kind: z.literal("circle-explicit"),
		radius: lengthPercentageSchema.describe("circle radius"),
	}),
	z.object({
		kind: z.literal("ellipse-explicit"),
		radiusX: lengthPercentageSchema.describe("horizontal radius"),
		radiusY: lengthPercentageSchema.describe("vertical radius"),
	}),
]);

/**
 * TypeScript type for radial gradient size.
 *
 * @public
 */
export type RadialGradientSize = z.infer<typeof radialGradientSizeSchema>;


=== File: src/core/types/gradient/radial.ts ===
// b_path:: src/core/types/gradient/radial.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import { colorStopListSchema } from "../color-stop";
import { position2DSchema } from "../position";
import { radialGradientShapeSchema } from "./radial-shape";
import { radialGradientSizeSchema } from "./radial-size";

/**
 * CSS radial gradient value.
 *
 * A radial gradient transitions colors progressively from a center point (origin)
 * outward in a circular or elliptical pattern. The gradient can have optional shape,
 * size, position, color interpolation method, and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients}
 *
 * @example
 * ```typescript
 * import { radialGradientSchema } from "@/core/types/gradient/radial";
 *
 * // Simple radial gradient (defaults to ellipse at center)
 * const grad1: RadialGradient = {
 *   kind: "radial",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // Circle with keyword size
 * const grad2: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "keyword", value: "closest-side" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // Ellipse at specific position
 * const grad3: RadialGradient = {
 *   kind: "radial",
 *   shape: "ellipse",
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With explicit size and color interpolation
 * const grad4: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "circle-explicit", radius: { value: 100, unit: "px" } },
 *   position: { horizontal: "center", vertical: "center" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating radial gradient
 * const grad5: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const radialGradientSchema = z.object({
	kind: z.literal("radial"),
	shape: radialGradientShapeSchema.optional().describe("gradient shape (default: ellipse)"),
	size: radialGradientSizeSchema.optional().describe("gradient size (default: farthest-corner)"),
	position: position2DSchema.optional().describe("gradient center position (default: center)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for radial gradient.
 *
 * @public
 */
export type RadialGradient = z.infer<typeof radialGradientSchema>;


=== File: src/core/types/grid-line.ts ===
// b_path:: src/core/types/grid-line.ts
import { z } from "zod";

/**
 * CSS Grid line value (simple version for Phase 1).
 *
 * Grid line values specify where grid items start and end.
 * This implementation supports:
 * - Integer values (positive, negative, or zero)
 * - The `auto` keyword (browser places item automatically)
 * - Span notation (e.g., `span 2` means span 2 grid tracks)
 *
 * Phase 2 will add support for named grid lines.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid}
 *
 * @example
 * ```typescript
 * import { gridLineSchema } from "@/core/types/grid-line";
 *
 * // Integer line number
 * const line1: GridLine = 1;
 * const line2: GridLine = -1; // Last line
 *
 * // Auto keyword
 * const line3: GridLine = "auto";
 *
 * // Span notation
 * const line4: GridLine = { type: "span", value: 2 };
 * ```
 *
 * @public
 */
export const gridLineSchema = z.union([
	z.number().int().describe("integer grid line number (positive, negative, or zero)"),
	z.literal("auto").describe("browser automatically places the item"),
	z
		.object({
			type: z.literal("span"),
			value: z.number().int().positive().describe("number of tracks to span"),
		})
		.describe("span notation (e.g., span 2 means span across 2 tracks)"),
]);

/**
 * TypeScript type for grid line values.
 *
 * @public
 */
export type GridLine = z.infer<typeof gridLineSchema>;

/**
 * Metadata for grid line values.
 *
 * Provides documentation for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { gridLineMetadata } from "@/core/types/grid-line";
 *
 * console.log(gridLineMetadata.description);
 * ```
 *
 * @public
 */
export const gridLineMetadata = {
	description: "Specifies grid line position (integer, auto, or span)",
	syntax: ["<integer>", "auto", "span <integer>"],
	examples: ["1", "-1", "auto", "span 2"],
} as const;

/**
 * Type for grid line metadata.
 *
 * @public
 */
export type GridLineMetadata = typeof gridLineMetadata;


=== File: src/core/types/index.ts ===
// b_path:: src/core/types/index.ts

export * from "./angle";
export * from "./animation";
export * from "./border";
export * from "./clip-path";
export * from "./color";
export * from "./color-stop";
export * from "./css-value";
export * from "./filter";
export * from "./gradient";
export * from "./grid-line";
export * from "./layout";
export * from "./length-percentage";
export * from "./outline";
export * from "./position";
export * from "./position-layer";
export * from "./ratio";
export * from "./shadow";
export * from "./size-layer";
export * from "./time";
export * from "./transform";
export * from "./transition";


=== File: src/core/types/layout.ts ===
// b_path:: src/core/types/layout.ts
import { z } from "zod";
import { cursorKeywordsSchema } from "../keywords/cursor-keywords";
import { displayKeywordsSchema } from "../keywords/display-keywords";
import { overflowKeywordsSchema } from "../keywords/overflow-keywords";
import { positionPropertyKeywordsSchema } from "../keywords/position-property-keywords";
import { visibilityKeywordsSchema } from "../keywords/visibility-keywords";
import { lengthPercentageAutoSchema } from "./length-percentage";

/**
 * CSS display property IR.
 *
 * The display property controls how an element is displayed in the layout,
 * including its box generation, inner layout type, and outer display type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display}
 *
 * @example
 * ```typescript
 * const display: Display = {
 *   kind: "display",
 *   value: "flex"
 * };
 * // CSS: display: flex;
 * ```
 *
 * @public
 */
export const displaySchema = z.object({
	kind: z.literal("display"),
	value: displayKeywordsSchema,
});

/**
 * TypeScript type for display property.
 *
 * @public
 */
export type Display = z.infer<typeof displaySchema>;

/**
 * CSS visibility property IR.
 *
 * The visibility property controls whether an element is visible or hidden.
 * Unlike display: none, visibility: hidden elements still take up space in the layout.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility}
 *
 * @example
 * ```typescript
 * const visibility: Visibility = {
 *   kind: "visibility",
 *   value: "hidden"
 * };
 * // CSS: visibility: hidden;
 * ```
 *
 * @public
 */
export const visibilitySchema = z.object({
	kind: z.literal("visibility"),
	value: visibilityKeywordsSchema,
});

/**
 * TypeScript type for visibility property.
 *
 * @public
 */
export type Visibility = z.infer<typeof visibilitySchema>;

/**
 * CSS opacity property IR.
 *
 * The opacity property sets the opacity level for an element.
 * Value range: 0 (fully transparent) to 1 (fully opaque).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/opacity}
 *
 * @example
 * ```typescript
 * const opacity: Opacity = {
 *   kind: "opacity",
 *   value: 0.5
 * };
 * // CSS: opacity: 0.5;
 * ```
 *
 * @public
 */
export const opacitySchema = z.object({
	kind: z.literal("opacity"),
	value: z.number().min(0).max(1),
});

/**
 * TypeScript type for opacity property.
 *
 * @public
 */
export type Opacity = z.infer<typeof opacitySchema>;

/**
 * CSS cursor property IR.
 *
 * The cursor property sets the mouse cursor to display when the mouse pointer is over an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}
 *
 * @example
 * ```typescript
 * const cursor: Cursor = {
 *   kind: "cursor",
 *   value: "pointer"
 * };
 * // CSS: cursor: pointer;
 * ```
 *
 * @public
 */
export const cursorSchema = z.object({
	kind: z.literal("cursor"),
	value: cursorKeywordsSchema,
});

/**
 * TypeScript type for cursor property.
 *
 * @public
 */
export type Cursor = z.infer<typeof cursorSchema>;

/**
 * CSS overflow-x property IR.
 *
 * The overflow-x property controls what happens when content overflows
 * an element's box horizontally (left and right edges).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x}
 *
 * @example
 * ```typescript
 * const overflowX: OverflowX = {
 *   kind: "overflow-x",
 *   value: "hidden"
 * };
 * // CSS: overflow-x: hidden;
 * ```
 *
 * @public
 */
export const overflowXSchema = z.object({
	kind: z.literal("overflow-x"),
	value: overflowKeywordsSchema,
});

/**
 * TypeScript type for overflow-x property.
 *
 * @public
 */
export type OverflowX = z.infer<typeof overflowXSchema>;

/**
 * CSS overflow-y property IR.
 *
 * The overflow-y property controls what happens when content overflows
 * an element's box vertically (top and bottom edges).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y}
 *
 * @example
 * ```typescript
 * const overflowY: OverflowY = {
 *   kind: "overflow-y",
 *   value: "scroll"
 * };
 * // CSS: overflow-y: scroll;
 * ```
 *
 * @public
 */
export const overflowYSchema = z.object({
	kind: z.literal("overflow-y"),
	value: overflowKeywordsSchema,
});

/**
 * TypeScript type for overflow-y property.
 *
 * @public
 */
export type OverflowY = z.infer<typeof overflowYSchema>;

/**
 * CSS position property IR.
 *
 * The position property sets how an element is positioned in a document.
 * The top, right, bottom, and left properties determine the final location
 * of positioned elements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position}
 *
 * @example
 * ```typescript
 * const position: PositionProperty = {
 *   kind: "position-property",
 *   value: "absolute"
 * };
 * // CSS: position: absolute;
 * ```
 *
 * @public
 */
export const positionPropertySchema = z.object({
	kind: z.literal("position-property"),
	value: positionPropertyKeywordsSchema,
});

/**
 * TypeScript type for position property.
 *
 * @public
 */
export type PositionProperty = z.infer<typeof positionPropertySchema>;

/**
 * CSS z-index property IR.
 *
 * The z-index property sets the z-order (stack level) of a positioned element.
 * Only works on positioned elements (position other than static).
 * Accepts integer values (positive, negative, or zero) or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/z-index}
 *
 * @example
 * ```typescript
 * const zIndex: ZIndex = {
 *   kind: "z-index",
 *   value: 10
 * };
 * // CSS: z-index: 10;
 * ```
 *
 * @example
 * ```typescript
 * const zIndex: ZIndex = {
 *   kind: "z-index",
 *   value: "auto"
 * };
 * // CSS: z-index: auto;
 * ```
 *
 * @public
 */
export const zIndexSchema = z.object({
	kind: z.literal("z-index"),
	value: z.union([z.number().int(), z.literal("auto")]),
});

/**
 * TypeScript type for z-index property.
 *
 * @public
 */
export type ZIndex = z.infer<typeof zIndexSchema>;

/**
 * CSS top property IR.
 *
 * The top property affects the vertical position of a positioned element.
 * Accepts length-percentage values or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/top}
 *
 * @example
 * ```typescript
 * const top: Top = {
 *   kind: "top",
 *   value: { value: 10, unit: "px" }
 * };
 * // CSS: top: 10px;
 * ```
 *
 * @example
 * ```typescript
 * const top: Top = {
 *   kind: "top",
 *   value: "auto"
 * };
 * // CSS: top: auto;
 * ```
 *
 * @public
 */
export const topSchema = z.object({
	kind: z.literal("top"),
	value: lengthPercentageAutoSchema,
});

/**
 * TypeScript type for top property.
 *
 * @public
 */
export type Top = z.infer<typeof topSchema>;

/**
 * CSS right property IR.
 *
 * The right property affects the horizontal position of a positioned element.
 * Accepts length-percentage values or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/right}
 *
 * @example
 * ```typescript
 * const right: Right = {
 *   kind: "right",
 *   value: { value: 10, unit: "px" }
 * };
 * // CSS: right: 10px;
 * ```
 *
 * @example
 * ```typescript
 * const right: Right = {
 *   kind: "right",
 *   value: "auto"
 * };
 * // CSS: right: auto;
 * ```
 *
 * @public
 */
export const rightSchema = z.object({
	kind: z.literal("right"),
	value: lengthPercentageAutoSchema,
});

/**
 * TypeScript type for right property.
 *
 * @public
 */
export type Right = z.infer<typeof rightSchema>;

/**
 * CSS bottom property IR.
 *
 * The bottom property affects the vertical position of a positioned element.
 * Accepts length-percentage values or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/bottom}
 *
 * @example
 * ```typescript
 * const bottom: Bottom = {
 *   kind: "bottom",
 *   value: { value: 10, unit: "px" }
 * };
 * // CSS: bottom: 10px;
 * ```
 *
 * @example
 * ```typescript
 * const bottom: Bottom = {
 *   kind: "bottom",
 *   value: "auto"
 * };
 * // CSS: bottom: auto;
 * ```
 *
 * @public
 */
export const bottomSchema = z.object({
	kind: z.literal("bottom"),
	value: lengthPercentageAutoSchema,
});

/**
 * TypeScript type for bottom property.
 *
 * @public
 */
export type Bottom = z.infer<typeof bottomSchema>;

/**
 * CSS left property IR.
 *
 * The left property affects the horizontal position of a positioned element.
 * Accepts length-percentage values or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/left}
 *
 * @example
 * ```typescript
 * const left: Left = {
 *   kind: "left",
 *   value: { value: 10, unit: "px" }
 * };
 * // CSS: left: 10px;
 * ```
 *
 * @example
 * ```typescript
 * const left: Left = {
 *   kind: "left",
 *   value: "auto"
 * };
 * // CSS: left: auto;
 * ```
 *
 * @public
 */
export const leftSchema = z.object({
	kind: z.literal("left"),
	value: lengthPercentageAutoSchema,
});

/**
 * TypeScript type for left property.
 *
 * @public
 */
export type Left = z.infer<typeof leftSchema>;

/**
 * CSS width property IR.
 *
 * The width property sets the width of an element.
 * Accepts length-percentage, auto, or intrinsic sizing keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width}
 *
 * @example
 * ```typescript
 * const width: Width = {
 *   kind: "width",
 *   value: { value: 200, unit: "px" }
 * };
 * // CSS: width: 200px;
 * ```
 *
 * @example
 * ```typescript
 * const width: Width = {
 *   kind: "width",
 *   value: "auto"
 * };
 * // CSS: width: auto;
 * ```
 *
 * @example
 * ```typescript
 * const width: Width = {
 *   kind: "width",
 *   value: "min-content"
 * };
 * // CSS: width: min-content;
 * ```
 *
 * @public
 */
export const widthSchema = z.object({
	kind: z.literal("width"),
	value: z.union([lengthPercentageAutoSchema, z.enum(["min-content", "max-content", "fit-content"])]),
});

/**
 * TypeScript type for width property.
 *
 * @public
 */
export type Width = z.infer<typeof widthSchema>;

/**
 * CSS height property IR.
 *
 * The height property sets the height of an element.
 * Accepts length-percentage, auto, or intrinsic sizing keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/height}
 *
 * @example
 * ```typescript
 * const height: Height = {
 *   kind: "height",
 *   value: { value: 100, unit: "px" }
 * };
 * // CSS: height: 100px;
 * ```
 *
 * @example
 * ```typescript
 * const height: Height = {
 *   kind: "height",
 *   value: "auto"
 * };
 * // CSS: height: auto;
 * ```
 *
 * @example
 * ```typescript
 * const height: Height = {
 *   kind: "height",
 *   value: "max-content"
 * };
 * // CSS: height: max-content;
 * ```
 *
 * @public
 */
export const heightSchema = z.object({
	kind: z.literal("height"),
	value: z.union([lengthPercentageAutoSchema, z.enum(["min-content", "max-content", "fit-content"])]),
});

/**
 * TypeScript type for height property.
 *
 * @public
 */
export type Height = z.infer<typeof heightSchema>;


=== File: src/core/types/length-percentage.ts ===
// b_path:: src/core/types/length-percentage.ts
import { z } from "zod";
import * as Unit from "@/core/units";

/**
 * All CSS length unit identifiers.
 *
 * Union of absolute, font-relative, and viewport-relative length units.
 * Per CSS Values & Units Module Level 4 specification.
 *
 * @see {@link https://www.w3.org/TR/css-values-4/#lengths}
 *
 * @internal
 */
const allLengthUnitsSchema = z.union([
	Unit.absoluteLengthUnitSchema,
	Unit.fontLengthUnitSchema,
	Unit.viewportLengthUnitSchema,
]);

/**
 * CSS `<length>` dimension.
 *
 * A length is a distance measurement consisting of a number and a unit.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length}
 *
 * @example
 * ```typescript
 * import { lengthSchema } from "@/core/types/length-percentage";
 *
 * const size: Length = { value: 100, unit: "px" };
 * const fontSize: Length = { value: 1.5, unit: "rem" };
 * ```
 *
 * @public
 */
export const lengthSchema = z.object({
	value: z.number(),
	unit: allLengthUnitsSchema,
});

/**
 * TypeScript type for `<length>` dimension.
 *
 * @public
 */
export type Length = z.infer<typeof lengthSchema>;

/**
 * CSS `<length-percentage>` data type.
 *
 * A type that can accept either a `<length>` or a `<percentage>` value.
 * This is a CSS spec-defined composite type.
 *
 * Per CSS spec: <length-percentage> = <length> | <percentage>
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage}
 *
 * @example
 * ```typescript
 * import { lengthPercentageSchema } from "@/core/types/length-percentage";
 *
 * // Percentage
 * const size1: LengthPercentage = { value: 50, unit: "%" };
 *
 * // Length (px)
 * const size2: LengthPercentage = { value: 100, unit: "px" };
 *
 * // Length (em)
 * const size3: LengthPercentage = { value: 2, unit: "em" };
 * ```
 *
 * @public
 */
export const lengthPercentageSchema = z.union([lengthSchema, Unit.percentageSchema]);

/**
 * TypeScript type for `<length-percentage>` values.
 *
 * @public
 */
export type LengthPercentage = z.infer<typeof lengthPercentageSchema>;

/**
 * CSS `<length-percentage>` with `auto` keyword.
 *
 * Extends `<length-percentage>` to also accept the `auto` keyword.
 * Used in properties like `background-size` where auto is valid.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage}
 *
 * @example
 * ```typescript
 * import { lengthPercentageAutoSchema } from "@/core/types/length-percentage";
 *
 * // Auto keyword
 * const size1: LengthPercentageAuto = "auto";
 *
 * // Percentage
 * const size2: LengthPercentageAuto = { value: 50, unit: "%" };
 *
 * // Length
 * const size3: LengthPercentageAuto = { value: 100, unit: "px" };
 * ```
 *
 * @public
 */
export const lengthPercentageAutoSchema = z.union([z.literal("auto"), lengthPercentageSchema]);

/**
 * TypeScript type for `<length-percentage>` with `auto`.
 *
 * @public
 */
export type LengthPercentageAuto = z.infer<typeof lengthPercentageAutoSchema>;


=== File: src/core/types/outline.ts ===
// b_path:: src/core/types/outline.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthSchema } from "./length-percentage";

/**
 * CSS outline-width property IR.
 *
 * Specifies the width of the outline.
 * Single length value or keyword (thin, medium, thick).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-width}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-width}
 *
 * @public
 */
export const outlineWidthValueSchema = z.object({
	kind: z.literal("outline-width"),
	width: z.union([lengthSchema, Keyword.borderWidthKeywordsSchema]),
});

/**
 * CSS outline-width property type.
 *
 * @public
 */
export type OutlineWidthValue = z.infer<typeof outlineWidthValueSchema>;

/**
 * CSS outline-style property IR.
 *
 * Specifies the style of the outline line.
 * Single style keyword including 'auto' (outline-specific).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-style}
 *
 * @public
 */
export const outlineStyleValueSchema = z.object({
	kind: z.literal("outline-style"),
	style: Keyword.outlineStyleKeywordsSchema,
});

/**
 * CSS outline-style property type.
 *
 * @public
 */
export type OutlineStyleValue = z.infer<typeof outlineStyleValueSchema>;

/**
 * CSS outline-style keyword type (extracted from schema).
 *
 * @public
 */
export type OutlineStyle = z.infer<typeof Keyword.outlineStyleKeywordsSchema>;

/**
 * CSS outline-color property IR.
 *
 * Specifies the color of the outline.
 * Single color value or keyword including 'invert' (outline-specific).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-color}
 *
 * @public
 */
export const outlineColorValueSchema = z.object({
	kind: z.literal("outline-color"),
	color: z.union([Keyword.colorValueKeywordsSchema, z.literal("invert")]),
});

/**
 * CSS outline-color property type.
 *
 * @public
 */
export type OutlineColorValue = z.infer<typeof outlineColorValueSchema>;

/**
 * CSS outline-offset property IR.
 *
 * Specifies the space between outline and element edge.
 * Single length value (can be negative).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-offset}
 *
 * @public
 */
export const outlineOffsetValueSchema = z.object({
	kind: z.literal("outline-offset"),
	offset: lengthSchema,
});

/**
 * CSS outline-offset property type.
 *
 * @public
 */
export type OutlineOffsetValue = z.infer<typeof outlineOffsetValueSchema>;


=== File: src/core/types/position-layer.ts ===
// b_path:: src/core/types/position-layer.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import * as Type from "../types";

/**
 * CSS position value for background positioning.
 *
 * Can be a keyword, length, or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 * @public
 */
export const backgroundPositionValueSchema = z.union([Keyword.positionKeywordsSchema, Type.lengthPercentageSchema]);

/**
 * TypeScript type for background position value.
 * @public
 */
export type BackgroundPositionValue = z.infer<typeof backgroundPositionValueSchema>;

/**
 * CSS background-position layer value.
 *
 * Represents a single layer value for the background-position property.
 * Supports 1-value, 2-value, and 4-value syntax.
 *
 * Per CSS spec, background-position accepts:
 * - Single keyword: `center` | `left` | `right` | `top` | `bottom`
 * - One value: `<length-percentage>` | keyword
 * - Two values: `<length-percentage> <length-percentage>` | keyword combinations
 * - Four values: `<edge> <length-percentage> <edge> <length-percentage>` (edge offsets)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionLayerSchema } from "@/core/types/position-layer";
 *
 * // Center keyword
 * const layer1: PositionLayer = { kind: "center" };
 *
 * // One value
 * const layer2: PositionLayer = {
 *   kind: "one-value",
 *   value: { value: 50, unit: "%" }
 * };
 *
 * // Two values
 * const layer3: PositionLayer = {
 *   kind: "two-value",
 *   horizontal: "left",
 *   vertical: { value: 20, unit: "px" }
 * };
 *
 * // Four values (edge offsets)
 * const layer4: PositionLayer = {
 *   kind: "four-value",
 *   horizontalEdge: "right",
 *   horizontalOffset: { value: 10, unit: "px" },
 *   verticalEdge: "bottom",
 *   verticalOffset: { value: 20, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const positionLayerSchema = z.discriminatedUnion("kind", [
	// Center keyword (special case)
	z.object({
		kind: z.literal("center"),
	}),

	// One value: applies to horizontal, vertical is centered (50%)
	z.object({
		kind: z.literal("one-value"),
		value: backgroundPositionValueSchema,
	}),

	// Two values: horizontal vertical
	z.object({
		kind: z.literal("two-value"),
		horizontal: backgroundPositionValueSchema,
		vertical: backgroundPositionValueSchema,
	}),

	// Four values: edge offset pairs
	// Format: <horizontal-edge> <h-offset> <vertical-edge> <v-offset>
	// Example: right 10px bottom 20px
	z.object({
		kind: z.literal("four-value"),
		horizontalEdge: z.literal("left").or(z.literal("right")),
		horizontalOffset: Type.lengthPercentageSchema,
		verticalEdge: z.literal("top").or(z.literal("bottom")),
		verticalOffset: Type.lengthPercentageSchema,
	}),
]);

/**
 * TypeScript type for position layer.
 * @public
 */
export type PositionLayer = z.infer<typeof positionLayerSchema>;

/**
 * CSS position property (reusable across properties).
 *
 * Specifies the position of elements. Used in:
 * - `background-position` - Background image positioning
 * - `object-position` - Replaced element positioning
 * - `transform-origin` - Transform origin positioning
 * - `perspective-origin` - Perspective origin positioning
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionSchema, type Position } from "@/core/types/position-layer";
 *
 * // Single layer
 * const pos1: Position = {
 *   layers: [{ kind: "center" }]
 * };
 *
 * // Multiple layers with different syntaxes
 * const pos2: Position = {
 *   layers: [
 *     { kind: "center" },
 *     { kind: "two-value", horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } },
 *     {
 *       kind: "four-value",
 *       horizontalEdge: "right",
 *       horizontalOffset: { value: 10, unit: "px" },
 *       verticalEdge: "bottom",
 *       verticalOffset: { value: 20, unit: "px" }
 *     }
 *   ]
 * };
 * ```
 *
 * @public
 */
export const positionSchema = z.object({
	layers: z.array(positionLayerSchema).min(1),
});

/**
 * TypeScript type for position property.
 * @public
 */
export type Position = z.infer<typeof positionSchema>;


=== File: src/core/types/position.ts ===
// b_path:: src/core/types/position.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthPercentageSchema, lengthSchema } from "./length-percentage";

/**
 * CSS position value (single axis).
 *
 * A position value that can be used on a single axis (horizontal or vertical).
 * Used as a building block for 2D position values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionValueSchema } from "@/core/types/position";
 *
 * // Keyword
 * const pos1: PositionValue = "center";
 *
 * // Length
 * const pos2: PositionValue = { value: 100, unit: "px" };
 *
 * // Percentage
 * const pos3: PositionValue = { value: 50, unit: "%" };
 * ```
 *
 * @public
 */
export const positionValueSchema = z.union([Keyword.positionKeywordsSchema, lengthPercentageSchema]);

/**
 * TypeScript type for position value.
 * @public
 */
export type PositionValue = z.infer<typeof positionValueSchema>;

/**
 * CSS 2D position value.
 *
 * A position value that specifies both horizontal and vertical positions.
 * Used in properties like transform-origin, perspective-origin, object-position.
 *
 * Per CSS spec: <position> = [ [ left | center | right | top | bottom | <length-percentage> ] |
 *                            [ left | center | right ] && [ top | center | bottom ] |
 *                            [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] |
 *                            [ [ center | [ left | right ] <length-percentage>? ] &&
 *                              [ center | [ top | bottom ] <length-percentage>? ] ] ]
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { position2DSchema } from "@/core/types/position";
 *
 * // Keywords
 * const pos1: Position2D = { horizontal: "center", vertical: "center" };
 * const pos2: Position2D = { horizontal: "left", vertical: "top" };
 *
 * // Mixed keywords and values
 * const pos3: Position2D = {
 *   horizontal: { value: 25, unit: "%" },
 *   vertical: "center"
 * };
 *
 * // Both values
 * const pos4: Position2D = {
 *   horizontal: { value: 100, unit: "px" },
 *   vertical: { value: 50, unit: "%" }
 * };
 * ```
 *
 * @public
 */
export const position2DSchema = z.object({
	horizontal: positionValueSchema.describe("horizontal position"),
	vertical: positionValueSchema.describe("vertical position"),
});

/**
 * TypeScript type for 2D position.
 * @public
 */
export type Position2D = z.infer<typeof position2DSchema>;

/**
 * CSS 3D position value.
 *
 * A position value that specifies position in 3D space with x, y, and z coordinates.
 * Used in properties like transform-origin in 3D contexts.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin}
 *
 * @example
 * ```typescript
 * import { position3DSchema } from "@/core/types/position";
 *
 * const pos: Position3D = {
 *   x: { value: 100, unit: "px" },
 *   y: { value: 50, unit: "%" },
 *   z: { value: 10, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const position3DSchema = z.object({
	x: positionValueSchema.describe("x-axis position"),
	y: positionValueSchema.describe("y-axis position"),
	z: lengthSchema.describe("z-axis position (depth)"),
});

/**
 * TypeScript type for 3D position.
 * @public
 */
export type Position3D = z.infer<typeof position3DSchema>;

/**
 * CSS position list.
 *
 * An array of position values used in properties that accept multiple positions.
 * Common in animation keyframes and multi-position properties.
 *
 * @example
 * ```typescript
 * import { positionListSchema } from "@/core/types/position";
 *
 * const positions: PositionList = [
 *   { horizontal: "left", vertical: "top" },
 *   { horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } },
 *   { horizontal: "right", vertical: "bottom" }
 * ];
 * ```
 *
 * @public
 */
export const positionListSchema = z
	.array(position2DSchema)
	.min(1, "Position list must contain at least 1 position")
	.describe("array of 2D positions for multi-position CSS properties");

/**
 * TypeScript type for position list.
 * @public
 */
export type PositionList = z.infer<typeof positionListSchema>;

/**
 * Common position presets.
 *
 * Predefined positions for common use cases in CSS layout and positioning.
 *
 * @example
 * ```typescript
 * import { COMMON_POSITIONS } from "@/core/types/position";
 *
 * const centerPos = COMMON_POSITIONS.center; // { horizontal: "center", vertical: "center" }
 * const topLeftPos = COMMON_POSITIONS.topLeft; // { horizontal: "left", vertical: "top" }
 * ```
 *
 * @public
 */
export const COMMON_POSITIONS = {
	center: { horizontal: "center" as const, vertical: "center" as const },
	topLeft: { horizontal: "left" as const, vertical: "top" as const },
	topCenter: { horizontal: "center" as const, vertical: "top" as const },
	topRight: { horizontal: "right" as const, vertical: "top" as const },
	middleLeft: { horizontal: "left" as const, vertical: "center" as const },
	middleRight: { horizontal: "right" as const, vertical: "center" as const },
	bottomLeft: { horizontal: "left" as const, vertical: "bottom" as const },
	bottomCenter: { horizontal: "center" as const, vertical: "bottom" as const },
	bottomRight: { horizontal: "right" as const, vertical: "bottom" as const },
} as const;

/**
 * Type for common position presets.
 * @public
 */
export type CommonPositions = typeof COMMON_POSITIONS;


=== File: src/core/types/ratio.ts ===
// b_path:: src/core/types/ratio.ts
import { z } from "zod";

/**
 * CSS ratio value.
 *
 * A ratio consists of two numbers separated by a slash (/).
 * Used in properties like aspect-ratio, resolution, and other ratio-based values.
 *
 * Per CSS spec: <ratio> = <number> [ / <number> ]?
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/ratio}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio}
 *
 * @example
 * ```typescript
 * import { ratioSchema } from "@/core/types/ratio";
 *
 * // Simple ratio
 * const ratio1: Ratio = { numerator: 16, denominator: 9 };
 *
 * // Single number (denominator defaults to 1)
 * const ratio2: Ratio = { numerator: 4, denominator: 3 };
 *
 * // Auto keyword
 * const ratio3: Ratio = "auto";
 * ```
 *
 * @public
 */
export const ratioSchema = z.union([
	// Explicit ratio with numerator and denominator
	z.object({
		numerator: z.number().positive().describe("numerator of the ratio"),
		denominator: z.number().positive().describe("denominator of the ratio"),
	}),

	// Auto keyword for automatic ratio
	z
		.literal("auto")
		.describe("automatic ratio based on content"),
]);

/**
 * TypeScript type for ratio.
 * @public
 */
export type Ratio = z.infer<typeof ratioSchema>;

/**
 * CSS ratio list.
 *
 * An array of ratios used in properties that accept multiple ratios.
 * Common in resolution and aspect-ratio contexts.
 *
 * @example
 * ```typescript
 * import { ratioListSchema } from "@/core/types/ratio";
 *
 * const ratios: RatioList = [
 *   { numerator: 16, denominator: 9 },
 *   { numerator: 4, denominator: 3 },
 *   "auto"
 * ];
 * ```
 *
 * @public
 */
export const ratioListSchema = z
	.array(ratioSchema)
	.min(1, "Ratio list must contain at least 1 ratio")
	.describe("array of ratios for multi-ratio CSS properties");

/**
 * TypeScript type for ratio list.
 * @public
 */
export type RatioList = z.infer<typeof ratioListSchema>;

/**
 * Common aspect ratio presets.
 *
 * Predefined ratios for common use cases like video, images, and design.
 *
 * @example
 * ```typescript
 * import { COMMON_ASPECT_RATIOS } from "@/core/types/ratio";
 *
 * const videoRatio = COMMON_ASPECT_RATIOS["16:9"]; // { numerator: 16, denominator: 9 }
 * const squareRatio = COMMON_ASPECT_RATIOS["1:1"]; // { numerator: 1, denominator: 1 }
 * ```
 *
 * @public
 */
export const COMMON_ASPECT_RATIOS = {
	"21:9": { numerator: 21, denominator: 9 },
	"16:9": { numerator: 16, denominator: 9 },
	"3:2": { numerator: 3, denominator: 2 },
	"4:3": { numerator: 4, denominator: 3 },
	"1:1": { numerator: 1, denominator: 1 },
	"3:4": { numerator: 3, denominator: 4 },
	"2:3": { numerator: 2, denominator: 3 },
	"9:16": { numerator: 9, denominator: 16 },
	"9:21": { numerator: 9, denominator: 21 },
} as const;

/**
 * Type for common aspect ratio presets.
 * @public
 */
export type CommonAspectRatio = typeof COMMON_ASPECT_RATIOS;

/**
 * Helper function to create a ratio from a string.
 *
 * @param ratioString - String in format "numerator:denominator" or "numerator/denominator"
 * @returns Ratio object or null if invalid format
 *
 * @example
 * ```typescript
 * import { createRatioFromString } from "@/core/types/ratio";
 *
 * const ratio1 = createRatioFromString("16:9"); // { numerator: 16, denominator: 9 }
 * const ratio2 = createRatioFromString("4/3"); // { numerator: 4, denominator: 3 }
 * ```
 *
 * @public
 */
export function createRatioFromString(ratioString: string): Ratio | null {
	const colonMatch = ratioString.match(/^(\d+):(\d+)$/);
	const slashMatch = ratioString.match(/^(\d+)\/(\d+)$/);

	if (colonMatch?.[1] && colonMatch?.[2]) {
		const numerator = Number.parseInt(colonMatch[1], 10);
		const denominator = Number.parseInt(colonMatch[2], 10);
		if (numerator > 0 && denominator > 0) {
			return { numerator, denominator };
		}
	}

	if (slashMatch?.[1] && slashMatch?.[2]) {
		const numerator = Number.parseInt(slashMatch[1], 10);
		const denominator = Number.parseInt(slashMatch[2], 10);
		if (numerator > 0 && denominator > 0) {
			return { numerator, denominator };
		}
	}

	return null;
}

/**
 * Helper function to format a ratio as a string.
 *
 * @param ratio - Ratio object
 * @returns Formatted string representation
 *
 * @example
 * ```typescript
 * import { formatRatioAsString } from "@/core/types/ratio";
 *
 * const ratioString = formatRatioAsString({ numerator: 16, denominator: 9 }); // "16:9"
 * ```
 *
 * @public
 */
export function formatRatioAsString(ratio: Ratio): string {
	if (ratio === "auto") {
		return "auto";
	}

	return `${ratio.numerator}:${ratio.denominator}`;
}


=== File: src/core/types/shadow.ts ===
// b_path:: src/core/types/shadow.ts
import { z } from "zod";
import type { Color } from "./color";
import type { Length } from "./length-percentage";

/**
 * CSS box-shadow property value.
 *
 * Adds shadow effects around an element's frame.
 * Syntax: [inset?] offset-x offset-y [blur-radius] [spread-radius] [color]
 *
 * Multiple shadows can be stacked by comma separation.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow}
 *
 * @example
 * ```typescript
 * import type { BoxShadow } from "@/core/types/shadow";
 *
 * const shadow: BoxShadow = {
 *   kind: "box-shadow",
 *   shadows: [{
 *     offsetX: { value: 2, unit: "px" },
 *     offsetY: { value: 2, unit: "px" },
 *     blurRadius: { value: 4, unit: "px" },
 *     color: { kind: "named", name: "black" }
 *   }]
 * };
 * // CSS: 2px 2px 4px black
 * ```
 *
 * @public
 */
export const boxShadowSchema = z.object({
	kind: z.literal("box-shadow"),
	shadows: z.array(
		z.object({
			inset: z.boolean().optional(),
			offsetX: z.custom<Length>(),
			offsetY: z.custom<Length>(),
			blurRadius: z.custom<Length>().optional(),
			spreadRadius: z.custom<Length>().optional(),
			color: z.custom<Color>().optional(),
		}),
	),
});

/**
 * TypeScript type for box-shadow property.
 * @public
 */
export type BoxShadow = z.infer<typeof boxShadowSchema>;

/**
 * Single shadow layer in box-shadow.
 * @public
 */
export type BoxShadowLayer = BoxShadow["shadows"][number];

/**
 * CSS text-shadow property value.
 *
 * Adds shadow to text content.
 * Syntax: offset-x offset-y [blur-radius] [color]
 *
 * Multiple shadows can be stacked by comma separation.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow}
 *
 * @example
 * ```typescript
 * import type { TextShadow } from "@/core/types/shadow";
 *
 * const shadow: TextShadow = {
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" },
 *     blurRadius: { value: 2, unit: "px" },
 *     color: { kind: "named", name: "gray" }
 *   }]
 * };
 * // CSS: 1px 1px 2px gray
 * ```
 *
 * @public
 */
export const textShadowSchema = z.object({
	kind: z.literal("text-shadow"),
	shadows: z.array(
		z.object({
			offsetX: z.custom<Length>(),
			offsetY: z.custom<Length>(),
			blurRadius: z.custom<Length>().optional(),
			color: z.custom<Color>().optional(),
		}),
	),
});

/**
 * TypeScript type for text-shadow property.
 * @public
 */
export type TextShadow = z.infer<typeof textShadowSchema>;

/**
 * Single shadow layer in text-shadow.
 * @public
 */
export type TextShadowLayer = TextShadow["shadows"][number];


=== File: src/core/types/size-layer.ts ===
// b_path:: src/core/types/size-layer.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import * as Type from "../types";

/**
 * CSS size layer value.
 *
 * Represents a single layer value for sizing properties.
 * Can be a sizing keyword, auto, or explicit dimensions.
 *
 * Per CSS spec, size values accept:
 * - Keywords: `cover` | `contain`
 * - Single value: `<length-percentage>` | `auto`
 * - Two values: `<length-percentage>` | `auto` for width and height
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 *
 * @example
 * ```typescript
 * import { sizeLayerSchema } from "@/core/types/size-layer";
 *
 * // Keyword
 * const layer1: SizeLayer = { kind: "keyword", value: "cover" };
 *
 * // Auto
 * const layer2: SizeLayer = { kind: "auto" };
 *
 * // Single value
 * const layer3: SizeLayer = {
 *   kind: "one-value",
 *   value: { value: 50, unit: "%" }
 * };
 *
 * // Two values
 * const layer4: SizeLayer = {
 *   kind: "two-value",
 *   width: { value: 100, unit: "px" },
 *   height: "auto"
 * };
 * ```
 *
 * @public
 */
export const sizeLayerSchema = z.discriminatedUnion("kind", [
	// Sizing keywords: cover, contain
	z.object({
		kind: z.literal("keyword"),
		value: Keyword.sizingKeywordsSchema,
	}),

	// Auto keyword
	z.object({
		kind: z.literal("auto"),
	}),

	// Single value: <length-percentage> or auto
	// Applies to both width and height (maintaining aspect ratio)
	z.object({
		kind: z.literal("one-value"),
		value: Type.lengthPercentageAutoSchema,
	}),

	// Two values: width height
	// Each can be <length-percentage> or auto
	z.object({
		kind: z.literal("two-value"),
		width: Type.lengthPercentageAutoSchema,
		height: Type.lengthPercentageAutoSchema,
	}),
]);

/**
 * TypeScript type for size layer.
 * @public
 */
export type SizeLayer = z.infer<typeof sizeLayerSchema>;

/**
 * CSS size property (reusable across properties).
 *
 * Specifies the size of elements. Used in:
 * - `background-size` - Background image sizing
 * - `object-fit` - Replaced element sizing
 * - `column-size` - Multi-column sizing
 * - `box-size` - Box sizing (future)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 *
 * @example
 * ```typescript
 * import { sizeSchema, type Size } from "@/core/types/size-layer";
 *
 * // Single keyword
 * const size1: Size = {
 *   layers: [{ kind: "keyword", value: "cover" }]
 * };
 *
 * // Multiple layers
 * const size2: Size = {
 *   layers: [
 *     { kind: "keyword", value: "cover" },
 *     { kind: "two-value", width: { value: 100, unit: "px" }, height: "auto" },
 *     { kind: "keyword", value: "contain" }
 *   ]
 * };
 *
 * // Single value
 * const size3: Size = {
 *   layers: [{ kind: "one-value", value: { value: 50, unit: "%" } }]
 * };
 * ```
 *
 * @public
 */
export const sizeSchema = z.object({
	layers: z.array(sizeLayerSchema).min(1),
});

/**
 * TypeScript type for size property.
 * @public
 */
export type Size = z.infer<typeof sizeSchema>;


=== File: src/core/types/time.ts ===
// b_path:: src/core/types/time.ts
import { z } from "zod";
import * as Unit from "../units";

/**
 * CSS `<time>` dimension.
 *
 * A time value consists of a number and a time unit (s or ms).
 * Used in animations, transitions, and other time-based CSS properties.
 *
 * Per CSS Values & Units Module Level 4 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/time}
 * @see {@link https://www.w3.org/TR/css-values-4/#time}
 *
 * @example
 * ```typescript
 * import { timeSchema } from "@/core/types/time";
 *
 * const delay: Time = { value: 1, unit: "s" };
 * const duration: Time = { value: 500, unit: "ms" };
 * ```
 *
 * @public
 */
export const timeSchema = z.object({
	value: z.number(),
	unit: Unit.timeUnitSchema,
});

/**
 * CSS `<time>` type.
 *
 * @public
 */
export type Time = z.infer<typeof timeSchema>;


=== File: src/core/types/transform.ts ===
// b_path:: src/core/types/transform.ts
import { z } from "zod";
import { angleSchema } from "./angle";
import { lengthPercentageSchema, lengthSchema } from "./length-percentage";

/**
 * CSS transform function types.
 *
 * Transform functions modify the coordinate space of an element's content.
 * Used in the transform property to apply geometric transformations.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform}
 *
 * @example
 * ```typescript
 * import { transformFunctionSchema } from "@/core/types/transform";
 *
 * // Translate
 * const translate: TransformFunction = {
 *   kind: "translate",
 *   x: { value: 100, unit: "px" },
 *   y: { value: 50, unit: "px" }
 * };
 *
 * // Rotate
 * const rotate: TransformFunction = {
 *   kind: "rotate",
 *   angle: { value: 45, unit: "deg" }
 * };
 *
 * // Scale
 * const scale: TransformFunction = {
 *   kind: "scale",
 *   x: 1.5,
 *   y: 2
 * };
 * ```
 *
 * @public
 */

// Note: numberOrPercentageSchema defined for future use in transform values
// const numberOrPercentageSchema = z.union([
//   z.number().describe("numeric value"),
//   percentageSchema.describe("percentage value")
// ]);

/**
 * Translate transform function.
 *
 * Moves an element along the x and/or y-axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate}
 */
export const translateFunctionSchema = z.object({
	kind: z.literal("translate").describe("translate function"),
	x: lengthPercentageSchema.describe("x-axis translation"),
	y: lengthPercentageSchema.optional().describe("y-axis translation"),
});

export type TranslateFunction = z.infer<typeof translateFunctionSchema>;

/**
 * TranslateX transform function.
 *
 * Moves an element along the x-axis only.
 */
export const translateXFunctionSchema = z.object({
	kind: z.literal("translateX").describe("translateX function"),
	x: lengthPercentageSchema.describe("x-axis translation"),
});

export type TranslateXFunction = z.infer<typeof translateXFunctionSchema>;

/**
 * TranslateY transform function.
 *
 * Moves an element along the y-axis only.
 */
export const translateYFunctionSchema = z.object({
	kind: z.literal("translateY").describe("translateY function"),
	y: lengthPercentageSchema.describe("y-axis translation"),
});

export type TranslateYFunction = z.infer<typeof translateYFunctionSchema>;

/**
 * TranslateZ transform function.
 *
 * Moves an element along the z-axis in 3D space.
 */
export const translateZFunctionSchema = z.object({
	kind: z.literal("translateZ").describe("translateZ function"),
	z: lengthSchema.describe("z-axis translation"),
});

export type TranslateZFunction = z.infer<typeof translateZFunctionSchema>;

/**
 * Translate3d transform function.
 *
 * Moves an element in 3D space along x, y, and z axes.
 */
export const translate3dFunctionSchema = z.object({
	kind: z.literal("translate3d").describe("translate3d function"),
	x: lengthPercentageSchema.describe("x-axis translation"),
	y: lengthPercentageSchema.describe("y-axis translation"),
	z: lengthSchema.describe("z-axis translation"),
});

export type Translate3dFunction = z.infer<typeof translate3dFunctionSchema>;

/**
 * Rotate transform function.
 *
 * Rotates an element around a fixed point.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate}
 */
export const rotateFunctionSchema = z.object({
	kind: z.literal("rotate").describe("rotate function"),
	angle: angleSchema.describe("rotation angle"),
});

export type RotateFunction = z.infer<typeof rotateFunctionSchema>;

/**
 * RotateX transform function.
 *
 * Rotates an element around the x-axis in 3D space.
 */
export const rotateXFunctionSchema = z.object({
	kind: z.literal("rotateX").describe("rotateX function"),
	angle: angleSchema.describe("rotation angle around x-axis"),
});

export type RotateXFunction = z.infer<typeof rotateXFunctionSchema>;

/**
 * RotateY transform function.
 *
 * Rotates an element around the y-axis in 3D space.
 */
export const rotateYFunctionSchema = z.object({
	kind: z.literal("rotateY").describe("rotateY function"),
	angle: angleSchema.describe("rotation angle around y-axis"),
});

export type RotateYFunction = z.infer<typeof rotateYFunctionSchema>;

/**
 * RotateZ transform function.
 *
 * Rotates an element around the z-axis in 3D space.
 */
export const rotateZFunctionSchema = z.object({
	kind: z.literal("rotateZ").describe("rotateZ function"),
	angle: angleSchema.describe("rotation angle around z-axis"),
});

export type RotateZFunction = z.infer<typeof rotateZFunctionSchema>;

/**
 * Rotate3d transform function.
 *
 * Rotates an element in 3D space around a custom axis.
 */
export const rotate3dFunctionSchema = z.object({
	kind: z.literal("rotate3d").describe("rotate3d function"),
	x: z.number().describe("x component of rotation axis vector"),
	y: z.number().describe("y component of rotation axis vector"),
	z: z.number().describe("z component of rotation axis vector"),
	angle: angleSchema.describe("rotation angle"),
});

export type Rotate3dFunction = z.infer<typeof rotate3dFunctionSchema>;

/**
 * Scale transform function.
 *
 * Scales an element up or down in size.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale}
 */
export const scaleFunctionSchema = z.object({
	kind: z.literal("scale").describe("scale function"),
	x: z.number().min(0).describe("x-axis scale factor"),
	y: z.number().min(0).optional().describe("y-axis scale factor"),
});

export type ScaleFunction = z.infer<typeof scaleFunctionSchema>;

/**
 * ScaleX transform function.
 *
 * Scales an element along the x-axis only.
 */
export const scaleXFunctionSchema = z.object({
	kind: z.literal("scaleX").describe("scaleX function"),
	x: z.number().min(0).describe("x-axis scale factor"),
});

export type ScaleXFunction = z.infer<typeof scaleXFunctionSchema>;

/**
 * ScaleY transform function.
 *
 * Scales an element along the y-axis only.
 */
export const scaleYFunctionSchema = z.object({
	kind: z.literal("scaleY").describe("scaleY function"),
	y: z.number().min(0).describe("y-axis scale factor"),
});

export type ScaleYFunction = z.infer<typeof scaleYFunctionSchema>;

/**
 * ScaleZ transform function.
 *
 * Scales an element along the z-axis in 3D space.
 */
export const scaleZFunctionSchema = z.object({
	kind: z.literal("scaleZ").describe("scaleZ function"),
	z: z.number().min(0).describe("z-axis scale factor"),
});

export type ScaleZFunction = z.infer<typeof scaleZFunctionSchema>;

/**
 * Scale3d transform function.
 *
 * Scales an element in 3D space along x, y, and z axes.
 */
export const scale3dFunctionSchema = z.object({
	kind: z.literal("scale3d").describe("scale3d function"),
	x: z.number().min(0).describe("x-axis scale factor"),
	y: z.number().min(0).describe("y-axis scale factor"),
	z: z.number().min(0).describe("z-axis scale factor"),
});

export type Scale3dFunction = z.infer<typeof scale3dFunctionSchema>;

/**
 * Skew transform function.
 *
 * Skews an element along the x and/or y-axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew}
 */
export const skewFunctionSchema = z.object({
	kind: z.literal("skew").describe("skew function"),
	x: angleSchema.describe("x-axis skew angle"),
	y: angleSchema.optional().describe("y-axis skew angle"),
});

export type SkewFunction = z.infer<typeof skewFunctionSchema>;

/**
 * SkewX transform function.
 *
 * Skews an element along the x-axis only.
 */
export const skewXFunctionSchema = z.object({
	kind: z.literal("skewX").describe("skewX function"),
	x: angleSchema.describe("x-axis skew angle"),
});

export type SkewXFunction = z.infer<typeof skewXFunctionSchema>;

/**
 * SkewY transform function.
 *
 * Skews an element along the y-axis only.
 */
export const skewYFunctionSchema = z.object({
	kind: z.literal("skewY").describe("skewY function"),
	y: angleSchema.describe("y-axis skew angle"),
});

export type SkewYFunction = z.infer<typeof skewYFunctionSchema>;

/**
 * Matrix transform function.
 *
 * Applies a 2D transformation matrix to an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix}
 */
export const matrixFunctionSchema = z.object({
	kind: z.literal("matrix").describe("matrix function"),
	a: z.number().describe("matrix value a"),
	b: z.number().describe("matrix value b"),
	c: z.number().describe("matrix value c"),
	d: z.number().describe("matrix value d"),
	e: lengthSchema.describe("matrix value e"),
	f: lengthSchema.describe("matrix value f"),
});

export type MatrixFunction = z.infer<typeof matrixFunctionSchema>;

/**
 * Matrix3d transform function.
 *
 * Applies a 3D transformation matrix to an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d}
 */
export const matrix3dFunctionSchema = z.object({
	kind: z.literal("matrix3d").describe("matrix3d function"),
	values: z.array(z.number()).length(16).describe("16 matrix values in column-major order"),
});

export type Matrix3dFunction = z.infer<typeof matrix3dFunctionSchema>;

/**
 * Perspective transform function.
 *
 * Gives an element a 3D appearance by defining a perspective point.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/perspective}
 */
export const perspectiveFunctionSchema = z.object({
	kind: z.literal("perspective").describe("perspective function"),
	depth: lengthSchema.describe("perspective depth"),
});

export type PerspectiveFunction = z.infer<typeof perspectiveFunctionSchema>;

/**
 * Union of all transform function types.
 */
export const transformFunctionSchema = z.discriminatedUnion("kind", [
	translateFunctionSchema,
	translateXFunctionSchema,
	translateYFunctionSchema,
	translateZFunctionSchema,
	translate3dFunctionSchema,
	rotateFunctionSchema,
	rotateXFunctionSchema,
	rotateYFunctionSchema,
	rotateZFunctionSchema,
	rotate3dFunctionSchema,
	scaleFunctionSchema,
	scaleXFunctionSchema,
	scaleYFunctionSchema,
	scaleZFunctionSchema,
	scale3dFunctionSchema,
	skewFunctionSchema,
	skewXFunctionSchema,
	skewYFunctionSchema,
	matrixFunctionSchema,
	matrix3dFunctionSchema,
	perspectiveFunctionSchema,
]);

/**
 * TypeScript type for all transform functions.
 * @public
 */
export type TransformFunction = z.infer<typeof transformFunctionSchema>;

/**
 * CSS transform value (list of transform functions).
 *
 * A space-separated list of transform functions that can be applied to an element.
 * Used in the transform CSS property.
 *
 * @example
 * ```typescript
 * import { transformSchema } from "@/core/types/transform";
 *
 * const transform: Transform = [
 *   { kind: "translateX", x: { value: 100, unit: "px" } },
 *   { kind: "rotate", angle: { value: 45, unit: "deg" } },
 *   { kind: "scale", x: 1.5, y: 1.5 }
 * ];
 * ```
 *
 * @public
 */
export const transformSchema = z
	.array(transformFunctionSchema)
	.min(1, "Transform must contain at least one function")
	.describe("array of transform functions for CSS transform property");

export type Transform = z.infer<typeof transformSchema>;


=== File: src/core/types/transition.ts ===
// b_path:: src/core/types/transition.ts
import { z } from "zod";
import { easingFunctionSchema } from "./animation";
import { timeSchema } from "./time";

/**
 * CSS transition-delay property IR.
 *
 * Specifies when a transition should start.
 * Comma-separated list of time values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-delay-property}
 *
 * @public
 */
export const transitionDelaySchema = z.object({
	kind: z.literal("transition-delay"),
	delays: z.array(timeSchema).min(1),
});

/**
 * CSS transition-delay type.
 *
 * @public
 */
export type TransitionDelay = z.infer<typeof transitionDelaySchema>;

/**
 * CSS transition-duration property IR.
 *
 * Specifies how long a transition should take to complete.
 * Comma-separated list of time values (non-negative only).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-duration-property}
 *
 * @public
 */
export const transitionDurationSchema = z.object({
	kind: z.literal("transition-duration"),
	durations: z.array(timeSchema).min(1),
});

/**
 * CSS transition-duration type.
 *
 * @public
 */
export type TransitionDuration = z.infer<typeof transitionDurationSchema>;

/**
 * CSS transition-timing-function property IR.
 *
 * Specifies the timing function for transitions.
 * Comma-separated list of easing functions.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property}
 *
 * @public
 */
export const transitionTimingFunctionSchema = z.object({
	kind: z.literal("transition-timing-function"),
	functions: z.array(easingFunctionSchema).min(1),
});

/**
 * CSS transition-timing-function type.
 *
 * @public
 */
export type TransitionTimingFunction = z.infer<typeof transitionTimingFunctionSchema>;

/**
 * CSS transition-property property IR.
 *
 * Specifies which CSS properties should be transitioned.
 * Comma-separated list of property names, 'none', or 'all'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-property-property}
 *
 * @public
 */
export const transitionPropertySchema = z.object({
	kind: z.literal("transition-property"),
	properties: z
		.array(
			z.union([
				z.object({ type: z.literal("none") }),
				z.object({ type: z.literal("all") }),
				z.object({ type: z.literal("identifier"), value: z.string() }),
			]),
		)
		.min(1),
});

/**
 * CSS transition-property type.
 *
 * @public
 */
export type TransitionProperty = z.infer<typeof transitionPropertySchema>;


=== File: src/core/types/url.ts ===
// b_path:: src/core/types/url.ts

import { z } from "zod";

/**
 * CSS url() function value.
 *
 * Represents a URL reference to an external resource or SVG element.
 * Can be an absolute URL, relative URL, data URL, or hash reference.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/url_function}
 *
 * @example
 * ```typescript
 * import type { Url } from "@/core/types/url";
 *
 * // Fragment identifier (SVG reference)
 * const url1: Url = { kind: "url", value: "#clip-shape" };
 *
 * // File path
 * const url2: Url = { kind: "url", value: "shapes.svg#clip" };
 *
 * // Absolute URL
 * const url3: Url = { kind: "url", value: "https://example.com/image.png" };
 *
 * // Data URL
 * const url4: Url = { kind: "url", value: "data:image/svg+xml,..." };
 * ```
 *
 * @public
 */
export const urlSchema = z.object({
	kind: z.literal("url"),
	value: z.string(),
});

/**
 * TypeScript type for CSS url() function.
 * @public
 */
export type Url = z.infer<typeof urlSchema>;


=== File: src/core/units/angle.ts ===
// b_path:: src/core/units/angle.ts
import { z } from "zod";

export const angleUnitSchema = z
	.union([
		z.literal("deg").describe("degrees - one full circle is 360deg"),
		z.literal("grad").describe("gradians - one full circle is 400grad"),
		z.literal("rad").describe("radians - one full circle is 2π radians (≈6.2832rad)"),
		z.literal("turn").describe("turns - one full circle is 1turn"),
	])
	.describe(
		"Angle units specify rotation or direction." +
			"Used in transforms, gradients, and other CSS properties requiring angular measurements.",
	);

export const ANGLE_UNITS = angleUnitSchema.options.map((option) => option.value);

export type AngleUnit = z.infer<typeof angleUnitSchema>;

export const angleUnitOptions = angleUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type AngleUnitOptions = typeof angleUnitOptions;


=== File: src/core/units/frequency.ts ===
// b_path:: src/core/units/frequency.ts
import { z } from "zod";

export const frequencyUnitSchema = z
	.union([
		z.literal("Hz").describe("hertz - number of occurrences per second (canonical unit)"),
		z.literal("kHz").describe("kilohertz - 1000 hertz"),
	])
	.describe(
		"Frequency units specify the number of occurrences per second." +
			"Used for sound pitches and other frequency-based CSS properties.",
	);

export const FREQUENCY_UNITS = frequencyUnitSchema.options.map((option) => option.value);

export type FrequencyUnit = z.infer<typeof frequencyUnitSchema>;

export const frequencyUnitOptions = frequencyUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type FrequencyUnitOptions = typeof frequencyUnitOptions;


=== File: src/core/units/index.ts ===
// b_path:: src/core/units/index.ts

export * from "./angle";
export * from "./frequency";
export * from "./length.absolute";
export * from "./length.font";
export * from "./length.viewport";
export * from "./percentage";
export * from "./time";


=== File: src/core/units/length.absolute.ts ===
// b_path:: src/core/units/length.absolute.ts
import { z } from "zod";

/**
 * CSS absolute length unit identifiers.
 *
 * Absolute length units specify a length using physical units.
 * These units are fixed and do not scale relative to other elements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#absolute_length_units}
 *
 * @example
 * ```typescript
 * import { absoluteLengthUnitSchema } from "@/core/units/length.absolute";
 *
 * const unit = absoluteLengthUnitSchema.parse("px"); // "px"
 * ```
 *
 * @public
 */
export const absoluteLengthUnitSchema = z
	.union([
		z.literal("px").describe("pixels - 1/96th of 1 inch"),
		z.literal("pt").describe("points - 1/72nd of 1 inch"),
		z.literal("cm").describe("centimeters"),
		z.literal("mm").describe("millimeters"),
		z.literal("Q").describe("quarter-millimeters - 1/40th of 1 centimeter"),
		z.literal("in").describe("inches - 2.54 centimeters"),
		z.literal("pc").describe("picas - 12 points"),
	])
	.describe(
		"Absolute length units specify a length using physical units. " +
			"These units are fixed and do not scale relative to other elements.",
	);

/**
 * Array of all absolute length unit values.
 *
 * @example
 * ```typescript
 * import { ABSOLUTE_LENGTH_UNITS } from "@/core/units/length.absolute";
 *
 * console.log(ABSOLUTE_LENGTH_UNITS); // ["px", "pt", "cm", "mm", "Q", "in", "pc"]
 * ```
 *
 * @public
 */
export const ABSOLUTE_LENGTH_UNITS = absoluteLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for absolute length units.
 *
 * @public
 */
export type AbsoluteLengthUnit = z.infer<typeof absoluteLengthUnitSchema>;

/**
 * Metadata for absolute length unit options.
 *
 * Provides value and description for each absolute length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { absoluteLengthUnitOptions } from "@/core/units/length.absolute";
 *
 * absoluteLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const absoluteLengthUnitOptions = absoluteLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for absolute length unit options metadata.
 *
 * @public
 */
export type AbsoluteLengthUnitOptions = typeof absoluteLengthUnitOptions;


=== File: src/core/units/length.font.ts ===
// b_path:: src/core/units/length.font.ts
import { z } from "zod";

/**
 * CSS font-relative length unit identifiers.
 *
 * Font-relative length units specify a length relative to font metrics.
 * These units allow measurements based on typography and text characteristics.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#font-relative_lengths}
 *
 * @example
 * ```typescript
 * import { fontLengthUnitSchema } from "@/core/units/length.font";
 *
 * const unit = fontLengthUnitSchema.parse("em"); // "em"
 * ```
 *
 * @public
 */
export const fontLengthUnitSchema = z
	.union([
		z.literal("em").describe("font size of the element"),
		z.literal("ex").describe("x-height of the element's font"),
		z.literal("cap").describe("cap height of capital letters"),
		z.literal("ch").describe("typical character advance of a narrow glyph"),
		z.literal("ic").describe("typical character advance of a fullwidth glyph"),
		z.literal("rem").describe("font size of the root element"),
		z.literal("rex").describe("x-height of the root element's font"),
		z.literal("rcap").describe("cap height of the root element's font"),
		z.literal("rch").describe("typical character advance of a narrow glyph in root element"),
		z.literal("ric").describe("typical character advance of a fullwidth glyph in root element"),
		z.literal("lh").describe("line height of the element"),
		z.literal("rlh").describe("line height of the root element"),
	])
	.describe(
		"Font-relative length units specify a length relative to font metrics. " +
			"These units allow measurements based on typography and text characteristics.",
	);

/**
 * Array of all font-relative length unit values.
 *
 * @example
 * ```typescript
 * import { FONT_LENGTH_UNITS } from "@/core/units/length.font";
 *
 * console.log(FONT_LENGTH_UNITS); // ["em", "ex", "cap", ...]
 * ```
 *
 * @public
 */
export const FONT_LENGTH_UNITS = fontLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-relative length units.
 *
 * @public
 */
export type FontLengthUnit = z.infer<typeof fontLengthUnitSchema>;

/**
 * Metadata for font-relative length unit options.
 *
 * Provides value and description for each font-relative length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { fontLengthUnitOptions } from "@/core/units/length.font";
 *
 * fontLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const fontLengthUnitOptions = fontLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-relative length unit options metadata.
 *
 * @public
 */
export type FontLengthUnitOptions = typeof fontLengthUnitOptions;


=== File: src/core/units/length.viewport.ts ===
// b_path:: src/core/units/length.viewport.ts
import { z } from "zod";

/**
 * CSS viewport-percentage length unit identifiers.
 *
 * Viewport-percentage length units are relative to the size of the initial containing block.
 * They provide different sizing strategies for responsive design across various viewport states.
 *
 * Includes default (large), small, large (explicit), and dynamic viewport units.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#viewport-percentage_lengths}
 *
 * @example
 * ```typescript
 * import { viewportLengthUnitSchema } from "@/core/units/length.viewport";
 *
 * const unit = viewportLengthUnitSchema.parse("vw"); // "vw"
 * ```
 *
 * @public
 */
export const viewportLengthUnitSchema = z
	.union([
		// Default/Large viewport units
		z
			.literal("vw")
			.describe("1% of the width of the large viewport size"),
		z.literal("vh").describe("1% of the height of the large viewport size"),
		z.literal("vi").describe("1% of the large viewport size in the inline axis"),
		z.literal("vb").describe("1% of the large viewport size in the block axis"),
		z.literal("vmin").describe("smaller of vw or vh"),
		z.literal("vmax").describe("larger of vw or vh"),

		// Small viewport units
		z
			.literal("svw")
			.describe("1% of the width of the small viewport size"),
		z.literal("svh").describe("1% of the height of the small viewport size"),
		z.literal("svi").describe("1% of the small viewport size in the inline axis"),
		z.literal("svb").describe("1% of the small viewport size in the block axis"),
		z.literal("svmin").describe("smaller of svw or svh"),
		z.literal("svmax").describe("larger of svw or svh"),

		// Large viewport units (explicit)
		z
			.literal("lvw")
			.describe("1% of the width of the large viewport size"),
		z.literal("lvh").describe("1% of the height of the large viewport size"),
		z.literal("lvi").describe("1% of the large viewport size in the inline axis"),
		z.literal("lvb").describe("1% of the large viewport size in the block axis"),
		z.literal("lvmin").describe("smaller of lvw or lvh"),
		z.literal("lvmax").describe("larger of lvw or lvh"),

		// Dynamic viewport units
		z
			.literal("dvw")
			.describe("1% of the width of the dynamic viewport size"),
		z.literal("dvh").describe("1% of the height of the dynamic viewport size"),
		z.literal("dvi").describe("1% of the dynamic viewport size in the inline axis"),
		z.literal("dvb").describe("1% of the dynamic viewport size in the block axis"),
		z.literal("dvmin").describe("smaller of dvw or dvh"),
		z.literal("dvmax").describe("larger of dvw or dvh"),
	])
	.describe(
		"Viewport-percentage length units are relative to the size of the initial containing block. " +
			"They provide different sizing strategies for responsive design across various viewport states.",
	);

/**
 * Array of all viewport-percentage length unit values.
 *
 * @example
 * ```typescript
 * import { VIEWPORT_LENGTH_UNITS } from "@/core/units/length.viewport";
 *
 * console.log(VIEWPORT_LENGTH_UNITS); // ["vw", "vh", "vi", ...]
 * ```
 *
 * @public
 */
export const VIEWPORT_LENGTH_UNITS = viewportLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for viewport-percentage length units.
 *
 * @public
 */
export type ViewportLengthUnit = z.infer<typeof viewportLengthUnitSchema>;

/**
 * Metadata for viewport-percentage length unit options.
 *
 * Provides value and description for each viewport-percentage length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { viewportLengthUnitOptions } from "@/core/units/length.viewport";
 *
 * viewportLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const viewportLengthUnitOptions = viewportLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for viewport-percentage length unit options metadata.
 *
 * @public
 */
export type ViewportLengthUnitOptions = typeof viewportLengthUnitOptions;


=== File: src/core/units/percentage.ts ===
// b_path:: src/core/units/percentage.ts
import { z } from "zod";

/**
 * CSS percentage unit identifier.
 *
 * The percentage unit `%` represents a fraction of some reference value.
 * The reference value depends on the property using the percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/percentage}
 *
 * @example
 * ```typescript
 * import { percentageUnitSchema } from "@/core/units/percentage";
 *
 * const unit = percentageUnitSchema.parse("%"); // "%"
 * ```
 *
 * @public
 */
export const percentageUnitSchema = z
	.literal("%")
	.describe("percentage sign - represents a fraction of some reference value");

/**
 * CSS `<percentage>` dimension.
 *
 * A percentage consists of a number followed by the percentage sign (%).
 * May be preceded by + or - sign, with no space between symbol and number.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/percentage}
 *
 * @example
 * ```typescript
 * import { percentageSchema, type Percentage } from "@/core/units/percentage";
 *
 * const size: Percentage = { value: 50, unit: "%" };
 * const opacity: Percentage = { value: 75, unit: "%" };
 *
 * // Validate
 * percentageSchema.parse({ value: 100, unit: "%" }); // Valid
 * ```
 *
 * @public
 */
export const percentageSchema = z
	.object({
		value: z.number().describe("numeric value of the percentage"),
		unit: percentageUnitSchema,
	})
	.describe(
		"Percentage data type consists of a number followed by the percentage sign (%). " +
			"May be preceded by + or - sign, with no space between symbol and number.",
	);

/**
 * Constant for the percentage unit value.
 *
 * @example
 * ```typescript
 * import { PERCENTAGE_UNIT } from "@/core/units/percentage";
 *
 * console.log(PERCENTAGE_UNIT); // "%"
 * ```
 *
 * @public
 */
export const PERCENTAGE_UNIT = percentageUnitSchema.value;

/**
 * TypeScript type for percentage unit.
 *
 * @public
 */
export type PercentageUnit = z.infer<typeof percentageUnitSchema>;

/**
 * TypeScript type for percentage dimension.
 *
 * @public
 */
export type Percentage = z.infer<typeof percentageSchema>;

/**
 * Metadata for percentage unit option.
 *
 * Provides value and description for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { percentageUnitOptions } from "@/core/units/percentage";
 *
 * percentageUnitOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const percentageUnitOptions = [
	{
		value: percentageUnitSchema.value,
		description: percentageUnitSchema.description,
	},
];

/**
 * Type for percentage unit options metadata.
 *
 * @public
 */
export type PercentageUnitOptions = typeof percentageUnitOptions;


=== File: src/core/units/time.ts ===
// b_path:: src/core/units/time.ts
import { z } from "zod";

export const timeUnitSchema = z
	.union([
		z.literal("s").describe("seconds - canonical time unit"),
		z.literal("ms").describe("milliseconds - 1000 milliseconds in a second"),
	])
	.describe(
		"Time units specify duration or delay." + "Used in animations, transitions, and other time-based CSS properties.",
	);

export const TIME_UNITS = timeUnitSchema.options.map((option) => option.value);

export type TimeUnit = z.infer<typeof timeUnitSchema>;

export const timeUnitOptions = timeUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type TimeUnitOptions = typeof timeUnitOptions;


=== File: src/generate/animation/animation.test.ts ===
// b_path:: src/generate/animation/animation.test.ts

import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types/animation";
import { generate } from "./animation";

describe("Generate.Animation.generate", () => {
	describe("animation-duration", () => {
		it("generates animation-duration with seconds", () => {
			const ir: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [{ type: "time", value: 1, unit: "s" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("1s");
			expect(result.issues).toEqual([]);
		});

		it("generates animation-duration with milliseconds", () => {
			const ir: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [{ type: "time", value: 500, unit: "ms" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("500ms");
		});

		it("generates animation-duration with auto", () => {
			const ir: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [{ type: "auto" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("auto");
		});
	});

	describe("animation-delay", () => {
		it("generates animation-delay with positive value", () => {
			const ir: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [{ value: 500, unit: "ms" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("500ms");
			expect(result.issues).toEqual([]);
		});

		it("generates animation-delay with negative value", () => {
			const ir: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [{ value: -200, unit: "ms" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("-200ms");
		});
	});

	describe("animation-timing-function", () => {
		it("generates timing function with keyword", () => {
			const ir: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["ease-in-out"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("ease-in-out");
			expect(result.issues).toEqual([]);
		});

		it("generates timing function with cubic-bezier", () => {
			const ir: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [{ type: "cubic-bezier", x1: 0.25, y1: 0.1, x2: 0.25, y2: 1 }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("cubic-bezier(0.25, 0.1, 0.25, 1)");
		});

		it("generates timing function with steps", () => {
			const ir: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [{ type: "steps", steps: 4, position: "end" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("steps(4, end)");
		});
	});

	describe("animation-iteration-count", () => {
		it("generates iteration count with number", () => {
			const ir: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [{ type: "number", value: 3 }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("3");
			expect(result.issues).toEqual([]);
		});

		it("generates iteration count with infinite", () => {
			const ir: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [{ type: "infinite" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("infinite");
		});
	});

	describe("animation-direction", () => {
		it("generates direction normal", () => {
			const ir: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["normal"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("normal");
			expect(result.issues).toEqual([]);
		});

		it("generates direction reverse", () => {
			const ir: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["reverse"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("reverse");
		});

		it("generates direction alternate", () => {
			const ir: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["alternate"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("alternate");
		});

		it("generates direction alternate-reverse", () => {
			const ir: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["alternate-reverse"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("alternate-reverse");
		});
	});

	describe("animation-fill-mode", () => {
		it("generates fill-mode none", () => {
			const ir: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["none"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("none");
			expect(result.issues).toEqual([]);
		});

		it("generates fill-mode forwards", () => {
			const ir: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["forwards"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("forwards");
		});

		it("generates fill-mode backwards", () => {
			const ir: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["backwards"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("backwards");
		});

		it("generates fill-mode both", () => {
			const ir: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["both"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("both");
		});
	});

	describe("animation-play-state", () => {
		it("generates play-state running", () => {
			const ir: Type.AnimationPlayState = {
				kind: "animation-play-state",
				states: ["running"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("running");
			expect(result.issues).toEqual([]);
		});

		it("generates play-state paused", () => {
			const ir: Type.AnimationPlayState = {
				kind: "animation-play-state",
				states: ["paused"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("paused");
		});
	});

	describe("animation-name", () => {
		it("generates animation name with identifier", () => {
			const ir: Type.AnimationName = {
				kind: "animation-name",
				names: [{ type: "identifier", value: "slide-in" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("slide-in");
			expect(result.issues).toEqual([]);
		});

		it("generates animation name with none", () => {
			const ir: Type.AnimationName = {
				kind: "animation-name",
				names: [{ type: "none" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("none");
		});
	});

	describe("error handling", () => {
		it("returns error for null IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(null as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Invalid animation IR: missing 'kind' field");
		});

		it("returns error for undefined IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(undefined as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
		});

		it("returns error for IR without kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({} as any);

			expect(result.ok).toBe(false);
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		});

		it("returns error for unknown kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({ kind: "unknown" } as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Unknown animation kind: unknown");
			expect(result.issues[0]?.suggestion).toContain("animation-delay");
			expect(result.issues[0]?.suggestion).toContain("animation-duration");
			expect(result.issues[0]?.suggestion).toContain("animation-timing-function");
		});
	});
});


=== File: src/generate/animation/animation.ts ===
// b_path:: src/generate/animation/animation.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types/animation";
import * as Delay from "./delay";
import * as Direction from "./direction";
import * as Duration from "./duration";
import * as FillMode from "./fill-mode";
import * as IterationCount from "./iteration-count";
import * as Name from "./name";
import * as PlayState from "./play-state";
import * as TimingFunction from "./timing-function";

/**
 * Animation property type union.
 *
 * @public
 */
export type Animation =
	| Type.AnimationDelay
	| Type.AnimationDirection
	| Type.AnimationDuration
	| Type.AnimationFillMode
	| Type.AnimationIterationCount
	| Type.AnimationName
	| Type.AnimationPlayState
	| Type.AnimationTimingFunction;

/**
 * Generate CSS from animation property IR with auto-detection.
 *
 * Automatically detects animation property type from IR.kind and generates appropriate CSS.
 * Supports all animation longhand properties.
 *
 * @param animation - Animation property IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Animation duration:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Animation.generate({
 *   kind: "animation-duration",
 *   durations: [{ type: "time", value: 1, unit: "s" }]
 * });
 * // → { ok: true, value: "1s", issues: [] }
 * ```
 *
 * @example
 * Animation delay:
 * ```typescript
 * const result = Generate.Animation.generate({
 *   kind: "animation-delay",
 *   delays: [{ value: 500, unit: "ms" }]
 * });
 * // → { ok: true, value: "500ms", issues: [] }
 * ```
 *
 * @example
 * Animation timing function:
 * ```typescript
 * const result = Generate.Animation.generate({
 *   kind: "animation-timing-function",
 *   functions: [{ type: "keyword", value: "ease-in-out" }]
 * });
 * // → { ok: true, value: "ease-in-out", issues: [] }
 * ```
 *
 * @example
 * Animation iteration count:
 * ```typescript
 * const result = Generate.Animation.generate({
 *   kind: "animation-iteration-count",
 *   counts: [{ type: "infinite" }]
 * });
 * // → { ok: true, value: "infinite", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Animation.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid animation IR: missing 'kind' field" }] }
 * ```
 *
 * @public
 */
export function generate(animation: Animation): GenerateResult {
	// Validate IR has 'kind' field
	if (!animation || typeof animation !== "object" || !("kind" in animation)) {
		return generateErr("missing-required-field", "Invalid animation IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (animation.kind) {
		case "animation-delay":
			return generateOk(Delay.toCss(animation));

		case "animation-direction":
			return generateOk(Direction.toCss(animation));

		case "animation-duration":
			return generateOk(Duration.toCss(animation));

		case "animation-fill-mode":
			return generateOk(FillMode.toCss(animation));

		case "animation-iteration-count":
			return generateOk(IterationCount.toCss(animation));

		case "animation-name":
			return generateOk(Name.toCss(animation));

		case "animation-play-state":
			return generateOk(PlayState.toCss(animation));

		case "animation-timing-function":
			return generateOk(TimingFunction.toCss(animation));

		default:
			return generateErr("unsupported-kind", `Unknown animation kind: ${(animation as { kind?: string }).kind}`, {
				suggestion:
					"Expected one of: animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, or animation-timing-function. Check that animation IR is valid.",
			});
	}
}


=== File: src/generate/animation/delay.generate.test.ts ===
// b_path:: src/generate/animation/delay.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/animation/delay";
import * as Generator from "./delay";

describe("Animation Delay Generator", () => {
	it("should generate single delay in seconds", () => {
		const ir = {
			kind: "animation-delay" as const,
			delays: [{ value: 1, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("1s");
	});

	it("should generate single delay in milliseconds", () => {
		const ir = {
			kind: "animation-delay" as const,
			delays: [{ value: 500, unit: "ms" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("500ms");
	});

	it("should generate negative delay", () => {
		const ir = {
			kind: "animation-delay" as const,
			delays: [{ value: -2, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("-2s");
	});

	it("should generate zero delay", () => {
		const ir = {
			kind: "animation-delay" as const,
			delays: [{ value: 0, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("0s");
	});

	it("should generate decimal values", () => {
		const ir = {
			kind: "animation-delay" as const,
			delays: [{ value: 0.5, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("0.5s");
	});

	it("should generate multiple delays", () => {
		const ir = {
			kind: "animation-delay" as const,
			delays: [
				{ value: 1, unit: "s" as const },
				{ value: 500, unit: "ms" as const },
				{ value: 2, unit: "s" as const },
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("1s, 500ms, 2s");
	});

	it("should generate mixed positive and negative delays", () => {
		const ir = {
			kind: "animation-delay" as const,
			delays: [
				{ value: 1, unit: "s" as const },
				{ value: -500, unit: "ms" as const },
				{ value: 2, unit: "s" as const },
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("1s, -500ms, 2s");
	});

	// Round-trip tests
	it("should round-trip single delay", () => {
		const original = "1s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip multiple delays", () => {
		const original = "1s, 500ms, 2s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip negative delays", () => {
		const original = "-2s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip decimal values", () => {
		const original = "0.5s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});


=== File: src/generate/animation/delay.ts ===
// b_path:: src/generate/animation/delay.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS animation-delay property value from IR.
 *
 * Converts AnimationDelay IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationDelay IR object
 * @returns CSS animation-delay value string
 *
 * @example
 * Single delay:
 * ```typescript
 * const css = toCss({ kind: "animation-delay", delays: [{ value: 1, unit: "s" }] });
 * // "1s"
 * ```
 *
 * @example
 * Multiple delays:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-delay",
 *   delays: [
 *     { value: 1, unit: "s" },
 *     { value: 500, unit: "ms" },
 *     { value: 2, unit: "s" }
 *   ]
 * });
 * // "1s, 500ms, 2s"
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay | MDN: animation-delay}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-delay | W3C Spec}
 */
export function toCss(ir: Type.AnimationDelay): string {
	return ir.delays.map((time) => `${time.value}${time.unit}`).join(", ");
}


=== File: src/generate/animation/direction.generate.test.ts ===
// b_path:: src/generate/animation/direction.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/animation/direction";
import * as Generator from "./direction";

describe("Animation Direction Generator", () => {
	it("should generate normal", () => {
		const ir = { kind: "animation-direction" as const, directions: ["normal" as const] };
		expect(Generator.toCss(ir)).toBe("normal");
	});

	it("should generate reverse", () => {
		const ir = { kind: "animation-direction" as const, directions: ["reverse" as const] };
		expect(Generator.toCss(ir)).toBe("reverse");
	});

	it("should generate alternate", () => {
		const ir = { kind: "animation-direction" as const, directions: ["alternate" as const] };
		expect(Generator.toCss(ir)).toBe("alternate");
	});

	it("should generate alternate-reverse", () => {
		const ir = { kind: "animation-direction" as const, directions: ["alternate-reverse" as const] };
		expect(Generator.toCss(ir)).toBe("alternate-reverse");
	});

	it("should generate multiple directions", () => {
		const ir = {
			kind: "animation-direction" as const,
			directions: ["normal" as const, "reverse" as const, "alternate" as const],
		};
		expect(Generator.toCss(ir)).toBe("normal, reverse, alternate");
	});

	// Round-trip tests
	it("should round-trip all keywords", () => {
		const keywords = ["normal", "reverse", "alternate", "alternate-reverse"];
		for (const keyword of keywords) {
			const parsed = Parser.parse(keyword);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generator.toCss(parsed.value);
				expect(generated).toBe(keyword);
				const reparsed = Parser.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		}
	});

	it("should round-trip multiple directions", () => {
		const css = "normal, reverse, alternate";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});
});


=== File: src/generate/animation/direction.ts ===
// b_path:: src/generate/animation/direction.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS animation-direction property value from IR.
 *
 * Converts AnimationDirection IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationDirection IR object
 * @returns CSS animation-direction value string
 *
 * @example
 * Single direction:
 * ```typescript
 * const css = toCss({ kind: "animation-direction", directions: ["normal"] });
 * // "normal"
 * ```
 *
 * @example
 * Multiple directions:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-direction",
 *   directions: ["normal", "reverse", "alternate"]
 * });
 * // "normal, reverse, alternate"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction | MDN: animation-direction}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-direction | W3C Spec}
 */
export function toCss(ir: Type.AnimationDirection): string {
	return ir.directions.join(", ");
}


=== File: src/generate/animation/duration.generate.test.ts ===
// b_path:: src/generate/animation/duration.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/animation/duration";
import * as Generator from "./duration";

describe("Animation Duration Generator", () => {
	it("should generate single time value in seconds", () => {
		const ir = {
			kind: "animation-duration" as const,
			durations: [{ type: "time" as const, value: 1, unit: "s" as const }],
		};

		expect(Generator.toCss(ir)).toBe("1s");
	});

	it("should generate single time value in milliseconds", () => {
		const ir = {
			kind: "animation-duration" as const,
			durations: [{ type: "time" as const, value: 500, unit: "ms" as const }],
		};

		expect(Generator.toCss(ir)).toBe("500ms");
	});

	it("should generate auto keyword", () => {
		const ir = {
			kind: "animation-duration" as const,
			durations: [{ type: "auto" as const }],
		};

		expect(Generator.toCss(ir)).toBe("auto");
	});

	it("should generate zero duration", () => {
		const ir = {
			kind: "animation-duration" as const,
			durations: [{ type: "time" as const, value: 0, unit: "s" as const }],
		};

		expect(Generator.toCss(ir)).toBe("0s");
	});

	it("should generate decimal values", () => {
		const ir = {
			kind: "animation-duration" as const,
			durations: [{ type: "time" as const, value: 0.5, unit: "s" as const }],
		};

		expect(Generator.toCss(ir)).toBe("0.5s");
	});

	it("should generate multiple durations", () => {
		const ir = {
			kind: "animation-duration" as const,
			durations: [
				{ type: "time" as const, value: 1, unit: "s" as const },
				{ type: "auto" as const },
				{ type: "time" as const, value: 500, unit: "ms" as const },
			],
		};

		expect(Generator.toCss(ir)).toBe("1s, auto, 500ms");
	});

	it("should generate large values", () => {
		const ir = {
			kind: "animation-duration" as const,
			durations: [{ type: "time" as const, value: 3600, unit: "s" as const }],
		};

		expect(Generator.toCss(ir)).toBe("3600s");
	});

	// Round-trip tests
	it("should round-trip single duration", () => {
		const css = "1s";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);

			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip auto keyword", () => {
		const css = "auto";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);

			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip multiple durations", () => {
		const css = "1s, auto, 500ms";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);

			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip decimal values", () => {
		const css = "0.5s";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);

			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});
});


=== File: src/generate/animation/duration.ts ===
// b_path:: src/generate/animation/duration.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS animation-duration property value from IR.
 *
 * Converts AnimationDuration IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationDuration IR object
 * @returns CSS animation-duration value string
 *
 * @example
 * Time duration:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-duration",
 *   durations: [{ type: "time", value: 1, unit: "s" }]
 * });
 * // "1s"
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-duration",
 *   durations: [{ type: "auto" }]
 * });
 * // "auto"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration | MDN: animation-duration}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-duration | W3C Spec}
 */
export function toCss(ir: Type.AnimationDuration): string {
	return ir.durations
		.map((duration) => {
			if (duration.type === "auto") {
				return "auto";
			}
			return `${duration.value}${duration.unit}`;
		})
		.join(", ");
}


=== File: src/generate/animation/fill-mode.generate.test.ts ===
// b_path:: src/generate/animation/fill-mode.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/animation/fill-mode";
import * as Generator from "./fill-mode";

describe("Animation Fill Mode Generator", () => {
	it("should generate none", () => {
		const ir = { kind: "animation-fill-mode" as const, modes: ["none" as const] };
		expect(Generator.toCss(ir)).toBe("none");
	});

	it("should generate forwards", () => {
		const ir = { kind: "animation-fill-mode" as const, modes: ["forwards" as const] };
		expect(Generator.toCss(ir)).toBe("forwards");
	});

	it("should generate backwards", () => {
		const ir = { kind: "animation-fill-mode" as const, modes: ["backwards" as const] };
		expect(Generator.toCss(ir)).toBe("backwards");
	});

	it("should generate both", () => {
		const ir = { kind: "animation-fill-mode" as const, modes: ["both" as const] };
		expect(Generator.toCss(ir)).toBe("both");
	});

	it("should generate multiple modes", () => {
		const ir = {
			kind: "animation-fill-mode" as const,
			modes: ["none" as const, "forwards" as const, "both" as const],
		};
		expect(Generator.toCss(ir)).toBe("none, forwards, both");
	});

	// Round-trip tests
	it("should round-trip all keywords", () => {
		const keywords = ["none", "forwards", "backwards", "both"];
		for (const keyword of keywords) {
			const parsed = Parser.parse(keyword);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generator.toCss(parsed.value);
				expect(generated).toBe(keyword);
				const reparsed = Parser.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		}
	});

	it("should round-trip multiple modes", () => {
		const css = "none, forwards, both";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});
});


=== File: src/generate/animation/fill-mode.ts ===
// b_path:: src/generate/animation/fill-mode.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS animation-fill-mode property value from IR.
 *
 * Converts AnimationFillMode IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationFillMode IR object
 * @returns CSS animation-fill-mode value string
 *
 * @example
 * Single fill mode:
 * ```typescript
 * const css = toCss({ kind: "animation-fill-mode", modes: ["forwards"] });
 * // "forwards"
 * ```
 *
 * @example
 * Multiple fill modes:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-fill-mode",
 *   modes: ["none", "forwards", "both"]
 * });
 * // "none, forwards, both"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode | MDN: animation-fill-mode}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-fill-mode | W3C Spec}
 */
export function toCss(ir: Type.AnimationFillMode): string {
	return ir.modes.join(", ");
}


=== File: src/generate/animation/index.ts ===
// b_path:: src/generate/animation/index.ts

export { generate } from "./animation";
export * as Delay from "./delay";
export * as Direction from "./direction";
export * as Duration from "./duration";
export * as FillMode from "./fill-mode";
export * as IterationCount from "./iteration-count";
export * as Name from "./name";
export * as PlayState from "./play-state";
export * as TimingFunction from "./timing-function";


=== File: src/generate/animation/iteration-count.generate.test.ts ===
// b_path:: src/generate/animation/iteration-count.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/animation/iteration-count";
import * as Generator from "./iteration-count";

describe("Animation Iteration Count Generator", () => {
	it("should generate single number", () => {
		const ir = {
			kind: "animation-iteration-count" as const,
			counts: [{ type: "number" as const, value: 3 }],
		};

		expect(Generator.toCss(ir)).toBe("3");
	});

	it("should generate infinite keyword", () => {
		const ir = {
			kind: "animation-iteration-count" as const,
			counts: [{ type: "infinite" as const }],
		};

		expect(Generator.toCss(ir)).toBe("infinite");
	});

	it("should generate zero count", () => {
		const ir = {
			kind: "animation-iteration-count" as const,
			counts: [{ type: "number" as const, value: 0 }],
		};

		expect(Generator.toCss(ir)).toBe("0");
	});

	it("should generate decimal values", () => {
		const ir = {
			kind: "animation-iteration-count" as const,
			counts: [{ type: "number" as const, value: 2.5 }],
		};

		expect(Generator.toCss(ir)).toBe("2.5");
	});

	it("should generate multiple counts", () => {
		const ir = {
			kind: "animation-iteration-count" as const,
			counts: [
				{ type: "number" as const, value: 1 },
				{ type: "infinite" as const },
				{ type: "number" as const, value: 2.5 },
			],
		};

		expect(Generator.toCss(ir)).toBe("1, infinite, 2.5");
	});

	// Round-trip tests
	it("should round-trip single number", () => {
		const css = "3";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);

			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip infinite keyword", () => {
		const css = "infinite";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);

			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip multiple counts", () => {
		const css = "1, infinite, 2.5";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);

			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip decimal value", () => {
		const css = "0.5";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);

			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});
});


=== File: src/generate/animation/iteration-count.ts ===
// b_path:: src/generate/animation/iteration-count.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS animation-iteration-count property value from IR.
 *
 * Converts AnimationIterationCount IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationIterationCount IR object
 * @returns CSS animation-iteration-count value string
 *
 * @example
 * Number count:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-iteration-count",
 *   counts: [{ type: "number", value: 3 }]
 * });
 * // "3"
 * ```
 *
 * @example
 * Infinite keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-iteration-count",
 *   counts: [{ type: "infinite" }]
 * });
 * // "infinite"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count | MDN: animation-iteration-count}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-iteration-count | W3C Spec}
 */
export function toCss(ir: Type.AnimationIterationCount): string {
	return ir.counts
		.map((count) => {
			if (count.type === "infinite") {
				return "infinite";
			}
			return String(count.value);
		})
		.join(", ");
}


=== File: src/generate/animation/name.generate.test.ts ===
// b_path:: src/generate/animation/name.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/animation/name";
import * as Generator from "./name";

describe("Animation Name Generator", () => {
	it("should generate none", () => {
		const ir = { kind: "animation-name" as const, names: [{ type: "none" as const }] };
		expect(Generator.toCss(ir)).toBe("none");
	});

	it("should generate identifier", () => {
		const ir = { kind: "animation-name" as const, names: [{ type: "identifier" as const, value: "slideIn" }] };
		expect(Generator.toCss(ir)).toBe("slideIn");
	});

	it("should generate multiple names", () => {
		const ir = {
			kind: "animation-name" as const,
			names: [
				{ type: "identifier" as const, value: "slideIn" },
				{ type: "identifier" as const, value: "fadeOut" },
				{ type: "none" as const },
			],
		};
		expect(Generator.toCss(ir)).toBe("slideIn, fadeOut, none");
	});

	// Round-trip tests
	it("should round-trip none", () => {
		const css = "none";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip identifier", () => {
		const css = "slideIn";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip multiple names", () => {
		const css = "slideIn, fadeOut, none";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip hyphenated names", () => {
		const css = "slide-in-from-left";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});
});


=== File: src/generate/animation/name.ts ===
// b_path:: src/generate/animation/name.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS animation-name property value from IR.
 *
 * Converts AnimationName IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationName IR object
 * @returns CSS animation-name value string
 *
 * @example
 * Identifier name:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-name",
 *   names: [{ type: "identifier", value: "slideIn" }]
 * });
 * // "slideIn"
 * ```
 *
 * @example
 * None keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-name",
 *   names: [{ type: "none" }]
 * });
 * // "none"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name | MDN: animation-name}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-name | W3C Spec}
 */
export function toCss(ir: Type.AnimationName): string {
	return ir.names
		.map((name) => {
			if (name.type === "none") {
				return "none";
			}
			return name.value;
		})
		.join(", ");
}


=== File: src/generate/animation/play-state.generate.test.ts ===
// b_path:: src/generate/animation/play-state.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/animation/play-state";
import * as Generator from "./play-state";

describe("Animation Play State Generator", () => {
	it("should generate running", () => {
		const ir = { kind: "animation-play-state" as const, states: ["running" as const] };
		expect(Generator.toCss(ir)).toBe("running");
	});

	it("should generate paused", () => {
		const ir = { kind: "animation-play-state" as const, states: ["paused" as const] };
		expect(Generator.toCss(ir)).toBe("paused");
	});

	it("should generate multiple states", () => {
		const ir = {
			kind: "animation-play-state" as const,
			states: ["running" as const, "paused" as const],
		};
		expect(Generator.toCss(ir)).toBe("running, paused");
	});

	// Round-trip tests
	it("should round-trip all keywords", () => {
		const keywords = ["running", "paused"];
		for (const keyword of keywords) {
			const parsed = Parser.parse(keyword);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generator.toCss(parsed.value);
				expect(generated).toBe(keyword);
				const reparsed = Parser.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		}
	});

	it("should round-trip multiple states", () => {
		const css = "running, paused";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});
});


=== File: src/generate/animation/play-state.ts ===
// b_path:: src/generate/animation/play-state.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS animation-play-state property value from IR.
 *
 * Converts AnimationPlayState IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationPlayState IR object
 * @returns CSS animation-play-state value string
 *
 * @example
 * Single play state:
 * ```typescript
 * const css = toCss({ kind: "animation-play-state", states: ["running"] });
 * // "running"
 * ```
 *
 * @example
 * Multiple play states:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-play-state",
 *   states: ["running", "paused"]
 * });
 * // "running, paused"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state | MDN: animation-play-state}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-play-state | W3C Spec}
 */
export function toCss(ir: Type.AnimationPlayState): string {
	return ir.states.join(", ");
}


=== File: src/generate/animation/timing-function.generate.test.ts ===
// b_path:: src/generate/animation/timing-function.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/animation/timing-function";
import * as Generator from "./timing-function";

describe("Animation Timing Function Generator", () => {
	// Keywords
	it("should generate ease keyword", () => {
		const ir = { kind: "animation-timing-function" as const, functions: ["ease" as const] };
		expect(Generator.toCss(ir)).toBe("ease");
	});

	it("should generate ease-in keyword", () => {
		const ir = { kind: "animation-timing-function" as const, functions: ["ease-in" as const] };
		expect(Generator.toCss(ir)).toBe("ease-in");
	});

	it("should generate linear keyword", () => {
		const ir = { kind: "animation-timing-function" as const, functions: ["linear" as const] };
		expect(Generator.toCss(ir)).toBe("linear");
	});

	it("should generate step-start keyword", () => {
		const ir = { kind: "animation-timing-function" as const, functions: ["step-start" as const] };
		expect(Generator.toCss(ir)).toBe("step-start");
	});

	// cubic-bezier()
	it("should generate cubic-bezier", () => {
		const ir = {
			kind: "animation-timing-function" as const,
			functions: [{ type: "cubic-bezier" as const, x1: 0.1, y1: 0.7, x2: 1.0, y2: 0.1 }],
		};
		expect(Generator.toCss(ir)).toBe("cubic-bezier(0.1, 0.7, 1, 0.1)");
	});

	it("should generate cubic-bezier with integers", () => {
		const ir = {
			kind: "animation-timing-function" as const,
			functions: [{ type: "cubic-bezier" as const, x1: 0, y1: 0, x2: 1, y2: 1 }],
		};
		expect(Generator.toCss(ir)).toBe("cubic-bezier(0, 0, 1, 1)");
	});

	// steps()
	it("should generate steps with count only", () => {
		const ir = {
			kind: "animation-timing-function" as const,
			functions: [{ type: "steps" as const, steps: 4, position: undefined }],
		};
		expect(Generator.toCss(ir)).toBe("steps(4)");
	});

	it("should generate steps with position", () => {
		const ir = {
			kind: "animation-timing-function" as const,
			functions: [{ type: "steps" as const, steps: 4, position: "jump-start" as const }],
		};
		expect(Generator.toCss(ir)).toBe("steps(4, jump-start)");
	});

	// linear()
	it("should generate linear with single stop", () => {
		const ir = {
			kind: "animation-timing-function" as const,
			functions: [{ type: "linear" as const, stops: [{ output: 0 }] }],
		};
		expect(Generator.toCss(ir)).toBe("linear(0)");
	});

	it("should generate linear with multiple stops", () => {
		const ir = {
			kind: "animation-timing-function" as const,
			functions: [{ type: "linear" as const, stops: [{ output: 0 }, { output: 0.5 }, { output: 1 }] }],
		};
		expect(Generator.toCss(ir)).toBe("linear(0, 0.5, 1)");
	});

	it("should generate linear with input percentages", () => {
		const ir = {
			kind: "animation-timing-function" as const,
			functions: [
				{
					type: "linear" as const,
					stops: [
						{ output: 0, input: 0 },
						{ output: 1, input: 1 },
					],
				},
			],
		};
		expect(Generator.toCss(ir)).toBe("linear(0 0%, 1 100%)");
	});

	// Multiple functions
	it("should generate multiple timing functions", () => {
		const ir = {
			kind: "animation-timing-function" as const,
			functions: [
				"ease" as const,
				{ type: "cubic-bezier" as const, x1: 0, y1: 0, x2: 1, y2: 1 },
				{ type: "steps" as const, steps: 2, position: undefined },
			],
		};
		expect(Generator.toCss(ir)).toBe("ease, cubic-bezier(0, 0, 1, 1), steps(2)");
	});

	// Round-trip tests
	it("should round-trip keywords", () => {
		const keywords = ["ease", "ease-in", "ease-out", "ease-in-out", "linear", "step-start", "step-end"];
		for (const keyword of keywords) {
			const parsed = Parser.parse(keyword);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generator.toCss(parsed.value);
				expect(generated).toBe(keyword);
				const reparsed = Parser.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		}
	});

	it("should round-trip cubic-bezier", () => {
		const css = "cubic-bezier(0.1, 0.7, 1, 0.1)";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip steps with count only", () => {
		const css = "steps(4)";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip steps with position", () => {
		const css = "steps(4, jump-start)";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip linear", () => {
		const css = "linear(0, 0.5, 1)";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip linear with percentages", () => {
		const css = "linear(0 0%, 1 100%)";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});

	it("should round-trip multiple functions", () => {
		const css = "ease, cubic-bezier(0, 0, 1, 1), steps(2)";
		const parsed = Parser.parse(css);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(css);
			const reparsed = Parser.parse(generated);
			expect(reparsed).toEqual(parsed);
		}
	});
});


=== File: src/generate/animation/timing-function.ts ===
// b_path:: src/generate/animation/timing-function.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS easing function string from IR.
 *
 * @param func - EasingFunction IR
 * @returns CSS easing function string
 *
 * @internal
 */
function easingFunctionToCss(func: Type.EasingFunction): string {
	// Keyword
	if (typeof func === "string") {
		return func;
	}

	// cubic-bezier()
	if (func.type === "cubic-bezier") {
		return `cubic-bezier(${func.x1}, ${func.y1}, ${func.x2}, ${func.y2})`;
	}

	// steps()
	if (func.type === "steps") {
		if (func.position !== undefined) {
			return `steps(${func.steps}, ${func.position})`;
		}
		return `steps(${func.steps})`;
	}

	// linear()
	if (func.type === "linear") {
		const stops = func.stops
			.map((stop) => {
				if (stop.input !== undefined) {
					return `${stop.output} ${stop.input * 100}%`;
				}
				return String(stop.output);
			})
			.join(", ");
		return `linear(${stops})`;
	}

	return "";
}

/**
 * Generate CSS animation-timing-function property value from IR.
 *
 * Converts AnimationTimingFunction IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationTimingFunction IR object
 * @returns CSS animation-timing-function value string
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-timing-function",
 *   functions: ["ease-in"]
 * });
 * // "ease-in"
 * ```
 *
 * @example
 * Cubic bezier:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-timing-function",
 *   functions: [{ type: "cubic-bezier", x1: 0.1, y1: 0.7, x2: 1.0, y2: 0.1 }]
 * });
 * // "cubic-bezier(0.1, 0.7, 1.0, 0.1)"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function | MDN: animation-timing-function}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-timing-function | W3C Spec}
 */
export function toCss(ir: Type.AnimationTimingFunction): string {
	return ir.functions.map(easingFunctionToCss).join(", ");
}


=== File: src/generate/background/attachment.ts ===
// b_path:: src/generate/background/attachment.ts
import type * as Keyword from "@/core/keywords";

/**
 * Generate CSS background-attachment string from keyword.
 *
 * @param keyword - BackgroundAttachmentKeyword value
 * @returns CSS background-attachment string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Attachment.toCss("fixed");
 * console.log(css); // "fixed"
 * ```
 */
export function toCss(keyword: Keyword.BackgroundAttachmentKeyword): string {
	return keyword;
}


=== File: src/generate/background/clip.ts ===
// b_path:: src/generate/background/clip.ts
import type * as Keyword from "@/core/keywords";

/**
 * Generate CSS background-clip string from keyword.
 *
 * @param keyword - BackgroundClipKeyword value
 * @returns CSS background-clip string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Clip.toCss("padding-box");
 * console.log(css); // "padding-box"
 * ```
 */
export function toCss(keyword: Keyword.BackgroundClipKeyword): string {
	return keyword;
}


=== File: src/generate/background/index.ts ===
// b_path:: src/generate/background/index.ts
export * as Attachment from "./attachment";
export * as Clip from "./clip";
export * as Origin from "./origin";
export * as Repeat from "./repeat";
export * as Size from "./size";


=== File: src/generate/background/origin.ts ===
// b_path:: src/generate/background/origin.ts
import type * as Keyword from "@/core/keywords";

/**
 * Generate CSS background-origin string from keyword.
 *
 * @param keyword - VisualBoxKeyword value
 * @returns CSS background-origin string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Origin.toCss("content-box");
 * console.log(css); // "content-box"
 * ```
 */
export function toCss(keyword: Keyword.VisualBoxKeyword): string {
	return keyword;
}


=== File: src/generate/background/repeat.ts ===
// b_path:: src/generate/background/repeat.ts
import type * as Keyword from "@/core/keywords";

/**
 * Generate CSS background-repeat string from keyword.
 *
 * @param keyword - RepeatKeyword value
 * @returns CSS background-repeat string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Repeat.toCss("repeat-x");
 * console.log(css); // "repeat-x"
 * ```
 */
export function toCss(keyword: Keyword.RepeatKeyword): string {
	return keyword;
}


=== File: src/generate/background/size.ts ===
// b_path:: src/generate/background/size.ts
import type { BackgroundSizeValue } from "../../parse/background/size";

/**
 * Generate CSS background-size string from value.
 *
 * @param value - BackgroundSizeValue (keyword, auto, or length-percentage)
 * @returns CSS background-size string
 *
 * @public
 *
 * @example
 * Keyword:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Size.toCss("cover");
 * console.log(css); // "cover"
 * ```
 *
 * @example
 * Length value:
 * ```typescript
 * const css = Generate.Background.Size.toCss({ value: 100, unit: "px" });
 * console.log(css); // "100px"
 * ```
 */
export function toCss(value: BackgroundSizeValue): string {
	if (typeof value === "string") {
		return value;
	}
	return `${value.value}${value.unit}`;
}


=== File: src/generate/border/border.test.ts ===
// b_path:: src/generate/border/border.test.ts

import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types/border";
import { generate } from "./border";

describe("Generate.Border.generate", () => {
	describe("border-width", () => {
		it("generates border-width with length", () => {
			const ir: Type.BorderWidthValue = {
				kind: "border-width",
				width: { value: 2, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px");
			expect(result.issues).toEqual([]);
		});

		it("generates border-width with keyword", () => {
			const ir: Type.BorderWidthValue = {
				kind: "border-width",
				width: "medium",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("medium");
		});

		it("generates border-width with thin", () => {
			const ir: Type.BorderWidthValue = {
				kind: "border-width",
				width: "thin",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("thin");
		});

		it("generates border-width with thick", () => {
			const ir: Type.BorderWidthValue = {
				kind: "border-width",
				width: "thick",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("thick");
		});
	});

	describe("border-style", () => {
		it("generates border-style solid", () => {
			const ir: Type.BorderStyleValue = {
				kind: "border-style",
				style: "solid",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("solid");
			expect(result.issues).toEqual([]);
		});

		it("generates border-style dashed", () => {
			const ir: Type.BorderStyleValue = {
				kind: "border-style",
				style: "dashed",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("dashed");
		});

		it("generates border-style dotted", () => {
			const ir: Type.BorderStyleValue = {
				kind: "border-style",
				style: "dotted",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("dotted");
		});

		it("generates border-style none", () => {
			const ir: Type.BorderStyleValue = {
				kind: "border-style",
				style: "none",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("none");
		});
	});

	describe("border-color", () => {
		it("generates border-color with keyword", () => {
			const ir: Type.BorderColorValue = {
				kind: "border-color",
				color: "red",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("red");
			expect(result.issues).toEqual([]);
		});

		it("generates border-color with transparent", () => {
			const ir: Type.BorderColorValue = {
				kind: "border-color",
				color: "transparent",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("transparent");
		});

		it("generates border-color with currentColor", () => {
			const ir: Type.BorderColorValue = {
				kind: "border-color",
				color: "currentColor",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("currentColor");
		});
	});

	describe("border-radius", () => {
		it("generates border-radius with px", () => {
			const ir: Type.BorderRadiusValue = {
				kind: "border-radius",
				radius: { value: 4, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("4px");
			expect(result.issues).toEqual([]);
		});

		it("generates border-radius with percentage", () => {
			const ir: Type.BorderRadiusValue = {
				kind: "border-radius",
				radius: { value: 50, unit: "%" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("50%");
		});

		it("generates border-radius with em", () => {
			const ir: Type.BorderRadiusValue = {
				kind: "border-radius",
				radius: { value: 0.5, unit: "em" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("0.5em");
		});
	});

	describe("error handling", () => {
		it("returns error for null IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(null as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Invalid border IR: missing 'kind' field");
		});

		it("returns error for undefined IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(undefined as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
		});

		it("returns error for IR without kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({} as any);

			expect(result.ok).toBe(false);
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		});

		it("returns error for unknown kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({ kind: "unknown" } as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Unknown border kind: unknown");
			expect(result.issues[0]?.suggestion).toContain("border-width");
			expect(result.issues[0]?.suggestion).toContain("border-style");
			expect(result.issues[0]?.suggestion).toContain("border-color");
			expect(result.issues[0]?.suggestion).toContain("border-radius");
		});
	});
});


=== File: src/generate/border/border.ts ===
// b_path:: src/generate/border/border.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types/border";
import * as Color from "./color";
import * as Radius from "./radius";
import * as Style from "./style";
import * as Width from "./width";

/**
 * Generate CSS from border property IR with auto-detection.
 *
 * Automatically detects border property type from IR.kind and generates appropriate CSS.
 * Supports border-width, border-style, border-color, and border-radius.
 *
 * @param border - Border property IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Border width:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Border.generate({
 *   kind: "border-width",
 *   width: { value: 2, unit: "px" }
 * });
 * // → { ok: true, value: "2px", issues: [] }
 * ```
 *
 * @example
 * Border style:
 * ```typescript
 * const result = Generate.Border.generate({
 *   kind: "border-style",
 *   style: "solid"
 * });
 * // → { ok: true, value: "solid", issues: [] }
 * ```
 *
 * @example
 * Border color:
 * ```typescript
 * const result = Generate.Border.generate({
 *   kind: "border-color",
 *   color: "red"
 * });
 * // → { ok: true, value: "red", issues: [] }
 * ```
 *
 * @example
 * Border radius:
 * ```typescript
 * const result = Generate.Border.generate({
 *   kind: "border-radius",
 *   radius: { value: 4, unit: "px" }
 * });
 * // → { ok: true, value: "4px", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Border.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid border IR: missing 'kind' field" }] }
 *
 * const result2 = Generate.Border.generate({ kind: "unknown" });
 * // → { ok: false, issues: [{ severity: "error", message: "Unknown border kind: unknown" }] }
 * ```
 *
 * @public
 */
export function generate(
	border: Type.BorderWidthValue | Type.BorderStyleValue | Type.BorderColorValue | Type.BorderRadiusValue,
): GenerateResult {
	// Validate IR has 'kind' field
	if (!border || typeof border !== "object" || !("kind" in border)) {
		return generateErr("missing-required-field", "Invalid border IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (border.kind) {
		case "border-width":
			return generateOk(Width.toCss(border));

		case "border-style":
			return generateOk(Style.toCss(border));

		case "border-color":
			return generateOk(Color.toCss(border));

		case "border-radius":
			return generateOk(Radius.toCss(border));

		default:
			return generateErr("unsupported-kind", `Unknown border kind: ${(border as { kind?: string }).kind}`, {
				suggestion:
					"Expected 'border-width', 'border-style', 'border-color', or 'border-radius'. Check that border IR is valid.",
			});
	}
}


=== File: src/generate/border/color.generate.test.ts ===
// b_path:: src/generate/border/color.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/border/color";
import * as Generate from "./color";

describe("Generate.Border.Color", () => {
	describe("round-trip", () => {
		it("should round-trip 'transparent'", () => {
			const input = "transparent";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("transparent");
			}
		});

		it("should round-trip 'currentcolor'", () => {
			const input = "currentcolor";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("currentcolor");
			}
		});

		it("should round-trip 'red'", () => {
			const input = "red";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("red");
			}
		});

		it("should round-trip 'blue'", () => {
			const input = "blue";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("blue");
			}
		});

		it("should round-trip 'green'", () => {
			const input = "green";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("green");
			}
		});
	});
});


=== File: src/generate/border/color.ts ===
// b_path:: src/generate/border/color.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS border-color property value from IR.
 *
 * Converts BorderColorValue IR to CSS string representation.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param ir - BorderColorValue IR object
 * @returns CSS border-color value string
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "border-color", color: "red" });
 * // "red"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color | MDN: border-color}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-color | W3C Spec}
 */
export function toCss(ir: Type.BorderColorValue): string {
	return ir.color;
}


=== File: src/generate/border/index.ts ===
// b_path:: src/generate/border/index.ts

export { generate } from "./border";
export * as Color from "./color";
export * as Radius from "./radius";
export * as Style from "./style";
export * as Width from "./width";


=== File: src/generate/border/radius.generate.test.ts ===
// b_path:: src/generate/border/radius.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/border/radius";
import * as Generate from "./radius";

describe("Generate.Border.Radius", () => {
	describe("round-trip", () => {
		it("should round-trip '5px'", () => {
			const input = "5px";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("5px");
			}
		});

		it("should round-trip '10.5px'", () => {
			const input = "10.5px";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("10.5px");
			}
		});

		it("should round-trip '50%'", () => {
			const input = "50%";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("50%");
			}
		});

		it("should round-trip '1em'", () => {
			const input = "1em";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("1em");
			}
		});

		it("should round-trip '0' as '0px'", () => {
			const input = "0";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("0px");
			}
		});
	});
});


=== File: src/generate/border/radius.ts ===
// b_path:: src/generate/border/radius.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS border-radius property value from IR.
 *
 * Converts BorderRadiusValue IR to CSS string representation.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param ir - BorderRadiusValue IR object
 * @returns CSS border-radius value string
 *
 * @example
 * Length:
 * ```typescript
 * const css = toCss({ kind: "border-radius", radius: { value: 5, unit: "px" } });
 * // "5px"
 * ```
 *
 * @example
 * Percentage:
 * ```typescript
 * const css = toCss({ kind: "border-radius", radius: { value: 50, unit: "%" } });
 * // "50%"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius | MDN: border-radius}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-radius | W3C Spec}
 */
export function toCss(ir: Type.BorderRadiusValue): string {
	return `${ir.radius.value}${ir.radius.unit}`;
}


=== File: src/generate/border/style.generate.test.ts ===
// b_path:: src/generate/border/style.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/border/style";
import * as Generate from "./style";

describe("Generate.Border.Style", () => {
	describe("round-trip", () => {
		it("should round-trip 'none'", () => {
			const input = "none";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("none");
			}
		});

		it("should round-trip 'hidden'", () => {
			const input = "hidden";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("hidden");
			}
		});

		it("should round-trip 'solid'", () => {
			const input = "solid";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("solid");
			}
		});

		it("should round-trip 'dashed'", () => {
			const input = "dashed";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("dashed");
			}
		});

		it("should round-trip 'dotted'", () => {
			const input = "dotted";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("dotted");
			}
		});

		it("should round-trip 'double'", () => {
			const input = "double";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("double");
			}
		});

		it("should round-trip 'groove'", () => {
			const input = "groove";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("groove");
			}
		});

		it("should round-trip 'ridge'", () => {
			const input = "ridge";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("ridge");
			}
		});

		it("should round-trip 'inset'", () => {
			const input = "inset";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("inset");
			}
		});

		it("should round-trip 'outset'", () => {
			const input = "outset";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("outset");
			}
		});
	});
});


=== File: src/generate/border/style.ts ===
// b_path:: src/generate/border/style.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS border-style property value from IR.
 *
 * Converts BorderStyleValue IR to CSS string representation.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param ir - BorderStyleValue IR object
 * @returns CSS border-style value string
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "border-style", style: "solid" });
 * // "solid"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style | MDN: border-style}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-style | W3C Spec}
 */
export function toCss(ir: Type.BorderStyleValue): string {
	return ir.style;
}


=== File: src/generate/border/width.generate.test.ts ===
// b_path:: src/generate/border/width.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/border/width";
import * as Generate from "./width";

describe("Generate.Border.Width", () => {
	describe("round-trip", () => {
		it("should round-trip 'thin'", () => {
			const input = "thin";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("thin");
			}
		});

		it("should round-trip 'medium'", () => {
			const input = "medium";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("medium");
			}
		});

		it("should round-trip 'thick'", () => {
			const input = "thick";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("thick");
			}
		});

		it("should round-trip '1px'", () => {
			const input = "1px";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("1px");
			}
		});

		it("should round-trip '2.5em'", () => {
			const input = "2.5em";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("2.5em");
			}
		});

		it("should round-trip '0' as '0px'", () => {
			const input = "0";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("0px");
			}
		});
	});
});


=== File: src/generate/border/width.ts ===
// b_path:: src/generate/border/width.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS border-width property value from IR.
 *
 * Converts BorderWidthValue IR to CSS string representation.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param ir - BorderWidthValue IR object
 * @returns CSS border-width value string
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({ kind: "border-width", width: "medium" });
 * // "medium"
 * ```
 *
 * @example
 * Length:
 * ```typescript
 * const css = toCss({ kind: "border-width", width: { value: 1, unit: "px" } });
 * // "1px"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width | MDN: border-width}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-width | W3C Spec}
 */
export function toCss(ir: Type.BorderWidthValue): string {
	if (typeof ir.width === "string") {
		return ir.width;
	}
	return `${ir.width.value}${ir.width.unit}`;
}


=== File: src/generate/clip-path/circle.test.ts ===
// b_path:: src/generate/clip-path/circle.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/clip-path/circle";
import * as Generate from "./circle";

describe("Generate.ClipPath.Circle", () => {
	describe("Basic generation", () => {
		it("generates circle() with no arguments", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
			});

			expect(css).toBe("circle()");
		});

		it("generates circle() with radius", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "px" },
			});

			expect(css).toBe("circle(50px)");
		});

		it("generates circle() with percentage radius", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "%" },
			});

			expect(css).toBe("circle(50%)");
		});

		it("generates circle() with closest-side", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				radius: "closest-side",
			});

			expect(css).toBe("circle(closest-side)");
		});

		it("generates circle() with farthest-side", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				radius: "farthest-side",
			});

			expect(css).toBe("circle(farthest-side)");
		});
	});

	describe("Position generation", () => {
		it("generates circle() with position only", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				position: { horizontal: "center", vertical: "center" },
			});

			expect(css).toBe("circle(at center center)");
		});

		it("generates circle() with radius and position", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "px" },
				position: { horizontal: "center", vertical: "center" },
			});

			expect(css).toBe("circle(50px at center center)");
		});

		it("generates circle() with length-percentage position", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				position: {
					horizontal: { value: 30, unit: "px" },
					vertical: { value: 40, unit: "%" },
				},
			});

			expect(css).toBe("circle(at 30px 40%)");
		});

		it("generates circle() with keyword position", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				position: { horizontal: "left", vertical: "top" },
			});

			expect(css).toBe("circle(at left top)");
		});
	});

	describe("Edge cases", () => {
		it("generates zero radius", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				radius: { value: 0, unit: "px" },
			});

			expect(css).toBe("circle(0px)");
		});

		it("generates zero percentage radius", () => {
			const css = Generate.toCss({
				kind: "clip-path-circle",
				radius: { value: 0, unit: "%" },
			});

			expect(css).toBe("circle(0%)");
		});
	});

	describe("Round-trip", () => {
		const testCases = [
			"circle()",
			"circle(50px)",
			"circle(50%)",
			"circle(closest-side)",
			"circle(farthest-side)",
			"circle(at center center)",
			"circle(50px at center center)",
			"circle(at 30px 40%)",
			"circle(at left top)",
			"circle(0px)",
		];

		for (const input of testCases) {
			it(`round-trips: ${input}`, () => {
				const parsed = Parse.parse(input);
				expect(parsed.ok).toBe(true);
				if (!parsed.ok) return;

				const generated = Generate.toCss(parsed.value);
				const reparsed = Parse.parse(generated);

				expect(reparsed.ok).toBe(true);
				if (!reparsed.ok) return;

				expect(reparsed.value).toEqual(parsed.value);
			});
		}
	});
});


=== File: src/generate/clip-path/circle.ts ===
// b_path:: src/generate/clip-path/circle.ts
import type * as Type from "@/core/types";
import * as Generate from "@/generate";
import * as GenerateUtils from "@/utils/generate";

/**
 * Convert circle() IR to CSS string.
 *
 * Generates optimized CSS for circle() shape function.
 * Omits defaults (no radius = closest-side, no position = center).
 *
 * @param value - ClipPathCircle IR
 * @returns CSS string
 *
 * @example
 * ```typescript
 * toCss({ kind: "clip-path-circle" });
 * // "circle()"
 *
 * toCss({ kind: "clip-path-circle", radius: { value: 50, unit: "px" } });
 * // "circle(50px)"
 *
 * toCss({
 *   kind: "clip-path-circle",
 *   radius: { value: 50, unit: "px" },
 *   position: { horizontal: "center", vertical: "center" }
 * });
 * // "circle(50px at center)"
 * ```
 *
 * @public
 */
export function toCss(value: Type.ClipPathCircle): string {
	const parts: string[] = ["circle("];

	// Add radius if present
	if (value.radius !== undefined) {
		if (typeof value.radius === "string") {
			parts.push(value.radius);
		} else {
			parts.push(GenerateUtils.lengthPercentageToCss(value.radius));
		}
	}

	// Add position if present
	if (value.position !== undefined) {
		if (parts.length > 1) {
			parts.push(" ");
		}
		parts.push("at ");
		parts.push(Generate.Position.Utils.toCss(value.position));
	}

	parts.push(")");
	return parts.join("");
}


=== File: src/generate/clip-path/clip-path.test.ts ===
// b_path:: src/generate/clip-path/clip-path.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./clip-path";

describe("ClipPath.generate()", () => {
	test("generates none", () => {
		const clipPath: Type.ClipPathValue = { kind: "clip-path-none" };
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("none");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates geometry-box", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "clip-path-geometry-box",
			value: "border-box",
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("border-box");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates circle", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "clip-path-circle",
			radius: { value: 50, unit: "%" },
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(50%)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates ellipse", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "clip-path-ellipse",
			radiusX: { value: 50, unit: "%" },
			radiusY: { value: 30, unit: "%" },
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ellipse(50% 30%)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates inset", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "px" },
			right: { value: 20, unit: "px" },
			bottom: { value: 10, unit: "px" },
			left: { value: 20, unit: "px" },
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10px 20px)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates polygon", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "clip-path-polygon",
			fillRule: "nonzero",
			points: [
				{
					x: { value: 0, unit: "%" },
					y: { value: 0, unit: "%" },
				},
				{
					x: { value: 100, unit: "%" },
					y: { value: 0, unit: "%" },
				},
				{
					x: { value: 50, unit: "%" },
					y: { value: 100, unit: "%" },
				},
			],
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("polygon(nonzero, 0% 0%, 100% 0%, 50% 100%)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates rect", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "clip-path-rect",
			top: { value: 10, unit: "px" },
			right: { value: 20, unit: "px" },
			bottom: { value: 30, unit: "px" },
			left: { value: 40, unit: "px" },
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rect(10px 20px 30px 40px)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates xywh", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "clip-path-xywh",
			x: { value: 10, unit: "px" },
			y: { value: 20, unit: "px" },
			width: { value: 100, unit: "px" },
			height: { value: 50, unit: "px" },
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("xywh(10px 20px 100px 50px)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates path", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "clip-path-path",
			fillRule: "nonzero",
			pathData: "M 10 10 L 90 90",
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("path(nonzero, 'M 10 10 L 90 90')");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates url", () => {
		const clipPath: Type.ClipPathValue = {
			kind: "url",
			value: "#clip-shape",
		};
		const result = generate(clipPath);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("url(#clip-shape)");
			expect(result.issues).toEqual([]);
		}
	});

	test("returns error for invalid IR (missing kind)", () => {
		const clipPath = {} as Type.ClipPathValue;
		const result = generate(clipPath);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});

	test("returns error for unknown kind", () => {
		const clipPath = { kind: "unknown" } as unknown as Type.ClipPathValue;
		const result = generate(clipPath);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("Unknown clip-path kind");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});
});


=== File: src/generate/clip-path/clip-path.ts ===
// b_path:: src/generate/clip-path/clip-path.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Circle from "./circle";
import * as Ellipse from "./ellipse";
import * as GeometryBox from "./geometry-box";
import * as Inset from "./inset";
import * as None from "./none";
import * as Path from "./path";
import * as Polygon from "./polygon";
import * as Rect from "./rect";
import * as Url from "./url";
import * as Xywh from "./xywh";

/**
 * Generate CSS from clip-path IR with auto-detection.
 *
 * Automatically detects clip-path shape from IR.kind and generates appropriate CSS.
 * Supports all clip-path shapes and keywords.
 *
 * @param clipPath - ClipPath IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate({ kind: "clip-path-circle", radius: { value: 50, unit: "%" } })
 * // → { ok: true, value: "circle(50%)", issues: [] }
 *
 * generate({ kind: "clip-path-none" })
 * // → { ok: true, value: "none", issues: [] }
 *
 * generate({ kind: "url", value: "#clip-shape" })
 * // → { ok: true, value: "url(#clip-shape)", issues: [] }
 * ```
 *
 * @public
 */
export function generate(clipPath: Type.ClipPathValue): GenerateResult {
	// Validate IR has 'kind' field
	if (!clipPath || typeof clipPath !== "object" || !("kind" in clipPath)) {
		return generateErr("missing-required-field", "Invalid clip-path IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (clipPath.kind) {
		case "clip-path-none":
			return generateOk(None.toCss(clipPath));

		case "clip-path-geometry-box":
			return generateOk(GeometryBox.toCss(clipPath));

		case "clip-path-inset":
			return generateOk(Inset.toCss(clipPath));

		case "clip-path-circle":
			return generateOk(Circle.toCss(clipPath));

		case "clip-path-ellipse":
			return generateOk(Ellipse.toCss(clipPath));

		case "clip-path-polygon":
			return generateOk(Polygon.toCss(clipPath));

		case "clip-path-rect":
			return generateOk(Rect.toCss(clipPath));

		case "clip-path-xywh":
			return generateOk(Xywh.toCss(clipPath));

		case "clip-path-path":
			return generateOk(Path.toCss(clipPath));

		case "url":
			return generateOk(Url.toCss(clipPath));

		default:
			return generateErr("unsupported-kind", `Unknown clip-path kind: ${(clipPath as { kind?: string }).kind}`, {
				suggestion: "Check that clip-path IR is valid",
			});
	}
}


=== File: src/generate/clip-path/ellipse.test.ts ===
// b_path:: src/generate/clip-path/ellipse.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse";
import * as Ellipse from "./ellipse";

describe("generate/clip-path/ellipse", () => {
	describe("basic generation", () => {
		it("should generate ellipse with no arguments", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
			});
			expect(css).toBe("ellipse()");
		});

		it("should generate ellipse with single radius", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: { value: 50, unit: "px" },
			});
			expect(css).toBe("ellipse(50px)");
		});

		it("should generate ellipse with two radii", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: { value: 50, unit: "px" },
				radiusY: { value: 100, unit: "px" },
			});
			expect(css).toBe("ellipse(50px 100px)");
		});

		it("should generate ellipse with percentage radii", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: { value: 50, unit: "%" },
				radiusY: { value: 75, unit: "%" },
			});
			expect(css).toBe("ellipse(50% 75%)");
		});

		it("should generate ellipse with mixed units", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: { value: 2, unit: "rem" },
				radiusY: { value: 100, unit: "px" },
			});
			expect(css).toBe("ellipse(2rem 100px)");
		});
	});

	describe("keyword radii", () => {
		it("should generate ellipse with closest-side keywords", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: "closest-side",
				radiusY: "closest-side",
			});
			expect(css).toBe("ellipse(closest-side closest-side)");
		});

		it("should generate ellipse with farthest-side keywords", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: "farthest-side",
				radiusY: "farthest-side",
			});
			expect(css).toBe("ellipse(farthest-side farthest-side)");
		});

		it("should generate ellipse with mixed keywords", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: "closest-side",
				radiusY: "farthest-side",
			});
			expect(css).toBe("ellipse(closest-side farthest-side)");
		});

		it("should generate ellipse with keyword and value", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: { value: 50, unit: "px" },
				radiusY: "farthest-side",
			});
			expect(css).toBe("ellipse(50px farthest-side)");
		});
	});

	describe("position generation", () => {
		it("should generate ellipse with position only", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				position: {
					horizontal: "center",
					vertical: "center",
				},
			});
			expect(css).toBe("ellipse(at center center)");
		});

		it("should generate ellipse with radii and position", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: { value: 50, unit: "px" },
				radiusY: { value: 100, unit: "px" },
				position: {
					horizontal: { value: 30, unit: "px" },
					vertical: { value: 40, unit: "px" },
				},
			});
			expect(css).toBe("ellipse(50px 100px at 30px 40px)");
		});

		it("should generate ellipse with keywords and position", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: "closest-side",
				radiusY: "farthest-side",
				position: {
					horizontal: "left",
					vertical: "top",
				},
			});
			expect(css).toBe("ellipse(closest-side farthest-side at left top)");
		});
	});

	describe("edge cases", () => {
		it("should generate ellipse with zero radii", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusX: { value: 0, unit: "px" },
				radiusY: { value: 0, unit: "px" },
			});
			expect(css).toBe("ellipse(0px 0px)");
		});

		it("should generate ellipse with only radiusY", () => {
			const css = Ellipse.toCss({
				kind: "clip-path-ellipse",
				radiusY: { value: 100, unit: "px" },
			});
			expect(css).toBe("ellipse(100px)");
		});
	});

	describe("round-trip validation", () => {
		it("should round-trip empty ellipse", () => {
			const original = "ellipse()";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with single radius", () => {
			const original = "ellipse(50px)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with two radii", () => {
			const original = "ellipse(50px 100px)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with keywords", () => {
			const original = "ellipse(closest-side farthest-side)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with position", () => {
			const original = "ellipse(at center center)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with radii and position", () => {
			const original = "ellipse(50px 100px at 30px 40px)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with keywords and position", () => {
			const original = "ellipse(closest-side farthest-side at left top)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with percentage", () => {
			const original = "ellipse(50% 75%)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with zero", () => {
			const original = "ellipse(0 0)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});

		it("should round-trip ellipse with mixed units", () => {
			const original = "ellipse(2rem 100px at 30% top)";
			const parsed = Parse.ClipPath.Ellipse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Ellipse.toCss(parsed.value);
				const reparsed = Parse.ClipPath.Ellipse.parse(generated);
				expect(reparsed).toEqual(parsed);
			}
		});
	});
});


=== File: src/generate/clip-path/ellipse.ts ===
// b_path:: src/generate/clip-path/ellipse.ts
import type * as Type from "@/core/types";
import * as Generate from "@/generate";
import * as GenerateUtils from "@/utils/generate";

/**
 * Convert ellipse() IR to CSS string.
 *
 * Generates optimized CSS for ellipse() shape function.
 * Omits defaults (no radii = closest-side, no position = center).
 *
 * @param value - ClipPathEllipse IR
 * @returns CSS string
 *
 * @example
 * ```typescript
 * toCss({ kind: "clip-path-ellipse" });
 * // "ellipse()"
 *
 * toCss({ kind: "clip-path-ellipse", radiusX: { value: 50, unit: "px" } });
 * // "ellipse(50px)"
 *
 * toCss({
 *   kind: "clip-path-ellipse",
 *   radiusX: { value: 50, unit: "px" },
 *   radiusY: { value: 100, unit: "px" }
 * });
 * // "ellipse(50px 100px)"
 * ```
 *
 * @public
 */
export function toCss(value: Type.ClipPathEllipse): string {
	const parts: string[] = ["ellipse("];

	// Add radiusX if present
	if (value.radiusX !== undefined) {
		if (typeof value.radiusX === "string") {
			parts.push(value.radiusX);
		} else {
			parts.push(GenerateUtils.lengthPercentageToCss(value.radiusX));
		}
	}

	// Add radiusY if present
	if (value.radiusY !== undefined) {
		if (parts.length > 1) {
			parts.push(" ");
		}
		if (typeof value.radiusY === "string") {
			parts.push(value.radiusY);
		} else {
			parts.push(GenerateUtils.lengthPercentageToCss(value.radiusY));
		}
	}

	// Add position if present
	if (value.position !== undefined) {
		if (parts.length > 1) {
			parts.push(" ");
		}
		parts.push("at ");
		parts.push(Generate.Position.Utils.toCss(value.position));
	}

	parts.push(")");
	return parts.join("");
}


=== File: src/generate/clip-path/geometry-box.ts ===
// b_path:: src/generate/clip-path/geometry-box.ts

import type { ClipPathGeometryBox } from "@/core/types/clip-path";

/**
 * Generate CSS geometry-box keyword for clip-path property.
 *
 * Converts ClipPathGeometryBox IR to CSS keyword string.
 *
 * @param value - ClipPathGeometryBox IR value
 * @returns CSS string like "content-box" or "fill-box"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path#geometry-box}
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.ClipPath.GeometryBox.toCss({
 *   kind: "clip-path-geometry-box",
 *   value: "padding-box"
 * });
 * // "padding-box"
 * ```
 *
 * @public
 */
export function toCss(value: ClipPathGeometryBox): string {
	return value.value;
}


=== File: src/generate/clip-path/index.ts ===
// b_path:: src/generate/clip-path/index.ts

export * as Circle from "./circle";
export { generate } from "./clip-path";
export * as Ellipse from "./ellipse";
export * as GeometryBox from "./geometry-box";
export * as Inset from "./inset";
export * as None from "./none";
export * as Path from "./path";
export * as Polygon from "./polygon";
export * as Rect from "./rect";
export * as Url from "./url";
export * as Xywh from "./xywh";


=== File: src/generate/clip-path/inset.test.ts ===
// b_path:: src/generate/clip-path/inset.test.ts
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Parse from "@/parse/clip-path";
import { toCss } from "./inset";

describe("generate inset()", () => {
	describe("TRBL optimization", () => {
		it("should optimize all equal values to 1 value", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 10, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 10, unit: "px" },
			};

			expect(toCss(value)).toBe("inset(10px)");
		});

		it("should optimize vertical/horizontal pairs to 2 values", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 20, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 20, unit: "px" },
			};

			expect(toCss(value)).toBe("inset(10px 20px)");
		});

		it("should optimize horizontal same to 3 values", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 20, unit: "px" },
				bottom: { value: 30, unit: "px" },
				left: { value: 20, unit: "px" },
			};

			expect(toCss(value)).toBe("inset(10px 20px 30px)");
		});

		it("should generate all different as 4 values", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 20, unit: "px" },
				bottom: { value: 30, unit: "px" },
				left: { value: 40, unit: "px" },
			};

			expect(toCss(value)).toBe("inset(10px 20px 30px 40px)");
		});

		it("should preserve mixed units", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "%" },
				right: { value: 20, unit: "px" },
				bottom: { value: 5, unit: "em" },
				left: { value: 0, unit: "px" },
			};

			expect(toCss(value)).toBe("inset(10% 20px 5em 0px)");
		});

		it("should handle zero values", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 0, unit: "px" },
				right: { value: 0, unit: "px" },
				bottom: { value: 0, unit: "px" },
				left: { value: 0, unit: "px" },
			};

			expect(toCss(value)).toBe("inset(0px)");
		});

		it("should handle negative values", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: -10, unit: "px" },
				right: { value: -10, unit: "px" },
				bottom: { value: -10, unit: "px" },
				left: { value: -10, unit: "px" },
			};

			expect(toCss(value)).toBe("inset(-10px)");
		});
	});

	describe("border-radius optimization", () => {
		it("should optimize all equal radii to 1 value", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 10, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 10, unit: "px" },
				borderRadius: {
					topLeft: { value: 5, unit: "px" },
					topRight: { value: 5, unit: "px" },
					bottomRight: { value: 5, unit: "px" },
					bottomLeft: { value: 5, unit: "px" },
				},
			};

			expect(toCss(value)).toBe("inset(10px round 5px)");
		});

		it("should optimize diagonal pairs to 2 values", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 10, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 10, unit: "px" },
				borderRadius: {
					topLeft: { value: 5, unit: "px" },
					topRight: { value: 10, unit: "px" },
					bottomRight: { value: 5, unit: "px" },
					bottomLeft: { value: 10, unit: "px" },
				},
			};

			expect(toCss(value)).toBe("inset(10px round 5px 10px)");
		});

		it("should optimize TR/BL same to 3 values", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 10, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 10, unit: "px" },
				borderRadius: {
					topLeft: { value: 5, unit: "px" },
					topRight: { value: 10, unit: "px" },
					bottomRight: { value: 15, unit: "px" },
					bottomLeft: { value: 10, unit: "px" },
				},
			};

			expect(toCss(value)).toBe("inset(10px round 5px 10px 15px)");
		});

		it("should generate all different as 4 values", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 10, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 10, unit: "px" },
				borderRadius: {
					topLeft: { value: 5, unit: "px" },
					topRight: { value: 10, unit: "px" },
					bottomRight: { value: 15, unit: "px" },
					bottomLeft: { value: 20, unit: "px" },
				},
			};

			expect(toCss(value)).toBe("inset(10px round 5px 10px 15px 20px)");
		});

		it("should handle zero radius", () => {
			const value: Type.ClipPathInset = {
				kind: "clip-path-inset",
				top: { value: 10, unit: "px" },
				right: { value: 10, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 10, unit: "px" },
				borderRadius: {
					topLeft: { value: 0, unit: "px" },
					topRight: { value: 0, unit: "px" },
					bottomRight: { value: 0, unit: "px" },
					bottomLeft: { value: 0, unit: "px" },
				},
			};

			expect(toCss(value)).toBe("inset(10px round 0px)");
		});
	});

	describe("round-trip validation", () => {
		it("should round-trip simple inset", () => {
			const original = "inset(10px)";
			const parsed = Parse.Inset.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("should round-trip with 4 values", () => {
			const original = "inset(10px 20px 30px 40px)";
			const parsed = Parse.Inset.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("should round-trip with border-radius", () => {
			const original = "inset(10px round 5px)";
			const parsed = Parse.Inset.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("should normalize optimizable values", () => {
			const original = "inset(10px 10px 10px 10px)";
			const parsed = Parse.Inset.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				expect(generated).toBe("inset(10px)");
			}
		});

		it("should round-trip complex example", () => {
			const original = "inset(5% 10% 15% 20% round 2px 4px 6px 8px)";
			const parsed = Parse.Inset.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});
	});
});


=== File: src/generate/clip-path/inset.ts ===
// b_path:: src/generate/clip-path/inset.ts
import type * as Type from "@/core/types";
import * as GenerateUtils from "@/utils/generate";

/**
 * Generate CSS for inset() function.
 *
 * Optimizes TRBL values to shortest form:
 * - 4 equal values → 1 value
 * - top/bottom same, left/right same → 2 values
 * - etc.
 *
 * @param value - ClipPathInset IR
 * @returns CSS inset() function string
 *
 * @example
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-inset",
 *   top: { value: 10, unit: "px" },
 *   right: { value: 10, unit: "px" },
 *   bottom: { value: 10, unit: "px" },
 *   left: { value: 10, unit: "px" }
 * });
 * // "inset(10px)"
 * ```
 *
 * @public
 */
export function toCss(value: Type.ClipPathInset): string {
	// Generate TRBL CSS (optimized to shortest form)
	const trblCss = generateTRBL({
		top: value.top,
		right: value.right,
		bottom: value.bottom,
		left: value.left,
	});

	// Generate optional border-radius
	let radiusCss = "";
	if (value.borderRadius) {
		radiusCss = ` round ${GenerateUtils.borderRadiusToCss(value.borderRadius)}`;
	}

	return `inset(${trblCss}${radiusCss})`;
}

/**
 * Generate TRBL CSS in shortest form.
 *
 * @internal
 */
function generateTRBL(trbl: {
	top: Type.LengthPercentage;
	right: Type.LengthPercentage;
	bottom: Type.LengthPercentage;
	left: Type.LengthPercentage;
}): string {
	const top = GenerateUtils.lengthPercentageToCss(trbl.top);
	const right = GenerateUtils.lengthPercentageToCss(trbl.right);
	const bottom = GenerateUtils.lengthPercentageToCss(trbl.bottom);
	const left = GenerateUtils.lengthPercentageToCss(trbl.left);

	// Check for optimization opportunities
	if (top === right && right === bottom && bottom === left) {
		// All equal: 1 value
		return top;
	}

	if (top === bottom && right === left) {
		// Vertical same, horizontal same: 2 values
		return `${top} ${right}`;
	}

	if (right === left) {
		// Left/right same: 3 values
		return `${top} ${right} ${bottom}`;
	}

	// All different: 4 values
	return `${top} ${right} ${bottom} ${left}`;
}


=== File: src/generate/clip-path/none.ts ===
// b_path:: src/generate/clip-path/none.ts

import type { ClipPathNone } from "@/core/types/clip-path";

/**
 * Generate CSS none keyword for clip-path property.
 *
 * Converts ClipPathNone IR to CSS "none" keyword.
 *
 * @param _value - ClipPathNone IR value (unused)
 * @returns CSS string "none"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.ClipPath.None.toCss({ kind: "clip-path-none" });
 * // "none"
 * ```
 *
 * @public
 */
export function toCss(_value: ClipPathNone): string {
	return "none";
}


=== File: src/generate/clip-path/path.test.ts ===
// b_path:: src/generate/clip-path/path.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "@/parse/clip-path/path";
import { toCss } from "./path";

describe("generate path()", () => {
	describe("basic path data", () => {
		it("should generate simple path", () => {
			const css = toCss({
				kind: "clip-path-path",
				pathData: "M 10,10 L 90,10 L 50,90 Z",
			});

			expect(css).toBe("path('M 10,10 L 90,10 L 50,90 Z')");
		});

		it("should generate path with lowercase commands", () => {
			const css = toCss({
				kind: "clip-path-path",
				pathData: "m 10,10 l 80,0 l -40,80 z",
			});

			expect(css).toBe("path('m 10,10 l 80,0 l -40,80 z')");
		});

		it("should generate compact path syntax", () => {
			const css = toCss({
				kind: "clip-path-path",
				pathData: "M10 10L90 10L50 90z",
			});

			expect(css).toBe("path('M10 10L90 10L50 90z')");
		});

		it("should generate path with various commands", () => {
			const css = toCss({
				kind: "clip-path-path",
				pathData: "M 0,0 H 100 V 100 L 0,100 Z",
			});

			expect(css).toBe("path('M 0,0 H 100 V 100 L 0,100 Z')");
		});
	});

	describe("fill-rule", () => {
		it("should generate with nonzero fill-rule", () => {
			const css = toCss({
				kind: "clip-path-path",
				fillRule: "nonzero",
				pathData: "M 10,10 L 90,10 Z",
			});

			expect(css).toBe("path(nonzero, 'M 10,10 L 90,10 Z')");
		});

		it("should generate with evenodd fill-rule", () => {
			const css = toCss({
				kind: "clip-path-path",
				fillRule: "evenodd",
				pathData: "M 10,10 L 90,10 Z",
			});

			expect(css).toBe("path(evenodd, 'M 10,10 L 90,10 Z')");
		});
	});

	describe("round-trip", () => {
		it("should round-trip basic path", () => {
			const input = "path('M 10,10 L 90,10 L 50,90 Z')";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip with fill-rule", () => {
			const input = "path(evenodd, 'M 10,10 L 90,10 Z')";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip compact syntax", () => {
			const input = "path('M10 10L90 10L50 90z')";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip with curves", () => {
			const input = "path('M 10,10 C 20,20 40,20 50,10')";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/clip-path/path.ts ===
// b_path:: src/generate/clip-path/path.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS for path() function.
 *
 * Outputs the path data string, optionally prefixed with fill-rule.
 *
 * @param value - ClipPathPath IR
 * @returns CSS path() function string
 *
 * @example
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-path",
 *   pathData: "M 10,10 L 90,10 L 50,90 Z"
 * });
 * // "path('M 10,10 L 90,10 L 50,90 Z')"
 * ```
 *
 * @example
 * With fill-rule:
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-path",
 *   fillRule: "evenodd",
 *   pathData: "M 10,10 L 90,10 Z"
 * });
 * // "path(evenodd, 'M 10,10 L 90,10 Z')"
 * ```
 *
 * @public
 */
export function toCss(value: Type.ClipPathPath): string {
	const pathDataEscaped = value.pathData.replace(/'/g, "\\'");

	if (value.fillRule) {
		return `path(${value.fillRule}, '${pathDataEscaped}')`;
	}

	return `path('${pathDataEscaped}')`;
}


=== File: src/generate/clip-path/polygon.test.ts ===
// b_path:: src/generate/clip-path/polygon.test.ts

import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/clip-path/polygon";
import * as Polygon from "./polygon";

describe("Generate.ClipPath.Polygon.toCss", () => {
	describe("basic generation", () => {
		it("should generate 3-point triangle", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				points: [
					{ x: { value: 50, unit: "%" as const }, y: { value: 0, unit: "%" as const } },
					{ x: { value: 100, unit: "%" as const }, y: { value: 100, unit: "%" as const } },
					{ x: { value: 0, unit: "%" as const }, y: { value: 100, unit: "%" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(50% 0%, 100% 100%, 0% 100%)");
		});

		it("should generate 4-point square", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				points: [
					{ x: { value: 0, unit: "px" as const }, y: { value: 0, unit: "px" as const } },
					{ x: { value: 100, unit: "px" as const }, y: { value: 0, unit: "px" as const } },
					{ x: { value: 100, unit: "px" as const }, y: { value: 100, unit: "px" as const } },
					{ x: { value: 0, unit: "px" as const }, y: { value: 100, unit: "px" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(0px 0px, 100px 0px, 100px 100px, 0px 100px)");
		});

		it("should generate 5-point pentagon", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				points: [
					{ x: { value: 50, unit: "%" as const }, y: { value: 0, unit: "%" as const } },
					{ x: { value: 100, unit: "%" as const }, y: { value: 38, unit: "%" as const } },
					{ x: { value: 82, unit: "%" as const }, y: { value: 100, unit: "%" as const } },
					{ x: { value: 18, unit: "%" as const }, y: { value: 100, unit: "%" as const } },
					{ x: { value: 0, unit: "%" as const }, y: { value: 38, unit: "%" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)");
		});

		it("should generate polygon with mixed units", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				points: [
					{ x: { value: 10, unit: "px" as const }, y: { value: 20, unit: "%" as const } },
					{ x: { value: 50, unit: "%" as const }, y: { value: 30, unit: "px" as const } },
					{ x: { value: 100, unit: "px" as const }, y: { value: 100, unit: "%" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(10px 20%, 50% 30px, 100px 100%)");
		});

		it("should generate polygon with zero values", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				points: [
					{ x: { value: 0, unit: "px" as const }, y: { value: 0, unit: "px" as const } },
					{ x: { value: 100, unit: "px" as const }, y: { value: 0, unit: "px" as const } },
					{ x: { value: 100, unit: "px" as const }, y: { value: 100, unit: "px" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(0px 0px, 100px 0px, 100px 100px)");
		});
	});

	describe("fill-rule generation", () => {
		it("should generate with nonzero fill-rule", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				fillRule: "nonzero" as const,
				points: [
					{ x: { value: 50, unit: "%" as const }, y: { value: 0, unit: "%" as const } },
					{ x: { value: 100, unit: "%" as const }, y: { value: 50, unit: "%" as const } },
					{ x: { value: 50, unit: "%" as const }, y: { value: 100, unit: "%" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(nonzero, 50% 0%, 100% 50%, 50% 100%)");
		});

		it("should generate with evenodd fill-rule", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				fillRule: "evenodd" as const,
				points: [
					{ x: { value: 0, unit: "px" as const }, y: { value: 0, unit: "px" as const } },
					{ x: { value: 100, unit: "px" as const }, y: { value: 0, unit: "px" as const } },
					{ x: { value: 100, unit: "px" as const }, y: { value: 100, unit: "px" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(evenodd, 0px 0px, 100px 0px, 100px 100px)");
		});

		it("should generate without fill-rule when omitted", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				points: [
					{ x: { value: 50, unit: "%" as const }, y: { value: 0, unit: "%" as const } },
					{ x: { value: 100, unit: "%" as const }, y: { value: 50, unit: "%" as const } },
					{ x: { value: 50, unit: "%" as const }, y: { value: 100, unit: "%" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(50% 0%, 100% 50%, 50% 100%)");
		});
	});

	describe("complex shapes", () => {
		it("should generate 10-point star", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				points: [
					{ x: { value: 50, unit: "%" as const }, y: { value: 0, unit: "%" as const } },
					{ x: { value: 61, unit: "%" as const }, y: { value: 35, unit: "%" as const } },
					{ x: { value: 98, unit: "%" as const }, y: { value: 35, unit: "%" as const } },
					{ x: { value: 68, unit: "%" as const }, y: { value: 57, unit: "%" as const } },
					{ x: { value: 79, unit: "%" as const }, y: { value: 91, unit: "%" as const } },
					{ x: { value: 50, unit: "%" as const }, y: { value: 70, unit: "%" as const } },
					{ x: { value: 21, unit: "%" as const }, y: { value: 91, unit: "%" as const } },
					{ x: { value: 32, unit: "%" as const }, y: { value: 57, unit: "%" as const } },
					{ x: { value: 2, unit: "%" as const }, y: { value: 35, unit: "%" as const } },
					{ x: { value: 39, unit: "%" as const }, y: { value: 35, unit: "%" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe(
				"polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)",
			);
		});

		it("should generate 6-sided hexagon", () => {
			const polygon = {
				kind: "clip-path-polygon" as const,
				points: [
					{ x: { value: 50, unit: "%" as const }, y: { value: 0, unit: "%" as const } },
					{ x: { value: 100, unit: "%" as const }, y: { value: 25, unit: "%" as const } },
					{ x: { value: 100, unit: "%" as const }, y: { value: 75, unit: "%" as const } },
					{ x: { value: 50, unit: "%" as const }, y: { value: 100, unit: "%" as const } },
					{ x: { value: 0, unit: "%" as const }, y: { value: 75, unit: "%" as const } },
					{ x: { value: 0, unit: "%" as const }, y: { value: 25, unit: "%" as const } },
				],
			};
			expect(Polygon.toCss(polygon)).toBe("polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)");
		});
	});

	describe("edge cases", () => {
		it("should handle many points", () => {
			const points = Array.from({ length: 20 }, (_, i) => ({
				x: { value: i * 5, unit: "%" as const },
				y: { value: (i * 3) % 100, unit: "%" as const },
			}));
			const polygon = {
				kind: "clip-path-polygon" as const,
				points,
			};
			const css = Polygon.toCss(polygon);
			expect(css).toContain("polygon(");
			expect(css.split(",").length).toBe(20); // 20 points = 20 commas separating them
		});
	});

	describe("round-trip", () => {
		it("should round-trip basic triangle", () => {
			const css = "polygon(50% 0%, 100% 100%, 0% 100%)";
			const parsed = Parse.parse(css);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Polygon.toCss(parsed.value);
			expect(generated).toBe(css);
		});

		it("should round-trip with fill-rule", () => {
			const css = "polygon(nonzero, 50% 0%, 100% 50%, 50% 100%)";
			const parsed = Parse.parse(css);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Polygon.toCss(parsed.value);
			expect(generated).toBe(css);
		});

		it("should round-trip square", () => {
			const css = "polygon(0px 0px, 100px 0px, 100px 100px, 0px 100px)";
			const parsed = Parse.parse(css);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Polygon.toCss(parsed.value);
			expect(generated).toBe(css);
		});

		it("should round-trip mixed units", () => {
			const css = "polygon(10px 20%, 50% 30px, 100px 100%)";
			const parsed = Parse.parse(css);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Polygon.toCss(parsed.value);
			expect(generated).toBe(css);
		});

		it("should round-trip hexagon", () => {
			const css = "polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)";
			const parsed = Parse.parse(css);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Polygon.toCss(parsed.value);
			expect(generated).toBe(css);
		});

		it("should round-trip with evenodd", () => {
			const css = "polygon(evenodd, 0px 0px, 100px 0px, 100px 100px)";
			const parsed = Parse.parse(css);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Polygon.toCss(parsed.value);
			expect(generated).toBe(css);
		});

		it("should round-trip star", () => {
			const css = "polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)";
			const parsed = Parse.parse(css);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Polygon.toCss(parsed.value);
			expect(generated).toBe(css);
		});
	});
});


=== File: src/generate/clip-path/polygon.ts ===
// b_path:: src/generate/clip-path/polygon.ts

import type * as Type from "@/core/types";
import * as GenerateUtils from "@/utils/generate";

/**
 * Generate CSS polygon() function from ClipPathPolygon IR.
 *
 * Syntax: polygon( <fill-rule>? , <shape-arg># )
 *
 * @param polygon - ClipPathPolygon IR
 * @returns CSS string
 *
 * @example
 * toCss({ kind: "clip-path-polygon", points: [{x: {value:50, unit:"%"}, y: {value:0, unit:"%"}}, ...] });
 * // "polygon(50% 0%, 100% 50%, 50% 100%)"
 *
 * toCss({ kind: "clip-path-polygon", fillRule: "nonzero", points: [...] });
 * // "polygon(nonzero, 50% 0%, 100% 50%, 50% 100%)"
 *
 * @public
 */
export function toCss(polygon: Type.ClipPathPolygon): string {
	const parts: string[] = ["polygon("];

	// Add fill-rule if present
	if (polygon.fillRule) {
		parts.push(polygon.fillRule, ", ");
	}

	// Add points
	const pointStrings = polygon.points.map((point) => {
		const x = GenerateUtils.lengthPercentageToCss(point.x);
		const y = GenerateUtils.lengthPercentageToCss(point.y);
		return `${x} ${y}`;
	});

	parts.push(pointStrings.join(", "));
	parts.push(")");

	return parts.join("");
}


=== File: src/generate/clip-path/rect.test.ts ===
// b_path:: src/generate/clip-path/rect.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "@/parse/clip-path/rect";
import { toCss } from "./rect";

describe("generate rect()", () => {
	describe("basic TRBL", () => {
		it("should generate four values", () => {
			const css = toCss({
				kind: "clip-path-rect",
				top: { value: 10, unit: "px" },
				right: { value: 20, unit: "px" },
				bottom: { value: 30, unit: "px" },
				left: { value: 40, unit: "px" },
			});

			expect(css).toBe("rect(10px 20px 30px 40px)");
		});

		it("should generate with percentages", () => {
			const css = toCss({
				kind: "clip-path-rect",
				top: { value: 10, unit: "%" },
				right: { value: 20, unit: "%" },
				bottom: { value: 30, unit: "%" },
				left: { value: 40, unit: "%" },
			});

			expect(css).toBe("rect(10% 20% 30% 40%)");
		});

		it("should generate with zero values", () => {
			const css = toCss({
				kind: "clip-path-rect",
				top: { value: 0, unit: "px" },
				right: { value: 0, unit: "px" },
				bottom: { value: 0, unit: "px" },
				left: { value: 0, unit: "px" },
			});

			expect(css).toBe("rect(0px 0px 0px 0px)");
		});
	});

	describe("auto keyword", () => {
		it("should generate auto for all sides", () => {
			const css = toCss({
				kind: "clip-path-rect",
				top: "auto",
				right: "auto",
				bottom: "auto",
				left: "auto",
			});

			expect(css).toBe("rect(auto auto auto auto)");
		});

		it("should generate mixed auto and lengths", () => {
			const css = toCss({
				kind: "clip-path-rect",
				top: { value: 10, unit: "px" },
				right: "auto",
				bottom: { value: 20, unit: "px" },
				left: "auto",
			});

			expect(css).toBe("rect(10px auto 20px auto)");
		});
	});

	describe("border-radius", () => {
		it("should generate with single border-radius", () => {
			const css = toCss({
				kind: "clip-path-rect",
				top: { value: 10, unit: "px" },
				right: { value: 10, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 10, unit: "px" },
				borderRadius: {
					topLeft: { value: 5, unit: "px" },
					topRight: { value: 5, unit: "px" },
					bottomRight: { value: 5, unit: "px" },
					bottomLeft: { value: 5, unit: "px" },
				},
			});

			expect(css).toBe("rect(10px 10px 10px 10px round 5px)");
		});

		it("should generate with different border-radius values", () => {
			const css = toCss({
				kind: "clip-path-rect",
				top: { value: 10, unit: "px" },
				right: { value: 10, unit: "px" },
				bottom: { value: 10, unit: "px" },
				left: { value: 10, unit: "px" },
				borderRadius: {
					topLeft: { value: 5, unit: "px" },
					topRight: { value: 10, unit: "px" },
					bottomRight: { value: 5, unit: "px" },
					bottomLeft: { value: 10, unit: "px" },
				},
			});

			expect(css).toBe("rect(10px 10px 10px 10px round 5px 10px)");
		});
	});

	describe("round-trip", () => {
		it("should round-trip basic rect", () => {
			const input = "rect(10px 20px 30px 40px)";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip with auto", () => {
			const input = "rect(10px auto 20px auto)";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip with border-radius", () => {
			const input = "rect(10px 20px 30px 40px round 5px)";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/clip-path/rect.ts ===
// b_path:: src/generate/clip-path/rect.ts
import type * as Type from "@/core/types";
import * as GenerateUtils from "@/utils/generate";

/**
 * Generate CSS for rect() function.
 *
 * Always outputs all 4 values for clarity (top right bottom left).
 * Does not optimize to shorter forms.
 *
 * @param value - ClipPathRect IR
 * @returns CSS rect() function string
 *
 * @example
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-rect",
 *   top: { value: 10, unit: "px" },
 *   right: "auto",
 *   bottom: { value: 20, unit: "px" },
 *   left: "auto"
 * });
 * // "rect(10px auto 20px auto)"
 * ```
 *
 * @public
 */
export function toCss(value: Type.ClipPathRect): string {
	// Generate TRBL CSS (always 4 values)
	const top = value.top === "auto" ? "auto" : GenerateUtils.lengthPercentageToCss(value.top);
	const right = value.right === "auto" ? "auto" : GenerateUtils.lengthPercentageToCss(value.right);
	const bottom = value.bottom === "auto" ? "auto" : GenerateUtils.lengthPercentageToCss(value.bottom);
	const left = value.left === "auto" ? "auto" : GenerateUtils.lengthPercentageToCss(value.left);

	const trblCss = `${top} ${right} ${bottom} ${left}`;

	// Generate optional border-radius
	let radiusCss = "";
	if (value.borderRadius) {
		radiusCss = ` round ${GenerateUtils.borderRadiusToCss(value.borderRadius)}`;
	}

	return `rect(${trblCss}${radiusCss})`;
}


=== File: src/generate/clip-path/url.ts ===
// b_path:: src/generate/clip-path/url.ts

import type { Url } from "@/core/types/url";
import { urlToCss } from "@/utils/generate/url";

/**
 * Generate CSS url() for clip-path property.
 *
 * Converts Url IR to CSS url() function string.
 *
 * @param value - Url IR value
 * @returns CSS string like "url(#clip-shape)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.ClipPath.Url.toCss({
 *   kind: "url",
 *   value: "#clip-shape"
 * });
 * // "url(#clip-shape)"
 * ```
 *
 * @public
 */
export function toCss(value: Url): string {
	return urlToCss(value);
}


=== File: src/generate/clip-path/xywh.test.ts ===
// b_path:: src/generate/clip-path/xywh.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "@/parse/clip-path/xywh";
import { toCss } from "./xywh";

describe("generate xywh()", () => {
	describe("basic position and size", () => {
		it("should generate four values", () => {
			const css = toCss({
				kind: "clip-path-xywh",
				x: { value: 10, unit: "px" },
				y: { value: 20, unit: "px" },
				width: { value: 100, unit: "px" },
				height: { value: 50, unit: "px" },
			});

			expect(css).toBe("xywh(10px 20px 100px 50px)");
		});

		it("should generate with percentages", () => {
			const css = toCss({
				kind: "clip-path-xywh",
				x: { value: 0, unit: "%" },
				y: { value: 0, unit: "%" },
				width: { value: 100, unit: "%" },
				height: { value: 100, unit: "%" },
			});

			expect(css).toBe("xywh(0% 0% 100% 100%)");
		});

		it("should generate with zero values", () => {
			const css = toCss({
				kind: "clip-path-xywh",
				x: { value: 0, unit: "px" },
				y: { value: 0, unit: "px" },
				width: { value: 0, unit: "px" },
				height: { value: 0, unit: "px" },
			});

			expect(css).toBe("xywh(0px 0px 0px 0px)");
		});

		it("should generate with mixed units", () => {
			const css = toCss({
				kind: "clip-path-xywh",
				x: { value: 10, unit: "px" },
				y: { value: 5, unit: "em" },
				width: { value: 50, unit: "%" },
				height: { value: 80, unit: "px" },
			});

			expect(css).toBe("xywh(10px 5em 50% 80px)");
		});
	});

	describe("border-radius", () => {
		it("should generate with single border-radius", () => {
			const css = toCss({
				kind: "clip-path-xywh",
				x: { value: 10, unit: "px" },
				y: { value: 20, unit: "px" },
				width: { value: 100, unit: "px" },
				height: { value: 50, unit: "px" },
				borderRadius: {
					topLeft: { value: 5, unit: "px" },
					topRight: { value: 5, unit: "px" },
					bottomRight: { value: 5, unit: "px" },
					bottomLeft: { value: 5, unit: "px" },
				},
			});

			expect(css).toBe("xywh(10px 20px 100px 50px round 5px)");
		});

		it("should generate with different border-radius values", () => {
			const css = toCss({
				kind: "clip-path-xywh",
				x: { value: 0, unit: "%" },
				y: { value: 0, unit: "%" },
				width: { value: 100, unit: "%" },
				height: { value: 100, unit: "%" },
				borderRadius: {
					topLeft: { value: 5, unit: "px" },
					topRight: { value: 10, unit: "px" },
					bottomRight: { value: 5, unit: "px" },
					bottomLeft: { value: 10, unit: "px" },
				},
			});

			expect(css).toBe("xywh(0% 0% 100% 100% round 5px 10px)");
		});
	});

	describe("round-trip", () => {
		it("should round-trip basic xywh", () => {
			const input = "xywh(10px 20px 100px 50px)";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip with border-radius", () => {
			const input = "xywh(0 0 100% 100% round 10px)";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip with mixed units", () => {
			const input = "xywh(10px 5em 50% 80px round 5px 10px)";
			const parsed = parse(input);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = toCss(parsed.value);
				const reparsed = parse(generated);

				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/clip-path/xywh.ts ===
// b_path:: src/generate/clip-path/xywh.ts
import type * as Type from "@/core/types";
import * as GenerateUtils from "@/utils/generate";

/**
 * Generate CSS for xywh() function.
 *
 * Always outputs all 4 values (x, y, width, height).
 *
 * @param value - ClipPathXywh IR
 * @returns CSS xywh() function string
 *
 * @example
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-xywh",
 *   x: { value: 10, unit: "px" },
 *   y: { value: 20, unit: "px" },
 *   width: { value: 100, unit: "px" },
 *   height: { value: 50, unit: "px" }
 * });
 * // "xywh(10px 20px 100px 50px)"
 * ```
 *
 * @public
 */
export function toCss(value: Type.ClipPathXywh): string {
	const x = GenerateUtils.lengthPercentageToCss(value.x);
	const y = GenerateUtils.lengthPercentageToCss(value.y);
	const width = GenerateUtils.lengthPercentageToCss(value.width);
	const height = GenerateUtils.lengthPercentageToCss(value.height);

	const xywhCss = `${x} ${y} ${width} ${height}`;

	// Generate optional border-radius
	let radiusCss = "";
	if (value.borderRadius) {
		radiusCss = ` round ${GenerateUtils.borderRadiusToCss(value.borderRadius)}`;
	}

	return `xywh(${xywhCss}${radiusCss})`;
}


=== File: src/generate/color/color-function.test.ts ===
// b_path:: src/generate/color/color-function.test.ts
import { describe, expect, test } from "vitest";
import * as Parse from "../../parse/color/color-function";
import * as Generate from "./color-function";

describe("toCss() - color() function generator", () => {
	describe("Basic Generation", () => {
		test("srgb color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toBe("color(srgb 0.5 0.2 0.8)");
		});

		test("srgb-linear color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb-linear",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toBe("color(srgb-linear 0.5 0.2 0.8)");
		});

		test("display-p3 color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "display-p3",
				channels: [0.928, 0.322, 0.203],
			});
			expect(css).toBe("color(display-p3 0.928 0.322 0.203)");
		});

		test("a98-rgb color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "a98-rgb",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toBe("color(a98-rgb 0.5 0.2 0.8)");
		});

		test("prophoto-rgb color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "prophoto-rgb",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toBe("color(prophoto-rgb 0.5 0.2 0.8)");
		});

		test("rec2020 color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "rec2020",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toBe("color(rec2020 0.5 0.2 0.8)");
		});

		test("xyz color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "xyz",
				channels: [0.3, 0.4, 0.5],
			});
			expect(css).toBe("color(xyz 0.3 0.4 0.5)");
		});

		test("xyz-d50 color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "xyz-d50",
				channels: [0.3, 0.4, 0.5],
			});
			expect(css).toBe("color(xyz-d50 0.3 0.4 0.5)");
		});

		test("xyz-d65 color space", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "xyz-d65",
				channels: [0.3, 0.4, 0.5],
			});
			expect(css).toBe("color(xyz-d65 0.3 0.4 0.5)");
		});
	});

	describe("Alpha Generation", () => {
		test("color with alpha", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
				alpha: 0.5,
			});
			expect(css).toBe("color(srgb 0.5 0.2 0.8 / 0.5)");
		});

		test("color without alpha", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toBe("color(srgb 0.5 0.2 0.8)");
		});

		test("alpha 0", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
				alpha: 0,
			});
			expect(css).toBe("color(srgb 0.5 0.2 0.8 / 0)");
		});

		test("alpha 1", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
				alpha: 1,
			});
			expect(css).toBe("color(srgb 0.5 0.2 0.8 / 1)");
		});
	});

	describe("Precision and Rounding", () => {
		test("rounds trailing zeros", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.20000000000001, 0.8],
			});
			expect(css).toBe("color(srgb 0.5 0.2 0.8)");
		});

		test("preserves necessary precision", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.123456, 0.789012, 0.345678],
			});
			expect(css).toBe("color(srgb 0.123456 0.789012 0.345678)");
		});

		test("handles zero values", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [0, 0, 0],
			});
			expect(css).toBe("color(srgb 0 0 0)");
		});

		test("handles one values", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "srgb",
				channels: [1, 1, 1],
			});
			expect(css).toBe("color(srgb 1 1 1)");
		});

		test("handles negative values", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "xyz",
				channels: [-0.1, 0.5, -0.2],
			});
			expect(css).toBe("color(xyz -0.1 0.5 -0.2)");
		});

		test("handles values over 1", () => {
			const css = Generate.toCss({
				kind: "color",
				colorSpace: "xyz",
				channels: [1.5, 2.0, 1.8],
			});
			expect(css).toBe("color(xyz 1.5 2 1.8)");
		});
	});

	describe("Round-Trip", () => {
		test("parse and generate srgb", () => {
			const original = "color(srgb 0.5 0.2 0.8)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe(original);

				const reparsed = Parse.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		test("parse and generate display-p3 with alpha", () => {
			const original = "color(display-p3 0.928 0.322 0.203 / 0.8)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe(original);

				const reparsed = Parse.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		test("parse and generate xyz-d50", () => {
			const original = "color(xyz-d50 0.3 0.4 0.5)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe(original);

				const reparsed = Parse.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/color/color-function.ts ===
// b_path:: src/generate/color/color-function.ts
import type * as Type from "@/core/types";

/**
 * Convert color() IR to CSS string.
 *
 * @param value - ColorFunction IR
 * @returns CSS color() function string
 *
 * @example
 * ```typescript
 * toCss({
 *   kind: "color",
 *   colorSpace: "display-p3",
 *   channels: [0.928, 0.322, 0.203],
 *   alpha: 0.8
 * });
 * // "color(display-p3 0.928 0.322 0.203 / 0.8)"
 * ```
 *
 * @public
 */
export function toCss(value: Type.ColorFunction): string {
	const parts: string[] = ["color(", value.colorSpace];

	// Add channels
	for (const channel of value.channels) {
		parts.push(" ");
		parts.push(channel.toFixed(6).replace(/\.?0+$/, "") || "0");
	}

	// Add alpha if present
	if (value.alpha !== undefined) {
		parts.push(" / ");
		parts.push(value.alpha.toFixed(6).replace(/\.?0+$/, "") || "0");
	}

	parts.push(")");
	return parts.join("");
}


=== File: src/generate/color/color.test.ts ===
// b_path:: src/generate/color/color.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./color";

describe("Color.generate()", () => {
	test("generates hex color", () => {
		const color: Type.Color = { kind: "hex", value: "#FF0000" };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("#FF0000");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates named color", () => {
		const color: Type.Color = { kind: "named", name: "red" };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("red");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates rgb color", () => {
		const color: Type.Color = { kind: "rgb", r: 255, g: 0, b: 0 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rgb(255 0 0)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates rgb color with alpha", () => {
		const color: Type.Color = { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rgb(255 0 0 / 0.5)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates hsl color", () => {
		const color: Type.Color = { kind: "hsl", h: 120, s: 100, l: 50 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("hsl(120 100% 50%)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates hwb color", () => {
		const color: Type.Color = { kind: "hwb", h: 120, w: 20, b: 30 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("hwb(120 20% 30%)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates lab color", () => {
		const color: Type.Color = { kind: "lab", l: 50, a: -20, b: 30 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("lab(50 -20 30)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates lch color", () => {
		const color: Type.Color = { kind: "lch", l: 50, c: 50, h: 180 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("lch(50 50 180)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates oklab color", () => {
		const color: Type.Color = { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("oklab(0.5 -0.2 0.3)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates oklch color", () => {
		const color: Type.Color = { kind: "oklch", l: 0.5, c: 0.2, h: 180 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("oklch(0.5 0.2 180)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates system color", () => {
		const color: Type.Color = { kind: "system", keyword: "ButtonText" };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ButtonText");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates special color", () => {
		const color: Type.Color = { kind: "special", keyword: "transparent" };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("transparent");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates color() function", () => {
		const color: Type.Color = {
			kind: "color",
			colorSpace: "display-p3",
			channels: [0.928, 0.322, 0.203],
		};
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("color(display-p3 0.928 0.322 0.203)");
			expect(result.issues).toEqual([]);
		}
	});

	test("returns error for invalid IR (missing kind)", () => {
		const color = {} as Type.Color;
		const result = generate(color);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});

	test("returns error for unknown kind", () => {
		const color = { kind: "unknown" } as unknown as Type.Color;
		const result = generate(color);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("Unknown color kind");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});
});


=== File: src/generate/color/color.ts ===
// b_path:: src/generate/color/color.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as ColorFunction from "./color-function";
import * as Hex from "./hex";
import * as Hsl from "./hsl";
import * as Hwb from "./hwb";
import * as Lab from "./lab";
import * as Lch from "./lch";
import * as Named from "./named";
import * as Oklab from "./oklab";
import * as Oklch from "./oklch";
import * as Rgb from "./rgb";
import * as Special from "./special";
import * as System from "./system";

/**
 * Generate CSS from color IR with auto-detection.
 *
 * Automatically detects color format from IR.kind and generates appropriate CSS.
 * Supports all 12 CSS color formats.
 *
 * @param color - Color IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate({ kind: "hex", value: "#FF0000" })
 * // → { ok: true, value: "#FF0000", issues: [] }
 *
 * generate({ kind: "rgb", r: 255, g: 0, b: 0 })
 * // → { ok: true, value: "rgb(255 0 0)", issues: [] }
 *
 * generate({ kind: "hsl", h: 120, s: 100, l: 50 })
 * // → { ok: true, value: "hsl(120 100% 50%)", issues: [] }
 * ```
 *
 * @public
 */
export function generate(color: Type.Color): GenerateResult {
	// Validate IR has 'kind' field
	if (!color || typeof color !== "object" || !("kind" in color)) {
		return generateErr("missing-required-field", "Invalid color IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (color.kind) {
		case "hex":
			return generateOk(Hex.toCss(color));

		case "named":
			return generateOk(Named.toCss(color));

		case "rgb":
			return generateOk(Rgb.toCss(color));

		case "hsl":
			return generateOk(Hsl.toCss(color));

		case "hwb":
			return generateOk(Hwb.toCss(color));

		case "lab":
			return generateOk(Lab.toCss(color));

		case "lch":
			return generateOk(Lch.toCss(color));

		case "oklab":
			return generateOk(Oklab.toCss(color));

		case "oklch":
			return generateOk(Oklch.toCss(color));

		case "system":
			return generateOk(System.toCss(color));

		case "special":
			return generateOk(Special.toCss(color));

		case "color":
			return generateOk(ColorFunction.toCss(color));

		default:
			return generateErr("unsupported-kind", `Unknown color kind: ${(color as { kind?: string }).kind}`, {
				suggestion: "Check that color IR is valid",
			});
	}
}


=== File: src/generate/color/hex.ts ===
// b_path:: src/generate/color/hex.ts
import type { HexColor } from "@/core/types/color";

/**
 * Generate CSS from a hex color value.
 *
 * Converts a HexColor IR back to its CSS string representation.
 * Output is always uppercase #RRGGBB or #RRGGBBAA format.
 *
 * @param color - The hex color to convert
 * @returns CSS hex color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/hex";
 *
 * const css1 = toCss({ kind: "hex", value: "#FF5733" });
 * // => "#FF5733"
 *
 * const css2 = toCss({ kind: "hex", value: "#FF573380" });
 * // => "#FF573380"
 * ```
 *
 * @public
 */
export function toCss(color: HexColor): string {
	return color.value;
}


=== File: src/generate/color/hsl.ts ===
// b_path:: src/generate/color/hsl.ts
import type { HSLColor } from "@/core/types/color";

/**
 * Generate CSS from an HSL color value.
 *
 * Converts an HSLColor IR back to its CSS string representation.
 * Uses modern space-separated syntax without units on percentages.
 *
 * @param color - The HSL color to convert
 * @returns CSS HSL color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/hsl";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "hsl", h: 120, s: 100, l: 50 });
 * // => "hsl(120 100% 50%)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "hsl", h: 120, s: 100, l: 50, alpha: 0.5 });
 * // => "hsl(120 100% 50% / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "hsl", h: 120, s: 100, l: 50, alpha: 1 });
 * // => "hsl(120 100% 50%)"
 * ```
 *
 * @public
 */
export function toCss(color: HSLColor): string {
	const { h, s, l, alpha } = color;

	// Format HSL values (hue as number, saturation and lightness with %)
	const hslPart = `${h} ${s}% ${l}%`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return `hsl(${hslPart} / ${alpha})`;
	}

	return `hsl(${hslPart})`;
}


=== File: src/generate/color/hwb.ts ===
// b_path:: src/generate/color/hwb.ts
import type { HWBColor } from "@/core/types/color";

/**
 * Generate CSS string from HWB color object.
 *
 * Always outputs modern space-separated syntax:
 * - `hwb(120 20% 30%)` - without alpha
 * - `hwb(120 20% 30% / 0.5)` - with alpha
 *
 * @param color - The HWB color object
 * @returns CSS HWB color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/hwb";
 *
 * // Basic HWB
 * toCss({ kind: "hwb", h: 120, w: 20, b: 30 });
 * // => "hwb(120 20% 30%)"
 *
 * // With alpha
 * toCss({ kind: "hwb", h: 120, w: 20, b: 30, alpha: 0.5 });
 * // => "hwb(120 20% 30% / 0.5)"
 * ```
 *
 * @public
 */
export function toCss(color: HWBColor): string {
	const { h, w, b, alpha } = color;

	// Format: hwb(H W% B%)
	let result = `hwb(${h} ${w}% ${b}%`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha !== 1) {
		result += ` / ${alpha}`;
	}

	result += ")";
	return result;
}


=== File: src/generate/color/index.ts ===
// b_path:: src/generate/color/index.ts

/**
 * CSS color generators - convert color IR to CSS strings.
 *
 * All color generators return CSS strings directly.
 *
 * @module Generate.Color
 * @public
 */

/**
 * Generate CSS from color IR with auto-detection.
 *
 * @see {@link generate}
 */
export { generate } from "./color";

/**
 * Generate color() function CSS strings.
 *
 * @see {@link ColorFunction.toCss}
 */
export * as ColorFunction from "./color-function";
/**
 * Generate hex color CSS strings.
 *
 * @see {@link Hex.toCss}
 */
export * as Hex from "./hex";
/**
 * Generate HSL color CSS strings.
 *
 * @see {@link Hsl.toCss}
 */
export * as Hsl from "./hsl";
/**
 * Generate HWB color CSS strings.
 *
 * @see {@link Hwb.toCss}
 */
export * as Hwb from "./hwb";
/**
 * Generate LAB color CSS strings.
 *
 * @see {@link Lab.toCss}
 */
export * as Lab from "./lab";
/**
 * Generate LCH color CSS strings.
 *
 * @see {@link Lch.toCss}
 */
export * as Lch from "./lch";
/**
 * Generate named color CSS strings.
 *
 * @see {@link Named.toCss}
 */
export * as Named from "./named";
/**
 * Generate OKLab color CSS strings.
 *
 * @see {@link Oklab.toCss}
 */
export * as Oklab from "./oklab";
/**
 * Generate OKLCH color CSS strings.
 *
 * @see {@link Oklch.toCss}
 */
export * as Oklch from "./oklch";
/**
 * Generate RGB color CSS strings.
 *
 * @see {@link Rgb.toCss}
 */
export * as Rgb from "./rgb";
/**
 * Generate special color CSS strings (transparent, currentcolor).
 *
 * @see {@link Special.toCss}
 */
export * as Special from "./special";
/**
 * Generate system color CSS strings.
 *
 * @see {@link System.toCss}
 */
export * as System from "./system";


=== File: src/generate/color/lab.ts ===
// b_path:: src/generate/color/lab.ts
import type { LABColor } from "@/core/types/color";

/**
 * Generate CSS from a LAB color value.
 *
 * Converts a LABColor IR back to its CSS string representation.
 * Uses modern space-separated syntax.
 *
 * @param color - The LAB color to convert
 * @returns CSS LAB color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/lab";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "lab", l: 50, a: -20, b: 30 });
 * // => "lab(50 -20 30)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "lab", l: 50, a: -20, b: 30, alpha: 0.5 });
 * // => "lab(50 -20 30 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "lab", l: 50, a: -20, b: 30, alpha: 1 });
 * // => "lab(50 -20 30)"
 * ```
 *
 * @public
 */
export function toCss(color: LABColor): string {
	const { l, a, b, alpha } = color;

	// Format LAB values (lightness, a, b as numbers)
	const labPart = `${l} ${a} ${b}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return `lab(${labPart} / ${alpha})`;
	}

	return `lab(${labPart})`;
}


=== File: src/generate/color/lch.ts ===
// b_path:: src/generate/color/lch.ts
import type { LCHColor } from "@/core/types/color";

/**
 * Generate CSS from a LCH color value.
 *
 * Converts a LCHColor IR back to its CSS string representation.
 * Uses modern space-separated syntax without units.
 *
 * @param color - The LCH color to convert
 * @returns CSS LCH color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/lch";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "lch", l: 50, c: 50, h: 180 });
 * // => "lch(50 50 180)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "lch", l: 50, c: 50, h: 180, alpha: 0.5 });
 * // => "lch(50 50 180 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "lch", l: 50, c: 50, h: 180, alpha: 1 });
 * // => "lch(50 50 180)"
 * ```
 *
 * @public
 */
export function toCss(color: LCHColor): string {
	const { l, c, h, alpha } = color;

	// Format LCH values (lightness, chroma, hue as numbers)
	const lchPart = `${l} ${c} ${h}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return `lch(${lchPart} / ${alpha})`;
	}

	return `lch(${lchPart})`;
}


=== File: src/generate/color/named.ts ===
// b_path:: src/generate/color/named.ts
import type { NamedColor } from "@/core/types/color";

/**
 * Generate CSS from a named color value.
 *
 * Converts a NamedColor IR back to its CSS string representation.
 * Output is always lowercase color name.
 *
 * @param color - The named color to convert
 * @returns CSS color name string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/named";
 *
 * const css1 = toCss({ kind: "named", name: "red" });
 * // => "red"
 *
 * const css2 = toCss({ kind: "named", name: "cornflowerblue" });
 * // => "cornflowerblue"
 * ```
 *
 * @public
 */
export function toCss(color: NamedColor): string {
	return color.name;
}


=== File: src/generate/color/oklab.ts ===
// b_path:: src/generate/color/oklab.ts
import type { OKLabColor } from "@/core/types/color";

/**
 * Generate CSS from an OKLab color value.
 *
 * Converts an OKLabColor IR back to its CSS string representation.
 * Uses modern space-separated syntax.
 *
 * @param color - The OKLab color to convert
 * @returns CSS OKLab color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/oklab";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "oklab", l: 0.5, a: -0.2, b: 0.3 });
 * // => "oklab(0.5 -0.2 0.3)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "oklab", l: 0.5, a: -0.2, b: 0.3, alpha: 0.5 });
 * // => "oklab(0.5 -0.2 0.3 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "oklab", l: 0.5, a: -0.2, b: 0.3, alpha: 1 });
 * // => "oklab(0.5 -0.2 0.3)"
 * ```
 *
 * @public
 */
export function toCss(color: OKLabColor): string {
	const { l, a, b, alpha } = color;

	// Format OKLab values (lightness, a, b as numbers)
	const oklabPart = `${l} ${a} ${b}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return `oklab(${oklabPart} / ${alpha})`;
	}

	return `oklab(${oklabPart})`;
}


=== File: src/generate/color/oklch.ts ===
// b_path:: src/generate/color/oklch.ts
import type { OKLCHColor } from "@/core/types/color";

/**
 * Generate CSS from an OKLCH color value.
 *
 * Converts an OKLCHColor IR back to its CSS string representation.
 * Uses modern space-separated syntax. Hue is output as a unitless number (degrees implied).
 *
 * @param color - The OKLCH color to convert
 * @returns CSS OKLCH color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/oklch";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "oklch", l: 0.5, c: 0.2, h: 180 });
 * // => "oklch(0.5 0.2 180)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "oklch", l: 0.5, c: 0.2, h: 180, alpha: 0.5 });
 * // => "oklch(0.5 0.2 180 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "oklch", l: 0.5, c: 0.2, h: 180, alpha: 1 });
 * // => "oklch(0.5 0.2 180)"
 * ```
 *
 * @public
 */
export function toCss(color: OKLCHColor): string {
	const { l, c, h, alpha } = color;

	// Format OKLCH values (lightness, chroma, hue as numbers)
	// Hue is output as unitless (degrees implied)
	const oklchPart = `${l} ${c} ${h}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return `oklch(${oklchPart} / ${alpha})`;
	}

	return `oklch(${oklchPart})`;
}


=== File: src/generate/color/rgb.ts ===
// b_path:: src/generate/color/rgb.ts
import type { RGBColor } from "@/core/types/color";

/**
 * Generate CSS from an RGB color value.
 *
 * Converts an RGBColor IR back to its CSS string representation.
 * Uses modern space-separated syntax with slash for alpha.
 *
 * @param color - The RGB color to convert
 * @returns CSS RGB color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/rgb";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "rgb", r: 255, g: 0, b: 0 });
 * // => "rgb(255 0 0)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 });
 * // => "rgb(255 0 0 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "rgb", r: 255, g: 0, b: 0, alpha: 1 });
 * // => "rgb(255 0 0)"
 * ```
 *
 * @public
 */
export function toCss(color: RGBColor): string {
	const { r, g, b, alpha } = color;

	// Format RGB values (integers)
	const rgbPart = `${Math.round(r)} ${Math.round(g)} ${Math.round(b)}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return `rgb(${rgbPart} / ${alpha})`;
	}

	return `rgb(${rgbPart})`;
}


=== File: src/generate/color/special.ts ===
// b_path:: src/generate/color/special.ts
import type { SpecialColor } from "@/core/types/color";

/**
 * Generate CSS from a special color value.
 *
 * Converts a SpecialColor IR back to its CSS string representation.
 * Special color keywords are output in lowercase.
 *
 * @param color - The special color to convert
 * @returns CSS special color keyword string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/special";
 *
 * const css1 = toCss({ kind: "special", keyword: "transparent" });
 * // => "transparent"
 *
 * const css2 = toCss({ kind: "special", keyword: "currentcolor" });
 * // => "currentcolor"
 * ```
 *
 * @public
 */
export function toCss(color: SpecialColor): string {
	return color.keyword;
}


=== File: src/generate/color/system.ts ===
// b_path:: src/generate/color/system.ts
import type { SystemColor } from "@/core/types/color";

/**
 * Generate CSS from a system color value.
 *
 * Converts a SystemColor IR back to its CSS string representation.
 * System color keywords are output as-is with their original casing.
 *
 * @param color - The system color to convert
 * @returns CSS system color keyword string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/system";
 *
 * const css1 = toCss({ kind: "system", keyword: "ButtonText" });
 * // => "ButtonText"
 *
 * const css2 = toCss({ kind: "system", keyword: "Canvas" });
 * // => "Canvas"
 * ```
 *
 * @public
 */
export function toCss(color: SystemColor): string {
	return color.keyword;
}


=== File: src/generate/filter/blur.ts ===
// b_path:: src/generate/filter/blur.ts
import type { BlurFilter } from "@/core/types/filter";

/**
 * Generate CSS blur() filter function from IR.
 *
 * Outputs blur radius with its unit (px, em, rem, etc.).
 * Preserves the original unit from the IR.
 *
 * @param filter - BlurFilter IR
 * @returns CSS string like "blur(5px)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/blur";
 *
 * const css = toCss({ kind: "blur", radius: { value: 5, unit: "px" } });
 * // "blur(5px)"
 * ```
 *
 * @public
 */
export function toCss(filter: BlurFilter): string {
	const { radius } = filter;
	return `blur(${radius.value}${radius.unit})`;
}


=== File: src/generate/filter/brightness.ts ===
// b_path:: src/generate/filter/brightness.ts
import type { BrightnessFilter } from "@/core/types/filter";

/**
 * Generate CSS brightness() filter function from IR.
 *
 * Outputs brightness value as a number (not percentage).
 * 1 = 100% brightness (no change), 0 = completely black.
 *
 * @param filter - BrightnessFilter IR
 * @returns CSS string like "brightness(1.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/brightness";
 *
 * const css = toCss({ kind: "brightness", value: 1.5 });
 * // "brightness(1.5)"
 * ```
 *
 * @public
 */
export function toCss(filter: BrightnessFilter): string {
	const { value } = filter;
	return `brightness(${value})`;
}


=== File: src/generate/filter/contrast.ts ===
// b_path:: src/generate/filter/contrast.ts
import type { ContrastFilter } from "@/core/types/filter";

/**
 * Generate CSS contrast() filter function from IR.
 *
 * Outputs contrast value as a number (not percentage).
 * 1 = 100% contrast (no change), 0 = completely black.
 *
 * @param filter - ContrastFilter IR
 * @returns CSS string like "contrast(1.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/contrast";
 *
 * const css = toCss({ kind: "contrast", value: 1.5 });
 * // "contrast(1.5)"
 * ```
 *
 * @public
 */
export function toCss(filter: ContrastFilter): string {
	const { value } = filter;
	return `contrast(${value})`;
}


=== File: src/generate/filter/drop-shadow.ts ===
// b_path:: src/generate/filter/drop-shadow.ts
import type { DropShadowFilter } from "@/core/types/filter";
import { generateColor } from "@/utils/generate/color";

/**
 * Generate CSS drop-shadow() filter function from IR.
 *
 * Outputs drop-shadow with offset-x, offset-y, and optional blur-radius and color.
 * Preserves the original units from the IR.
 * Optional parameters are only included if present in the IR.
 *
 * @param filter - DropShadowFilter IR
 * @returns CSS string like "drop-shadow(2px 2px)" or "drop-shadow(2px 2px 4px black)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/drop-shadow";
 *
 * // Basic drop shadow
 * const css1 = toCss({
 *   kind: "drop-shadow",
 *   offsetX: { value: 2, unit: "px" },
 *   offsetY: { value: 2, unit: "px" }
 * });
 * // "drop-shadow(2px 2px)"
 *
 * // With blur radius
 * const css2 = toCss({
 *   kind: "drop-shadow",
 *   offsetX: { value: 2, unit: "px" },
 *   offsetY: { value: 2, unit: "px" },
 *   blurRadius: { value: 4, unit: "px" }
 * });
 * // "drop-shadow(2px 2px 4px)"
 *
 * // With color
 * const css3 = toCss({
 *   kind: "drop-shadow",
 *   offsetX: { value: 2, unit: "px" },
 *   offsetY: { value: 2, unit: "px" },
 *   blurRadius: { value: 4, unit: "px" },
 *   color: { kind: "named", name: "black" }
 * });
 * // "drop-shadow(2px 2px 4px black)"
 * ```
 *
 * @public
 */
export function toCss(filter: DropShadowFilter): string {
	const { offsetX, offsetY, blurRadius, color } = filter;

	// Start with required offset values
	let css = `drop-shadow(${offsetX.value}${offsetX.unit} ${offsetY.value}${offsetY.unit}`;

	// Add optional blur radius
	if (blurRadius !== undefined) {
		css += ` ${blurRadius.value}${blurRadius.unit}`;
	}

	// Add optional color
	if (color !== undefined) {
		css += ` ${generateColor(color)}`;
	}

	// Close function
	css += ")";

	return css;
}


=== File: src/generate/filter/filter.test.ts ===
// b_path:: src/generate/filter/filter.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./filter";

describe("Filter.generate()", () => {
	test("generates blur", () => {
		const filter: Type.FilterFunction = { kind: "blur", radius: { value: 5, unit: "px" } };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("blur(5px)");
		}
	});

	test("generates brightness", () => {
		const filter: Type.FilterFunction = { kind: "brightness", value: 150 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("brightness(150)");
		}
	});

	test("generates contrast", () => {
		const filter: Type.FilterFunction = { kind: "contrast", value: 75 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("contrast(75)");
		}
	});

	test("generates grayscale", () => {
		const filter: Type.FilterFunction = { kind: "grayscale", value: 100 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("grayscale(100)");
		}
	});

	test("generates hue-rotate", () => {
		const filter: Type.FilterFunction = { kind: "hue-rotate", angle: { value: 90, unit: "deg" } };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("hue-rotate(90deg)");
		}
	});

	test("generates invert", () => {
		const filter: Type.FilterFunction = { kind: "invert", value: 50 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("invert(50)");
		}
	});

	test("generates opacity", () => {
		const filter: Type.FilterFunction = { kind: "opacity", value: 75 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("opacity(75)");
		}
	});

	test("generates saturate", () => {
		const filter: Type.FilterFunction = { kind: "saturate", value: 200 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("saturate(200)");
		}
	});

	test("generates sepia", () => {
		const filter: Type.FilterFunction = { kind: "sepia", value: 80 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("sepia(80)");
		}
	});

	test("generates url", () => {
		const filter: Type.FilterFunction = { kind: "url", url: "#filter-id" };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("url(#filter-id)");
		}
	});

	test("returns error for missing kind", () => {
		const filter = {} as Type.FilterFunction;
		const result = generate(filter);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		}
	});
});


=== File: src/generate/filter/filter.ts ===
// b_path:: src/generate/filter/filter.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Blur from "./blur";
import * as Brightness from "./brightness";
import * as Contrast from "./contrast";
import * as DropShadow from "./drop-shadow";
import * as Grayscale from "./grayscale";
import * as HueRotate from "./hue-rotate";
import * as Invert from "./invert";
import * as Opacity from "./opacity";
import * as Saturate from "./saturate";
import * as Sepia from "./sepia";
import * as Url from "./url";

/**
 * Generate CSS from filter IR with auto-detection.
 *
 * @param filter - Filter IR
 * @returns GenerateResult with CSS string or error
 *
 * @public
 */
export function generate(filter: Type.FilterFunction): GenerateResult {
	if (!filter || typeof filter !== "object" || !("kind" in filter)) {
		return generateErr("missing-required-field", "Invalid filter IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	switch (filter.kind) {
		case "blur":
			return generateOk(Blur.toCss(filter));
		case "brightness":
			return generateOk(Brightness.toCss(filter));
		case "contrast":
			return generateOk(Contrast.toCss(filter));
		case "drop-shadow":
			return generateOk(DropShadow.toCss(filter));
		case "grayscale":
			return generateOk(Grayscale.toCss(filter));
		case "hue-rotate":
			return generateOk(HueRotate.toCss(filter));
		case "invert":
			return generateOk(Invert.toCss(filter));
		case "opacity":
			return generateOk(Opacity.toCss(filter));
		case "saturate":
			return generateOk(Saturate.toCss(filter));
		case "sepia":
			return generateOk(Sepia.toCss(filter));
		case "url":
			return generateOk(Url.toCss(filter));
		default:
			return generateErr("unsupported-kind", `Unknown filter kind: ${(filter as { kind?: string }).kind}`, {
				suggestion: "Check that filter IR is valid",
			});
	}
}


=== File: src/generate/filter/grayscale.ts ===
// b_path:: src/generate/filter/grayscale.ts
import type { GrayscaleFilter } from "@/core/types/filter";

/**
 * Generate CSS grayscale() filter function from IR.
 *
 * Outputs grayscale value as a number (not percentage).
 * 0 = no grayscale, 1 = 100% grayscale.
 *
 * @param filter - GrayscaleFilter IR
 * @returns CSS string like "grayscale(0.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/grayscale";
 *
 * const css = toCss({ kind: "grayscale", value: 0.5 });
 * // "grayscale(0.5)"
 * ```
 *
 * @public
 */
export function toCss(filter: GrayscaleFilter): string {
	const { value } = filter;
	return `grayscale(${value})`;
}


=== File: src/generate/filter/hue-rotate.ts ===
// b_path:: src/generate/filter/hue-rotate.ts
import type { HueRotateFilter } from "@/core/types/filter";

/**
 * Generate CSS hue-rotate() filter function from IR.
 *
 * Outputs hue rotation angle with its unit (deg, grad, rad, turn).
 * Preserves the original unit from the IR.
 *
 * @param filter - HueRotateFilter IR
 * @returns CSS string like "hue-rotate(90deg)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/hue-rotate";
 *
 * const css = toCss({ kind: "hue-rotate", angle: { value: 90, unit: "deg" } });
 * // "hue-rotate(90deg)"
 * ```
 *
 * @public
 */
export function toCss(filter: HueRotateFilter): string {
	const { angle } = filter;
	return `hue-rotate(${angle.value}${angle.unit})`;
}


=== File: src/generate/filter/index.ts ===
// b_path:: src/generate/filter/index.ts
export { generate } from "./filter";
// b_path:: src/generate/filter/index.ts

/**
 * CSS filter generators - convert filter IR to CSS strings.
 *
 * All filter generators return CSS strings directly.
 *
 * @module Generate.Filter
 * @public
 */

/**
 * Generate blur filter CSS strings.
 *
 * @see {@link Blur.toCss}
 */
export * as Blur from "./blur";
/**
 * Generate brightness filter CSS strings.
 *
 * @see {@link Brightness.toCss}
 */
export * as Brightness from "./brightness";
/**
 * Generate contrast filter CSS strings.
 *
 * @see {@link Contrast.toCss}
 */
export * as Contrast from "./contrast";
/**
 * Generate drop-shadow filter CSS strings.
 *
 * @see {@link DropShadow.toCss}
 */
export * as DropShadow from "./drop-shadow";
/**
 * Generate grayscale filter CSS strings.
 *
 * @see {@link Grayscale.toCss}
 */
export * as Grayscale from "./grayscale";
/**
 * Generate hue-rotate filter CSS strings.
 *
 * @see {@link HueRotate.toCss}
 */
export * as HueRotate from "./hue-rotate";
/**
 * Generate invert filter CSS strings.
 *
 * @see {@link Invert.toCss}
 */
export * as Invert from "./invert";
/**
 * Generate opacity filter CSS strings.
 *
 * @see {@link Opacity.toCss}
 */
export * as Opacity from "./opacity";
/**
 * Generate saturate filter CSS strings.
 *
 * @see {@link Saturate.toCss}
 */
export * as Saturate from "./saturate";
/**
 * Generate sepia filter CSS strings.
 *
 * @see {@link Sepia.toCss}
 */
export * as Sepia from "./sepia";
/**
 * Generate URL filter CSS strings.
 *
 * @see {@link Url.toCss}
 */
export * as Url from "./url";


=== File: src/generate/filter/invert.ts ===
// b_path:: src/generate/filter/invert.ts
import type { InvertFilter } from "@/core/types/filter";

/**
 * Generate CSS invert() filter function from IR.
 *
 * Outputs invert value as a number (not percentage).
 * 0 = no invert, 1 = 100% invert.
 *
 * @param filter - InvertFilter IR
 * @returns CSS string like "invert(0.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/invert";
 *
 * const css = toCss({ kind: "invert", value: 0.5 });
 * // "invert(0.5)"
 * ```
 *
 * @public
 */
export function toCss(filter: InvertFilter): string {
	const { value } = filter;
	return `invert(${value})`;
}


=== File: src/generate/filter/opacity.ts ===
// b_path:: src/generate/filter/opacity.ts
import type { OpacityFilter } from "@/core/types/filter";

/**
 * Generate CSS opacity() filter function from IR.
 *
 * Outputs opacity value as a number (not percentage).
 * 0 = no opacity, 1 = 100% opacity.
 *
 * @param filter - OpacityFilter IR
 * @returns CSS string like "opacity(0.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/opacity}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/opacity";
 *
 * const css = toCss({ kind: "opacity", value: 0.5 });
 * // "opacity(0.5)"
 * ```
 *
 * @public
 */
export function toCss(filter: OpacityFilter): string {
	const { value } = filter;
	return `opacity(${value})`;
}


=== File: src/generate/filter/saturate.ts ===
// b_path:: src/generate/filter/saturate.ts
import type { SaturateFilter } from "@/core/types/filter";

/**
 * Generate CSS saturate() filter function from IR.
 *
 * Outputs saturate value as a number (not percentage).
 * 1 = 100% saturate (no change), 0 = completely black.
 *
 * @param filter - SaturateFilter IR
 * @returns CSS string like "saturate(1.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/saturate";
 *
 * const css = toCss({ kind: "saturate", value: 1.5 });
 * // "saturate(1.5)"
 * ```
 *
 * @public
 */
export function toCss(filter: SaturateFilter): string {
	const { value } = filter;
	return `saturate(${value})`;
}


=== File: src/generate/filter/sepia.ts ===
// b_path:: src/generate/filter/sepia.ts
import type { SepiaFilter } from "@/core/types/filter";

/**
 * Generate CSS sepia() filter function from IR.
 *
 * Outputs sepia value as a number (not percentage).
 * 0 = no sepia, 1 = 100% sepia.
 *
 * @param filter - SepiaFilter IR
 * @returns CSS string like "sepia(0.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/sepia";
 *
 * const css = toCss({ kind: "sepia", value: 0.5 });
 * // "sepia(0.5)"
 * ```
 *
 * @public
 */
export function toCss(filter: SepiaFilter): string {
	const { value } = filter;
	return `sepia(${value})`;
}


=== File: src/generate/filter/url.ts ===
// b_path:: src/generate/filter/url.ts
import type { UrlFilter } from "@/core/types/filter";

/**
 * Generate CSS url() filter function from IR.
 *
 * Outputs URL as-is without quotes for simple URLs and fragments.
 *
 * @param filter - UrlFilter IR
 * @returns CSS string like "url(#filter-id)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/url}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/url";
 *
 * const css = toCss({ kind: "url", url: "#filter-id" });
 * // "url(#filter-id)"
 *
 * const css2 = toCss({ kind: "url", url: "path/to/filter.svg" });
 * // "url(path/to/filter.svg)"
 * ```
 *
 * @public
 */
export function toCss(filter: UrlFilter): string {
	const { url } = filter;
	return `url(${url})`;
}


=== File: src/generate/gradient/color-stop.ts ===
// b_path:: src/generate/gradient/color-stop.ts

import type * as Type from "@/core/types";
import { generateColor } from "@/utils/generate/color";

/**
 * Generate CSS color stop string from IR.
 *
 * Converts color stop IR into a valid CSS color stop string.
 *
 * @param ir - ColorStop IR object
 * @returns CSS color stop string
 *
 * @public
 *
 * @example
 * ```typescript
 * import * as Gradient from "@/ast/generate/gradient";
 *
 * const css1 = Gradient.ColorStop.toCss({
 *   color: { kind: "named", name: "red" }
 * });
 * // Returns: "red"
 *
 * const css2 = Gradient.ColorStop.toCss({
 *   color: { kind: "named", name: "blue" },
 *   position: { value: 50, unit: "%" }
 * });
 * // Returns: "blue 50%"
 *
 * const css3 = Gradient.ColorStop.toCss({
 *   color: { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 },
 *   position: { value: 100, unit: "px" }
 * });
 * // Returns: "rgb(255 0 0 / 0.5) 100px"
 * ```
 */
export function toCss(ir: Type.ColorStop): string {
	const colorStr = generateColor(ir.color);

	if (ir.position) {
		const { value, unit } = ir.position;
		return `${colorStr} ${value}${unit}`;
	}

	return colorStr;
}


=== File: src/generate/gradient/conic.generate.test.ts ===
// b_path:: src/generate/gradient/conic.generate.test.ts

import { describe, expect, it } from "vitest";
import * as ConicGenerator from "./conic";

describe("Conic Gradient Generator", () => {
	it("should generate simple conic gradient", () => {
		const ir = {
			kind: "conic" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(red, blue)");
	});

	it("should generate conic gradient with starting angle", () => {
		const ir = {
			kind: "conic" as const,
			fromAngle: { value: 45, unit: "deg" as const },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(from 45deg, red, blue)");
	});

	it("should generate conic gradient with position", () => {
		const ir = {
			kind: "conic" as const,
			position: {
				horizontal: "center" as const,
				vertical: "center" as const,
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(at center center, red, blue)");
	});

	it("should generate conic gradient with position keywords", () => {
		const ir = {
			kind: "conic" as const,
			position: {
				horizontal: "left" as const,
				vertical: "top" as const,
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(at left top, red, blue)");
	});

	it("should generate conic gradient with percentage position", () => {
		const ir = {
			kind: "conic" as const,
			position: {
				horizontal: { value: 50, unit: "%" as const },
				vertical: { value: 75, unit: "%" as const },
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(at 50% 75%, red, blue)");
	});

	it("should generate conic gradient with both angle and position", () => {
		const ir = {
			kind: "conic" as const,
			fromAngle: { value: 90, unit: "deg" as const },
			position: {
				horizontal: { value: 50, unit: "%" as const },
				vertical: { value: 50, unit: "%" as const },
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(from 90deg at 50% 50%, red, blue)");
	});

	it("should generate conic gradient with turn unit", () => {
		const ir = {
			kind: "conic" as const,
			fromAngle: { value: 0.25, unit: "turn" as const },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(from 0.25turn, red, blue)");
	});

	it("should generate conic gradient with rad unit", () => {
		const ir = {
			kind: "conic" as const,
			fromAngle: { value: 1.57, unit: "rad" as const },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(from 1.57rad, red, blue)");
	});

	it("should generate conic gradient with color stop angle positions", () => {
		const ir = {
			kind: "conic" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "deg" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 180, unit: "deg" as const } },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(red 0deg, blue 180deg)");
	});

	it("should generate conic gradient with color interpolation", () => {
		const ir = {
			kind: "conic" as const,
			colorSpace: "oklch" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(in oklch, red, blue)");
	});

	it("should generate conic gradient with angle and color interpolation", () => {
		const ir = {
			kind: "conic" as const,
			fromAngle: { value: 45, unit: "deg" as const },
			colorSpace: "oklch" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(from 45deg in oklch, red, blue)");
	});

	it("should generate repeating conic gradient", () => {
		const ir = {
			kind: "conic" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "deg" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 45, unit: "deg" as const } },
			],
			repeating: true,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("repeating-conic-gradient(red 0deg, blue 45deg)");
	});

	it("should generate complex conic gradient", () => {
		const ir = {
			kind: "conic" as const,
			fromAngle: { value: 90, unit: "deg" as const },
			position: {
				horizontal: { value: 30, unit: "%" as const },
				vertical: { value: 30, unit: "%" as const },
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "deg" as const } },
				{ color: { kind: "named", name: "yellow" } as const, position: { value: 120, unit: "deg" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 240, unit: "deg" as const } },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(from 90deg at 30% 30%, red 0deg, yellow 120deg, blue 240deg)");
	});

	it("should generate conic gradient with multiple color stops", () => {
		const ir = {
			kind: "conic" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "orange" } as const },
				{ color: { kind: "named", name: "yellow" } as const },
				{ color: { kind: "named", name: "green" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(red, orange, yellow, green, blue)");
	});

	it("should generate conic gradient with percentage color stop positions", () => {
		const ir = {
			kind: "conic" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "%" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 100, unit: "%" as const } },
			],
			repeating: false,
		};

		const css = ConicGenerator.toCss(ir);
		expect(css).toBe("conic-gradient(red 0%, blue 100%)");
	});
});


=== File: src/generate/gradient/conic.ts ===
// b_path:: src/generate/gradient/conic.ts

import type * as Type from "@/core/types";
import * as ColorStop from "./color-stop";

/**
 * Generate CSS position string from Position2D IR.
 *
 * @param position - Position2D IR object
 * @returns CSS position string (e.g., "center", "left top", "50% 50%")
 *
 * @internal
 */
function positionToCss(position: Type.Position2D): string {
	const h =
		typeof position.horizontal === "string"
			? position.horizontal
			: `${position.horizontal.value}${position.horizontal.unit}`;
	const v =
		typeof position.vertical === "string" ? position.vertical : `${position.vertical.value}${position.vertical.unit}`;
	return `${h} ${v}`;
}

/**
 * Generate a CSS conic gradient string from intermediate representation (IR).
 *
 * Converts a ConicGradient IR object into a valid CSS `conic-gradient()` or
 * `repeating-conic-gradient()` function string. Handles all gradient components:
 * starting angle, position, color interpolation, and color stops.
 *
 * The generated CSS string is spec-compliant and can be used directly in CSS
 * properties like `background-image`, `background`, or `mask-image`.
 *
 * This function performs the inverse operation of `Parse.Gradient.Conic.parse()`,
 * enabling bidirectional transformation between CSS and IR.
 *
 * @param ir - ConicGradient IR object to convert to CSS
 * @returns CSS conic gradient function string
 *
 * @public
 *
 * @example
 * Simple gradient:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Conic.toCss({
 *   kind: "conic",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(red, blue)"
 * ```
 *
 * @example
 * With starting angle:
 * ```typescript
 * const css = Generate.Gradient.Conic.toCss({
 *   kind: "conic",
 *   fromAngle: { value: 45, unit: "deg" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(from 45deg, red, blue)"
 * ```
 *
 * @example
 * At specific position:
 * ```typescript
 * const css = Generate.Gradient.Conic.toCss({
 *   kind: "conic",
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(at left top, red, blue)"
 * ```
 *
 * @example
 * With both angle and position:
 * ```typescript
 * const css = Generate.Gradient.Conic.toCss({
 *   kind: "conic",
 *   fromAngle: { value: 90, unit: "deg" },
 *   position: { horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } },
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "blue", position: { value: 180, unit: "deg" } }
 *   ],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(from 90deg at 50% 50%, red 0deg, blue 180deg)"
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const css = Generate.Gradient.Conic.toCss({
 *   kind: "conic",
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "blue", position: { value: 180, unit: "deg" } }
 *   ],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(in oklch, red 0deg, blue 180deg)"
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const css = Generate.Gradient.Conic.toCss({
 *   kind: "conic",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "blue", position: { value: 45, unit: "deg" } }
 *   ],
 *   repeating: true
 * });
 * console.log(css); // "repeating-conic-gradient(red 0deg, blue 45deg)"
 * ```
 *
 * @example
 * Round-trip transformation (parse → generate):
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "conic-gradient(from 45deg, red, blue)";
 * const parsed = Parse.Gradient.Conic.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Gradient.Conic.toCss(parsed.value);
 *   console.log(generated === original); // true - perfect round-trip!
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient | MDN: conic-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-4/#conic-gradients | W3C Spec: Conic Gradients}
 */
export function toCss(ir: Type.ConicGradient): string {
	const parts: string[] = [];
	const angleAndPos: string[] = [];

	// Build from angle and position part
	if (ir.fromAngle) {
		angleAndPos.push(`from ${ir.fromAngle.value}${ir.fromAngle.unit}`);
	}

	if (ir.position) {
		angleAndPos.push(`at ${positionToCss(ir.position)}`);
	}

	// Combine angle/position with color space
	const angleAndPosStr = angleAndPos.join(" ");
	if (ir.colorSpace) {
		if (angleAndPosStr) {
			parts.push(`${angleAndPosStr} in ${ir.colorSpace}`);
		} else {
			parts.push(`in ${ir.colorSpace}`);
		}
	} else if (angleAndPosStr) {
		parts.push(angleAndPosStr);
	}

	// Add color stops
	const stopStrings = ir.colorStops.map((stop) => ColorStop.toCss(stop));
	parts.push(...stopStrings);

	// Generate function
	const functionName = ir.repeating ? "repeating-conic-gradient" : "conic-gradient";
	return `${functionName}(${parts.join(", ")})`;
}


=== File: src/generate/gradient/gradient.test.ts ===
// b_path:: src/generate/gradient/gradient.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./gradient";

describe("Gradient.generate()", () => {
	test("generates linear gradient", () => {
		const gradient: Type.Gradient = {
			kind: "linear",
			direction: { kind: "to-side", value: "bottom" },
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(gradient);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("linear-gradient");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates radial gradient", () => {
		const gradient: Type.Gradient = {
			kind: "radial",
			shape: "circle",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(gradient);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("radial-gradient");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates conic gradient", () => {
		const gradient: Type.Gradient = {
			kind: "conic",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(gradient);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("conic-gradient");
			expect(result.issues).toEqual([]);
		}
	});

	test("returns error for invalid IR (missing kind)", () => {
		const gradient = {} as Type.Gradient;
		const result = generate(gradient);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});

	test("returns error for unknown kind", () => {
		const gradient = { kind: "unknown" } as unknown as Type.Gradient;
		const result = generate(gradient);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("Unknown gradient kind");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});
});


=== File: src/generate/gradient/gradient.ts ===
// b_path:: src/generate/gradient/gradient.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Conic from "./conic";
import * as Linear from "./linear";
import * as Radial from "./radial";

/**
 * Generate CSS from gradient IR with auto-detection.
 *
 * Automatically detects gradient type from IR.kind and generates appropriate CSS.
 * Supports linear, radial, and conic gradients.
 *
 * @param gradient - Gradient IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate({ kind: "linear", ... })
 * // → { ok: true, value: "linear-gradient(...)", issues: [] }
 *
 * generate({ kind: "radial", ... })
 * // → { ok: true, value: "radial-gradient(...)", issues: [] }
 * ```
 *
 * @public
 */
export function generate(gradient: Type.Gradient): GenerateResult {
	// Validate IR has 'kind' field
	if (!gradient || typeof gradient !== "object" || !("kind" in gradient)) {
		return generateErr("missing-required-field", "Invalid gradient IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (gradient.kind) {
		case "linear":
			return generateOk(Linear.toCss(gradient));

		case "radial":
			return generateOk(Radial.toCss(gradient));

		case "conic":
			return generateOk(Conic.toCss(gradient));

		default:
			return generateErr("unsupported-kind", `Unknown gradient kind: ${(gradient as { kind?: string }).kind}`, {
				suggestion: "Check that gradient IR is valid",
			});
	}
}


=== File: src/generate/gradient/index.ts ===
// b_path:: src/generate/gradient/index.ts

/**
 * CSS gradient generators - convert gradient IR to CSS strings.
 *
 * @module Generate.Gradient
 * @public
 */

/**
 * Generate color stop CSS strings.
 *
 * @see {@link ColorStop.toCss}
 */
export * as ColorStop from "./color-stop";
/**
 * Generate conic and repeating-conic gradient CSS strings.
 *
 * @see {@link Conic.toCss}
 */
export * as Conic from "./conic";
/**
 * Generate CSS from gradient IR with auto-detection.
 *
 * @see {@link generate}
 */
export { generate } from "./gradient";

/**
 * Generate linear and repeating-linear gradient CSS strings.
 *
 * @see {@link Linear.toCss}
 */
export * as Linear from "./linear";
/**
 * Generate radial and repeating-radial gradient CSS strings.
 *
 * @see {@link Radial.toCss}
 */
export * as Radial from "./radial";


=== File: src/generate/gradient/linear.generate.test.ts ===
// b_path:: src/generate/gradient/linear.generate.test.ts

import { describe, expect, it } from "vitest";
import * as LinearGenerator from "./linear";

describe("Linear Gradient Generator", () => {
	it("should generate simple linear gradient", () => {
		const ir = {
			kind: "linear" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(red, blue)");
	});

	it("should generate linear gradient with angle direction", () => {
		const ir = {
			kind: "linear" as const,
			direction: { kind: "angle" as const, value: { value: 45, unit: "deg" as const } },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(45deg, red, blue)");
	});

	it("should generate linear gradient with to-side direction", () => {
		const ir = {
			kind: "linear" as const,
			direction: { kind: "to-side" as const, value: "right" as const },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(to right, red, blue)");
	});

	it("should generate linear gradient with to-corner direction", () => {
		const ir = {
			kind: "linear" as const,
			direction: { kind: "to-corner" as const, value: "top right" as const },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(to top right, red, blue)");
	});

	it("should generate linear gradient with turn unit", () => {
		const ir = {
			kind: "linear" as const,
			direction: { kind: "angle" as const, value: { value: 0.25, unit: "turn" as const } },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(0.25turn, red, blue)");
	});

	it("should generate linear gradient with rad unit", () => {
		const ir = {
			kind: "linear" as const,
			direction: { kind: "angle" as const, value: { value: 1.57, unit: "rad" as const } },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(1.57rad, red, blue)");
	});

	it("should generate linear gradient with color stop positions", () => {
		const ir = {
			kind: "linear" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "%" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 100, unit: "%" as const } },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(red 0%, blue 100%)");
	});

	it("should generate linear gradient with color interpolation", () => {
		const ir = {
			kind: "linear" as const,
			colorSpace: "oklch" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(in oklch, red, blue)");
	});

	it("should generate linear gradient with direction and color interpolation", () => {
		const ir = {
			kind: "linear" as const,
			direction: { kind: "angle" as const, value: { value: 45, unit: "deg" as const } },
			colorSpace: "oklch" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(45deg in oklch, red, blue)");
	});

	it("should generate repeating linear gradient", () => {
		const ir = {
			kind: "linear" as const,
			direction: { kind: "angle" as const, value: { value: 45, unit: "deg" as const } },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "px" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 20, unit: "px" as const } },
			],
			repeating: true,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("repeating-linear-gradient(45deg, red 0px, blue 20px)");
	});

	it("should generate complex linear gradient", () => {
		const ir = {
			kind: "linear" as const,
			direction: { kind: "to-corner" as const, value: "bottom right" as const },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "%" as const } },
				{ color: { kind: "named", name: "yellow" } as const, position: { value: 50, unit: "%" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 100, unit: "%" as const } },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(to bottom right, red 0%, yellow 50%, blue 100%)");
	});

	it("should generate linear gradient with all side directions", () => {
		const sides: Array<"top" | "right" | "bottom" | "left"> = ["top", "right", "bottom", "left"];

		for (const side of sides) {
			const ir = {
				kind: "linear" as const,
				direction: { kind: "to-side" as const, value: side },
				colorStops: [
					{ color: { kind: "named", name: "red" } as const },
					{ color: { kind: "named", name: "blue" } as const },
				],
				repeating: false,
			};

			const css = LinearGenerator.toCss(ir);
			expect(css).toBe(`linear-gradient(to ${side}, red, blue)`);
		}
	});

	it("should generate linear gradient with all corner directions", () => {
		const corners: Array<"top left" | "top right" | "bottom left" | "bottom right"> = [
			"top left",
			"top right",
			"bottom left",
			"bottom right",
		];

		for (const corner of corners) {
			const ir = {
				kind: "linear" as const,
				direction: { kind: "to-corner" as const, value: corner },
				colorStops: [
					{ color: { kind: "named", name: "red" } as const },
					{ color: { kind: "named", name: "blue" } as const },
				],
				repeating: false,
			};

			const css = LinearGenerator.toCss(ir);
			expect(css).toBe(`linear-gradient(to ${corner}, red, blue)`);
		}
	});

	it("should generate linear gradient with multiple color stops", () => {
		const ir = {
			kind: "linear" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "orange" } as const },
				{ color: { kind: "named", name: "yellow" } as const },
				{ color: { kind: "named", name: "green" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = LinearGenerator.toCss(ir);
		expect(css).toBe("linear-gradient(red, orange, yellow, green, blue)");
	});
});


=== File: src/generate/gradient/linear.ts ===
// b_path:: src/generate/gradient/linear.ts

import type * as Type from "@/core/types";
import * as ColorStop from "./color-stop";

/**
 * Generate CSS direction string from GradientDirection IR.
 *
 * @param direction - GradientDirection IR object
 * @returns CSS direction string (e.g., "45deg", "to right", "to top left")
 *
 * @internal
 */
function directionToCss(direction: Type.GradientDirection): string {
	if (direction.kind === "angle") {
		return `${direction.value.value}${direction.value.unit}`;
	}

	if (direction.kind === "to-side") {
		return `to ${direction.value}`;
	}

	// to-corner
	return `to ${direction.value}`;
}

/**
 * Generate a CSS linear gradient string from intermediate representation (IR).
 *
 * Converts a LinearGradient IR object into a valid CSS `linear-gradient()` or
 * `repeating-linear-gradient()` function string. Handles all gradient components:
 * direction, color interpolation, and color stops.
 *
 * The generated CSS string is spec-compliant and can be used directly in CSS
 * properties like `background-image`, `background`, or `mask-image`.
 *
 * This function performs the inverse operation of `Parse.Gradient.Linear.parse()`,
 * enabling bidirectional transformation between CSS and IR.
 *
 * @param ir - LinearGradient IR object to convert to CSS
 * @returns CSS linear gradient function string
 *
 * @public
 *
 * @example
 * Simple gradient:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Linear.toCss({
 *   kind: "linear",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(red, blue)"
 * ```
 *
 * @example
 * With angle direction:
 * ```typescript
 * const css = Generate.Gradient.Linear.toCss({
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(45deg, red, blue)"
 * ```
 *
 * @example
 * With side direction:
 * ```typescript
 * const css = Generate.Gradient.Linear.toCss({
 *   kind: "linear",
 *   direction: { kind: "to-side", value: "right" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(to right, red, blue)"
 * ```
 *
 * @example
 * With corner direction:
 * ```typescript
 * const css = Generate.Gradient.Linear.toCss({
 *   kind: "linear",
 *   direction: { kind: "to-corner", value: "top right" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(to top right, red, blue)"
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const css = Generate.Gradient.Linear.toCss({
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 90, unit: "deg" } },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(90deg in oklch, red 0%, blue 100%)"
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const css = Generate.Gradient.Linear.toCss({
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "px" } },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * });
 * console.log(css); // "repeating-linear-gradient(45deg, red 0px, blue 20px)"
 * ```
 *
 * @example
 * Round-trip transformation (parse → generate):
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "linear-gradient(to right, red, blue)";
 * const parsed = Parse.Gradient.Linear.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Gradient.Linear.toCss(parsed.value);
 *   console.log(generated === original); // true - perfect round-trip!
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient | MDN: linear-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients | W3C Spec: Linear Gradients}
 */
export function toCss(ir: Type.LinearGradient): string {
	const parts: string[] = [];

	// Add direction if present
	if (ir.direction) {
		const dirStr = directionToCss(ir.direction);
		if (ir.colorSpace) {
			// Direction and color space together
			parts.push(`${dirStr} in ${ir.colorSpace}`);
		} else {
			parts.push(dirStr);
		}
	} else if (ir.colorSpace) {
		// Just color space
		parts.push(`in ${ir.colorSpace}`);
	}

	// Add color stops
	const stopStrings = ir.colorStops.map((stop) => ColorStop.toCss(stop));
	parts.push(...stopStrings);

	// Generate function
	const functionName = ir.repeating ? "repeating-linear-gradient" : "linear-gradient";
	return `${functionName}(${parts.join(", ")})`;
}


=== File: src/generate/gradient/radial.generate.test.ts ===
// b_path:: src/generate/gradient/radial.generate.test.ts

import { describe, expect, it } from "vitest";
import * as RadialGenerator from "./radial";

describe("Radial Gradient Generator", () => {
	it("should generate simple radial gradient", () => {
		const ir = {
			kind: "radial" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(red, blue)");
	});

	it("should generate radial gradient with shape", () => {
		const ir = {
			kind: "radial" as const,
			shape: "circle" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(circle, red, blue)");
	});

	it("should generate radial gradient with size keyword", () => {
		const ir = {
			kind: "radial" as const,
			shape: "circle" as const,
			size: { kind: "keyword" as const, value: "closest-side" as const },
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(circle closest-side, red, blue)");
	});

	it("should generate radial gradient with position", () => {
		const ir = {
			kind: "radial" as const,
			position: {
				horizontal: "left" as const,
				vertical: "top" as const,
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(at left top, red, blue)");
	});

	it("should generate radial gradient with center position", () => {
		const ir = {
			kind: "radial" as const,
			position: {
				horizontal: "center" as const,
				vertical: "center" as const,
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(at center center, red, blue)");
	});

	it("should generate radial gradient with percentage positions", () => {
		const ir = {
			kind: "radial" as const,
			position: {
				horizontal: { value: 50, unit: "%" as const },
				vertical: { value: 75, unit: "%" as const },
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(at 50% 75%, red, blue)");
	});

	it("should generate radial gradient with color stop positions", () => {
		const ir = {
			kind: "radial" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "%" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 100, unit: "%" as const } },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(red 0%, blue 100%)");
	});

	it("should generate repeating radial gradient", () => {
		const ir = {
			kind: "radial" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 20, unit: "px" as const } },
			],
			repeating: true,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("repeating-radial-gradient(red, blue 20px)");
	});

	it("should generate complex radial gradient", () => {
		const ir = {
			kind: "radial" as const,
			shape: "ellipse" as const,
			size: { kind: "keyword" as const, value: "farthest-corner" as const },
			position: {
				horizontal: { value: 30, unit: "%" as const },
				vertical: { value: 30, unit: "%" as const },
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const, position: { value: 0, unit: "%" as const } },
				{ color: { kind: "named", name: "blue" } as const, position: { value: 100, unit: "%" as const } },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(ellipse farthest-corner at 30% 30%, red 0%, blue 100%)");
	});

	it("should generate radial gradient with multiple color stops", () => {
		const ir = {
			kind: "radial" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "yellow" } as const, position: { value: 30, unit: "%" as const } },
				{ color: { kind: "named", name: "green" } as const, position: { value: 60, unit: "%" as const } },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(red, yellow 30%, green 60%, blue)");
	});

	it("should generate radial gradient with explicit circle radius", () => {
		const ir = {
			kind: "radial" as const,
			shape: "circle" as const,
			size: {
				kind: "circle-explicit" as const,
				radius: { value: 100, unit: "px" as const },
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(circle 100px, red, blue)");
	});

	it("should generate radial gradient with explicit ellipse radii", () => {
		const ir = {
			kind: "radial" as const,
			shape: "ellipse" as const,
			size: {
				kind: "ellipse-explicit" as const,
				radiusX: { value: 100, unit: "px" as const },
				radiusY: { value: 50, unit: "px" as const },
			},
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(ellipse 100px 50px, red, blue)");
	});

	it("should generate radial gradient with color interpolation", () => {
		const ir = {
			kind: "radial" as const,
			colorSpace: "srgb" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(in srgb, red, blue)");
	});

	it("should generate radial gradient with shape and color space", () => {
		const ir = {
			kind: "radial" as const,
			shape: "circle" as const,
			colorSpace: "oklch" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(circle in oklch, red, blue)");
	});

	it("should generate radial gradient with position and color space", () => {
		const ir = {
			kind: "radial" as const,
			position: {
				horizontal: "center" as const,
				vertical: "center" as const,
			},
			colorSpace: "display-p3" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(at center center in display-p3, red, blue)");
	});

	it("should generate radial gradient with shape, size and color space", () => {
		const ir = {
			kind: "radial" as const,
			shape: "ellipse" as const,
			size: { kind: "keyword" as const, value: "farthest-corner" as const },
			colorSpace: "lab" as const,
			colorStops: [
				{ color: { kind: "named", name: "red" } as const },
				{ color: { kind: "named", name: "blue" } as const },
			],
			repeating: false,
		};

		const css = RadialGenerator.toCss(ir);
		expect(css).toBe("radial-gradient(ellipse farthest-corner in lab, red, blue)");
	});
});


=== File: src/generate/gradient/radial.ts ===
// b_path:: src/generate/gradient/radial.ts

import type * as Type from "@/core/types";
import * as ColorStop from "./color-stop";

/**
 * Generate CSS position string from Position2D IR.
 *
 * @param position - Position2D IR object
 * @returns CSS position string (e.g., "center", "left top", "50% 50%")
 *
 * @internal
 */
function positionToCss(position: Type.Position2D): string {
	const h =
		typeof position.horizontal === "string"
			? position.horizontal
			: `${position.horizontal.value}${position.horizontal.unit}`;
	const v =
		typeof position.vertical === "string" ? position.vertical : `${position.vertical.value}${position.vertical.unit}`;
	return `${h} ${v}`;
}

/**
 * Generate CSS radial gradient size string from IR.
 *
 * @param size - RadialGradientSize IR object
 * @returns CSS size string
 *
 * @internal
 */
function sizeToCss(size: Type.RadialGradientSize): string {
	if (size.kind === "keyword") {
		return size.value;
	}

	if (size.kind === "circle-explicit") {
		return `${size.radius.value}${size.radius.unit}`;
	}

	// ellipse-explicit
	return `${size.radiusX.value}${size.radiusX.unit} ${size.radiusY.value}${size.radiusY.unit}`;
}

/**
 * Generate a CSS radial gradient string from intermediate representation (IR).
 *
 * Converts a RadialGradient IR object into a valid CSS `radial-gradient()` or
 * `repeating-radial-gradient()` function string. Handles all gradient components:
 * shape, size, position, color interpolation, and color stops.
 *
 * The generated CSS string is spec-compliant and can be used directly in CSS
 * properties like `background-image`, `background`, or `mask-image`.
 *
 * This function performs the inverse operation of `Parse.Gradient.Radial.parse()`,
 * enabling bidirectional transformation between CSS and IR.
 *
 * @param ir - RadialGradient IR object to convert to CSS
 * @returns CSS radial gradient function string
 *
 * @public
 *
 * @example
 * Simple gradient:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(red, blue)"
 * ```
 *
 * @example
 * Circle with keyword size:
 * ```typescript
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "keyword", value: "closest-side" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(circle closest-side, red, blue)"
 * ```
 *
 * @example
 * Positioned gradient:
 * ```typescript
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "ellipse",
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(ellipse at left top, red, blue)"
 * ```
 *
 * @example
 * With explicit size:
 * ```typescript
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "circle-explicit", radius: { value: 100, unit: "px" } },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(circle 100px, red, blue)"
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(in oklch, red 0%, blue 100%)"
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "circle",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "px" } },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * });
 * console.log(css); // "repeating-radial-gradient(circle, red 0px, blue 20px)"
 * ```
 *
 * @example
 * Round-trip transformation (parse → generate):
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "radial-gradient(circle closest-side, red, blue)";
 * const parsed = Parse.Gradient.Radial.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Gradient.Radial.toCss(parsed.value);
 *   console.log(generated === original); // true - perfect round-trip!
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient | MDN: radial-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients | W3C Spec: Radial Gradients}
 */
export function toCss(ir: Type.RadialGradient): string {
	const parts: string[] = [];
	const shapeAndSize: string[] = [];

	// Build shape and size part
	if (ir.shape) {
		shapeAndSize.push(ir.shape);
	}

	if (ir.size) {
		shapeAndSize.push(sizeToCss(ir.size));
	}

	// Combine shape/size with position
	const shapeAndSizeStr = shapeAndSize.join(" ");
	if (ir.position) {
		const posStr = positionToCss(ir.position);
		if (shapeAndSizeStr) {
			parts.push(`${shapeAndSizeStr} at ${posStr}`);
		} else {
			parts.push(`at ${posStr}`);
		}
	} else if (shapeAndSizeStr) {
		parts.push(shapeAndSizeStr);
	}

	// Add color interpolation if present
	if (ir.colorSpace) {
		if (parts.length > 0) {
			// Append to last part without comma
			parts[parts.length - 1] = `${parts[parts.length - 1]} in ${ir.colorSpace}`;
		} else {
			parts.push(`in ${ir.colorSpace}`);
		}
	}

	// Add color stops
	const stopStrings = ir.colorStops.map((stop) => ColorStop.toCss(stop));
	parts.push(...stopStrings);

	// Generate function
	const functionName = ir.repeating ? "repeating-radial-gradient" : "radial-gradient";
	return `${functionName}(${parts.join(", ")})`;
}


=== File: src/generate/index.ts ===
// b_path:: src/generate/index.ts

/**
 * CSS value generators - convert structured IR to CSS strings.
 *
 * All generators return CSS strings directly (no Result type needed since
 * generation cannot fail). Convert intermediate representation (IR) objects
 * into spec-compliant CSS that can be used in stylesheets.
 *
 * @module Generate
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "circle",
 *   colorStops: [
 *     { color: { kind: "named", name: "red" } },
 *     { color: { kind: "named", name: "blue" } }
 *   ],
 *   repeating: false
 * });
 *
 * console.log(css); // "radial-gradient(circle, red, blue)"
 * ```
 */

/**
 * Animation generators (delay, duration, iteration-count, direction, fill-mode, play-state, name, timing-function).
 *
 * @see {@link Animation.Delay.toCss}
 */
export * as Animation from "./animation";
/**
 * Background generators (attachment, clip, origin, repeat, size).
 *
 * @see {@link Background.Attachment.toCss}
 */
export * as Background from "./background";
/**
 * Border generators (width, style, color, radius).
 *
 * @see {@link Border.Width.toCss}
 */
export * as Border from "./border";
/**
 * Clip-path generators (url, none).
 *
 * @see {@link ClipPath.Url.toCss}
 */
export * as ClipPath from "./clip-path";
/**
 * Color generators (hex, named, RGB, HSL, HWB, LAB, LCH, OKLab, OKLCH, system, special).
 *
 * @see {@link Color.Hex.toCss}
 */
export * as Color from "./color";
/**
 * Filter generators (blur, brightness, contrast, drop-shadow, grayscale, hue-rotate, invert, opacity, saturate, sepia, url).
 *
 * @see {@link Filter.Blur.toCss}
 */
export * as Filter from "./filter";
/**
 * Gradient generators (radial, linear, conic).
 *
 * @see {@link Gradient.Radial.toCss}
 */
export * as Gradient from "./gradient";
/**
 * Layout generators (display, visibility, opacity).
 *
 * @see {@link Layout.Display.toCss}
 */
export * as Layout from "./layout";
/**
 * Outline generators (width, style, color, offset).
 *
 * @see {@link Outline.Width.toCss}
 */
export * as Outline from "./outline";
/**
 * Position generators (background-position, object-position, transform-origin, etc.).
 *
 * @see {@link Position.toCss}
 */
export * as Position from "./position";
/**
 * Shadow generators (box-shadow, text-shadow).
 *
 * @see {@link Shadow.BoxShadow.toCss}
 */
export * as Shadow from "./shadow";
/**
 * Text decoration generators (color, line, style, thickness).
 *
 * @see {@link Text.Color.toCss}
 */
export * as Text from "./text";
/**
 * Transform generators (translate, rotate, scale, skew, matrix, etc.).
 *
 * @see {@link Transform.Utils.toCss}
 */
export * as Transform from "./transform";
/**
 * Transition generators (delay, duration, timing-function, property).
 *
 * @see {@link Transition.Delay.toCss}
 */
export * as Transition from "./transition";


=== File: src/generate/layout/bottom.generate.test.ts ===
// b_path:: src/generate/layout/bottom.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/layout/bottom";
import { toCss } from "./bottom";

describe("Generate.Layout.Bottom", () => {
	describe("auto keyword", () => {
		it("generates 'auto'", () => {
			const ir = { kind: "bottom" as const, value: "auto" as const };
			expect(toCss(ir)).toBe("auto");
		});
	});

	describe("length values", () => {
		it("generates px", () => {
			const ir = { kind: "bottom" as const, value: { value: 10, unit: "px" as const } };
			expect(toCss(ir)).toBe("10px");
		});

		it("generates em", () => {
			const ir = { kind: "bottom" as const, value: { value: 2, unit: "em" as const } };
			expect(toCss(ir)).toBe("2em");
		});
	});

	describe("percentage values", () => {
		it("generates percentage", () => {
			const ir = { kind: "bottom" as const, value: { value: 50, unit: "%" as const } };
			expect(toCss(ir)).toBe("50%");
		});
	});

	describe("round-trip", () => {
		it("auto", () => {
			const parsed = Parse.parse("auto");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("10px", () => {
			const parsed = Parse.parse("10px");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/layout/bottom.ts ===
// b_path:: src/generate/layout/bottom.ts
import type { Bottom } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS bottom property from IR.
 *
 * Outputs length-percentage value or "auto" keyword.
 *
 * @param bottom - Bottom IR
 * @returns CSS string like "10px", "50%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/bottom}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/bottom";
 *
 * const css = toCss({ kind: "bottom", value: { value: 10, unit: "px" } });
 * // "10px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "bottom", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function toCss(bottom: Bottom): string {
	if (bottom.value === "auto") {
		return "auto";
	}
	return GenUtils.lengthPercentageToCss(bottom.value);
}


=== File: src/generate/layout/cursor.ts ===
// b_path:: src/generate/layout/cursor.ts
import type { Cursor } from "@/core/types";

/**
 * Generate CSS cursor property from IR.
 *
 * Outputs cursor keyword value.
 *
 * @param cursor - Cursor IR
 * @returns CSS string like "pointer" or "text"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/cursor";
 *
 * const css = toCss({ kind: "cursor", value: "pointer" });
 * // "pointer"
 * ```
 *
 * @public
 */
export function toCss(cursor: Cursor): string {
	return cursor.value;
}


=== File: src/generate/layout/display.ts ===
// b_path:: src/generate/layout/display.ts
import type { Display } from "@/core/types";

/**
 * Generate CSS display property from IR.
 *
 * Outputs display keyword value.
 *
 * @param display - Display IR
 * @returns CSS string like "flex" or "none"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/display";
 *
 * const css = toCss({ kind: "display", value: "flex" });
 * // "flex"
 * ```
 *
 * @public
 */
export function toCss(display: Display): string {
	return display.value;
}


=== File: src/generate/layout/height.generate.test.ts ===
// b_path:: src/generate/layout/height.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/layout/height";
import { toCss } from "./height";

describe("Generate.Layout.Height", () => {
	describe("auto keyword", () => {
		it("generates 'auto'", () => {
			const ir = { kind: "height" as const, value: "auto" as const };
			expect(toCss(ir)).toBe("auto");
		});
	});

	describe("intrinsic sizing keywords", () => {
		it("generates 'min-content'", () => {
			const ir = { kind: "height" as const, value: "min-content" as const };
			expect(toCss(ir)).toBe("min-content");
		});

		it("generates 'max-content'", () => {
			const ir = { kind: "height" as const, value: "max-content" as const };
			expect(toCss(ir)).toBe("max-content");
		});

		it("generates 'fit-content'", () => {
			const ir = { kind: "height" as const, value: "fit-content" as const };
			expect(toCss(ir)).toBe("fit-content");
		});
	});

	describe("length values", () => {
		it("generates px", () => {
			const ir = { kind: "height" as const, value: { value: 100, unit: "px" as const } };
			expect(toCss(ir)).toBe("100px");
		});

		it("generates vh", () => {
			const ir = { kind: "height" as const, value: { value: 100, unit: "vh" as const } };
			expect(toCss(ir)).toBe("100vh");
		});
	});

	describe("percentage values", () => {
		it("generates percentage", () => {
			const ir = { kind: "height" as const, value: { value: 100, unit: "%" as const } };
			expect(toCss(ir)).toBe("100%");
		});
	});

	describe("round-trip", () => {
		it("auto", () => {
			const parsed = Parse.parse("auto");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("max-content", () => {
			const parsed = Parse.parse("max-content");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("100px", () => {
			const parsed = Parse.parse("100px");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/layout/height.ts ===
// b_path:: src/generate/layout/height.ts
import type { Height } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS height property from IR.
 *
 * Outputs length-percentage value, auto keyword, or intrinsic sizing keyword.
 *
 * @param height - Height IR
 * @returns CSS string like "100px", "50%", "auto", or "max-content"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/height}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/height";
 *
 * const css = toCss({ kind: "height", value: { value: 100, unit: "px" } });
 * // "100px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "height", value: "auto" });
 * // "auto"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "height", value: "max-content" });
 * // "max-content"
 * ```
 *
 * @public
 */
export function toCss(height: Height): string {
	if (typeof height.value === "string") {
		return height.value;
	}
	return GenUtils.lengthPercentageToCss(height.value);
}


=== File: src/generate/layout/index.ts ===
// b_path:: src/generate/layout/index.ts

export * as Bottom from "./bottom";
export * as Cursor from "./cursor";
export * as Display from "./display";
export * as Height from "./height";
export * as Left from "./left";
export * as Opacity from "./opacity";
export * as OverflowX from "./overflow-x";
export * as OverflowY from "./overflow-y";
export * as Position from "./position";
export * as Right from "./right";
export * as Top from "./top";
export * as Visibility from "./visibility";
export * as Width from "./width";
export * as ZIndex from "./z-index";


=== File: src/generate/layout/layout.test.ts ===
// b_path:: src/generate/layout/layout.test.ts
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Cursor from "./cursor";
import * as Display from "./display";
import * as Opacity from "./opacity";
import * as Visibility from "./visibility";

describe("Generate Layout - Cursor", () => {
	it("should generate pointer cursor", () => {
		const ir: Type.Cursor = { kind: "cursor", value: "pointer" };
		expect(Cursor.toCss(ir)).toBe("pointer");
	});

	it("should generate default cursor", () => {
		const ir: Type.Cursor = { kind: "cursor", value: "default" };
		expect(Cursor.toCss(ir)).toBe("default");
	});

	it("should generate text cursor", () => {
		const ir: Type.Cursor = { kind: "cursor", value: "text" };
		expect(Cursor.toCss(ir)).toBe("text");
	});

	it("should generate move cursor", () => {
		const ir: Type.Cursor = { kind: "cursor", value: "move" };
		expect(Cursor.toCss(ir)).toBe("move");
	});

	it("should generate grab cursor", () => {
		const ir: Type.Cursor = { kind: "cursor", value: "grab" };
		expect(Cursor.toCss(ir)).toBe("grab");
	});

	it("should generate not-allowed cursor", () => {
		const ir: Type.Cursor = { kind: "cursor", value: "not-allowed" };
		expect(Cursor.toCss(ir)).toBe("not-allowed");
	});

	it("should generate zoom-in cursor", () => {
		const ir: Type.Cursor = { kind: "cursor", value: "zoom-in" };
		expect(Cursor.toCss(ir)).toBe("zoom-in");
	});
});

describe("Generate Layout - Display", () => {
	it("should generate flex display", () => {
		const ir: Type.Display = { kind: "display", value: "flex" };
		expect(Display.toCss(ir)).toBe("flex");
	});

	it("should generate block display", () => {
		const ir: Type.Display = { kind: "display", value: "block" };
		expect(Display.toCss(ir)).toBe("block");
	});

	it("should generate inline display", () => {
		const ir: Type.Display = { kind: "display", value: "inline" };
		expect(Display.toCss(ir)).toBe("inline");
	});

	it("should generate inline-block display", () => {
		const ir: Type.Display = { kind: "display", value: "inline-block" };
		expect(Display.toCss(ir)).toBe("inline-block");
	});

	it("should generate grid display", () => {
		const ir: Type.Display = { kind: "display", value: "grid" };
		expect(Display.toCss(ir)).toBe("grid");
	});

	it("should generate none display", () => {
		const ir: Type.Display = { kind: "display", value: "none" };
		expect(Display.toCss(ir)).toBe("none");
	});

	it("should generate table display", () => {
		const ir: Type.Display = { kind: "display", value: "table" };
		expect(Display.toCss(ir)).toBe("table");
	});

	it("should generate inline-flex display", () => {
		const ir: Type.Display = { kind: "display", value: "inline-flex" };
		expect(Display.toCss(ir)).toBe("inline-flex");
	});
});

describe("Generate Layout - Visibility", () => {
	it("should generate visible visibility", () => {
		const ir: Type.Visibility = { kind: "visibility", value: "visible" };
		expect(Visibility.toCss(ir)).toBe("visible");
	});

	it("should generate hidden visibility", () => {
		const ir: Type.Visibility = { kind: "visibility", value: "hidden" };
		expect(Visibility.toCss(ir)).toBe("hidden");
	});

	it("should generate collapse visibility", () => {
		const ir: Type.Visibility = { kind: "visibility", value: "collapse" };
		expect(Visibility.toCss(ir)).toBe("collapse");
	});
});

describe("Generate Layout - Opacity", () => {
	it("should generate opacity 0", () => {
		const ir: Type.Opacity = { kind: "opacity", value: 0 };
		expect(Opacity.toCss(ir)).toBe("0");
	});

	it("should generate opacity 1", () => {
		const ir: Type.Opacity = { kind: "opacity", value: 1 };
		expect(Opacity.toCss(ir)).toBe("1");
	});

	it("should generate opacity 0.5", () => {
		const ir: Type.Opacity = { kind: "opacity", value: 0.5 };
		expect(Opacity.toCss(ir)).toBe("0.5");
	});

	it("should generate opacity 0.75", () => {
		const ir: Type.Opacity = { kind: "opacity", value: 0.75 };
		expect(Opacity.toCss(ir)).toBe("0.75");
	});

	it("should generate opacity 0.25", () => {
		const ir: Type.Opacity = { kind: "opacity", value: 0.25 };
		expect(Opacity.toCss(ir)).toBe("0.25");
	});
});


=== File: src/generate/layout/left.generate.test.ts ===
// b_path:: src/generate/layout/left.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/layout/left";
import { toCss } from "./left";

describe("Generate.Layout.Left", () => {
	describe("auto keyword", () => {
		it("generates 'auto'", () => {
			const ir = { kind: "left" as const, value: "auto" as const };
			expect(toCss(ir)).toBe("auto");
		});
	});

	describe("length values", () => {
		it("generates px", () => {
			const ir = { kind: "left" as const, value: { value: 10, unit: "px" as const } };
			expect(toCss(ir)).toBe("10px");
		});

		it("generates em", () => {
			const ir = { kind: "left" as const, value: { value: 2, unit: "em" as const } };
			expect(toCss(ir)).toBe("2em");
		});
	});

	describe("percentage values", () => {
		it("generates percentage", () => {
			const ir = { kind: "left" as const, value: { value: 50, unit: "%" as const } };
			expect(toCss(ir)).toBe("50%");
		});
	});

	describe("round-trip", () => {
		it("auto", () => {
			const parsed = Parse.parse("auto");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("10px", () => {
			const parsed = Parse.parse("10px");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/layout/left.ts ===
// b_path:: src/generate/layout/left.ts
import type { Left } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS left property from IR.
 *
 * Outputs length-percentage value or "auto" keyword.
 *
 * @param left - Left IR
 * @returns CSS string like "10px", "50%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/left}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/left";
 *
 * const css = toCss({ kind: "left", value: { value: 10, unit: "px" } });
 * // "10px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "left", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function toCss(left: Left): string {
	if (left.value === "auto") {
		return "auto";
	}
	return GenUtils.lengthPercentageToCss(left.value);
}


=== File: src/generate/layout/opacity.ts ===
// b_path:: src/generate/layout/opacity.ts
import type { Opacity } from "@/core/types";

/**
 * Generate CSS opacity property from IR.
 *
 * Outputs opacity value as a number (0-1).
 *
 * @param opacity - Opacity IR
 * @returns CSS string like "0.5" or "1"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/opacity}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/opacity";
 *
 * const css = toCss({ kind: "opacity", value: 0.5 });
 * // "0.5"
 * ```
 *
 * @public
 */
export function toCss(opacity: Opacity): string {
	return opacity.value.toString();
}


=== File: src/generate/layout/overflow-x.generate.test.ts ===
// b_path:: src/generate/layout/overflow-x.generate.test.ts
import { describe, expect, it } from "vitest";
import type { OverflowX } from "@/core/types";
import * as Generate from "@/generate";

describe("Generate.Layout.OverflowX", () => {
	describe("valid overflow-x keywords", () => {
		it("should generate 'visible'", () => {
			const ir: OverflowX = { kind: "overflow-x", value: "visible" };
			const css = Generate.Layout.OverflowX.toCss(ir);
			expect(css).toBe("visible");
		});

		it("should generate 'hidden'", () => {
			const ir: OverflowX = { kind: "overflow-x", value: "hidden" };
			const css = Generate.Layout.OverflowX.toCss(ir);
			expect(css).toBe("hidden");
		});

		it("should generate 'clip'", () => {
			const ir: OverflowX = { kind: "overflow-x", value: "clip" };
			const css = Generate.Layout.OverflowX.toCss(ir);
			expect(css).toBe("clip");
		});

		it("should generate 'scroll'", () => {
			const ir: OverflowX = { kind: "overflow-x", value: "scroll" };
			const css = Generate.Layout.OverflowX.toCss(ir);
			expect(css).toBe("scroll");
		});

		it("should generate 'auto'", () => {
			const ir: OverflowX = { kind: "overflow-x", value: "auto" };
			const css = Generate.Layout.OverflowX.toCss(ir);
			expect(css).toBe("auto");
		});
	});
});


=== File: src/generate/layout/overflow-x.ts ===
// b_path:: src/generate/layout/overflow-x.ts
import type { OverflowX } from "@/core/types";

/**
 * Generate CSS overflow-x property from IR.
 *
 * Outputs overflow-x keyword value.
 *
 * @param overflowX - OverflowX IR
 * @returns CSS string like "hidden" or "scroll"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/overflow-x";
 *
 * const css = toCss({ kind: "overflow-x", value: "hidden" });
 * // "hidden"
 * ```
 *
 * @public
 */
export function toCss(overflowX: OverflowX): string {
	return overflowX.value;
}


=== File: src/generate/layout/overflow-y.generate.test.ts ===
// b_path:: src/generate/layout/overflow-y.generate.test.ts
import { describe, expect, it } from "vitest";
import type { OverflowY } from "@/core/types";
import * as Generate from "@/generate";

describe("Generate.Layout.OverflowY", () => {
	describe("valid overflow-y keywords", () => {
		it("should generate 'visible'", () => {
			const ir: OverflowY = { kind: "overflow-y", value: "visible" };
			const css = Generate.Layout.OverflowY.toCss(ir);
			expect(css).toBe("visible");
		});

		it("should generate 'hidden'", () => {
			const ir: OverflowY = { kind: "overflow-y", value: "hidden" };
			const css = Generate.Layout.OverflowY.toCss(ir);
			expect(css).toBe("hidden");
		});

		it("should generate 'clip'", () => {
			const ir: OverflowY = { kind: "overflow-y", value: "clip" };
			const css = Generate.Layout.OverflowY.toCss(ir);
			expect(css).toBe("clip");
		});

		it("should generate 'scroll'", () => {
			const ir: OverflowY = { kind: "overflow-y", value: "scroll" };
			const css = Generate.Layout.OverflowY.toCss(ir);
			expect(css).toBe("scroll");
		});

		it("should generate 'auto'", () => {
			const ir: OverflowY = { kind: "overflow-y", value: "auto" };
			const css = Generate.Layout.OverflowY.toCss(ir);
			expect(css).toBe("auto");
		});
	});
});


=== File: src/generate/layout/overflow-y.ts ===
// b_path:: src/generate/layout/overflow-y.ts
import type { OverflowY } from "@/core/types";

/**
 * Generate CSS overflow-y property from IR.
 *
 * Outputs overflow-y keyword value.
 *
 * @param overflowY - OverflowY IR
 * @returns CSS string like "auto" or "scroll"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/overflow-y";
 *
 * const css = toCss({ kind: "overflow-y", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function toCss(overflowY: OverflowY): string {
	return overflowY.value;
}


=== File: src/generate/layout/position.generate.test.ts ===
// b_path:: src/generate/layout/position.generate.test.ts
import { describe, expect, it } from "vitest";
import type { PositionProperty } from "@/core/types";
import * as Generate from "@/generate";

describe("Generate.Layout.Position", () => {
	describe("valid position keywords", () => {
		it("should generate 'static'", () => {
			const ir: PositionProperty = { kind: "position-property", value: "static" };
			const css = Generate.Layout.Position.toCss(ir);
			expect(css).toBe("static");
		});

		it("should generate 'relative'", () => {
			const ir: PositionProperty = { kind: "position-property", value: "relative" };
			const css = Generate.Layout.Position.toCss(ir);
			expect(css).toBe("relative");
		});

		it("should generate 'absolute'", () => {
			const ir: PositionProperty = { kind: "position-property", value: "absolute" };
			const css = Generate.Layout.Position.toCss(ir);
			expect(css).toBe("absolute");
		});

		it("should generate 'fixed'", () => {
			const ir: PositionProperty = { kind: "position-property", value: "fixed" };
			const css = Generate.Layout.Position.toCss(ir);
			expect(css).toBe("fixed");
		});

		it("should generate 'sticky'", () => {
			const ir: PositionProperty = { kind: "position-property", value: "sticky" };
			const css = Generate.Layout.Position.toCss(ir);
			expect(css).toBe("sticky");
		});
	});
});


=== File: src/generate/layout/position.ts ===
// b_path:: src/generate/layout/position.ts
import type { PositionProperty } from "@/core/types";

/**
 * Generate CSS position property from IR.
 *
 * Outputs position keyword value.
 *
 * @param position - PositionProperty IR
 * @returns CSS string like "absolute" or "sticky"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/position";
 *
 * const css = toCss({ kind: "position-property", value: "absolute" });
 * // "absolute"
 * ```
 *
 * @public
 */
export function toCss(position: PositionProperty): string {
	return position.value;
}


=== File: src/generate/layout/right.generate.test.ts ===
// b_path:: src/generate/layout/right.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/layout/right";
import { toCss } from "./right";

describe("Generate.Layout.Right", () => {
	describe("auto keyword", () => {
		it("generates 'auto'", () => {
			const ir = { kind: "right" as const, value: "auto" as const };
			expect(toCss(ir)).toBe("auto");
		});
	});

	describe("length values", () => {
		it("generates px", () => {
			const ir = { kind: "right" as const, value: { value: 10, unit: "px" as const } };
			expect(toCss(ir)).toBe("10px");
		});

		it("generates em", () => {
			const ir = { kind: "right" as const, value: { value: 2, unit: "em" as const } };
			expect(toCss(ir)).toBe("2em");
		});
	});

	describe("percentage values", () => {
		it("generates percentage", () => {
			const ir = { kind: "right" as const, value: { value: 50, unit: "%" as const } };
			expect(toCss(ir)).toBe("50%");
		});
	});

	describe("round-trip", () => {
		it("auto", () => {
			const parsed = Parse.parse("auto");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("10px", () => {
			const parsed = Parse.parse("10px");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/layout/right.ts ===
// b_path:: src/generate/layout/right.ts
import type { Right } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS right property from IR.
 *
 * Outputs length-percentage value or "auto" keyword.
 *
 * @param right - Right IR
 * @returns CSS string like "10px", "50%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/right}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/right";
 *
 * const css = toCss({ kind: "right", value: { value: 10, unit: "px" } });
 * // "10px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "right", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function toCss(right: Right): string {
	if (right.value === "auto") {
		return "auto";
	}
	return GenUtils.lengthPercentageToCss(right.value);
}


=== File: src/generate/layout/top.generate.test.ts ===
// b_path:: src/generate/layout/top.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/layout/top";
import { toCss } from "./top";

describe("Generate.Layout.Top", () => {
	describe("auto keyword", () => {
		it("generates 'auto'", () => {
			const ir = { kind: "top" as const, value: "auto" as const };
			expect(toCss(ir)).toBe("auto");
		});
	});

	describe("length values", () => {
		it("generates px", () => {
			const ir = { kind: "top" as const, value: { value: 10, unit: "px" as const } };
			expect(toCss(ir)).toBe("10px");
		});

		it("generates negative px", () => {
			const ir = { kind: "top" as const, value: { value: -10, unit: "px" as const } };
			expect(toCss(ir)).toBe("-10px");
		});

		it("generates em", () => {
			const ir = { kind: "top" as const, value: { value: 2, unit: "em" as const } };
			expect(toCss(ir)).toBe("2em");
		});

		it("generates rem", () => {
			const ir = { kind: "top" as const, value: { value: 1.5, unit: "rem" as const } };
			expect(toCss(ir)).toBe("1.5rem");
		});
	});

	describe("percentage values", () => {
		it("generates percentage", () => {
			const ir = { kind: "top" as const, value: { value: 50, unit: "%" as const } };
			expect(toCss(ir)).toBe("50%");
		});

		it("generates negative percentage", () => {
			const ir = { kind: "top" as const, value: { value: -25, unit: "%" as const } };
			expect(toCss(ir)).toBe("-25%");
		});
	});

	describe("round-trip", () => {
		it("auto", () => {
			const parsed = Parse.parse("auto");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("10px", () => {
			const parsed = Parse.parse("10px");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("50%", () => {
			const parsed = Parse.parse("50%");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/layout/top.ts ===
// b_path:: src/generate/layout/top.ts
import type { Top } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS top property from IR.
 *
 * Outputs length-percentage value or "auto" keyword.
 *
 * @param top - Top IR
 * @returns CSS string like "10px", "50%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/top}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/top";
 *
 * const css = toCss({ kind: "top", value: { value: 10, unit: "px" } });
 * // "10px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "top", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function toCss(top: Top): string {
	if (top.value === "auto") {
		return "auto";
	}
	return GenUtils.lengthPercentageToCss(top.value);
}


=== File: src/generate/layout/visibility.ts ===
// b_path:: src/generate/layout/visibility.ts
import type { Visibility } from "@/core/types";

/**
 * Generate CSS visibility property from IR.
 *
 * Outputs visibility keyword value.
 *
 * @param visibility - Visibility IR
 * @returns CSS string like "visible" or "hidden"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/visibility";
 *
 * const css = toCss({ kind: "visibility", value: "hidden" });
 * // "hidden"
 * ```
 *
 * @public
 */
export function toCss(visibility: Visibility): string {
	return visibility.value;
}


=== File: src/generate/layout/width.generate.test.ts ===
// b_path:: src/generate/layout/width.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/layout/width";
import { toCss } from "./width";

describe("Generate.Layout.Width", () => {
	describe("auto keyword", () => {
		it("generates 'auto'", () => {
			const ir = { kind: "width" as const, value: "auto" as const };
			expect(toCss(ir)).toBe("auto");
		});
	});

	describe("intrinsic sizing keywords", () => {
		it("generates 'min-content'", () => {
			const ir = { kind: "width" as const, value: "min-content" as const };
			expect(toCss(ir)).toBe("min-content");
		});

		it("generates 'max-content'", () => {
			const ir = { kind: "width" as const, value: "max-content" as const };
			expect(toCss(ir)).toBe("max-content");
		});

		it("generates 'fit-content'", () => {
			const ir = { kind: "width" as const, value: "fit-content" as const };
			expect(toCss(ir)).toBe("fit-content");
		});
	});

	describe("length values", () => {
		it("generates px", () => {
			const ir = { kind: "width" as const, value: { value: 200, unit: "px" as const } };
			expect(toCss(ir)).toBe("200px");
		});

		it("generates em", () => {
			const ir = { kind: "width" as const, value: { value: 10, unit: "em" as const } };
			expect(toCss(ir)).toBe("10em");
		});
	});

	describe("percentage values", () => {
		it("generates percentage", () => {
			const ir = { kind: "width" as const, value: { value: 50, unit: "%" as const } };
			expect(toCss(ir)).toBe("50%");
		});
	});

	describe("round-trip", () => {
		it("auto", () => {
			const parsed = Parse.parse("auto");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("min-content", () => {
			const parsed = Parse.parse("min-content");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("200px", () => {
			const parsed = Parse.parse("200px");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("50%", () => {
			const parsed = Parse.parse("50%");
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = toCss(parsed.value);
				const reparsed = Parse.parse(css);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/layout/width.ts ===
// b_path:: src/generate/layout/width.ts
import type { Width } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS width property from IR.
 *
 * Outputs length-percentage value, auto keyword, or intrinsic sizing keyword.
 *
 * @param width - Width IR
 * @returns CSS string like "200px", "50%", "auto", or "min-content"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/width";
 *
 * const css = toCss({ kind: "width", value: { value: 200, unit: "px" } });
 * // "200px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "width", value: "auto" });
 * // "auto"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "width", value: "min-content" });
 * // "min-content"
 * ```
 *
 * @public
 */
export function toCss(width: Width): string {
	if (typeof width.value === "string") {
		return width.value;
	}
	return GenUtils.lengthPercentageToCss(width.value);
}


=== File: src/generate/layout/z-index.generate.test.ts ===
// b_path:: src/generate/layout/z-index.generate.test.ts
import { describe, expect, it } from "vitest";
import type { ZIndex } from "@/core/types";
import * as Generate from "@/generate";

describe("Generate.Layout.ZIndex", () => {
	describe("integer values", () => {
		it("should generate positive integer", () => {
			const ir: ZIndex = { kind: "z-index", value: 10 };
			const css = Generate.Layout.ZIndex.toCss(ir);
			expect(css).toBe("10");
		});

		it("should generate negative integer", () => {
			const ir: ZIndex = { kind: "z-index", value: -5 };
			const css = Generate.Layout.ZIndex.toCss(ir);
			expect(css).toBe("-5");
		});

		it("should generate zero", () => {
			const ir: ZIndex = { kind: "z-index", value: 0 };
			const css = Generate.Layout.ZIndex.toCss(ir);
			expect(css).toBe("0");
		});

		it("should generate large positive integer", () => {
			const ir: ZIndex = { kind: "z-index", value: 999 };
			const css = Generate.Layout.ZIndex.toCss(ir);
			expect(css).toBe("999");
		});

		it("should generate large negative integer", () => {
			const ir: ZIndex = { kind: "z-index", value: -999 };
			const css = Generate.Layout.ZIndex.toCss(ir);
			expect(css).toBe("-999");
		});
	});

	describe("auto keyword", () => {
		it("should generate 'auto'", () => {
			const ir: ZIndex = { kind: "z-index", value: "auto" };
			const css = Generate.Layout.ZIndex.toCss(ir);
			expect(css).toBe("auto");
		});
	});
});


=== File: src/generate/layout/z-index.ts ===
// b_path:: src/generate/layout/z-index.ts
import type { ZIndex } from "@/core/types";

/**
 * Generate CSS z-index property from IR.
 *
 * Outputs integer value or "auto" keyword.
 *
 * @param zIndex - ZIndex IR
 * @returns CSS string like "10", "-5", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/z-index}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/z-index";
 *
 * const css = toCss({ kind: "z-index", value: 10 });
 * // "10"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "z-index", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function toCss(zIndex: ZIndex): string {
	return String(zIndex.value);
}


=== File: src/generate/outline/color.generate.test.ts ===
// b_path:: src/generate/outline/color.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/outline/color";
import * as Generate from "./color";

describe("Generate.Outline.Color", () => {
	describe("round-trip", () => {
		it("should round-trip 'invert'", () => {
			const input = "invert";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("invert");
			}
		});

		it("should round-trip 'transparent'", () => {
			const input = "transparent";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("transparent");
			}
		});

		it("should round-trip 'currentcolor'", () => {
			const input = "currentcolor";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("currentcolor");
			}
		});

		it("should round-trip 'red'", () => {
			const input = "red";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("red");
			}
		});

		it("should round-trip 'blue'", () => {
			const input = "blue";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("blue");
			}
		});

		it("should round-trip 'green'", () => {
			const input = "green";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("green");
			}
		});
	});
});


=== File: src/generate/outline/color.ts ===
// b_path:: src/generate/outline/color.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS outline-color property value from IR.
 *
 * Converts OutlineColorValue IR to CSS string representation.
 *
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param ir - OutlineColorValue IR object
 * @returns CSS outline-color value string
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "outline-color", color: "red" });
 * // "red"
 * ```
 *
 * @example
 * Invert (outline-specific):
 * ```typescript
 * const css = toCss({ kind: "outline-color", color: "invert" });
 * // "invert"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color | MDN: outline-color}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-color | W3C Spec}
 */
export function toCss(ir: Type.OutlineColorValue): string {
	return ir.color;
}


=== File: src/generate/outline/index.ts ===
// b_path:: src/generate/outline/index.ts

export * as Color from "./color";
export * as Offset from "./offset";
export { generate } from "./outline";
export * as Style from "./style";
export * as Width from "./width";


=== File: src/generate/outline/offset.generate.test.ts ===
// b_path:: src/generate/outline/offset.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/outline/offset";
import * as Generate from "./offset";

describe("Generate.Outline.Offset", () => {
	describe("round-trip", () => {
		it("should round-trip '5px'", () => {
			const input = "5px";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("5px");
			}
		});

		it("should round-trip '2.5em'", () => {
			const input = "2.5em";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("2.5em");
			}
		});

		it("should round-trip '-1px'", () => {
			const input = "-1px";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("-1px");
			}
		});

		it("should round-trip '-2.5em'", () => {
			const input = "-2.5em";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("-2.5em");
			}
		});

		it("should round-trip '0' as '0px'", () => {
			const input = "0";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("0px");
			}
		});
	});
});


=== File: src/generate/outline/offset.ts ===
// b_path:: src/generate/outline/offset.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS outline-offset property value from IR.
 *
 * Converts OutlineOffsetValue IR to CSS string representation.
 *
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param ir - OutlineOffsetValue IR object
 * @returns CSS outline-offset value string
 *
 * @example
 * Positive offset:
 * ```typescript
 * const css = toCss({ kind: "outline-offset", offset: { value: 5, unit: "px" } });
 * // "5px"
 * ```
 *
 * @example
 * Negative offset:
 * ```typescript
 * const css = toCss({ kind: "outline-offset", offset: { value: -2, unit: "px" } });
 * // "-2px"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset | MDN: outline-offset}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-offset | W3C Spec}
 */
export function toCss(ir: Type.OutlineOffsetValue): string {
	return `${ir.offset.value}${ir.offset.unit}`;
}


=== File: src/generate/outline/outline.test.ts ===
// b_path:: src/generate/outline/outline.test.ts

import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types/outline";
import { generate } from "./outline";

describe("Generate.Outline.generate", () => {
	describe("outline-width", () => {
		it("generates outline-width with length", () => {
			const ir: Type.OutlineWidthValue = {
				kind: "outline-width",
				width: { value: 2, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px");
			expect(result.issues).toEqual([]);
		});

		it("generates outline-width with keyword", () => {
			const ir: Type.OutlineWidthValue = {
				kind: "outline-width",
				width: "medium",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("medium");
		});

		it("generates outline-width with thin", () => {
			const ir: Type.OutlineWidthValue = {
				kind: "outline-width",
				width: "thin",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("thin");
		});

		it("generates outline-width with thick", () => {
			const ir: Type.OutlineWidthValue = {
				kind: "outline-width",
				width: "thick",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("thick");
		});
	});

	describe("outline-style", () => {
		it("generates outline-style solid", () => {
			const ir: Type.OutlineStyleValue = {
				kind: "outline-style",
				style: "solid",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("solid");
			expect(result.issues).toEqual([]);
		});

		it("generates outline-style dashed", () => {
			const ir: Type.OutlineStyleValue = {
				kind: "outline-style",
				style: "dashed",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("dashed");
		});

		it("generates outline-style auto", () => {
			const ir: Type.OutlineStyleValue = {
				kind: "outline-style",
				style: "auto",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("auto");
		});

		it("generates outline-style none", () => {
			const ir: Type.OutlineStyleValue = {
				kind: "outline-style",
				style: "none",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("none");
		});
	});

	describe("outline-color", () => {
		it("generates outline-color with keyword", () => {
			const ir: Type.OutlineColorValue = {
				kind: "outline-color",
				color: "red",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("red");
			expect(result.issues).toEqual([]);
		});

		it("generates outline-color with invert", () => {
			const ir: Type.OutlineColorValue = {
				kind: "outline-color",
				color: "invert",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("invert");
		});

		it("generates outline-color with transparent", () => {
			const ir: Type.OutlineColorValue = {
				kind: "outline-color",
				color: "transparent",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("transparent");
		});

		it("generates outline-color with currentColor", () => {
			const ir: Type.OutlineColorValue = {
				kind: "outline-color",
				color: "currentColor",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("currentColor");
		});
	});

	describe("outline-offset", () => {
		it("generates outline-offset with positive value", () => {
			const ir: Type.OutlineOffsetValue = {
				kind: "outline-offset",
				offset: { value: 4, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("4px");
			expect(result.issues).toEqual([]);
		});

		it("generates outline-offset with negative value", () => {
			const ir: Type.OutlineOffsetValue = {
				kind: "outline-offset",
				offset: { value: -2, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("-2px");
		});

		it("generates outline-offset with em units", () => {
			const ir: Type.OutlineOffsetValue = {
				kind: "outline-offset",
				offset: { value: 0.5, unit: "em" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("0.5em");
		});
	});

	describe("error handling", () => {
		it("returns error for null IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(null as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Invalid outline IR: missing 'kind' field");
		});

		it("returns error for undefined IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(undefined as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
		});

		it("returns error for IR without kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({} as any);

			expect(result.ok).toBe(false);
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		});

		it("returns error for unknown kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({ kind: "unknown" } as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Unknown outline kind: unknown");
			expect(result.issues[0]?.suggestion).toContain("outline-width");
			expect(result.issues[0]?.suggestion).toContain("outline-style");
			expect(result.issues[0]?.suggestion).toContain("outline-color");
			expect(result.issues[0]?.suggestion).toContain("outline-offset");
		});
	});
});


=== File: src/generate/outline/outline.ts ===
// b_path:: src/generate/outline/outline.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types/outline";
import * as Color from "./color";
import * as Offset from "./offset";
import * as Style from "./style";
import * as Width from "./width";

/**
 * Generate CSS from outline property IR with auto-detection.
 *
 * Automatically detects outline property type from IR.kind and generates appropriate CSS.
 * Supports outline-width, outline-style, outline-color, and outline-offset.
 *
 * @param outline - Outline property IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Outline width:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Outline.generate({
 *   kind: "outline-width",
 *   width: { value: 2, unit: "px" }
 * });
 * // → { ok: true, value: "2px", issues: [] }
 * ```
 *
 * @example
 * Outline style:
 * ```typescript
 * const result = Generate.Outline.generate({
 *   kind: "outline-style",
 *   style: "dashed"
 * });
 * // → { ok: true, value: "dashed", issues: [] }
 * ```
 *
 * @example
 * Outline color:
 * ```typescript
 * const result = Generate.Outline.generate({
 *   kind: "outline-color",
 *   color: "red"
 * });
 * // → { ok: true, value: "red", issues: [] }
 * ```
 *
 * @example
 * Outline offset:
 * ```typescript
 * const result = Generate.Outline.generate({
 *   kind: "outline-offset",
 *   offset: { value: 4, unit: "px" }
 * });
 * // → { ok: true, value: "4px", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Outline.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid outline IR: missing 'kind' field" }] }
 *
 * const result2 = Generate.Outline.generate({ kind: "unknown" });
 * // → { ok: false, issues: [{ severity: "error", message: "Unknown outline kind: unknown" }] }
 * ```
 *
 * @public
 */
export function generate(
	outline: Type.OutlineWidthValue | Type.OutlineStyleValue | Type.OutlineColorValue | Type.OutlineOffsetValue,
): GenerateResult {
	// Validate IR has 'kind' field
	if (!outline || typeof outline !== "object" || !("kind" in outline)) {
		return generateErr("missing-required-field", "Invalid outline IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (outline.kind) {
		case "outline-width":
			return generateOk(Width.toCss(outline));

		case "outline-style":
			return generateOk(Style.toCss(outline));

		case "outline-color":
			return generateOk(Color.toCss(outline));

		case "outline-offset":
			return generateOk(Offset.toCss(outline));

		default:
			return generateErr("unsupported-kind", `Unknown outline kind: ${(outline as { kind?: string }).kind}`, {
				suggestion:
					"Expected 'outline-width', 'outline-style', 'outline-color', or 'outline-offset'. Check that outline IR is valid.",
			});
	}
}


=== File: src/generate/outline/style.generate.test.ts ===
// b_path:: src/generate/outline/style.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/outline/style";
import * as Generate from "./style";

describe("Generate.Outline.Style", () => {
	describe("round-trip", () => {
		it("should round-trip 'auto'", () => {
			const input = "auto";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("auto");
			}
		});

		it("should round-trip 'none'", () => {
			const input = "none";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("none");
			}
		});

		it("should round-trip 'hidden'", () => {
			const input = "hidden";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("hidden");
			}
		});

		it("should round-trip 'solid'", () => {
			const input = "solid";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("solid");
			}
		});

		it("should round-trip 'dashed'", () => {
			const input = "dashed";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("dashed");
			}
		});

		it("should round-trip 'dotted'", () => {
			const input = "dotted";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("dotted");
			}
		});

		it("should round-trip 'double'", () => {
			const input = "double";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("double");
			}
		});

		it("should round-trip 'groove'", () => {
			const input = "groove";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("groove");
			}
		});

		it("should round-trip 'ridge'", () => {
			const input = "ridge";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("ridge");
			}
		});

		it("should round-trip 'inset'", () => {
			const input = "inset";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("inset");
			}
		});

		it("should round-trip 'outset'", () => {
			const input = "outset";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("outset");
			}
		});
	});
});


=== File: src/generate/outline/style.ts ===
// b_path:: src/generate/outline/style.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS outline-style property value from IR.
 *
 * Converts OutlineStyleValue IR to CSS string representation.
 *
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param ir - OutlineStyleValue IR object
 * @returns CSS outline-style value string
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "outline-style", style: "solid" });
 * // "solid"
 * ```
 *
 * @example
 * Auto (outline-specific):
 * ```typescript
 * const css = toCss({ kind: "outline-style", style: "auto" });
 * // "auto"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style | MDN: outline-style}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-style | W3C Spec}
 */
export function toCss(ir: Type.OutlineStyleValue): string {
	return ir.style;
}


=== File: src/generate/outline/width.generate.test.ts ===
// b_path:: src/generate/outline/width.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/outline/width";
import * as Generate from "./width";

describe("Generate.Outline.Width", () => {
	describe("round-trip", () => {
		it("should round-trip 'thin'", () => {
			const input = "thin";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("thin");
			}
		});

		it("should round-trip 'medium'", () => {
			const input = "medium";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("medium");
			}
		});

		it("should round-trip 'thick'", () => {
			const input = "thick";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("thick");
			}
		});

		it("should round-trip '1px'", () => {
			const input = "1px";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("1px");
			}
		});

		it("should round-trip '2.5em'", () => {
			const input = "2.5em";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("2.5em");
			}
		});

		it("should round-trip '0' as '0px'", () => {
			const input = "0";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const css = Generate.toCss(parsed.value);
				expect(css).toBe("0px");
			}
		});
	});
});


=== File: src/generate/outline/width.ts ===
// b_path:: src/generate/outline/width.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS outline-width property value from IR.
 *
 * Converts OutlineWidthValue IR to CSS string representation.
 *
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param ir - OutlineWidthValue IR object
 * @returns CSS outline-width value string
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({ kind: "outline-width", width: "medium" });
 * // "medium"
 * ```
 *
 * @example
 * Length:
 * ```typescript
 * const css = toCss({ kind: "outline-width", width: { value: 1, unit: "px" } });
 * // "1px"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-width | MDN: outline-width}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-width | W3C Spec}
 */
export function toCss(ir: Type.OutlineWidthValue): string {
	if (typeof ir.width === "string") {
		return ir.width;
	}
	return `${ir.width.value}${ir.width.unit}`;
}


=== File: src/generate/position/index.ts ===
// b_path:: src/generate/position/index.ts

export { generate } from "./position";
export * as Utils from "./utils";


=== File: src/generate/position/position.generate.test.ts ===
// b_path:: src/generate/position/position.generate.test.ts
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as PositionGenerator from "./utils";

describe("Position Generator", () => {
	describe("2D Position generation", () => {
		it("should generate single keyword position", () => {
			const ir: Type.Position2D = {
				horizontal: "center",
				vertical: "center",
			};
			const css = PositionGenerator.toCss(ir);
			expect(css).toBe("center center");
		});

		it("should generate two keyword positions", () => {
			const ir: Type.Position2D = {
				horizontal: "left",
				vertical: "top",
			};
			const css = PositionGenerator.toCss(ir);
			expect(css).toBe("left top");
		});

		it("should generate all keyword combinations", () => {
			const positions: Array<{ ir: Type.Position2D; expected: string }> = [
				{
					ir: { horizontal: "center", vertical: "center" },
					expected: "center center",
				},
				{
					ir: { horizontal: "left", vertical: "center" },
					expected: "left center",
				},
				{
					ir: { horizontal: "right", vertical: "center" },
					expected: "right center",
				},
				{
					ir: { horizontal: "center", vertical: "top" },
					expected: "center top",
				},
				{
					ir: { horizontal: "center", vertical: "bottom" },
					expected: "center bottom",
				},
				{
					ir: { horizontal: "left", vertical: "top" },
					expected: "left top",
				},
				{
					ir: { horizontal: "right", vertical: "bottom" },
					expected: "right bottom",
				},
			];

			for (const { ir, expected } of positions) {
				const css = PositionGenerator.toCss(ir);
				expect(css).toBe(expected);
			}
		});

		it("should generate length values", () => {
			const ir: Type.Position2D = {
				horizontal: { value: 100, unit: "px" },
				vertical: { value: 50, unit: "px" },
			};
			const css = PositionGenerator.toCss(ir);
			expect(css).toBe("100px 50px");
		});

		it("should generate percentage values", () => {
			const ir: Type.Position2D = {
				horizontal: { value: 50, unit: "%" },
				vertical: { value: 25, unit: "%" },
			};
			const css = PositionGenerator.toCss(ir);
			expect(css).toBe("50% 25%");
		});

		it("should generate mixed keyword and length", () => {
			const ir: Type.Position2D = {
				horizontal: "left",
				vertical: { value: 50, unit: "px" },
			};
			const css = PositionGenerator.toCss(ir);
			expect(css).toBe("left 50px");
		});

		it("should generate mixed keyword and percentage", () => {
			const ir: Type.Position2D = {
				horizontal: { value: 50, unit: "%" },
				vertical: "top",
			};
			const css = PositionGenerator.toCss(ir);
			expect(css).toBe("50% top");
		});

		it("should generate mixed length and percentage", () => {
			const ir: Type.Position2D = {
				horizontal: { value: 100, unit: "px" },
				vertical: { value: 50, unit: "%" },
			};
			const css = PositionGenerator.toCss(ir);
			expect(css).toBe("100px 50%");
		});
	});

	describe("3D Position generation", () => {
		it("should generate 3D position", () => {
			const ir: Type.Position3D = {
				x: { value: 10, unit: "px" },
				y: { value: 20, unit: "px" },
				z: { value: 30, unit: "px" },
			};
			const css = PositionGenerator.to3DCss(ir);
			expect(css).toBe("10px 20px 30px");
		});

		it("should generate 3D position with mixed units", () => {
			const ir: Type.Position3D = {
				x: { value: 50, unit: "%" },
				y: { value: 100, unit: "px" },
				z: { value: 2, unit: "em" },
			};
			const css = PositionGenerator.to3DCss(ir);
			expect(css).toBe("50% 100px 2em");
		});

		it("should generate 3D position with mixed keyword and values", () => {
			const ir: Type.Position3D = {
				x: "center",
				y: { value: 20, unit: "px" },
				z: { value: 30, unit: "px" },
			};
			const css = PositionGenerator.to3DCss(ir);
			expect(css).toBe("center 20px 30px");
		});
	});

	describe("Position list generation", () => {
		it("should generate position list", () => {
			const ir: Type.PositionList = [
				{ horizontal: "center", vertical: "center" },
				{ horizontal: "left", vertical: "top" },
				{ horizontal: { value: 50, unit: "%" }, vertical: { value: 25, unit: "%" } },
			];
			const css = PositionGenerator.toListCss(ir);
			expect(css).toBe("center center, left top, 50% 25%");
		});

		it("should generate single position in list", () => {
			const ir: Type.PositionList = [{ horizontal: "center", vertical: "center" }];
			const css = PositionGenerator.toListCss(ir);
			expect(css).toBe("center center");
		});

		it("should generate empty position list", () => {
			const ir: Type.PositionList = [];
			const css = PositionGenerator.toListCss(ir);
			expect(css).toBe("");
		});
	});

	describe("Common position presets", () => {
		it("should generate from common position presets", () => {
			const css = PositionGenerator.fromCommonPosition("center");
			expect(css).toBe("center center");
		});

		it("should generate from all common position presets", () => {
			const presets: Array<{ name: keyof Type.CommonPositions; expected: string }> = [
				{ name: "center", expected: "center center" },
				{ name: "topLeft", expected: "left top" },
				{ name: "topCenter", expected: "center top" },
				{ name: "topRight", expected: "right top" },
				{ name: "middleLeft", expected: "left center" },
				{ name: "middleRight", expected: "right center" },
				{ name: "bottomLeft", expected: "left bottom" },
				{ name: "bottomCenter", expected: "center bottom" },
				{ name: "bottomRight", expected: "right bottom" },
			];

			for (const { name, expected } of presets) {
				const css = PositionGenerator.fromCommonPosition(name);
				expect(css).toBe(expected);
			}
		});
	});
});


=== File: src/generate/position/position.ts ===
// b_path:: src/generate/position/position.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Utils from "./utils";

/**
 * Generate CSS from Position2D IR.
 *
 * Wraps the existing position generator with GenerateResult for consistent API.
 *
 * @param position - Position2D IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate({ horizontal: "center", vertical: "center" })
 * // → { ok: true, value: "center center", issues: [] }
 * ```
 *
 * @public
 */
export function generate(position: Type.Position2D): GenerateResult {
	if (!position || typeof position !== "object") {
		return generateErr("invalid-ir", "Invalid position IR", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	try {
		const css = Utils.toCss(position);
		return generateOk(css);
	} catch (error) {
		return generateErr("invalid-ir", `Failed to generate position: ${error}`, {
			suggestion: "Check that position IR is valid",
		});
	}
}


=== File: src/generate/position/utils.ts ===
// b_path:: src/generate/position/utils.ts
import * as Type from "@/core/types";
import { positionValueToCss } from "@/utils/generate/values";

/**
 * Generate CSS 2D position string from Position2D IR.
 *
 * Converts a Position2D IR object into a valid CSS position string.
 * Handles both keyword and length/percentage values.
 *
 * @param ir - Position2D IR object to convert to CSS
 * @returns CSS position string
 *
 * @public
 *
 * @example
 * Keyword position:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Position.toCss({
 *   horizontal: "center",
 *   vertical: "center"
 * });
 * console.log(css); // "center center"
 * ```
 *
 * @example
 * Mixed position:
 * ```typescript
 * const css = Generate.Position.toCss({
 *   horizontal: "left",
 *   vertical: { value: 50, unit: "%" }
 * });
 * console.log(css); // "left 50%"
 * ```
 *
 * @example
 * Length/percentage position:
 * ```typescript
 * const css = Generate.Position.toCss({
 *   horizontal: { value: 100, unit: "px" },
 *   vertical: { value: 50, unit: "%" }
 * });
 * console.log(css); // "100px 50%"
 * ```
 */
export function toCss(ir: Type.Position2D): string {
	const h = positionValueToCss(ir.horizontal);
	const v = positionValueToCss(ir.vertical);
	return `${h} ${v}`;
}

/**
 * Generate CSS 3D position string from Position3D IR.
 *
 * @param ir - Position3D IR object to convert to CSS
 * @returns CSS 3D position string
 *
 * @public
 */
export function to3DCss(ir: Type.Position3D): string {
	const x = positionValueToCss(ir.x);
	const y = positionValueToCss(ir.y);
	const z = `${ir.z.value}${ir.z.unit}`;
	return `${x} ${y} ${z}`;
}

/**
 * Generate CSS position list string from PositionList IR.
 *
 * @param ir - PositionList IR object to convert to CSS
 * @returns CSS position list string
 *
 * @public
 */
export function toListCss(ir: Type.PositionList): string {
	const positionStrings = ir.map(toCss);
	return positionStrings.join(", ");
}

/**
 * Generate CSS position string from common position preset.
 *
 * @param preset - Common position preset name
 * @returns CSS position string
 *
 * @public
 */
export function fromCommonPosition(preset: keyof Type.CommonPositions): string {
	const position = Type.COMMON_POSITIONS[preset];
	return toCss(position);
}


=== File: src/generate/shadow/box-shadow.generate.test.ts ===
// b_path:: src/generate/shadow/box-shadow.generate.test.ts

import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/shadow/box-shadow";
import * as Generate from "./box-shadow";

describe("BoxShadow Generator", () => {
	it("should generate basic box-shadow with offsets only", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					offsetX: { value: 2, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("2px 2px");
	});

	it("should generate box-shadow with blur radius", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					offsetX: { value: 2, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
					blurRadius: { value: 4, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("2px 2px 4px");
	});

	it("should generate box-shadow with spread radius", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					offsetX: { value: 2, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
					blurRadius: { value: 4, unit: "px" as const },
					spreadRadius: { value: 2, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("2px 2px 4px 2px");
	});

	it("should generate box-shadow with color", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					offsetX: { value: 2, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
					color: { kind: "named" as const, name: "black" },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("2px 2px black");
	});

	it("should generate inset box-shadow", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					inset: true,
					offsetX: { value: 0, unit: "px" as const },
					offsetY: { value: 0, unit: "px" as const },
					blurRadius: { value: 10, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("inset 0px 0px 10px");
	});

	it("should generate inset box-shadow with color", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					inset: true,
					offsetX: { value: 0, unit: "px" as const },
					offsetY: { value: 0, unit: "px" as const },
					blurRadius: { value: 10, unit: "px" as const },
					color: { kind: "named" as const, name: "black" },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("inset 0px 0px 10px black");
	});

	it("should generate box-shadow with all parameters", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					inset: true,
					offsetX: { value: 1, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
					blurRadius: { value: 3, unit: "px" as const },
					spreadRadius: { value: 4, unit: "px" as const },
					color: { kind: "named" as const, name: "red" },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("inset 1px 2px 3px 4px red");
	});

	it("should generate multiple box-shadows", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					offsetX: { value: 2, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
					color: { kind: "named" as const, name: "black" },
				},
				{
					inset: true,
					offsetX: { value: 0, unit: "px" as const },
					offsetY: { value: 0, unit: "px" as const },
					blurRadius: { value: 10, unit: "px" as const },
					color: { kind: "named" as const, name: "white" },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("2px 2px black, inset 0px 0px 10px white");
	});

	it("should preserve different length units", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					offsetX: { value: 1, unit: "em" as const },
					offsetY: { value: 1.5, unit: "rem" as const },
					blurRadius: { value: 0.5, unit: "vw" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("1em 1.5rem 0.5vw");
	});

	it("should handle negative offsets", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					offsetX: { value: -2, unit: "px" as const },
					offsetY: { value: -2, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("-2px -2px");
	});

	it("should generate box-shadow with rgba color", () => {
		const ir = {
			kind: "box-shadow" as const,
			shadows: [
				{
					offsetX: { value: 2, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
					blurRadius: { value: 4, unit: "px" as const },
					color: {
						kind: "rgb" as const,
						r: 0,
						g: 0,
						b: 0,
						alpha: 0.5,
					},
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("2px 2px 4px rgb(0 0 0 / 0.5)");
	});

	describe("Round-trip parsing", () => {
		it("should round-trip basic shadow", () => {
			const original = "2px 2px";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Generate.toCss(parsed.value);
			const reparsed = Parse.parse(generated);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		it("should round-trip shadow with all parameters", () => {
			const original = "inset 1px 2px 3px 4px red";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Generate.toCss(parsed.value);
			const reparsed = Parse.parse(generated);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		it("should round-trip multiple shadows", () => {
			const original = "2px 2px black, inset 0px 0px 10px white";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Generate.toCss(parsed.value);
			const reparsed = Parse.parse(generated);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});
	});
});


=== File: src/generate/shadow/box-shadow.ts ===
// b_path:: src/generate/shadow/box-shadow.ts
import type { BoxShadow } from "@/core/types/shadow";
import { generateColor } from "@/utils/generate/color";

/**
 * Generate CSS box-shadow property value from IR.
 *
 * Outputs box-shadow with required offsets and optional inset, blur, spread, and color.
 * Preserves the original units from the IR.
 * Supports multiple comma-separated shadow layers.
 *
 * @param shadow - BoxShadow IR
 * @returns CSS string like "2px 2px" or "inset 0 0 10px 2px rgba(0,0,0,0.5), 2px 2px 4px black"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/shadow/box-shadow";
 *
 * // Basic shadow
 * const css1 = toCss({
 *   kind: "box-shadow",
 *   shadows: [{
 *     offsetX: { value: 2, unit: "px" },
 *     offsetY: { value: 2, unit: "px" }
 *   }]
 * });
 * // "2px 2px"
 *
 * // With blur and spread
 * const css2 = toCss({
 *   kind: "box-shadow",
 *   shadows: [{
 *     offsetX: { value: 2, unit: "px" },
 *     offsetY: { value: 2, unit: "px" },
 *     blurRadius: { value: 4, unit: "px" },
 *     spreadRadius: { value: 2, unit: "px" }
 *   }]
 * });
 * // "2px 2px 4px 2px"
 *
 * // Inset shadow with color
 * const css3 = toCss({
 *   kind: "box-shadow",
 *   shadows: [{
 *     inset: true,
 *     offsetX: { value: 0, unit: "px" },
 *     offsetY: { value: 0, unit: "px" },
 *     blurRadius: { value: 10, unit: "px" },
 *     color: { kind: "named", name: "black" }
 *   }]
 * });
 * // "inset 0px 0px 10px black"
 *
 * // Multiple shadows
 * const css4 = toCss({
 *   kind: "box-shadow",
 *   shadows: [
 *     {
 *       offsetX: { value: 2, unit: "px" },
 *       offsetY: { value: 2, unit: "px" },
 *       color: { kind: "named", name: "black" }
 *     },
 *     {
 *       inset: true,
 *       offsetX: { value: 0, unit: "px" },
 *       offsetY: { value: 0, unit: "px" },
 *       blurRadius: { value: 10, unit: "px" },
 *       color: { kind: "named", name: "white" }
 *     }
 *   ]
 * });
 * // "2px 2px black, inset 0px 0px 10px white"
 * ```
 *
 * @public
 */
export function toCss(shadow: BoxShadow): string {
	const layers = shadow.shadows.map((layer) => {
		const { inset, offsetX, offsetY, blurRadius, spreadRadius, color } = layer;

		const parts: string[] = [];

		// Add inset keyword if present
		if (inset) {
			parts.push("inset");
		}

		// Add required offset values
		parts.push(`${offsetX.value}${offsetX.unit}`);
		parts.push(`${offsetY.value}${offsetY.unit}`);

		// Add optional blur radius
		if (blurRadius !== undefined) {
			parts.push(`${blurRadius.value}${blurRadius.unit}`);
		}

		// Add optional spread radius
		if (spreadRadius !== undefined) {
			parts.push(`${spreadRadius.value}${spreadRadius.unit}`);
		}

		// Add optional color
		if (color !== undefined) {
			parts.push(generateColor(color));
		}

		return parts.join(" ");
	});

	return layers.join(", ");
}


=== File: src/generate/shadow/index.ts ===
// b_path:: src/generate/shadow/index.ts
export * as BoxShadow from "./box-shadow";
export { generate } from "./shadow";
export * as TextShadow from "./text-shadow";


=== File: src/generate/shadow/shadow.test.ts ===
// b_path:: src/generate/shadow/shadow.test.ts

import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types/shadow";
import { generate } from "./shadow";

describe("Generate.Shadow.generate", () => {
	describe("box-shadow", () => {
		it("generates basic box-shadow", () => {
			const ir: Type.BoxShadow = {
				kind: "box-shadow",
				shadows: [
					{
						offsetX: { value: 2, unit: "px" },
						offsetY: { value: 2, unit: "px" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px 2px");
			expect(result.issues).toEqual([]);
		});

		it("generates box-shadow with blur", () => {
			const ir: Type.BoxShadow = {
				kind: "box-shadow",
				shadows: [
					{
						offsetX: { value: 2, unit: "px" },
						offsetY: { value: 2, unit: "px" },
						blurRadius: { value: 4, unit: "px" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px 2px 4px");
		});

		it("generates box-shadow with blur and spread", () => {
			const ir: Type.BoxShadow = {
				kind: "box-shadow",
				shadows: [
					{
						offsetX: { value: 2, unit: "px" },
						offsetY: { value: 2, unit: "px" },
						blurRadius: { value: 4, unit: "px" },
						spreadRadius: { value: 2, unit: "px" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px 2px 4px 2px");
		});

		it("generates box-shadow with color", () => {
			const ir: Type.BoxShadow = {
				kind: "box-shadow",
				shadows: [
					{
						offsetX: { value: 2, unit: "px" },
						offsetY: { value: 2, unit: "px" },
						blurRadius: { value: 4, unit: "px" },
						color: { kind: "named", name: "black" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px 2px 4px black");
		});

		it("generates inset box-shadow", () => {
			const ir: Type.BoxShadow = {
				kind: "box-shadow",
				shadows: [
					{
						inset: true,
						offsetX: { value: 0, unit: "px" },
						offsetY: { value: 0, unit: "px" },
						blurRadius: { value: 10, unit: "px" },
						color: { kind: "named", name: "rgba(0,0,0,0.5)" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("inset 0px 0px 10px rgba(0,0,0,0.5)");
		});

		it("generates multiple box-shadows", () => {
			const ir: Type.BoxShadow = {
				kind: "box-shadow",
				shadows: [
					{
						offsetX: { value: 2, unit: "px" },
						offsetY: { value: 2, unit: "px" },
						color: { kind: "named", name: "black" },
					},
					{
						inset: true,
						offsetX: { value: 0, unit: "px" },
						offsetY: { value: 0, unit: "px" },
						blurRadius: { value: 10, unit: "px" },
						color: { kind: "named", name: "white" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px 2px black, inset 0px 0px 10px white");
		});
	});

	describe("text-shadow", () => {
		it("generates basic text-shadow", () => {
			const ir: Type.TextShadow = {
				kind: "text-shadow",
				shadows: [
					{
						offsetX: { value: 1, unit: "px" },
						offsetY: { value: 1, unit: "px" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("1px 1px");
			expect(result.issues).toEqual([]);
		});

		it("generates text-shadow with blur", () => {
			const ir: Type.TextShadow = {
				kind: "text-shadow",
				shadows: [
					{
						offsetX: { value: 1, unit: "px" },
						offsetY: { value: 1, unit: "px" },
						blurRadius: { value: 2, unit: "px" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("1px 1px 2px");
		});

		it("generates text-shadow with color", () => {
			const ir: Type.TextShadow = {
				kind: "text-shadow",
				shadows: [
					{
						offsetX: { value: 1, unit: "px" },
						offsetY: { value: 1, unit: "px" },
						blurRadius: { value: 2, unit: "px" },
						color: { kind: "named", name: "gray" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("1px 1px 2px gray");
		});

		it("generates multiple text-shadows", () => {
			const ir: Type.TextShadow = {
				kind: "text-shadow",
				shadows: [
					{
						offsetX: { value: 1, unit: "px" },
						offsetY: { value: 1, unit: "px" },
						blurRadius: { value: 2, unit: "px" },
						color: { kind: "named", name: "black" },
					},
					{
						offsetX: { value: -1, unit: "px" },
						offsetY: { value: -1, unit: "px" },
						blurRadius: { value: 2, unit: "px" },
						color: { kind: "named", name: "white" },
					},
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("1px 1px 2px black, -1px -1px 2px white");
		});
	});

	describe("error handling", () => {
		it("returns error for null IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(null as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Invalid shadow IR: missing 'kind' field");
		});

		it("returns error for undefined IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(undefined as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
		});

		it("returns error for IR without kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({} as any);

			expect(result.ok).toBe(false);
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		});

		it("returns error for unknown kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({ kind: "unknown" } as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Unknown shadow kind: unknown");
			expect(result.issues[0]?.suggestion).toContain("box-shadow");
			expect(result.issues[0]?.suggestion).toContain("text-shadow");
		});
	});
});


=== File: src/generate/shadow/shadow.ts ===
// b_path:: src/generate/shadow/shadow.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types/shadow";
import * as BoxShadow from "./box-shadow";
import * as TextShadow from "./text-shadow";

/**
 * Generate CSS from shadow IR with auto-detection.
 *
 * Automatically detects shadow type from IR.kind and generates appropriate CSS.
 * Supports both box-shadow and text-shadow formats.
 *
 * @param shadow - Shadow IR (BoxShadow or TextShadow)
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Box shadow:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Shadow.generate({
 *   kind: "box-shadow",
 *   shadows: [{
 *     offsetX: { value: 2, unit: "px" },
 *     offsetY: { value: 2, unit: "px" },
 *     blurRadius: { value: 4, unit: "px" },
 *     color: { kind: "named", name: "black" }
 *   }]
 * });
 * // → { ok: true, value: "2px 2px 4px black", issues: [] }
 * ```
 *
 * @example
 * Text shadow:
 * ```typescript
 * const result = Generate.Shadow.generate({
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" },
 *     blurRadius: { value: 2, unit: "px" },
 *     color: { kind: "named", name: "gray" }
 *   }]
 * });
 * // → { ok: true, value: "1px 1px 2px gray", issues: [] }
 * ```
 *
 * @example
 * Multiple shadows:
 * ```typescript
 * const result = Generate.Shadow.generate({
 *   kind: "box-shadow",
 *   shadows: [
 *     {
 *       offsetX: { value: 2, unit: "px" },
 *       offsetY: { value: 2, unit: "px" },
 *       color: { kind: "named", name: "black" }
 *     },
 *     {
 *       inset: true,
 *       offsetX: { value: 0, unit: "px" },
 *       offsetY: { value: 0, unit: "px" },
 *       blurRadius: { value: 10, unit: "px" },
 *       color: { kind: "named", name: "white" }
 *     }
 *   ]
 * });
 * // → { ok: true, value: "2px 2px black, inset 0px 0px 10px white", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Shadow.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid shadow IR: missing 'kind' field" }] }
 *
 * const result2 = Generate.Shadow.generate({ kind: "unknown" });
 * // → { ok: false, issues: [{ severity: "error", message: "Unknown shadow kind: unknown" }] }
 * ```
 *
 * @public
 */
export function generate(shadow: Type.BoxShadow | Type.TextShadow): GenerateResult {
	// Validate IR has 'kind' field
	if (!shadow || typeof shadow !== "object" || !("kind" in shadow)) {
		return generateErr("missing-required-field", "Invalid shadow IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (shadow.kind) {
		case "box-shadow":
			return generateOk(BoxShadow.toCss(shadow));

		case "text-shadow":
			return generateOk(TextShadow.toCss(shadow));

		default:
			return generateErr("unsupported-kind", `Unknown shadow kind: ${(shadow as { kind?: string }).kind}`, {
				suggestion: "Expected 'box-shadow' or 'text-shadow'. Check that shadow IR is valid.",
			});
	}
}


=== File: src/generate/shadow/text-shadow.generate.test.ts ===
// b_path:: src/generate/shadow/text-shadow.generate.test.ts

import { describe, expect, it } from "vitest";
import * as Parse from "@/parse/shadow/text-shadow";
import * as Generate from "./text-shadow";

describe("TextShadow Generator", () => {
	it("should generate basic text-shadow with offsets only", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 1, unit: "px" as const },
					offsetY: { value: 1, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("1px 1px");
	});

	it("should generate text-shadow with blur radius", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 1, unit: "px" as const },
					offsetY: { value: 1, unit: "px" as const },
					blurRadius: { value: 2, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("1px 1px 2px");
	});

	it("should generate text-shadow with color", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 1, unit: "px" as const },
					offsetY: { value: 1, unit: "px" as const },
					color: { kind: "named" as const, name: "gray" },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("1px 1px gray");
	});

	it("should generate text-shadow with blur and color", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 1, unit: "px" as const },
					offsetY: { value: 1, unit: "px" as const },
					blurRadius: { value: 2, unit: "px" as const },
					color: { kind: "named" as const, name: "gray" },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("1px 1px 2px gray");
	});

	it("should generate multiple text-shadows", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 1, unit: "px" as const },
					offsetY: { value: 1, unit: "px" as const },
					blurRadius: { value: 2, unit: "px" as const },
					color: { kind: "named" as const, name: "black" },
				},
				{
					offsetX: { value: -1, unit: "px" as const },
					offsetY: { value: -1, unit: "px" as const },
					blurRadius: { value: 2, unit: "px" as const },
					color: { kind: "named" as const, name: "white" },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("1px 1px 2px black, -1px -1px 2px white");
	});

	it("should preserve different length units", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 0.5, unit: "em" as const },
					offsetY: { value: 0.5, unit: "rem" as const },
					blurRadius: { value: 1, unit: "vw" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("0.5em 0.5rem 1vw");
	});

	it("should handle negative offsets", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: -1, unit: "px" as const },
					offsetY: { value: -1, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("-1px -1px");
	});

	it("should handle zero offsets", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 0, unit: "px" as const },
					offsetY: { value: 0, unit: "px" as const },
					blurRadius: { value: 5, unit: "px" as const },
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("0px 0px 5px");
	});

	it("should generate text-shadow with rgba color", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 1, unit: "px" as const },
					offsetY: { value: 1, unit: "px" as const },
					blurRadius: { value: 2, unit: "px" as const },
					color: {
						kind: "rgb" as const,
						r: 128,
						g: 128,
						b: 128,
						alpha: 0.5,
					},
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("1px 1px 2px rgb(128 128 128 / 0.5)");
	});

	it("should generate text-shadow with hex color", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 2, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
					color: {
						kind: "hex" as const,
						value: "#FF0000",
					},
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("2px 2px #FF0000");
	});

	it("should generate complex multi-layer shadow", () => {
		const ir = {
			kind: "text-shadow" as const,
			shadows: [
				{
					offsetX: { value: 0, unit: "px" as const },
					offsetY: { value: 1, unit: "px" as const },
					blurRadius: { value: 2, unit: "px" as const },
					color: {
						kind: "rgb" as const,
						r: 0,
						g: 0,
						b: 0,
						alpha: 0.3,
					},
				},
				{
					offsetX: { value: 0, unit: "px" as const },
					offsetY: { value: 2, unit: "px" as const },
					blurRadius: { value: 4, unit: "px" as const },
					color: {
						kind: "rgb" as const,
						r: 0,
						g: 0,
						b: 0,
						alpha: 0.2,
					},
				},
				{
					offsetX: { value: 0, unit: "px" as const },
					offsetY: { value: 3, unit: "px" as const },
					blurRadius: { value: 6, unit: "px" as const },
					color: {
						kind: "rgb" as const,
						r: 0,
						g: 0,
						b: 0,
						alpha: 0.1,
					},
				},
			],
		};

		const css = Generate.toCss(ir);
		expect(css).toBe("0px 1px 2px rgb(0 0 0 / 0.3), 0px 2px 4px rgb(0 0 0 / 0.2), 0px 3px 6px rgb(0 0 0 / 0.1)");
	});

	describe("Round-trip parsing", () => {
		it("should round-trip basic shadow", () => {
			const original = "1px 1px";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Generate.toCss(parsed.value);
			const reparsed = Parse.parse(generated);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		it("should round-trip shadow with all parameters", () => {
			const original = "1px 1px 2px gray";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Generate.toCss(parsed.value);
			const reparsed = Parse.parse(generated);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		it("should round-trip multiple shadows", () => {
			const original = "1px 1px 2px black, -1px -1px 2px white";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const generated = Generate.toCss(parsed.value);
			const reparsed = Parse.parse(generated);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});
	});
});


=== File: src/generate/shadow/text-shadow.ts ===
// b_path:: src/generate/shadow/text-shadow.ts
import type { TextShadow } from "@/core/types/shadow";
import { generateColor } from "@/utils/generate/color";

/**
 * Generate CSS text-shadow property value from IR.
 *
 * Outputs text-shadow with required offsets and optional blur and color.
 * Preserves the original units from the IR.
 * Supports multiple comma-separated shadow layers.
 *
 * @param shadow - TextShadow IR
 * @returns CSS string like "1px 1px" or "1px 1px 2px gray, -1px -1px 2px white"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/shadow/text-shadow";
 *
 * // Basic shadow
 * const css1 = toCss({
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" }
 *   }]
 * });
 * // "1px 1px"
 *
 * // With blur radius
 * const css2 = toCss({
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" },
 *     blurRadius: { value: 2, unit: "px" }
 *   }]
 * });
 * // "1px 1px 2px"
 *
 * // With color
 * const css3 = toCss({
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" },
 *     blurRadius: { value: 2, unit: "px" },
 *     color: { kind: "named", name: "gray" }
 *   }]
 * });
 * // "1px 1px 2px gray"
 *
 * // Multiple shadows
 * const css4 = toCss({
 *   kind: "text-shadow",
 *   shadows: [
 *     {
 *       offsetX: { value: 1, unit: "px" },
 *       offsetY: { value: 1, unit: "px" },
 *       blurRadius: { value: 2, unit: "px" },
 *       color: { kind: "named", name: "black" }
 *     },
 *     {
 *       offsetX: { value: -1, unit: "px" },
 *       offsetY: { value: -1, unit: "px" },
 *       blurRadius: { value: 2, unit: "px" },
 *       color: { kind: "named", name: "white" }
 *     }
 *   ]
 * });
 * // "1px 1px 2px black, -1px -1px 2px white"
 * ```
 *
 * @public
 */
export function toCss(shadow: TextShadow): string {
	const layers = shadow.shadows.map((layer) => {
		const { offsetX, offsetY, blurRadius, color } = layer;

		const parts: string[] = [];

		// Add required offset values
		parts.push(`${offsetX.value}${offsetX.unit}`);
		parts.push(`${offsetY.value}${offsetY.unit}`);

		// Add optional blur radius
		if (blurRadius !== undefined) {
			parts.push(`${blurRadius.value}${blurRadius.unit}`);
		}

		// Add optional color
		if (color !== undefined) {
			parts.push(generateColor(color));
		}

		return parts.join(" ");
	});

	return layers.join(", ");
}


=== File: src/generate/text/color.ts ===
// b_path:: src/generate/text/color.ts
import type { Color } from "@/core/types/color";
import * as ColorGenerators from "../color";

/**
 * Generate CSS text-decoration-color string from Color IR.
 *
 * @param color - Color IR object
 * @returns CSS text-decoration-color string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Text.Color.toCss({ kind: "named", name: "red" });
 * console.log(css); // "red"
 * ```
 */
export function toCss(color: Color): string {
	switch (color.kind) {
		case "hex":
			return ColorGenerators.Hex.toCss(color);
		case "named":
			return ColorGenerators.Named.toCss(color);
		case "rgb":
			return ColorGenerators.Rgb.toCss(color);
		case "hsl":
			return ColorGenerators.Hsl.toCss(color);
		case "hwb":
			return ColorGenerators.Hwb.toCss(color);
		case "lab":
			return ColorGenerators.Lab.toCss(color);
		case "lch":
			return ColorGenerators.Lch.toCss(color);
		case "oklab":
			return ColorGenerators.Oklab.toCss(color);
		case "oklch":
			return ColorGenerators.Oklch.toCss(color);
		case "system":
			return ColorGenerators.System.toCss(color);
		case "special":
			return ColorGenerators.Special.toCss(color);
		case "color":
			return ColorGenerators.ColorFunction.toCss(color);
	}
}


=== File: src/generate/text/index.ts ===
// b_path:: src/generate/text/index.ts
export * as Color from "./color";
export * as Line from "./line";
export * as Style from "./style";
export * as Thickness from "./thickness";


=== File: src/generate/text/line.ts ===
// b_path:: src/generate/text/line.ts
import type * as Keyword from "@/core/keywords";

/**
 * Generate CSS text-decoration-line string from keyword.
 *
 * @param keyword - TextDecorationLineKeyword value
 * @returns CSS text-decoration-line string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Text.Line.toCss("underline");
 * console.log(css); // "underline"
 * ```
 */
export function toCss(keyword: Keyword.TextDecorationLineKeyword): string {
	return keyword;
}


=== File: src/generate/text/style.ts ===
// b_path:: src/generate/text/style.ts
import type * as Keyword from "@/core/keywords";

/**
 * Generate CSS text-decoration-style string from keyword.
 *
 * @param keyword - TextDecorationStyleKeyword value
 * @returns CSS text-decoration-style string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Text.Style.toCss("wavy");
 * console.log(css); // "wavy"
 * ```
 */
export function toCss(keyword: Keyword.TextDecorationStyleKeyword): string {
	return keyword;
}


=== File: src/generate/text/thickness.ts ===
// b_path:: src/generate/text/thickness.ts
import type { TextDecorationThicknessValue } from "../../parse/text/thickness";

/**
 * Generate CSS text-decoration-thickness string from value.
 *
 * @param value - TextDecorationThicknessValue (keyword or length-percentage)
 * @returns CSS text-decoration-thickness string
 *
 * @public
 *
 * @example
 * Keyword:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Text.Thickness.toCss("auto");
 * console.log(css); // "auto"
 * ```
 *
 * @example
 * Length value:
 * ```typescript
 * const css = Generate.Text.Thickness.toCss({ value: 2, unit: "px" });
 * console.log(css); // "2px"
 * ```
 */
export function toCss(value: TextDecorationThicknessValue): string {
	if (typeof value === "string") {
		return value;
	}
	return `${value.value}${value.unit}`;
}


=== File: src/generate/transform/index.ts ===
// b_path:: src/generate/transform/index.ts

export * as Origin from "./origin";
export { generate } from "./transform";
export * as Utils from "./utils";


=== File: src/generate/transform/origin.test.ts ===
// b_path:: src/generate/transform/origin.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "../../parse/transform/origin";
import * as Origin from "./origin";

describe("Transform.Origin.toCss", () => {
	describe("2D positions - keywords", () => {
		it("generates center", () => {
			const css = Origin.toCss({
				horizontal: "center",
				vertical: "center",
			});
			expect(css).toBe("center center");
		});

		it("generates left top", () => {
			const css = Origin.toCss({
				horizontal: "left",
				vertical: "top",
			});
			expect(css).toBe("left top");
		});

		it("generates right bottom", () => {
			const css = Origin.toCss({
				horizontal: "right",
				vertical: "bottom",
			});
			expect(css).toBe("right bottom");
		});
	});

	describe("2D positions - values", () => {
		it("generates percentage values", () => {
			const css = Origin.toCss({
				horizontal: { value: 50, unit: "%" },
				vertical: { value: 50, unit: "%" },
			});
			expect(css).toBe("50% 50%");
		});

		it("generates pixel values", () => {
			const css = Origin.toCss({
				horizontal: { value: 100, unit: "px" },
				vertical: { value: 200, unit: "px" },
			});
			expect(css).toBe("100px 200px");
		});

		it("generates mixed values", () => {
			const css = Origin.toCss({
				horizontal: "left",
				vertical: { value: 25, unit: "%" },
			});
			expect(css).toBe("left 25%");
		});

		it("generates zero values", () => {
			const css = Origin.toCss({
				horizontal: { value: 0, unit: "px" },
				vertical: { value: 0, unit: "px" },
			});
			expect(css).toBe("0px 0px");
		});
	});

	describe("3D positions", () => {
		it("generates 3D with pixel values", () => {
			const css = Origin.toCss({
				x: { value: 50, unit: "px" },
				y: { value: 100, unit: "px" },
				z: { value: 10, unit: "px" },
			});
			expect(css).toBe("50px 100px 10px");
		});

		it("generates 3D with keywords and z-value", () => {
			const css = Origin.toCss({
				x: "left",
				y: "top",
				z: { value: 20, unit: "px" },
			});
			expect(css).toBe("left top 20px");
		});

		it("generates 3D with center", () => {
			const css = Origin.toCss({
				x: "center",
				y: "center",
				z: { value: 5, unit: "px" },
			});
			expect(css).toBe("center center 5px");
		});
	});

	describe("round-trip validation", () => {
		it("round-trips 2D keywords", () => {
			const original = "left top";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Origin.toCss(parsed.value);
				const reparsed = Parse.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("round-trips 2D values", () => {
			const original = "50% 100px";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Origin.toCss(parsed.value);
				const reparsed = Parse.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("round-trips 3D positions", () => {
			const original = "center center 10px";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Origin.toCss(parsed.value);
				const reparsed = Parse.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("round-trips 3D with values", () => {
			const original = "50px 100px 20px";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Origin.toCss(parsed.value);
				const reparsed = Parse.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});

describe("Transform.PerspectiveOrigin.toCssPerspectiveOrigin", () => {
	describe("2D positions", () => {
		it("generates center", () => {
			const css = Origin.toCssPerspectiveOrigin({
				horizontal: "center",
				vertical: "center",
			});
			expect(css).toBe("center center");
		});

		it("generates percentage values", () => {
			const css = Origin.toCssPerspectiveOrigin({
				horizontal: { value: 50, unit: "%" },
				vertical: { value: 50, unit: "%" },
			});
			expect(css).toBe("50% 50%");
		});

		it("generates mixed values", () => {
			const css = Origin.toCssPerspectiveOrigin({
				horizontal: "left",
				vertical: { value: 75, unit: "%" },
			});
			expect(css).toBe("left 75%");
		});
	});

	describe("round-trip validation", () => {
		it("round-trips keywords", () => {
			const original = "right bottom";
			const parsed = Parse.parsePerspectiveOrigin(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Origin.toCssPerspectiveOrigin(parsed.value);
				const reparsed = Parse.parsePerspectiveOrigin(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("round-trips values", () => {
			const original = "100px 200px";
			const parsed = Parse.parsePerspectiveOrigin(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Origin.toCssPerspectiveOrigin(parsed.value);
				const reparsed = Parse.parsePerspectiveOrigin(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/transform/origin.ts ===
// b_path:: src/generate/transform/origin.ts
import type * as Type from "@/core/types";
import * as Position from "../position/utils";

/**
 * Generate CSS transform-origin string from Position2D or Position3D IR.
 *
 * Converts a Position2D or Position3D IR object into a valid CSS transform-origin string.
 * Handles both 2D (x y) and 3D (x y z) positions.
 *
 * @param ir - Position2D or Position3D IR object
 * @returns CSS transform-origin string
 *
 * @public
 *
 * @example
 * 2D keyword position:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Transform.Origin.toCss({
 *   horizontal: "center",
 *   vertical: "top"
 * });
 * console.log(css); // "center top"
 * ```
 *
 * @example
 * 2D with values:
 * ```typescript
 * const css = Generate.Transform.Origin.toCss({
 *   horizontal: { value: 50, unit: "%" },
 *   vertical: { value: 100, unit: "px" }
 * });
 * console.log(css); // "50% 100px"
 * ```
 *
 * @example
 * 3D position:
 * ```typescript
 * const css = Generate.Transform.Origin.toCss({
 *   x: "left",
 *   y: "top",
 *   z: { value: 10, unit: "px" }
 * });
 * console.log(css); // "left top 10px"
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin | MDN: transform-origin}
 */
export function toCss(ir: Type.Position2D | Type.Position3D): string {
	// Check if it's a 3D position (has x, y, z)
	if ("x" in ir && "y" in ir && "z" in ir) {
		return Position.to3DCss(ir);
	}

	// 2D position
	return Position.toCss(ir);
}

/**
 * Generate CSS perspective-origin string from Position2D IR.
 *
 * Converts a Position2D IR object into a valid CSS perspective-origin string.
 * Only supports 2D positions.
 *
 * @param ir - Position2D IR object
 * @returns CSS perspective-origin string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Transform.PerspectiveOrigin.toCss({
 *   horizontal: { value: 50, unit: "%" },
 *   vertical: { value: 50, unit: "%" }
 * });
 * console.log(css); // "50% 50%"
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/perspective-origin | MDN: perspective-origin}
 */
export function toCssPerspectiveOrigin(ir: Type.Position2D): string {
	return Position.toCss(ir);
}


=== File: src/generate/transform/transform.generate.test.ts ===
// b_path:: src/generate/transform/transform.generate.test.ts
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as TransformGenerator from "./utils";

describe("Transform Generator", () => {
	describe("Translation transform generation", () => {
		it("should generate translate with two values", () => {
			const ir: Type.Transform = [
				{
					kind: "translate",
					x: { value: 100, unit: "px" },
					y: { value: 50, unit: "px" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translate(100px, 50px)");
		});

		it("should generate translate with one value", () => {
			const ir: Type.Transform = [
				{
					kind: "translate",
					x: { value: 100, unit: "px" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translate(100px)");
		});

		it("should generate translate with percentage values", () => {
			const ir: Type.Transform = [
				{
					kind: "translate",
					x: { value: 50, unit: "%" },
					y: { value: 25, unit: "%" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translate(50%, 25%)");
		});

		it("should generate translateX", () => {
			const ir: Type.Transform = [
				{
					kind: "translateX",
					x: { value: 100, unit: "px" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translateX(100px)");
		});

		it("should generate translateY", () => {
			const ir: Type.Transform = [
				{
					kind: "translateY",
					y: { value: 50, unit: "%" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translateY(50%)");
		});

		it("should generate translateZ", () => {
			const ir: Type.Transform = [
				{
					kind: "translateZ",
					z: { value: 30, unit: "px" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translateZ(30px)");
		});

		it("should generate translate3d", () => {
			const ir: Type.Transform = [
				{
					kind: "translate3d",
					x: { value: 10, unit: "px" },
					y: { value: 20, unit: "px" },
					z: { value: 30, unit: "px" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translate3d(10px, 20px, 30px)");
		});
	});

	describe("Rotation transform generation", () => {
		it("should generate rotate", () => {
			const ir: Type.Transform = [
				{
					kind: "rotate",
					angle: { value: 45, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("rotate(45deg)");
		});

		it("should generate rotate with radians", () => {
			const ir: Type.Transform = [
				{
					kind: "rotate",
					angle: { value: 1.57, unit: "rad" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("rotate(1.57rad)");
		});

		it("should generate rotate with turns", () => {
			const ir: Type.Transform = [
				{
					kind: "rotate",
					angle: { value: 0.25, unit: "turn" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("rotate(0.25turn)");
		});

		it("should generate rotateX", () => {
			const ir: Type.Transform = [
				{
					kind: "rotateX",
					angle: { value: 45, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("rotateX(45deg)");
		});

		it("should generate rotateY", () => {
			const ir: Type.Transform = [
				{
					kind: "rotateY",
					angle: { value: 45, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("rotateY(45deg)");
		});

		it("should generate rotateZ", () => {
			const ir: Type.Transform = [
				{
					kind: "rotateZ",
					angle: { value: 45, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("rotateZ(45deg)");
		});

		it("should generate rotate3d", () => {
			const ir: Type.Transform = [
				{
					kind: "rotate3d",
					x: 1,
					y: 1,
					z: 0,
					angle: { value: 45, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("rotate3d(1, 1, 0, 45deg)");
		});
	});

	describe("Scale transform generation", () => {
		it("should generate scale with two values", () => {
			const ir: Type.Transform = [
				{
					kind: "scale",
					x: 1.5,
					y: 2,
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("scale(1.5, 2)");
		});

		it("should generate scale with one value", () => {
			const ir: Type.Transform = [
				{
					kind: "scale",
					x: 1.5,
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("scale(1.5)");
		});

		it("should generate scaleX", () => {
			const ir: Type.Transform = [
				{
					kind: "scaleX",
					x: 1.5,
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("scaleX(1.5)");
		});

		it("should generate scaleY", () => {
			const ir: Type.Transform = [
				{
					kind: "scaleY",
					y: 2,
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("scaleY(2)");
		});

		it("should generate scaleZ", () => {
			const ir: Type.Transform = [
				{
					kind: "scaleZ",
					z: 0.5,
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("scaleZ(0.5)");
		});

		it("should generate scale3d", () => {
			const ir: Type.Transform = [
				{
					kind: "scale3d",
					x: 1.5,
					y: 2,
					z: 0.5,
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("scale3d(1.5, 2, 0.5)");
		});
	});

	describe("Skew transform generation", () => {
		it("should generate skew with two values", () => {
			const ir: Type.Transform = [
				{
					kind: "skew",
					x: { value: 45, unit: "deg" },
					y: { value: 10, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("skew(45deg, 10deg)");
		});

		it("should generate skew with one value", () => {
			const ir: Type.Transform = [
				{
					kind: "skew",
					x: { value: 45, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("skew(45deg)");
		});

		it("should generate skewX", () => {
			const ir: Type.Transform = [
				{
					kind: "skewX",
					x: { value: 45, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("skewX(45deg)");
		});

		it("should generate skewY", () => {
			const ir: Type.Transform = [
				{
					kind: "skewY",
					y: { value: 10, unit: "deg" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("skewY(10deg)");
		});
	});

	describe("Matrix transform generation", () => {
		it("should generate matrix", () => {
			const ir: Type.Transform = [
				{
					kind: "matrix",
					a: 1,
					b: 0.5,
					c: -0.5,
					d: 1,
					e: { value: 10, unit: "px" },
					f: { value: 20, unit: "px" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("matrix(1, 0.5, -0.5, 1, 10, 20)");
		});

		it("should generate matrix3d", () => {
			const ir: Type.Transform = [
				{
					kind: "matrix3d",
					values: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)");
		});
	});

	describe("Perspective transform generation", () => {
		it("should generate perspective", () => {
			const ir: Type.Transform = [
				{
					kind: "perspective",
					depth: { value: 1000, unit: "px" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("perspective(1000px)");
		});
	});

	describe("Multiple transform generation", () => {
		it("should generate multiple transforms", () => {
			const ir: Type.Transform = [
				{ kind: "translateX", x: { value: 100, unit: "px" } },
				{ kind: "rotate", angle: { value: 45, unit: "deg" } },
				{ kind: "scale", x: 1.5, y: 1.5 },
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translateX(100px) rotate(45deg) scale(1.5, 1.5)");
		});

		it("should generate complex transform chain", () => {
			const ir: Type.Transform = [
				{
					kind: "translate3d",
					x: { value: 10, unit: "px" },
					y: { value: 20, unit: "px" },
					z: { value: 30, unit: "px" },
				},
				{ kind: "rotateY", angle: { value: 45, unit: "deg" } },
				{ kind: "scale3d", x: 1.5, y: 2, z: 0.5 },
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translate3d(10px, 20px, 30px) rotateY(45deg) scale3d(1.5, 2, 0.5)");
		});
	});

	describe("Individual function generation", () => {
		it("should generate individual translate function", () => {
			const ir: Type.TransformFunction = {
				kind: "translate",
				x: { value: 100, unit: "px" },
				y: { value: 50, unit: "px" },
			};
			const css = TransformGenerator.toFunctionCss(ir);
			expect(css).toBe("translate(100px, 50px)");
		});

		it("should generate individual rotate function", () => {
			const ir: Type.TransformFunction = {
				kind: "rotate",
				angle: { value: 45, unit: "deg" },
			};
			const css = TransformGenerator.toFunctionCss(ir);
			expect(css).toBe("rotate(45deg)");
		});

		it("should generate individual scale function", () => {
			const ir: Type.TransformFunction = {
				kind: "scale",
				x: 1.5,
				y: 2,
			};
			const css = TransformGenerator.toFunctionCss(ir);
			expect(css).toBe("scale(1.5, 2)");
		});

		it("should generate individual matrix function", () => {
			const ir: Type.TransformFunction = {
				kind: "matrix",
				a: 1,
				b: 0.5,
				c: -0.5,
				d: 1,
				e: { value: 10, unit: "px" },
				f: { value: 20, unit: "px" },
			};
			const css = TransformGenerator.toFunctionCss(ir);
			expect(css).toBe("matrix(1, 0.5, -0.5, 1, 10, 20)");
		});
	});

	describe("Edge cases", () => {
		it("should handle empty transform array", () => {
			const ir: Type.Transform = [];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("");
		});

		it("should handle single transform", () => {
			const ir: Type.Transform = [
				{
					kind: "translateX",
					x: { value: 100, unit: "px" },
				},
			];
			const css = TransformGenerator.toCss(ir);
			expect(css).toBe("translateX(100px)");
		});
	});
});


=== File: src/generate/transform/transform.ts ===
// b_path:: src/generate/transform/transform.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Utils from "./utils";

/**
 * Generate CSS from Transform IR.
 *
 * Wraps the existing transform generator with GenerateResult for consistent API.
 *
 * @param transform - Transform IR (array of transform functions)
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate([
 *   { kind: "translateX", x: { value: 100, unit: "px" } },
 *   { kind: "rotate", angle: { value: 45, unit: "deg" } }
 * ])
 * // → { ok: true, value: "translateX(100px) rotate(45deg)", issues: [] }
 * ```
 *
 * @public
 */
export function generate(transform: Type.Transform): GenerateResult {
	if (!transform || !Array.isArray(transform)) {
		return generateErr("invalid-ir", "Invalid transform IR: must be an array", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	if (transform.length === 0) {
		return generateErr("invalid-ir", "Transform array cannot be empty", {
			suggestion: "Provide at least one transform function",
		});
	}

	try {
		const css = Utils.toCss(transform);
		return generateOk(css);
	} catch (error) {
		return generateErr("invalid-ir", `Failed to generate transform: ${error}`, {
			suggestion: "Check that transform IR is valid",
		});
	}
}


=== File: src/generate/transform/utils.ts ===
// b_path:: src/generate/transform/utils.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS length/percentage string from IR value.
 *
 * @param value - LengthPercentage IR object
 * @returns CSS length/percentage string
 *
 * @internal
 */
function lengthPercentageToCss(value: Type.LengthPercentage): string {
	return `${value.value}${value.unit}`;
}

/**
 * Generate CSS length string from IR value.
 *
 * @param value - Length IR object
 * @returns CSS length string
 *
 * @internal
 */
function lengthToCss(value: Type.Length): string {
	return `${value.value}${value.unit}`;
}

/**
 * Generate CSS angle string from IR value.
 *
 * @param value - Angle IR object
 * @returns CSS angle string
 *
 * @internal
 */
function angleToCss(value: Type.Angle): string {
	return `${value.value}${value.unit}`;
}

/**
 * Generate CSS transform function string from TransformFunction IR.
 *
 * Converts a single TransformFunction IR object into a valid CSS transform function string.
 *
 * @param ir - TransformFunction IR object to convert to CSS
 * @returns CSS transform function string
 *
 * @public
 *
 * @example
 * Translation:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Transform.toFunctionCss({
 *   kind: "translate",
 *   x: { value: 100, unit: "px" },
 *   y: { value: 50, unit: "px" }
 * });
 * console.log(css); // "translate(100px, 50px)"
 * ```
 *
 * @example
 * Rotation:
 * ```typescript
 * const css = Generate.Transform.toFunctionCss({
 *   kind: "rotate",
 *   angle: { value: 45, unit: "deg" }
 * });
 * console.log(css); // "rotate(45deg)"
 * ```
 *
 * @example
 * Scale:
 * ```typescript
 * const css = Generate.Transform.toFunctionCss({
 *   kind: "scale",
 *   x: 1.5,
 *   y: 2
 * });
 * console.log(css); // "scale(1.5, 2)"
 * ```
 */
export function toFunctionCss(ir: Type.TransformFunction): string {
	switch (ir.kind) {
		case "translate":
			if (ir.y) {
				return `translate(${lengthPercentageToCss(ir.x)}, ${lengthPercentageToCss(ir.y)})`;
			}
			return `translate(${lengthPercentageToCss(ir.x)})`;

		case "translateX":
			return `translateX(${lengthPercentageToCss(ir.x)})`;

		case "translateY":
			return `translateY(${lengthPercentageToCss(ir.y)})`;

		case "translateZ":
			return `translateZ(${lengthToCss(ir.z)})`;

		case "translate3d":
			return `translate3d(${lengthPercentageToCss(ir.x)}, ${lengthPercentageToCss(ir.y)}, ${lengthToCss(ir.z)})`;

		case "rotate":
			return `rotate(${angleToCss(ir.angle)})`;

		case "rotateX":
			return `rotateX(${angleToCss(ir.angle)})`;

		case "rotateY":
			return `rotateY(${angleToCss(ir.angle)})`;

		case "rotateZ":
			return `rotateZ(${angleToCss(ir.angle)})`;

		case "rotate3d":
			return `rotate3d(${ir.x}, ${ir.y}, ${ir.z}, ${angleToCss(ir.angle)})`;

		case "scale":
			if (ir.y) {
				return `scale(${ir.x}, ${ir.y})`;
			}
			return `scale(${ir.x})`;

		case "scaleX":
			return `scaleX(${ir.x})`;

		case "scaleY":
			return `scaleY(${ir.y})`;

		case "scaleZ":
			return `scaleZ(${ir.z})`;

		case "scale3d":
			return `scale3d(${ir.x}, ${ir.y}, ${ir.z})`;

		case "skew":
			if (ir.y) {
				return `skew(${angleToCss(ir.x)}, ${angleToCss(ir.y)})`;
			}
			return `skew(${angleToCss(ir.x)})`;

		case "skewX":
			return `skewX(${angleToCss(ir.x)})`;

		case "skewY":
			return `skewY(${angleToCss(ir.y)})`;

		case "matrix":
			return `matrix(${ir.a}, ${ir.b}, ${ir.c}, ${ir.d}, ${ir.e.value}, ${ir.f.value})`;

		case "matrix3d":
			return `matrix3d(${ir.values.join(", ")})`;

		case "perspective":
			return `perspective(${lengthToCss(ir.depth)})`;

		default: {
			// Exhaustive check - TypeScript will ensure all cases are handled
			const _exhaustiveCheck: never = ir;
			throw new Error(`Unknown transform function kind: ${(_exhaustiveCheck as { kind: string }).kind}`);
		}
	}
}

/**
 * Generate a CSS transform string from intermediate representation (IR).
 *
 * Converts a Transform IR object (array of transform functions) into a valid CSS
 * transform property value string. Multiple transform functions are space-separated.
 *
 * The generated CSS string is spec-compliant and can be used directly in CSS
 * properties like `transform`, `transform-origin`, etc.
 *
 * This function performs the inverse operation of `Parse.Transform.parse()`,
 * enabling bidirectional transformation between CSS and IR.
 *
 * @param ir - Transform IR object to convert to CSS
 * @returns CSS transform property value string
 *
 * @public
 *
 * @example
 * Simple translation:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Transform.toCss([{
 *   kind: "translateX",
 *   x: { value: 100, unit: "px" }
 * }]);
 * console.log(css); // "translateX(100px)"
 * ```
 *
 * @example
 * Multiple transforms:
 * ```typescript
 * const css = Generate.Transform.toCss([
 *   { kind: "translate", x: { value: 100, unit: "px" }, y: { value: 50, unit: "px" } },
 *   { kind: "rotate", angle: { value: 45, unit: "deg" } },
 *   { kind: "scale", x: 1.5, y: 1.5 }
 * ]);
 * console.log(css); // "translate(100px, 50px) rotate(45deg) scale(1.5, 1.5)"
 * ```
 *
 * @example
 * 3D transforms:
 * ```typescript
 * const css = Generate.Transform.toCss([
 *   { kind: "translate3d", x: { value: 10, unit: "px" }, y: { value: 20, unit: "px" }, z: { value: 30, unit: "px" } },
 *   { kind: "rotateY", angle: { value: 45, unit: "deg" } }
 * ]);
 * console.log(css); // "translate3d(10px, 20px, 30px) rotateY(45deg)"
 * ```
 *
 * @example
 * Matrix transform:
 * ```typescript
 * const css = Generate.Transform.toCss([{
 *   kind: "matrix",
 *   a: 1, b: 0.5, c: -0.5, d: 1,
 *   e: { value: 10, unit: "px" },
 *   f: { value: 20, unit: "px" }
 * }]);
 * console.log(css); // "matrix(1, 0.5, -0.5, 1, 10, 20)"
 * ```
 *
 * @example
 * Round-trip transformation (parse → generate):
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "translateX(100px) rotate(45deg) scale(1.5)";
 * const parsed = Parse.Transform.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Transform.toCss(parsed.value);
 *   console.log(generated === original); // true - perfect round-trip!
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform | MDN: transform}
 * @see {@link https://www.w3.org/TR/css-transforms-1/ | W3C Spec: CSS Transforms Level 1}
 * @see {@link https://www.w3.org/TR/css-transforms-2/ | W3C Spec: CSS Transforms Level 2}
 */
export function toCss(ir: Type.Transform): string {
	if (ir.length === 0) {
		return "";
	}

	const functionStrings = ir.map(toFunctionCss);
	return functionStrings.join(" ");
}


=== File: src/generate/transition/delay.generate.test.ts ===
// b_path:: src/generate/transition/delay.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/transition/delay";
import * as Generator from "./delay";

describe("Transition Delay Generator", () => {
	it("should generate single delay in seconds", () => {
		const ir = {
			kind: "transition-delay" as const,
			delays: [{ value: 1, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("1s");
	});

	it("should generate single delay in milliseconds", () => {
		const ir = {
			kind: "transition-delay" as const,
			delays: [{ value: 500, unit: "ms" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("500ms");
	});

	it("should generate negative delay", () => {
		const ir = {
			kind: "transition-delay" as const,
			delays: [{ value: -2, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("-2s");
	});

	it("should generate zero delay", () => {
		const ir = {
			kind: "transition-delay" as const,
			delays: [{ value: 0, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("0s");
	});

	it("should generate decimal values", () => {
		const ir = {
			kind: "transition-delay" as const,
			delays: [{ value: 0.5, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("0.5s");
	});

	it("should generate multiple delays", () => {
		const ir = {
			kind: "transition-delay" as const,
			delays: [
				{ value: 1, unit: "s" as const },
				{ value: 500, unit: "ms" as const },
				{ value: 2, unit: "s" as const },
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("1s, 500ms, 2s");
	});

	it("should generate mixed positive and negative delays", () => {
		const ir = {
			kind: "transition-delay" as const,
			delays: [
				{ value: 1, unit: "s" as const },
				{ value: -500, unit: "ms" as const },
				{ value: 2, unit: "s" as const },
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("1s, -500ms, 2s");
	});

	// Round-trip tests
	it("should round-trip single delay", () => {
		const original = "1s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip multiple delays", () => {
		const original = "1s, 500ms, 2s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip negative delays", () => {
		const original = "-2s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip decimal values", () => {
		const original = "0.5s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});


=== File: src/generate/transition/delay.ts ===
// b_path:: src/generate/transition/delay.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS transition-delay property value from IR.
 *
 * Converts TransitionDelay IR to CSS string representation.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param ir - TransitionDelay IR object
 * @returns CSS transition-delay value string
 *
 * @example
 * Single delay:
 * ```typescript
 * const css = toCss({ kind: "transition-delay", delays: [{ value: 1, unit: "s" }] });
 * // "1s"
 * ```
 *
 * @example
 * Multiple delays:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-delay",
 *   delays: [
 *     { value: 1, unit: "s" },
 *     { value: 500, unit: "ms" },
 *     { value: 2, unit: "s" }
 *   ]
 * });
 * // "1s, 500ms, 2s"
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay | MDN: transition-delay}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-delay-property | W3C Spec}
 */
export function toCss(ir: Type.TransitionDelay): string {
	return ir.delays.map((time) => `${time.value}${time.unit}`).join(", ");
}


=== File: src/generate/transition/duration.generate.test.ts ===
// b_path:: src/generate/transition/duration.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/transition/duration";
import * as Generator from "./duration";

describe("Transition Duration Generator", () => {
	it("should generate single duration in seconds", () => {
		const ir = {
			kind: "transition-duration" as const,
			durations: [{ value: 1, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("1s");
	});

	it("should generate single duration in milliseconds", () => {
		const ir = {
			kind: "transition-duration" as const,
			durations: [{ value: 500, unit: "ms" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("500ms");
	});

	it("should generate zero duration", () => {
		const ir = {
			kind: "transition-duration" as const,
			durations: [{ value: 0, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("0s");
	});

	it("should generate decimal values", () => {
		const ir = {
			kind: "transition-duration" as const,
			durations: [{ value: 0.5, unit: "s" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("0.5s");
	});

	it("should generate multiple durations", () => {
		const ir = {
			kind: "transition-duration" as const,
			durations: [
				{ value: 1, unit: "s" as const },
				{ value: 500, unit: "ms" as const },
				{ value: 2, unit: "s" as const },
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("1s, 500ms, 2s");
	});

	// Round-trip tests
	it("should round-trip single duration", () => {
		const original = "1s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip multiple durations", () => {
		const original = "1s, 500ms, 2s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip decimal values", () => {
		const original = "0.5s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip zero duration", () => {
		const original = "0s";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});


=== File: src/generate/transition/duration.ts ===
// b_path:: src/generate/transition/duration.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS transition-duration property value from IR.
 *
 * Converts TransitionDuration IR to CSS string representation.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param ir - TransitionDuration IR object
 * @returns CSS transition-duration value string
 *
 * @example
 * Time duration:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-duration",
 *   durations: [{ value: 1, unit: "s" }]
 * });
 * // "1s"
 * ```
 *
 * @example
 * Multiple durations:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-duration",
 *   durations: [
 *     { value: 1, unit: "s" },
 *     { value: 500, unit: "ms" }
 *   ]
 * });
 * // "1s, 500ms"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration | MDN: transition-duration}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-duration-property | W3C Spec}
 */
export function toCss(ir: Type.TransitionDuration): string {
	return ir.durations.map((duration) => `${duration.value}${duration.unit}`).join(", ");
}


=== File: src/generate/transition/index.ts ===
// b_path:: src/generate/transition/index.ts

export * as Delay from "./delay";
export * as Duration from "./duration";
export * as Property from "./property";
export * as TimingFunction from "./timing-function";
export { generate } from "./transition";


=== File: src/generate/transition/property.generate.test.ts ===
// b_path:: src/generate/transition/property.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/transition/property";
import * as Generator from "./property";

describe("Transition Property Generator", () => {
	// Keywords
	it("should generate none keyword", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [{ type: "none" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("none");
	});

	it("should generate all keyword", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [{ type: "all" as const }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("all");
	});

	// Single properties
	it("should generate single property name", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [{ type: "identifier" as const, value: "opacity" }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("opacity");
	});

	it("should generate hyphenated property name", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [{ type: "identifier" as const, value: "background-color" }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("background-color");
	});

	it("should generate transform property", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [{ type: "identifier" as const, value: "transform" }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("transform");
	});

	it("should preserve case of property name", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [{ type: "identifier" as const, value: "WebkitTransform" }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("WebkitTransform");
	});

	// Custom properties
	it("should generate custom property", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [{ type: "identifier" as const, value: "--custom-prop" }],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("--custom-prop");
	});

	// Multiple properties
	it("should generate multiple properties", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [
				{ type: "identifier" as const, value: "opacity" },
				{ type: "identifier" as const, value: "transform" },
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("opacity, transform");
	});

	it("should generate three properties", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [
				{ type: "identifier" as const, value: "opacity" },
				{ type: "identifier" as const, value: "transform" },
				{ type: "identifier" as const, value: "background-color" },
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("opacity, transform, background-color");
	});

	it("should generate mixed properties and custom properties", () => {
		const ir = {
			kind: "transition-property" as const,
			properties: [
				{ type: "identifier" as const, value: "opacity" },
				{ type: "identifier" as const, value: "--custom-color" },
				{ type: "identifier" as const, value: "transform" },
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("opacity, --custom-color, transform");
	});

	// Round-trip tests
	it("should round-trip none keyword", () => {
		const original = "none";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip all keyword", () => {
		const original = "all";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip single property", () => {
		const original = "opacity";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip hyphenated property", () => {
		const original = "background-color";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip custom property", () => {
		const original = "--custom-prop";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip multiple properties", () => {
		const original = "opacity, transform";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip three properties", () => {
		const original = "opacity, transform, background-color";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});


=== File: src/generate/transition/property.ts ===
// b_path:: src/generate/transition/property.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS transition-property property value from IR.
 *
 * Converts TransitionProperty IR to CSS string representation.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param ir - TransitionProperty IR object
 * @returns CSS transition-property value string
 *
 * @example
 * Single property:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-property",
 *   properties: [{ type: "identifier", value: "opacity" }]
 * });
 * // "opacity"
 * ```
 *
 * @example
 * Multiple properties:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-property",
 *   properties: [
 *     { type: "identifier", value: "opacity" },
 *     { type: "identifier", value: "transform" }
 *   ]
 * });
 * // "opacity, transform"
 * ```
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-property",
 *   properties: [{ type: "all" }]
 * });
 * // "all"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property | MDN: transition-property}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-property-property | W3C Spec}
 */
export function toCss(ir: Type.TransitionProperty): string {
	return ir.properties
		.map((prop) => {
			if (prop.type === "none" || prop.type === "all") {
				return prop.type;
			}
			return prop.value;
		})
		.join(", ");
}


=== File: src/generate/transition/timing-function.generate.test.ts ===
// b_path:: src/generate/transition/timing-function.generate.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "../../parse/transition/timing-function";
import * as Generator from "./timing-function";

describe("Transition Timing Function Generator", () => {
	// Keywords
	it("should generate ease keyword", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: ["ease" as const],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("ease");
	});

	it("should generate ease-in keyword", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: ["ease-in" as const],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("ease-in");
	});

	it("should generate linear keyword", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: ["linear" as const],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("linear");
	});

	// cubic-bezier
	it("should generate cubic-bezier", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				{
					type: "cubic-bezier" as const,
					x1: 0.1,
					y1: 0.7,
					x2: 1.0,
					y2: 0.1,
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("cubic-bezier(0.1, 0.7, 1, 0.1)");
	});

	it("should generate cubic-bezier with negative values", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				{
					type: "cubic-bezier" as const,
					x1: 0.5,
					y1: -0.5,
					x2: 0.5,
					y2: 1.5,
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("cubic-bezier(0.5, -0.5, 0.5, 1.5)");
	});

	// steps
	it("should generate steps without position", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				{
					type: "steps" as const,
					steps: 4,
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("steps(4)");
	});

	it("should generate steps with start position", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				{
					type: "steps" as const,
					steps: 4,
					position: "start" as const,
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("steps(4, start)");
	});

	it("should generate steps with end position", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				{
					type: "steps" as const,
					steps: 4,
					position: "end" as const,
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("steps(4, end)");
	});

	// linear()
	it("should generate linear with single stop", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				{
					type: "linear" as const,
					stops: [{ output: 0 }],
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("linear(0)");
	});

	it("should generate linear with multiple stops", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				{
					type: "linear" as const,
					stops: [{ output: 0 }, { output: 0.5 }, { output: 1 }],
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("linear(0, 0.5, 1)");
	});

	it("should generate linear with input percentages", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				{
					type: "linear" as const,
					stops: [
						{ output: 0, input: 0 },
						{ output: 0.5, input: 0.5 },
						{ output: 1, input: 1 },
					],
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("linear(0 0%, 0.5 50%, 1 100%)");
	});

	// Multiple functions
	it("should generate multiple timing functions", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: ["ease" as const, "ease-in" as const, "linear" as const],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("ease, ease-in, linear");
	});

	it("should generate mixed function types", () => {
		const ir = {
			kind: "transition-timing-function" as const,
			functions: [
				"ease-in" as const,
				{
					type: "cubic-bezier" as const,
					x1: 0.1,
					y1: 0.7,
					x2: 1.0,
					y2: 0.1,
				},
				{
					type: "steps" as const,
					steps: 4,
				},
			],
		};

		const css = Generator.toCss(ir);
		expect(css).toBe("ease-in, cubic-bezier(0.1, 0.7, 1, 0.1), steps(4)");
	});

	// Round-trip tests
	it("should round-trip ease keyword", () => {
		const original = "ease";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip cubic-bezier", () => {
		const original = "cubic-bezier(0.1, 0.7, 1, 0.1)";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip steps", () => {
		const original = "steps(4, start)";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip linear", () => {
		const original = "linear(0, 0.5, 1)";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});

	it("should round-trip multiple functions", () => {
		const original = "ease, ease-in, linear";
		const parsed = Parser.parse(original);

		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generator.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});


=== File: src/generate/transition/timing-function.ts ===
// b_path:: src/generate/transition/timing-function.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS easing function string from IR.
 *
 * @param func - EasingFunction IR
 * @returns CSS easing function string
 *
 * @internal
 */
function easingFunctionToCss(func: Type.EasingFunction): string {
	// Keyword
	if (typeof func === "string") {
		return func;
	}

	// cubic-bezier()
	if (func.type === "cubic-bezier") {
		return `cubic-bezier(${func.x1}, ${func.y1}, ${func.x2}, ${func.y2})`;
	}

	// steps()
	if (func.type === "steps") {
		if (func.position !== undefined) {
			return `steps(${func.steps}, ${func.position})`;
		}
		return `steps(${func.steps})`;
	}

	// linear()
	if (func.type === "linear") {
		const stops = func.stops
			.map((stop) => {
				if (stop.input !== undefined) {
					return `${stop.output} ${stop.input * 100}%`;
				}
				return String(stop.output);
			})
			.join(", ");
		return `linear(${stops})`;
	}

	return "";
}

/**
 * Generate CSS transition-timing-function property value from IR.
 *
 * Converts TransitionTimingFunction IR to CSS string representation.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param ir - TransitionTimingFunction IR object
 * @returns CSS transition-timing-function value string
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-timing-function",
 *   functions: ["ease-in"]
 * });
 * // "ease-in"
 * ```
 *
 * @example
 * Cubic bezier:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-timing-function",
 *   functions: [{ type: "cubic-bezier", x1: 0.1, y1: 0.7, x2: 1.0, y2: 0.1 }]
 * });
 * // "cubic-bezier(0.1, 0.7, 1, 0.1)"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function | MDN: transition-timing-function}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property | W3C Spec}
 */
export function toCss(ir: Type.TransitionTimingFunction): string {
	return ir.functions.map(easingFunctionToCss).join(", ");
}


=== File: src/generate/transition/transition.test.ts ===
// b_path:: src/generate/transition/transition.test.ts

import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types/transition";
import { generate } from "./transition";

describe("Generate.Transition.generate", () => {
	describe("transition-duration", () => {
		it("generates duration in seconds", () => {
			const ir: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [{ value: 1, unit: "s" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("1s");
			expect(result.issues).toEqual([]);
		});

		it("generates duration in milliseconds", () => {
			const ir: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [{ value: 500, unit: "ms" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("500ms");
		});

		it("generates fractional duration", () => {
			const ir: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [{ value: 0.5, unit: "s" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("0.5s");
		});

		it("generates multiple durations", () => {
			const ir: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{ value: 1, unit: "s" },
					{ value: 500, unit: "ms" },
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("1s, 500ms");
		});
	});

	describe("transition-delay", () => {
		it("generates delay in seconds", () => {
			const ir: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [{ value: 2, unit: "s" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2s");
		});

		it("generates delay in milliseconds", () => {
			const ir: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [{ value: 100, unit: "ms" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("100ms");
		});

		it("generates negative delay", () => {
			const ir: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [{ value: -0.5, unit: "s" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("-0.5s");
		});

		it("generates multiple delays", () => {
			const ir: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{ value: 0, unit: "s" },
					{ value: 500, unit: "ms" },
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("0s, 500ms");
		});
	});

	describe("transition-timing-function", () => {
		it("generates ease keyword", () => {
			const ir: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["ease"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("ease");
		});

		it("generates ease-in-out keyword", () => {
			const ir: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["ease-in-out"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("ease-in-out");
		});

		it("generates linear keyword", () => {
			const ir: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["linear"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("linear");
		});

		it("generates step-start keyword", () => {
			const ir: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["step-start"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("step-start");
		});

		it("generates multiple timing functions", () => {
			const ir: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["ease-in", "linear"],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("ease-in, linear");
		});
	});

	describe("transition-property", () => {
		it("generates property name", () => {
			const ir: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [{ type: "identifier", value: "opacity" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("opacity");
		});

		it("generates all keyword", () => {
			const ir: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [{ type: "all" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("all");
		});

		it("generates none keyword", () => {
			const ir: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [{ type: "none" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("none");
		});

		it("generates complex property name", () => {
			const ir: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [{ type: "identifier", value: "background-color" }],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("background-color");
		});

		it("generates multiple properties", () => {
			const ir: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{ type: "identifier", value: "opacity" },
					{ type: "identifier", value: "transform" },
				],
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("opacity, transform");
		});
	});

	describe("error handling", () => {
		it("returns error for null IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(null as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Invalid transition IR: missing 'kind' field");
		});

		it("returns error for undefined IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(undefined as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
		});

		it("returns error for IR without kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({} as any);

			expect(result.ok).toBe(false);
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		});

		it("returns error for unknown kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({ kind: "unknown" } as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Unknown transition kind: unknown");
			expect(result.issues[0]?.suggestion).toContain("transition-duration");
			expect(result.issues[0]?.suggestion).toContain("transition-delay");
		});
	});
});


=== File: src/generate/transition/transition.ts ===
// b_path:: src/generate/transition/transition.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types/transition";
import * as Delay from "./delay";
import * as Duration from "./duration";
import * as Property from "./property";
import * as TimingFunction from "./timing-function";

/**
 * Generate CSS from transition IR with auto-detection.
 *
 * Automatically detects transition property type from IR.kind and generates appropriate CSS.
 * Supports transition-delay, transition-duration, transition-property, and transition-timing-function.
 *
 * @param transition - Transition IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Duration:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Transition.generate({
 *   kind: "transition-duration",
 *   value: 1,
 *   unit: "s"
 * });
 * // → { ok: true, value: "1s", issues: [] }
 * ```
 *
 * @example
 * Delay:
 * ```typescript
 * const result = Generate.Transition.generate({
 *   kind: "transition-delay",
 *   value: 500,
 *   unit: "ms"
 * });
 * // → { ok: true, value: "500ms", issues: [] }
 * ```
 *
 * @example
 * Timing function:
 * ```typescript
 * const result = Generate.Transition.generate({
 *   kind: "transition-timing-function",
 *   function: "ease-in-out"
 * });
 * // → { ok: true, value: "ease-in-out", issues: [] }
 * ```
 *
 * @example
 * Property:
 * ```typescript
 * const result = Generate.Transition.generate({
 *   kind: "transition-property",
 *   property: "opacity"
 * });
 * // → { ok: true, value: "opacity", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Transition.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid transition IR: missing 'kind' field" }] }
 * ```
 *
 * @public
 */
export function generate(
	transition: Type.TransitionDelay | Type.TransitionDuration | Type.TransitionProperty | Type.TransitionTimingFunction,
): GenerateResult {
	// Validate IR has 'kind' field
	if (!transition || typeof transition !== "object" || !("kind" in transition)) {
		return generateErr("missing-required-field", "Invalid transition IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (transition.kind) {
		case "transition-duration":
			return generateOk(Duration.toCss(transition));

		case "transition-delay":
			return generateOk(Delay.toCss(transition));

		case "transition-timing-function":
			return generateOk(TimingFunction.toCss(transition));

		case "transition-property":
			return generateOk(Property.toCss(transition));

		default:
			return generateErr("unsupported-kind", `Unknown transition kind: ${(transition as { kind?: string }).kind}`, {
				suggestion:
					"Expected 'transition-duration', 'transition-delay', 'transition-timing-function', or 'transition-property'",
			});
	}
}


=== File: src/index.ts ===
// b_path:: src/index.ts

/**
 * b_value - Bidirectional CSS value parser
 *
 * Parse CSS values to structured IR and generate CSS from IR.
 * Built on css-tree and Zod for type-safe, spec-compliant CSS value handling.
 *
 * @packageDocumentation
 *
 * @example
 * Parse CSS to IR:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(circle at center, red 0%, blue 100%)"
 * );
 *
 * if (result.ok) {
 *   console.log(result.value);
 * }
 * ```
 *
 * @example
 * Generate IR to CSS:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "circle",
 *   position: { horizontal: "center", vertical: "center" },
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * });
 *
 * console.log(css);
 * // "radial-gradient(circle at center center, red 0%, blue 100%)"
 * ```
 *
 * @example
 * Round-trip transformation:
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "radial-gradient(circle, red, blue)";
 * const parsed = Parse.Gradient.Radial.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Gradient.Radial.toCss(parsed.value);
 *   console.log(generated === original); // true
 * }
 * ```
 */

/**
 * Core types, schemas, units, and keywords.
 *
 * Provides access to all Zod schemas and TypeScript types used for CSS value
 * intermediate representation (IR). Most users won't need to use Core directly,
 * but it's available for advanced use cases like custom validation or schema
 * composition.
 *
 * @example
 * ```typescript
 * import { Core } from "b_value";
 *
 * // Access TypeScript types
 * type RadialGradient = Core.Type.RadialGradient;
 * type ColorStop = Core.Type.ColorStop;
 *
 * // Access Zod schemas for validation
 * const result = Core.Schema.radialGradientSchema.safeParse(data);
 * ```
 */
export * as Core from "./core";
/**
 * Public API types for parsing and generation.
 *
 * @example
 * ```typescript
 * import type { ParseResult, GenerateResult, Issue, CSSPropertyName } from "b_value";
 *
 * const result: ParseResult<Color> = Parse.Color.parse("#ff0000");
 * if (result.ok) {
 *   console.log(result.value);
 * } else {
 *   console.error(result.issues);
 * }
 * ```
 */
export type {
	CSSLonghandProperty,
	CSSPropertyName,
	CSSShorthandProperty,
	GenerateResult,
	Issue,
	IssueCode,
	ParseResult,
} from "./core/result";
export {
	addIssue,
	combineResults,
	generateErr,
	generateOk,
	Issues,
	parseErr,
	parseOk,
	withWarning,
} from "./core/result";

// Export CSSValue union type and helpers
export type { CSSValue } from "./core/types/css-value";
export { isCSSValue, isUnparsedString } from "./core/types/css-value";
/**
 * CSS → IR generators (convert IR to CSS strings).
 *
 * Generators take intermediate representation (IR) objects and produce
 * spec-compliant CSS strings. All generators return strings directly
 * (no Result type needed since generation cannot fail).
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * // "radial-gradient(red, blue)"
 * ```
 */
export * as Generate from "./generate";
/**
 * CSS → IR parsers (convert CSS strings to structured IR).
 *
 * Parsers take CSS strings and produce type-safe intermediate representation
 * (IR) objects. All parsers return Result<T, string> for type-safe error
 * handling without exceptions.
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(red, blue)"
 * );
 *
 * if (result.ok) {
 *   console.log(result.value); // RadialGradient IR
 * } else {
 *   console.error(result.error); // Error message
 * }
 * ```
 */
export * as Parse from "./parse";
/**
 * Universal API for parsing and generating ANY CSS longhand property.
 *
 * Parse declarations like "color: red" and generate CSS from IR with property names.
 *
 * @example
 * Parse any longhand property:
 * ```typescript
 * import { parse } from "b_value";
 *
 * const result = parse("color: red");
 * if (result.ok) {
 *   console.log(result.property); // "color"
 *   console.log(result.value);    // { kind: "named", name: "red" }
 * }
 * ```
 *
 * @example
 * Generate CSS from IR:
 * ```typescript
 * import { generate } from "b_value";
 *
 * const result = generate({
 *   property: "color",
 *   value: { kind: "hex", r: 255, g: 0, b: 0 }
 * });
 * if (result.ok) {
 *   console.log(result.value); // "#ff0000"
 * }
 * ```
 *
 * @example
 * Batch parse multiple properties:
 * ```typescript
 * import { parseAll } from "b_value";
 *
 * const result = parseAll("color: red; width: 10px");
 * if (result.ok) {
 *   console.log(result.value.color);  // { kind: "named", name: "red" }
 *   console.log(result.value.width);  // { kind: "length", value: 10, unit: "px" }
 * }
 * ```
 *
 * @example
 * Batch generate CSS from properties:
 * ```typescript
 * import { generateAll } from "b_value";
 *
 * const css = generateAll({
 *   color: { kind: "hex", r: 255, g: 0, b: 0 },
 *   width: { kind: "length", value: 10, unit: "px" }
 * });
 * console.log(css); // "color: #ff0000; width: 10px"
 * ```
 *
 * @example
 * Round-trip: parse, modify, generate:
 * ```typescript
 * import { parseAll, generateAll } from "b_value";
 *
 * const parsed = parseAll("color: red; width: 10px");
 * if (parsed.ok) {
 *   // Modify the color
 *   parsed.value.color = { kind: "hex", r: 0, g: 255, b: 0 };
 *
 *   // Generate back to CSS
 *   const css = generateAll(parsed.value);
 *   console.log(css); // "color: #00ff00; width: 10px"
 * }
 * ```
 */
export { generate, generateAll, parse, parseAll } from "./universal";


=== File: src/parse/animation/animation.test.ts ===
// b_path:: src/parse/animation/animation.test.ts

import { describe, expect, test } from "vitest";
import { parse } from "./animation";

describe("parse() - auto-detection", () => {
	describe("duration", () => {
		test("detects time values", () => {
			const result = parse("1s");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-duration");
		});

		test("detects auto", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-duration");
		});
	});

	describe("delay", () => {
		test("detects delay values", () => {
			const result = parse("500ms");
			expect(result.ok).toBe(true);
			// Note: Ambiguous with duration - duration takes precedence
			expect(result.value?.kind).toBe("animation-duration");
		});
	});

	describe("timing-function", () => {
		test("detects ease keywords", () => {
			const result = parse("ease-in-out");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-timing-function");
		});

		test("detects cubic-bezier", () => {
			const result = parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-timing-function");
		});

		test("detects steps", () => {
			const result = parse("steps(4, end)");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-timing-function");
		});
	});

	describe("iteration-count", () => {
		test("detects infinite", () => {
			const result = parse("infinite");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-iteration-count");
		});

		test("detects number", () => {
			const result = parse("2.5");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-iteration-count");
		});
	});

	describe("direction", () => {
		test("detects normal", () => {
			const result = parse("normal");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-direction");
		});

		test("detects alternate", () => {
			const result = parse("alternate");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-direction");
		});

		test("detects reverse", () => {
			const result = parse("reverse");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-direction");
		});
	});

	describe("fill-mode", () => {
		test("detects forwards", () => {
			const result = parse("forwards");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-fill-mode");
		});

		test("detects backwards", () => {
			const result = parse("backwards");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-fill-mode");
		});

		test("detects both", () => {
			const result = parse("both");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-fill-mode");
		});
	});

	describe("play-state", () => {
		test("detects running", () => {
			const result = parse("running");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-play-state");
		});

		test("detects paused", () => {
			const result = parse("paused");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-play-state");
		});
	});

	describe("name", () => {
		test("detects custom name", () => {
			const result = parse("slideIn");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-name");
		});

		test("none matches fill-mode first (ambiguous)", () => {
			// "none" is valid for both fill-mode and animation-name
			// fill-mode parser comes first in dispatch order
			const result = parse("none");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-fill-mode");
		});
	});

	describe("error handling", () => {
		test("rejects truly invalid value", () => {
			const result = parse("@invalid");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues).toHaveLength(1);
				expect(result.issues[0]?.severity).toBe("error");
				expect(result.issues[0]?.message).toContain("Invalid animation property value");
			}
		});

		test("provides helpful suggestion", () => {
			const result = parse("@bad");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.suggestion).toBeDefined();
			}
		});
	});
});


=== File: src/parse/animation/animation.ts ===
// b_path:: src/parse/animation/animation.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";
import type * as Type from "@/core/types/animation";

import * as Delay from "./delay";
import * as Direction from "./direction";
import * as Duration from "./duration";
import * as FillMode from "./fill-mode";
import * as IterationCount from "./iteration-count";
import * as Name from "./name";
import * as PlayState from "./play-state";
import * as TimingFunction from "./timing-function";

/**
 * Animation property type union.
 *
 * @public
 */
export type Animation =
	| Type.AnimationDelay
	| Type.AnimationDirection
	| Type.AnimationDuration
	| Type.AnimationFillMode
	| Type.AnimationIterationCount
	| Type.AnimationName
	| Type.AnimationPlayState
	| Type.AnimationTimingFunction;

/**
 * Parse animation property value with auto-detection.
 *
 * Attempts to parse as each animation property type in order:
 * - duration (time values, auto)
 * - delay (time values)
 * - timing-function (ease, linear, cubic-bezier, steps)
 * - iteration-count (number, infinite)
 * - direction (normal, reverse, alternate, alternate-reverse)
 * - fill-mode (none, forwards, backwards, both)
 * - play-state (running, paused)
 * - name (identifier, none)
 *
 * @param value - CSS animation property value
 * @returns ParseResult with detected animation property IR
 *
 * @example
 * ```typescript
 * parse("1s");                  // duration
 * parse("500ms");               // duration or delay (ambiguous - tries duration first)
 * parse("ease-in-out");         // timing-function
 * parse("infinite");            // iteration-count
 * parse("alternate");           // direction
 * parse("forwards");            // fill-mode
 * parse("paused");              // play-state
 * parse("slideIn");             // name
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Animation> {
	const durationResult = Duration.parse(value);
	if (durationResult.ok) return toParseResult(durationResult);

	const delayResult = Delay.parse(value);
	if (delayResult.ok) return toParseResult(delayResult);

	const timingResult = TimingFunction.parse(value);
	if (timingResult.ok) return toParseResult(timingResult);

	const iterationResult = IterationCount.parse(value);
	if (iterationResult.ok) return toParseResult(iterationResult);

	const directionResult = Direction.parse(value);
	if (directionResult.ok) return toParseResult(directionResult);

	const fillModeResult = FillMode.parse(value);
	if (fillModeResult.ok) return toParseResult(fillModeResult);

	const playStateResult = PlayState.parse(value);
	if (playStateResult.ok) return toParseResult(playStateResult);

	const nameResult = Name.parse(value);
	if (nameResult.ok) return toParseResult(nameResult);

	return parseErr("invalid-value", "Invalid animation property value", {
		suggestion:
			"Expected duration (1s, 500ms, auto), delay, timing-function, iteration-count, direction, fill-mode, play-state, or name",
	});
}


=== File: src/parse/animation/delay.test.ts ===
// b_path:: src/parse/animation/delay.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./delay";

describe("Animation Delay Parser", () => {
	it("should parse single time value in seconds", () => {
		const result = Parser.parse("1s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("animation-delay");
			expect(result.value.delays).toHaveLength(1);
			expect(result.value.delays[0]).toEqual({ value: 1, unit: "s" });
		}
	});

	it("should parse single time value in milliseconds", () => {
		const result = Parser.parse("500ms");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays).toHaveLength(1);
			expect(result.value.delays[0]).toEqual({ value: 500, unit: "ms" });
		}
	});

	it("should parse negative delay", () => {
		const result = Parser.parse("-2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays[0]).toEqual({ value: -2, unit: "s" });
		}
	});

	it("should parse zero delay", () => {
		const result = Parser.parse("0s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays[0]).toEqual({ value: 0, unit: "s" });
		}
	});

	it("should parse decimal values", () => {
		const result = Parser.parse("0.5s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays[0]).toEqual({ value: 0.5, unit: "s" });
		}
	});

	it("should parse multiple delays", () => {
		const result = Parser.parse("1s, 500ms, 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays).toHaveLength(3);
			expect(result.value.delays[0]).toEqual({ value: 1, unit: "s" });
			expect(result.value.delays[1]).toEqual({ value: 500, unit: "ms" });
			expect(result.value.delays[2]).toEqual({ value: 2, unit: "s" });
		}
	});

	it("should parse delays with whitespace", () => {
		const result = Parser.parse("1s , 500ms , 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays).toHaveLength(3);
		}
	});

	it("should parse mixed positive and negative delays", () => {
		const result = Parser.parse("1s, -500ms, 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays).toHaveLength(3);
			expect(result.value.delays[1]).toEqual({ value: -500, unit: "ms" });
		}
	});

	it("should return error for invalid unit", () => {
		const result = Parser.parse("1px");

		expect(result.ok).toBe(false);
	});

	it("should return error for missing unit", () => {
		const result = Parser.parse("1");

		expect(result.ok).toBe(false);
	});

	it("should return error for empty value", () => {
		const result = Parser.parse("");

		expect(result.ok).toBe(false);
	});

	it("should return error for invalid value", () => {
		const result = Parser.parse("invalid");

		expect(result.ok).toBe(false);
	});

	it("should return error for trailing comma", () => {
		const result = Parser.parse("1s,");

		expect(result.ok).toBe(false);
	});

	it("should return error for leading comma", () => {
		const result = Parser.parse(",1s");

		expect(result.ok).toBe(false);
	});

	it("should return error for double comma", () => {
		const result = Parser.parse("1s,,2s");

		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/animation/delay.ts ===
// b_path:: src/parse/animation/delay.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse time value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with Time object or error
 *
 * @internal
 */
function parseTime(node: csstree.CssNode): Result<Type.Time, string> {
	if (node.type !== "Dimension") {
		return err(`Expected time dimension, got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);
	const unit = node.unit.toLowerCase();

	if (unit !== "s" && unit !== "ms") {
		return err(`Invalid time unit: ${unit}. Expected 's' or 'ms'`);
	}

	return ok({
		value,
		unit: unit as "s" | "ms",
	});
}

/**
 * Parse CSS animation-delay property value.
 *
 * Parses comma-separated list of time values.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-delay value (e.g., "1s, 500ms, 2s")
 * @returns Result with AnimationDelay IR or error message
 *
 * @example
 * Simple delay:
 * ```typescript
 * const result = parse("1s");
 * // { ok: true, value: { kind: "animation-delay", delays: [{ value: 1, unit: "s" }] } }
 * ```
 *
 * @example
 * Multiple delays:
 * ```typescript
 * const result = parse("1s, 500ms, 2s");
 * // { ok: true, value: { kind: "animation-delay", delays: [...] } }
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay | MDN: animation-delay}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-delay | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationDelay, string> {
	const delaysResult = parseCommaSeparatedSingle(css, parseTime, "animation-delay");

	if (!delaysResult.ok) {
		return err(delaysResult.error);
	}

	return ok({
		kind: "animation-delay",
		delays: delaysResult.value,
	});
}


=== File: src/parse/animation/direction.test.ts ===
// b_path:: src/parse/animation/direction.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./direction";

describe("Animation Direction Parser", () => {
	it("should parse normal keyword", () => {
		const result = Parser.parse("normal");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("animation-direction");
			expect(result.value.directions).toEqual(["normal"]);
		}
	});

	it("should parse reverse keyword", () => {
		const result = Parser.parse("reverse");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.directions).toEqual(["reverse"]);
		}
	});

	it("should parse alternate keyword", () => {
		const result = Parser.parse("alternate");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.directions).toEqual(["alternate"]);
		}
	});

	it("should parse alternate-reverse keyword", () => {
		const result = Parser.parse("alternate-reverse");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.directions).toEqual(["alternate-reverse"]);
		}
	});

	it("should parse multiple directions", () => {
		const result = Parser.parse("normal, reverse, alternate");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.directions).toEqual(["normal", "reverse", "alternate"]);
		}
	});

	it("should handle whitespace", () => {
		const result = Parser.parse("normal , reverse");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.directions).toHaveLength(2);
		}
	});

	it("should handle case insensitive", () => {
		const result = Parser.parse("NORMAL");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.directions).toEqual(["normal"]);
		}
	});

	it("should reject invalid keyword", () => {
		const result = Parser.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/animation/direction.ts ===
// b_path:: src/parse/animation/direction.ts
import type * as csstree from "css-tree";
import { ANIMATION_DIRECTION_KEYWORDS } from "@/core/keywords/animation";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse direction keyword from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with direction keyword or error
 *
 * @internal
 */
function parseDirection(node: csstree.CssNode): Result<Type.AnimationDirection["directions"][number], string> {
	if (node.type !== "Identifier") {
		return err(`Expected direction keyword, got: ${node.type}`);
	}

	const keyword = node.name.toLowerCase();
	if (!ANIMATION_DIRECTION_KEYWORDS.includes(keyword as (typeof ANIMATION_DIRECTION_KEYWORDS)[number])) {
		return err(
			`Invalid animation-direction keyword: ${keyword}. Expected one of: ${ANIMATION_DIRECTION_KEYWORDS.join(", ")}`,
		);
	}

	return ok(keyword as Type.AnimationDirection["directions"][number]);
}

/**
 * Parse CSS animation-direction property value.
 *
 * Parses comma-separated list of direction keywords.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-direction value (e.g., "normal, reverse, alternate")
 * @returns Result with AnimationDirection IR or error message
 *
 * @example
 * Single direction:
 * ```typescript
 * const result = parse("normal");
 * // { ok: true, value: { kind: "animation-direction", directions: ["normal"] } }
 * ```
 *
 * @example
 * Multiple directions:
 * ```typescript
 * const result = parse("normal, reverse, alternate");
 * // { ok: true, value: { kind: "animation-direction", directions: ["normal", "reverse", "alternate"] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction | MDN: animation-direction}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-direction | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationDirection, string> {
	const directionsResult = parseCommaSeparatedSingle(css, parseDirection, "animation-direction");

	if (!directionsResult.ok) {
		return err(directionsResult.error);
	}

	return ok({
		kind: "animation-direction",
		directions: directionsResult.value,
	});
}


=== File: src/parse/animation/duration.test.ts ===
// b_path:: src/parse/animation/duration.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./duration";

describe("Animation Duration Parser", () => {
	it("should parse single time value in seconds", () => {
		const result = Parser.parse("1s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("animation-duration");
			expect(result.value.durations).toHaveLength(1);
			expect(result.value.durations[0]).toEqual({ type: "time", value: 1, unit: "s" });
		}
	});

	it("should parse single time value in milliseconds", () => {
		const result = Parser.parse("500ms");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations).toHaveLength(1);
			expect(result.value.durations[0]).toEqual({ type: "time", value: 500, unit: "ms" });
		}
	});

	it("should parse auto keyword", () => {
		const result = Parser.parse("auto");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations).toHaveLength(1);
			expect(result.value.durations[0]).toEqual({ type: "auto" });
		}
	});

	it("should parse zero duration", () => {
		const result = Parser.parse("0s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations[0]).toEqual({ type: "time", value: 0, unit: "s" });
		}
	});

	it("should parse decimal values", () => {
		const result = Parser.parse("0.5s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations[0]).toEqual({ type: "time", value: 0.5, unit: "s" });
		}
	});

	it("should parse multiple durations", () => {
		const result = Parser.parse("1s, auto, 500ms");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations).toHaveLength(3);
			expect(result.value.durations[0]).toEqual({ type: "time", value: 1, unit: "s" });
			expect(result.value.durations[1]).toEqual({ type: "auto" });
			expect(result.value.durations[2]).toEqual({ type: "time", value: 500, unit: "ms" });
		}
	});

	it("should parse durations with whitespace", () => {
		const result = Parser.parse("1s , auto , 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations).toHaveLength(3);
		}
	});

	it("should parse large values", () => {
		const result = Parser.parse("3600s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations[0]).toEqual({ type: "time", value: 3600, unit: "s" });
		}
	});

	it("should reject negative duration", () => {
		const result = Parser.parse("-1s");

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("non-negative");
		}
	});

	it("should reject invalid unit", () => {
		const result = Parser.parse("1px");

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid time unit");
		}
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");

		expect(result.ok).toBe(false);
	});

	it("should reject trailing comma", () => {
		const result = Parser.parse("1s,");

		expect(result.ok).toBe(false);
	});

	it("should reject leading comma", () => {
		const result = Parser.parse(",1s");

		expect(result.ok).toBe(false);
	});

	it("should handle case insensitive auto", () => {
		const result = Parser.parse("AUTO");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations[0]).toEqual({ type: "auto" });
		}
	});
});


=== File: src/parse/animation/duration.ts ===
// b_path:: src/parse/animation/duration.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse duration value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with duration object or error
 *
 * @internal
 */
function parseDuration(node: csstree.CssNode): Result<{ type: "auto" } | (Type.Time & { type: "time" }), string> {
	if (node.type === "Identifier" && node.name.toLowerCase() === "auto") {
		return ok({ type: "auto" as const });
	}

	if (node.type !== "Dimension") {
		return err(`Expected time dimension or 'auto', got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);
	const unit = node.unit.toLowerCase();

	if (unit !== "s" && unit !== "ms") {
		return err(`Invalid time unit: ${unit}. Expected 's' or 'ms'`);
	}

	if (value < 0) {
		return err(`animation-duration must be non-negative, got: ${value}`);
	}

	return ok({
		type: "time" as const,
		value,
		unit: unit as "s" | "ms",
	});
}

/**
 * Parse CSS animation-duration property value.
 *
 * Parses comma-separated list of time values or 'auto'.
 * Time values must be non-negative.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-duration value (e.g., "1s, auto, 500ms")
 * @returns Result with AnimationDuration IR or error message
 *
 * @example
 * Simple duration:
 * ```typescript
 * const result = parse("1s");
 * // { ok: true, value: { kind: "animation-duration", durations: [{ type: "time", value: 1, unit: "s" }] } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "animation-duration", durations: [{ type: "auto" }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration | MDN: animation-duration}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-duration | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationDuration, string> {
	const durationsResult = parseCommaSeparatedSingle(css, parseDuration, "animation-duration");

	if (!durationsResult.ok) {
		return err(durationsResult.error);
	}

	return ok({
		kind: "animation-duration",
		durations: durationsResult.value,
	});
}


=== File: src/parse/animation/fill-mode.test.ts ===
// b_path:: src/parse/animation/fill-mode.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./fill-mode";

describe("Animation Fill Mode Parser", () => {
	it("should parse none keyword", () => {
		const result = Parser.parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("animation-fill-mode");
			expect(result.value.modes).toEqual(["none"]);
		}
	});

	it("should parse forwards keyword", () => {
		const result = Parser.parse("forwards");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.modes).toEqual(["forwards"]);
		}
	});

	it("should parse backwards keyword", () => {
		const result = Parser.parse("backwards");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.modes).toEqual(["backwards"]);
		}
	});

	it("should parse both keyword", () => {
		const result = Parser.parse("both");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.modes).toEqual(["both"]);
		}
	});

	it("should parse multiple modes", () => {
		const result = Parser.parse("none, forwards, both");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.modes).toEqual(["none", "forwards", "both"]);
		}
	});

	it("should handle whitespace", () => {
		const result = Parser.parse("none , forwards");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.modes).toHaveLength(2);
		}
	});

	it("should handle case insensitive", () => {
		const result = Parser.parse("BOTH");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.modes).toEqual(["both"]);
		}
	});

	it("should reject invalid keyword", () => {
		const result = Parser.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/animation/fill-mode.ts ===
// b_path:: src/parse/animation/fill-mode.ts
import type * as csstree from "css-tree";
import { ANIMATION_FILL_MODE_KEYWORDS } from "@/core/keywords/animation";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse fill mode keyword from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with fill mode keyword or error
 *
 * @internal
 */
function parseFillMode(node: csstree.CssNode): Result<Type.AnimationFillMode["modes"][number], string> {
	if (node.type !== "Identifier") {
		return err(`Expected fill mode keyword, got: ${node.type}`);
	}

	const keyword = node.name.toLowerCase();
	if (!ANIMATION_FILL_MODE_KEYWORDS.includes(keyword as (typeof ANIMATION_FILL_MODE_KEYWORDS)[number])) {
		return err(
			`Invalid animation-fill-mode keyword: ${keyword}. Expected one of: ${ANIMATION_FILL_MODE_KEYWORDS.join(", ")}`,
		);
	}

	return ok(keyword as Type.AnimationFillMode["modes"][number]);
}

/**
 * Parse CSS animation-fill-mode property value.
 *
 * Parses comma-separated list of fill mode keywords.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-fill-mode value (e.g., "none, forwards, both")
 * @returns Result with AnimationFillMode IR or error message
 *
 * @example
 * Single fill mode:
 * ```typescript
 * const result = parse("forwards");
 * // { ok: true, value: { kind: "animation-fill-mode", modes: ["forwards"] } }
 * ```
 *
 * @example
 * Multiple fill modes:
 * ```typescript
 * const result = parse("none, forwards, both");
 * // { ok: true, value: { kind: "animation-fill-mode", modes: ["none", "forwards", "both"] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode | MDN: animation-fill-mode}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-fill-mode | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationFillMode, string> {
	const modesResult = parseCommaSeparatedSingle(css, parseFillMode, "animation-fill-mode");

	if (!modesResult.ok) {
		return err(modesResult.error);
	}

	return ok({
		kind: "animation-fill-mode",
		modes: modesResult.value,
	});
}


=== File: src/parse/animation/index.ts ===
// b_path:: src/parse/animation/index.ts

export { parse } from "./animation";

export * as Delay from "./delay";
export * as Direction from "./direction";
export * as Duration from "./duration";
export * as FillMode from "./fill-mode";
export * as IterationCount from "./iteration-count";
export * as Name from "./name";
export * as PlayState from "./play-state";
export * as TimingFunction from "./timing-function";


=== File: src/parse/animation/iteration-count.test.ts ===
// b_path:: src/parse/animation/iteration-count.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./iteration-count";

describe("Animation Iteration Count Parser", () => {
	it("should parse single number", () => {
		const result = Parser.parse("3");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("animation-iteration-count");
			expect(result.value.counts).toHaveLength(1);
			expect(result.value.counts[0]).toEqual({ type: "number", value: 3 });
		}
	});

	it("should parse infinite keyword", () => {
		const result = Parser.parse("infinite");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.counts).toHaveLength(1);
			expect(result.value.counts[0]).toEqual({ type: "infinite" });
		}
	});

	it("should parse zero count", () => {
		const result = Parser.parse("0");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.counts[0]).toEqual({ type: "number", value: 0 });
		}
	});

	it("should parse decimal values", () => {
		const result = Parser.parse("2.5");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.counts[0]).toEqual({ type: "number", value: 2.5 });
		}
	});

	it("should parse multiple counts", () => {
		const result = Parser.parse("1, infinite, 2.5");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.counts).toHaveLength(3);
			expect(result.value.counts[0]).toEqual({ type: "number", value: 1 });
			expect(result.value.counts[1]).toEqual({ type: "infinite" });
			expect(result.value.counts[2]).toEqual({ type: "number", value: 2.5 });
		}
	});

	it("should parse counts with whitespace", () => {
		const result = Parser.parse("1 , 2 , 3");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.counts).toHaveLength(3);
		}
	});

	it("should reject negative count", () => {
		const result = Parser.parse("-1");

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("non-negative");
		}
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");

		expect(result.ok).toBe(false);
	});

	it("should reject trailing comma", () => {
		const result = Parser.parse("1,");

		expect(result.ok).toBe(false);
	});

	it("should handle case insensitive infinite", () => {
		const result = Parser.parse("INFINITE");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.counts[0]).toEqual({ type: "infinite" });
		}
	});

	it("should parse very large count", () => {
		const result = Parser.parse("1000");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.counts[0]).toEqual({ type: "number", value: 1000 });
		}
	});
});


=== File: src/parse/animation/iteration-count.ts ===
// b_path:: src/parse/animation/iteration-count.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse iteration count value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with iteration count object or error
 *
 * @internal
 */
function parseIterationCount(
	node: csstree.CssNode,
): Result<{ type: "infinite" } | { type: "number"; value: number }, string> {
	if (node.type === "Identifier" && node.name.toLowerCase() === "infinite") {
		return ok({ type: "infinite" as const });
	}

	if (node.type !== "Number") {
		return err(`Expected number or 'infinite', got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);

	if (value < 0) {
		return err(`animation-iteration-count must be non-negative, got: ${value}`);
	}

	return ok({
		type: "number" as const,
		value,
	});
}

/**
 * Parse CSS animation-iteration-count property value.
 *
 * Parses comma-separated list of numbers or 'infinite'.
 * Number values must be non-negative.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-iteration-count value (e.g., "infinite, 2, 0.5")
 * @returns Result with AnimationIterationCount IR or error message
 *
 * @example
 * Number count:
 * ```typescript
 * const result = parse("3");
 * // { ok: true, value: { kind: "animation-iteration-count", counts: [{ type: "number", value: 3 }] } }
 * ```
 *
 * @example
 * Infinite keyword:
 * ```typescript
 * const result = parse("infinite");
 * // { ok: true, value: { kind: "animation-iteration-count", counts: [{ type: "infinite" }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count | MDN: animation-iteration-count}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-iteration-count | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationIterationCount, string> {
	const countsResult = parseCommaSeparatedSingle(css, parseIterationCount, "animation-iteration-count");

	if (!countsResult.ok) {
		return err(countsResult.error);
	}

	return ok({
		kind: "animation-iteration-count",
		counts: countsResult.value,
	});
}


=== File: src/parse/animation/name.test.ts ===
// b_path:: src/parse/animation/name.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./name";

describe("Animation Name Parser", () => {
	it("should parse none keyword", () => {
		const result = Parser.parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("animation-name");
			expect(result.value.names).toEqual([{ type: "none" }]);
		}
	});

	it("should parse identifier", () => {
		const result = Parser.parse("slideIn");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.names).toEqual([{ type: "identifier", value: "slideIn" }]);
		}
	});

	it("should parse multiple names", () => {
		const result = Parser.parse("slideIn, fadeOut, none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.names).toEqual([
				{ type: "identifier", value: "slideIn" },
				{ type: "identifier", value: "fadeOut" },
				{ type: "none" },
			]);
		}
	});

	it("should handle whitespace", () => {
		const result = Parser.parse("slideIn , fadeOut");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.names).toHaveLength(2);
		}
	});

	it("should handle case sensitive identifiers", () => {
		const result = Parser.parse("SlideIn");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.names[0]).toEqual({ type: "identifier", value: "SlideIn" });
		}
	});

	it("should handle case insensitive none", () => {
		const result = Parser.parse("NONE");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.names).toEqual([{ type: "none" }]);
		}
	});

	it("should parse hyphenated names", () => {
		const result = Parser.parse("slide-in-from-left");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.names[0]).toEqual({ type: "identifier", value: "slide-in-from-left" });
		}
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/animation/name.ts ===
// b_path:: src/parse/animation/name.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse animation name from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with animation name object or error
 *
 * @internal
 */
function parseAnimationName(
	node: csstree.CssNode,
): Result<{ type: "none" } | { type: "identifier"; value: string }, string> {
	if (node.type !== "Identifier") {
		return err(`Expected identifier or 'none', got: ${node.type}`);
	}

	const name = node.name;

	if (name.toLowerCase() === "none") {
		return ok({ type: "none" as const });
	}

	return ok({
		type: "identifier" as const,
		value: name,
	});
}

/**
 * Parse CSS animation-name property value.
 *
 * Parses comma-separated list of keyframe names or 'none'.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-name value (e.g., "slideIn, fadeOut")
 * @returns Result with AnimationName IR or error message
 *
 * @example
 * Single name:
 * ```typescript
 * const result = parse("slideIn");
 * // { ok: true, value: { kind: "animation-name", names: [{ type: "identifier", value: "slideIn" }] } }
 * ```
 *
 * @example
 * None keyword:
 * ```typescript
 * const result = parse("none");
 * // { ok: true, value: { kind: "animation-name", names: [{ type: "none" }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name | MDN: animation-name}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-name | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationName, string> {
	const namesResult = parseCommaSeparatedSingle(css, parseAnimationName, "animation-name");

	if (!namesResult.ok) {
		return err(namesResult.error);
	}

	return ok({
		kind: "animation-name",
		names: namesResult.value,
	});
}


=== File: src/parse/animation/play-state.test.ts ===
// b_path:: src/parse/animation/play-state.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./play-state";

describe("Animation Play State Parser", () => {
	it("should parse running keyword", () => {
		const result = Parser.parse("running");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("animation-play-state");
			expect(result.value.states).toEqual(["running"]);
		}
	});

	it("should parse paused keyword", () => {
		const result = Parser.parse("paused");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.states).toEqual(["paused"]);
		}
	});

	it("should parse multiple states", () => {
		const result = Parser.parse("running, paused");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.states).toEqual(["running", "paused"]);
		}
	});

	it("should handle whitespace", () => {
		const result = Parser.parse("running , paused");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.states).toHaveLength(2);
		}
	});

	it("should handle case insensitive", () => {
		const result = Parser.parse("PAUSED");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.states).toEqual(["paused"]);
		}
	});

	it("should reject invalid keyword", () => {
		const result = Parser.parse("stopped");
		expect(result.ok).toBe(false);
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/animation/play-state.ts ===
// b_path:: src/parse/animation/play-state.ts
import type * as csstree from "css-tree";
import { ANIMATION_PLAY_STATE_KEYWORDS } from "@/core/keywords/animation";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse play state keyword from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with play state keyword or error
 *
 * @internal
 */
function parsePlayState(node: csstree.CssNode): Result<Type.AnimationPlayState["states"][number], string> {
	if (node.type !== "Identifier") {
		return err(`Expected play state keyword, got: ${node.type}`);
	}

	const keyword = node.name.toLowerCase();
	if (!ANIMATION_PLAY_STATE_KEYWORDS.includes(keyword as (typeof ANIMATION_PLAY_STATE_KEYWORDS)[number])) {
		return err(
			`Invalid animation-play-state keyword: ${keyword}. Expected one of: ${ANIMATION_PLAY_STATE_KEYWORDS.join(", ")}`,
		);
	}

	return ok(keyword as Type.AnimationPlayState["states"][number]);
}

/**
 * Parse CSS animation-play-state property value.
 *
 * Parses comma-separated list of play state keywords.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-play-state value (e.g., "running, paused")
 * @returns Result with AnimationPlayState IR or error message
 *
 * @example
 * Single play state:
 * ```typescript
 * const result = parse("running");
 * // { ok: true, value: { kind: "animation-play-state", states: ["running"] } }
 * ```
 *
 * @example
 * Multiple play states:
 * ```typescript
 * const result = parse("running, paused");
 * // { ok: true, value: { kind: "animation-play-state", states: ["running", "paused"] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state | MDN: animation-play-state}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-play-state | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationPlayState, string> {
	const statesResult = parseCommaSeparatedSingle(css, parsePlayState, "animation-play-state");

	if (!statesResult.ok) {
		return err(statesResult.error);
	}

	return ok({
		kind: "animation-play-state",
		states: statesResult.value,
	});
}


=== File: src/parse/animation/timing-function.test.ts ===
// b_path:: src/parse/animation/timing-function.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./timing-function";

describe("Animation Timing Function Parser", () => {
	// Keywords
	it("should parse ease keyword", () => {
		const result = Parser.parse("ease");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("animation-timing-function");
			expect(result.value.functions).toEqual(["ease"]);
		}
	});

	it("should parse ease-in keyword", () => {
		const result = Parser.parse("ease-in");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["ease-in"]);
		}
	});

	it("should parse linear keyword", () => {
		const result = Parser.parse("linear");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["linear"]);
		}
	});

	it("should parse step-start keyword", () => {
		const result = Parser.parse("step-start");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["step-start"]);
		}
	});

	// cubic-bezier()
	it("should parse cubic-bezier with 4 values", () => {
		const result = Parser.parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "cubic-bezier",
				x1: 0.1,
				y1: 0.7,
				x2: 1.0,
				y2: 0.1,
			});
		}
	});

	it("should parse cubic-bezier without spaces", () => {
		const result = Parser.parse("cubic-bezier(0,0,1,1)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: 1,
				y2: 1,
			});
		}
	});

	it("should parse cubic-bezier with negative values", () => {
		const result = Parser.parse("cubic-bezier(0.5, -0.5, 0.5, 1.5)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "cubic-bezier",
				x1: 0.5,
				y1: -0.5,
				x2: 0.5,
				y2: 1.5,
			});
		}
	});

	it("should reject cubic-bezier with wrong number of args", () => {
		const result = Parser.parse("cubic-bezier(0.1, 0.7)");
		expect(result.ok).toBe(false);
	});

	// steps()
	it("should parse steps with count only", () => {
		const result = Parser.parse("steps(4)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "steps",
				steps: 4,
				position: undefined,
			});
		}
	});

	it("should parse steps with jump-start", () => {
		const result = Parser.parse("steps(4, jump-start)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "steps",
				steps: 4,
				position: "jump-start",
			});
		}
	});

	it("should parse steps with jump-end", () => {
		const result = Parser.parse("steps(3, jump-end)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "steps",
				steps: 3,
				position: "jump-end",
			});
		}
	});

	it("should parse steps with start", () => {
		const result = Parser.parse("steps(5, start)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "steps",
				steps: 5,
				position: "start",
			});
		}
	});

	it("should reject steps with zero", () => {
		const result = Parser.parse("steps(0)");
		expect(result.ok).toBe(false);
	});

	it("should reject steps with negative", () => {
		const result = Parser.parse("steps(-1)");
		expect(result.ok).toBe(false);
	});

	it("should reject steps with decimal", () => {
		const result = Parser.parse("steps(2.5)");
		expect(result.ok).toBe(false);
	});

	// linear()
	it("should parse linear with single stop", () => {
		const result = Parser.parse("linear(0)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "linear",
				stops: [{ output: 0 }],
			});
		}
	});

	it("should parse linear with multiple stops", () => {
		const result = Parser.parse("linear(0, 0.5, 1)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "linear",
				stops: [{ output: 0 }, { output: 0.5 }, { output: 1 }],
			});
		}
	});

	it("should parse linear with input percentages", () => {
		const result = Parser.parse("linear(0 0%, 1 100%)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "linear",
				stops: [
					{ output: 0, input: 0 },
					{ output: 1, input: 1 },
				],
			});
		}
	});

	it("should parse linear with mixed stops", () => {
		const result = Parser.parse("linear(0, 0.5 50%, 1)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "linear",
				stops: [{ output: 0 }, { output: 0.5, input: 0.5 }, { output: 1 }],
			});
		}
	});

	// Multiple functions
	it("should parse multiple timing functions", () => {
		const result = Parser.parse("ease, cubic-bezier(0, 0, 1, 1), steps(2)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toHaveLength(3);
			expect(result.value.functions[0]).toBe("ease");
			expect(result.value.functions[1]).toEqual({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: 1,
				y2: 1,
			});
			expect(result.value.functions[2]).toEqual({
				type: "steps",
				steps: 2,
				position: undefined,
			});
		}
	});

	// Error cases
	it("should reject invalid keyword", () => {
		const result = Parser.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");
		expect(result.ok).toBe(false);
	});

	it("should reject unknown function", () => {
		const result = Parser.parse("unknown(0.5)");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/animation/timing-function.ts ===
// b_path:: src/parse/animation/timing-function.ts
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";
import { EasingFunction } from "@/utils/parse/easing";

/**
 * Parse CSS animation-timing-function property value.
 *
 * Parses comma-separated list of easing functions.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-timing-function value (e.g., "ease-in, cubic-bezier(0.1, 0.7, 1.0, 0.1)")
 * @returns Result with AnimationTimingFunction IR or error message
 *
 * @example
 * Keyword:
 * ```typescript
 * const result = parse("ease-in");
 * // { ok: true, value: { kind: "animation-timing-function", functions: ["ease-in"] } }
 * ```
 *
 * @example
 * Cubic bezier:
 * ```typescript
 * const result = parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)");
 * // { ok: true, value: { kind: "animation-timing-function", functions: [{ type: "cubic-bezier", x1: 0.1, ... }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function | MDN: animation-timing-function}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-timing-function | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationTimingFunction, string> {
	const functionsResult = parseCommaSeparatedSingle(
		css,
		EasingFunction.parseEasingFunction,
		"animation-timing-function",
	);

	if (!functionsResult.ok) {
		return err(functionsResult.error);
	}

	return ok({
		kind: "animation-timing-function",
		functions: functionsResult.value,
	});
}


=== File: src/parse/background/attachment.ts ===
// b_path:: src/parse/background/attachment.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse background-attachment value.
 *
 * Parses CSS background-attachment values that control whether a background
 * image's position is fixed within the viewport, or scrolls with its containing block.
 *
 * Valid values: scroll | fixed | local
 *
 * @param css - CSS string containing background-attachment value
 * @returns Result containing BackgroundAttachmentKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Attachment.parse("fixed");
 * if (result.ok) {
 *   console.log(result.value); // "fixed"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment | MDN: background-attachment}
 */
export function parse(css: string): Result<Keyword.BackgroundAttachmentKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.backgroundAttachmentKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid background-attachment value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/background/background.test.ts ===
// b_path:: src/parse/background/background.test.ts
import { describe, expect, it } from "vitest";
import * as Generate from "../../generate/background";
import * as Parse from "./index";

describe("Background.Attachment", () => {
	it("parses scroll", () => {
		const result = Parse.Attachment.parse("scroll");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("scroll");
	});

	it("parses fixed", () => {
		const result = Parse.Attachment.parse("fixed");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("fixed");
	});

	it("parses local", () => {
		const result = Parse.Attachment.parse("local");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("local");
	});

	it("rejects invalid keyword", () => {
		const result = Parse.Attachment.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("round-trips", () => {
		const original = "fixed";
		const parsed = Parse.Attachment.parse(original);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generate.Attachment.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});

describe("Background.Repeat", () => {
	it("parses repeat", () => {
		const result = Parse.Repeat.parse("repeat");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("repeat");
	});

	it("parses repeat-x", () => {
		const result = Parse.Repeat.parse("repeat-x");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("repeat-x");
	});

	it("parses repeat-y", () => {
		const result = Parse.Repeat.parse("repeat-y");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("repeat-y");
	});

	it("parses no-repeat", () => {
		const result = Parse.Repeat.parse("no-repeat");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("no-repeat");
	});

	it("parses space", () => {
		const result = Parse.Repeat.parse("space");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("space");
	});

	it("parses round", () => {
		const result = Parse.Repeat.parse("round");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("round");
	});

	it("rejects invalid keyword", () => {
		const result = Parse.Repeat.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("round-trips", () => {
		const original = "repeat-x";
		const parsed = Parse.Repeat.parse(original);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generate.Repeat.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});

describe("Background.Clip", () => {
	it("parses border-box", () => {
		const result = Parse.Clip.parse("border-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("border-box");
	});

	it("parses padding-box", () => {
		const result = Parse.Clip.parse("padding-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("padding-box");
	});

	it("parses content-box", () => {
		const result = Parse.Clip.parse("content-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("content-box");
	});

	it("parses text", () => {
		const result = Parse.Clip.parse("text");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("text");
	});

	it("rejects invalid keyword", () => {
		const result = Parse.Clip.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("round-trips", () => {
		const original = "padding-box";
		const parsed = Parse.Clip.parse(original);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generate.Clip.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});

describe("Background.Origin", () => {
	it("parses border-box", () => {
		const result = Parse.Origin.parse("border-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("border-box");
	});

	it("parses padding-box", () => {
		const result = Parse.Origin.parse("padding-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("padding-box");
	});

	it("parses content-box", () => {
		const result = Parse.Origin.parse("content-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("content-box");
	});

	it("rejects invalid keyword", () => {
		const result = Parse.Origin.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("round-trips", () => {
		const original = "content-box";
		const parsed = Parse.Origin.parse(original);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generate.Origin.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});

describe("Background.Size", () => {
	describe("keywords", () => {
		it("parses cover", () => {
			const result = Parse.Size.parse("cover");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value).toBe("cover");
		});

		it("parses contain", () => {
			const result = Parse.Size.parse("contain");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value).toBe("contain");
		});

		it("parses auto", () => {
			const result = Parse.Size.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value).toBe("auto");
		});
	});

	describe("length/percentage values", () => {
		it("parses pixel values", () => {
			const result = Parse.Size.parse("100px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 100, unit: "px" });
			}
		});

		it("parses percentage values", () => {
			const result = Parse.Size.parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 50, unit: "%" });
			}
		});

		it("parses em values", () => {
			const result = Parse.Size.parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 2, unit: "em" });
			}
		});
	});

	it("rejects invalid keyword", () => {
		const result = Parse.Size.parse("invalid");
		expect(result.ok).toBe(false);
	});

	describe("round-trips", () => {
		it("round-trips keywords", () => {
			const original = "cover";
			const parsed = Parse.Size.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.Size.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("round-trips auto", () => {
			const original = "auto";
			const parsed = Parse.Size.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.Size.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("round-trips length values", () => {
			const original = "100px";
			const parsed = Parse.Size.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.Size.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("round-trips percentage values", () => {
			const original = "50%";
			const parsed = Parse.Size.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.Size.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});
	});
});


=== File: src/parse/background/background.ts ===
// b_path:: src/parse/background/background.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";

import * as Attachment from "./attachment";
import * as Clip from "./clip";
import * as Origin from "./origin";
import * as Repeat from "./repeat";
import * as Size from "./size";

export function parse(value: string): ParseResult<unknown> {
	const sizeResult = Size.parse(value);
	if (sizeResult.ok) return toParseResult(sizeResult);

	const repeatResult = Repeat.parse(value);
	if (repeatResult.ok) return toParseResult(repeatResult);

	const attachmentResult = Attachment.parse(value);
	if (attachmentResult.ok) return toParseResult(attachmentResult);

	const clipResult = Clip.parse(value);
	if (clipResult.ok) return toParseResult(clipResult);

	const originResult = Origin.parse(value);
	if (originResult.ok) return toParseResult(originResult);

	return parseErr("invalid-value", "Invalid background property value", {
		suggestion: "Expected size, repeat, attachment, clip, or origin",
	});
}


=== File: src/parse/background/clip.ts ===
// b_path:: src/parse/background/clip.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse background-clip value.
 *
 * Parses CSS background-clip values that set whether an element's background
 * extends underneath its border box, padding box, or content box.
 *
 * Valid values: border-box | padding-box | content-box | text
 *
 * @param css - CSS string containing background-clip value
 * @returns Result containing BackgroundClipKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Clip.parse("padding-box");
 * if (result.ok) {
 *   console.log(result.value); // "padding-box"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip | MDN: background-clip}
 */
export function parse(css: string): Result<Keyword.BackgroundClipKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.backgroundClipKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid background-clip value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/background/index.ts ===
// b_path:: src/parse/background/index.ts

export * as Attachment from "./attachment";
export { parse } from "./background";
export * as Clip from "./clip";
export * as Origin from "./origin";
export * as Repeat from "./repeat";
export * as Size from "./size";


=== File: src/parse/background/origin.ts ===
// b_path:: src/parse/background/origin.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse background-origin value.
 *
 * Parses CSS background-origin values that set the background's origin,
 * from the border start, inside the border, or inside the padding.
 *
 * Valid values: border-box | padding-box | content-box
 *
 * @param css - CSS string containing background-origin value
 * @returns Result containing VisualBoxKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Origin.parse("content-box");
 * if (result.ok) {
 *   console.log(result.value); // "content-box"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin | MDN: background-origin}
 */
export function parse(css: string): Result<Keyword.VisualBoxKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.visualBoxKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid background-origin value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/background/repeat.ts ===
// b_path:: src/parse/background/repeat.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse background-repeat value.
 *
 * Parses CSS background-repeat values that control how background images repeat.
 * Supports single-value syntax (repeat, repeat-x, repeat-y, no-repeat, space, round).
 *
 * @param css - CSS string containing background-repeat value
 * @returns Result containing RepeatKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Repeat.parse("repeat-x");
 * if (result.ok) {
 *   console.log(result.value); // "repeat-x"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat | MDN: background-repeat}
 */
export function parse(css: string): Result<Keyword.RepeatKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.repeatKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid background-repeat value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/background/size.ts ===
// b_path:: src/parse/background/size.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Background size value (keyword or length-percentage).
 *
 * @public
 */
export type BackgroundSizeValue = Keyword.SizingKeyword | Type.LengthPercentage | "auto";

/**
 * Parse background-size value (single dimension).
 *
 * Parses CSS background-size values that control the size of background images.
 * Supports keywords (cover, contain), auto, and length/percentage values.
 *
 * @param css - CSS string containing background-size value
 * @returns Result containing BackgroundSizeValue, or error message
 *
 * @public
 *
 * @example
 * Keywords:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Size.parse("cover");
 * if (result.ok) {
 *   console.log(result.value); // "cover"
 * }
 * ```
 *
 * @example
 * Length values:
 * ```typescript
 * const result = Parse.Background.Size.parse("100px");
 * if (result.ok) {
 *   console.log(result.value); // { value: 100, unit: "px" }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size | MDN: background-size}
 */
export function parse(css: string): Result<BackgroundSizeValue, string> {
	const trimmed = css.trim();

	// Try sizing keywords (cover, contain)
	const keywordResult = Keyword.sizingKeywordsSchema.safeParse(trimmed);
	if (keywordResult.success) {
		return ok(keywordResult.data);
	}

	// Try 'auto' keyword
	if (trimmed === "auto") {
		return ok("auto");
	}

	// Try length-percentage
	const csstree = require("css-tree");
	try {
		const ast = csstree.parse(trimmed, { context: "value" });
		const children = ast.children.toArray();
		if (children.length === 1) {
			const lengthResult = ParseUtils.parseLengthPercentageNode(children[0]);
			if (lengthResult.ok) {
				return lengthResult;
			}
		}
	} catch {
		// Continue to error
	}

	return err(`Invalid background-size value: "${css}"`);
}


=== File: src/parse/border/border.ts ===
// b_path:: src/parse/border/border.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";

import * as Color from "./color";
import * as Radius from "./radius";
import * as Style from "./style";
import * as Width from "./width";

export function parse(value: string): ParseResult<unknown> {
	const widthResult = Width.parse(value);
	if (widthResult.ok) return toParseResult(widthResult);

	const styleResult = Style.parse(value);
	if (styleResult.ok) return toParseResult(styleResult);

	const radiusResult = Radius.parse(value);
	if (radiusResult.ok) return toParseResult(radiusResult);

	const colorResult = Color.parse(value);
	if (colorResult.ok) return toParseResult(colorResult);

	return parseErr("invalid-value", "Invalid border property value", {
		suggestion: "Expected width, style, radius, or color",
	});
}


=== File: src/parse/border/color.test.ts ===
// b_path:: src/parse/border/color.test.ts
import { describe, expect, it } from "vitest";
import * as BorderColor from "./color";

describe("Parse.Border.Color", () => {
	describe("valid keywords", () => {
		it("should parse 'transparent'", () => {
			const result = BorderColor.parse("transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "transparent",
				});
			}
		});

		it("should parse 'currentcolor'", () => {
			const result = BorderColor.parse("currentcolor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "currentcolor",
				});
			}
		});

		it("should parse 'red'", () => {
			const result = BorderColor.parse("red");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "red",
				});
			}
		});

		it("should parse 'blue'", () => {
			const result = BorderColor.parse("blue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "blue",
				});
			}
		});

		it("should parse 'green'", () => {
			const result = BorderColor.parse("green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "green",
				});
			}
		});

		it("should parse 'black'", () => {
			const result = BorderColor.parse("black");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "black",
				});
			}
		});

		it("should parse 'white'", () => {
			const result = BorderColor.parse("white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "white",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = BorderColor.parse("notacolor");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("color keyword");
			}
		});

		it("should reject length values", () => {
			const result = BorderColor.parse("1px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = BorderColor.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = BorderColor.parse("red blue");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/color.ts ===
// b_path:: src/parse/border/color.ts
import * as csstree from "css-tree";
import { ALL_NAMED_COLOR_KEYWORDS } from "@/core/keywords/color-value-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS border-color property value.
 *
 * Accepts color keywords (currentcolor, transparent, named colors).
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * Note: This parser currently handles color keywords only.
 * For full color support (rgb, hsl, hex, etc.), use the color parsers.
 *
 * @param css - CSS border-color value (e.g., "red", "transparent", "currentcolor")
 * @returns Result with BorderColor IR or error message
 *
 * @example
 * Named color:
 * ```typescript
 * const result = parse("red");
 * // { ok: true, value: { kind: "border-color", color: "red" } }
 * ```
 *
 * @example
 * Transparent:
 * ```typescript
 * const result = parse("transparent");
 * // { ok: true, value: { kind: "border-color", color: "transparent" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color | MDN: border-color}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-color | W3C Spec}
 */
export function parse(css: string): Result<Type.BorderColorValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single border-color value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty border-color value");
		}

		if (node.type !== "Identifier") {
			return err(`Expected color keyword for border-color, got: ${node.type}`);
		}

		const keyword = node.name.toLowerCase();
		if (!ALL_NAMED_COLOR_KEYWORDS.includes(keyword as (typeof ALL_NAMED_COLOR_KEYWORDS)[number])) {
			return err(`Invalid color keyword: ${keyword}`);
		}

		return ok({
			kind: "border-color",
			color: keyword as (typeof ALL_NAMED_COLOR_KEYWORDS)[number],
		});
	} catch (e) {
		return err(`Failed to parse border-color: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/border/index.ts ===
// b_path:: src/parse/border/index.ts

export { parse } from "./border";

export * as Color from "./color";
export * as Radius from "./radius";
export * as Style from "./style";
export * as Width from "./width";


=== File: src/parse/border/radius.test.ts ===
// b_path:: src/parse/border/radius.test.ts
import { describe, expect, it } from "vitest";
import * as BorderRadius from "./radius";

describe("Parse.Border.Radius", () => {
	describe("valid lengths", () => {
		it("should parse '0' (unitless zero)", () => {
			const result = BorderRadius.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '5px'", () => {
			const result = BorderRadius.parse("5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 5, unit: "px" },
				});
			}
		});

		it("should parse '10.5px'", () => {
			const result = BorderRadius.parse("10.5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 10.5, unit: "px" },
				});
			}
		});

		it("should parse '1em'", () => {
			const result = BorderRadius.parse("1em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 1, unit: "em" },
				});
			}
		});

		it("should parse '2rem'", () => {
			const result = BorderRadius.parse("2rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 2, unit: "rem" },
				});
			}
		});
	});

	describe("valid percentages", () => {
		it("should parse '50%'", () => {
			const result = BorderRadius.parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 50, unit: "%" },
				});
			}
		});

		it("should parse '100%'", () => {
			const result = BorderRadius.parse("100%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 100, unit: "%" },
				});
			}
		});

		it("should parse '25.5%'", () => {
			const result = BorderRadius.parse("25.5%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 25.5, unit: "%" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject negative values", () => {
			const result = BorderRadius.parse("-5px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject keywords", () => {
			const result = BorderRadius.parse("medium");
			expect(result.ok).toBe(false);
		});

		it("should reject unitless non-zero", () => {
			const result = BorderRadius.parse("5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless");
			}
		});

		it("should reject empty string", () => {
			const result = BorderRadius.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = BorderRadius.parse("5px 10px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/radius.ts ===
// b_path:: src/parse/border/radius.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS border-radius property value.
 *
 * Accepts length or percentage values.
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param css - CSS border-radius value (e.g., "5px", "50%", "1em")
 * @returns Result with BorderRadius IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("5px");
 * // { ok: true, value: { kind: "border-radius", radius: { value: 5, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "border-radius", radius: { value: 50, unit: "%" } } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius | MDN: border-radius}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-radius | W3C Spec}
 */
export function parse(css: string): Result<Type.BorderRadiusValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single border-radius value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty border-radius value");
		}

		// Handle zero without unit
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value !== 0) {
				return err("Unitless values must be zero");
			}
			return ok({
				kind: "border-radius",
				radius: {
					value: 0,
					unit: "px",
				},
			});
		}

		// Use utility to parse length-percentage
		const radiusResult = ParseUtils.parseLengthPercentageNode(node);
		if (!radiusResult.ok) {
			return err(`Invalid border-radius value: ${radiusResult.error}`);
		}

		// border-radius doesn't accept negative values
		if (radiusResult.value.value < 0) {
			return err(`border-radius must be non-negative, got: ${radiusResult.value.value}`);
		}

		return ok({
			kind: "border-radius",
			radius: radiusResult.value,
		});
	} catch (e) {
		return err(`Failed to parse border-radius: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/border/style.test.ts ===
// b_path:: src/parse/border/style.test.ts
import { describe, expect, it } from "vitest";
import * as BorderStyle from "./style";

describe("Parse.Border.Style", () => {
	describe("valid keywords", () => {
		it("should parse 'none'", () => {
			const result = BorderStyle.parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "none",
				});
			}
		});

		it("should parse 'hidden'", () => {
			const result = BorderStyle.parse("hidden");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "hidden",
				});
			}
		});

		it("should parse 'dotted'", () => {
			const result = BorderStyle.parse("dotted");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "dotted",
				});
			}
		});

		it("should parse 'dashed'", () => {
			const result = BorderStyle.parse("dashed");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "dashed",
				});
			}
		});

		it("should parse 'solid'", () => {
			const result = BorderStyle.parse("solid");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "solid",
				});
			}
		});

		it("should parse 'double'", () => {
			const result = BorderStyle.parse("double");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "double",
				});
			}
		});

		it("should parse 'groove'", () => {
			const result = BorderStyle.parse("groove");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "groove",
				});
			}
		});

		it("should parse 'ridge'", () => {
			const result = BorderStyle.parse("ridge");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "ridge",
				});
			}
		});

		it("should parse 'inset'", () => {
			const result = BorderStyle.parse("inset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "inset",
				});
			}
		});

		it("should parse 'outset'", () => {
			const result = BorderStyle.parse("outset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "outset",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = BorderStyle.parse("wavy");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("keyword");
			}
		});

		it("should reject length values", () => {
			const result = BorderStyle.parse("1px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = BorderStyle.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = BorderStyle.parse("solid dashed");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/style.ts ===
// b_path:: src/parse/border/style.ts
import * as csstree from "css-tree";
import { BORDER_STYLE_KEYWORDS } from "@/core/keywords/border-style-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS border-style property value.
 *
 * Accepts predefined style keywords.
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param css - CSS border-style value (e.g., "solid", "dashed", "dotted")
 * @returns Result with BorderStyle IR or error message
 *
 * @example
 * Solid border:
 * ```typescript
 * const result = parse("solid");
 * // { ok: true, value: { kind: "border-style", style: "solid" } }
 * ```
 *
 * @example
 * Dashed border:
 * ```typescript
 * const result = parse("dashed");
 * // { ok: true, value: { kind: "border-style", style: "dashed" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style | MDN: border-style}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-style | W3C Spec}
 */
export function parse(css: string): Result<Type.BorderStyleValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single border-style value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty border-style value");
		}

		if (node.type !== "Identifier") {
			return err(`Expected keyword for border-style, got: ${node.type}`);
		}

		const keyword = node.name.toLowerCase();
		if (!BORDER_STYLE_KEYWORDS.includes(keyword as Type.BorderStyle)) {
			return err(`Invalid border-style keyword: ${keyword}`);
		}

		return ok({
			kind: "border-style",
			style: keyword as Type.BorderStyle,
		});
	} catch (e) {
		return err(`Failed to parse border-style: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/border/width.test.ts ===
// b_path:: src/parse/border/width.test.ts
import { describe, expect, it } from "vitest";
import * as BorderWidth from "./width";

describe("Parse.Border.Width", () => {
	describe("valid keywords", () => {
		it("should parse 'thin'", () => {
			const result = BorderWidth.parse("thin");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: "thin",
				});
			}
		});

		it("should parse 'medium'", () => {
			const result = BorderWidth.parse("medium");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: "medium",
				});
			}
		});

		it("should parse 'thick'", () => {
			const result = BorderWidth.parse("thick");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: "thick",
				});
			}
		});
	});

	describe("valid lengths", () => {
		it("should parse '0' (unitless zero)", () => {
			const result = BorderWidth.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '1px'", () => {
			const result = BorderWidth.parse("1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 1, unit: "px" },
				});
			}
		});

		it("should parse '2.5em'", () => {
			const result = BorderWidth.parse("2.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 2.5, unit: "em" },
				});
			}
		});

		it("should parse '0.5rem'", () => {
			const result = BorderWidth.parse("0.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 0.5, unit: "rem" },
				});
			}
		});

		it("should parse '10pt'", () => {
			const result = BorderWidth.parse("10pt");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 10, unit: "pt" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject negative values", () => {
			const result = BorderWidth.parse("-1px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject invalid keywords", () => {
			const result = BorderWidth.parse("large");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("keyword");
			}
		});

		it("should reject unitless non-zero", () => {
			const result = BorderWidth.parse("5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless");
			}
		});

		it("should reject percentage values", () => {
			const result = BorderWidth.parse("50%");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = BorderWidth.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = BorderWidth.parse("1px 2px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/width.ts ===
// b_path:: src/parse/border/width.ts
import * as csstree from "css-tree";
import { BORDER_WIDTH_KEYWORDS } from "@/core/keywords/border-width-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { ABSOLUTE_LENGTH_UNITS, FONT_LENGTH_UNITS, VIEWPORT_LENGTH_UNITS } from "@/core/units";

/**
 * Parse CSS border-width property value.
 *
 * Accepts length values or predefined keywords (thin, medium, thick).
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param css - CSS border-width value (e.g., "1px", "medium", "0.5em")
 * @returns Result with BorderWidth IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("1px");
 * // { ok: true, value: { kind: "border-width", width: { value: 1, unit: "px" } } }
 * ```
 *
 * @example
 * Keyword value:
 * ```typescript
 * const result = parse("medium");
 * // { ok: true, value: { kind: "border-width", width: "medium" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width | MDN: border-width}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-width | W3C Spec}
 */
export function parse(css: string): Result<Type.BorderWidthValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single border-width value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty border-width value");
		}

		// Handle keywords
		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			const keywordValue = keyword as "thin" | "medium" | "thick";
			if (BORDER_WIDTH_KEYWORDS.includes(keywordValue)) {
				return ok({
					kind: "border-width",
					width: keywordValue,
				});
			}
			return err(`Invalid border-width keyword: ${keyword}`);
		}

		// Handle length
		if (node.type === "Dimension") {
			const value = Number.parseFloat(node.value);
			const unit = node.unit.toLowerCase();

			const allLengthUnits = [...ABSOLUTE_LENGTH_UNITS, ...FONT_LENGTH_UNITS, ...VIEWPORT_LENGTH_UNITS];
			if (!allLengthUnits.includes(unit as (typeof allLengthUnits)[number])) {
				return err(`Invalid length unit for border-width: ${unit}`);
			}

			if (value < 0) {
				return err(`border-width must be non-negative, got: ${value}`);
			}

			return ok({
				kind: "border-width",
				width: {
					value,
					unit: unit as (typeof allLengthUnits)[number],
				},
			});
		}

		// Handle zero without unit
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value !== 0) {
				return err("Unitless values must be zero");
			}
			return ok({
				kind: "border-width",
				width: {
					value: 0,
					unit: "px",
				},
			});
		}

		return err(`Unexpected node type: ${node.type}`);
	} catch (e) {
		return err(`Failed to parse border-width: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/clip-path/circle.test.ts ===
// b_path:: src/parse/clip-path/circle.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "./circle";

describe("Parse.ClipPath.Circle", () => {
	describe("Basic parsing", () => {
		it("parses circle() with no arguments (all defaults)", () => {
			const result = Parse.parse("circle()");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
			});
		});

		it("parses circle() with radius only", () => {
			const result = Parse.parse("circle(50px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "px" },
			});
		});

		it("parses circle() with percentage radius", () => {
			const result = Parse.parse("circle(50%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "%" },
			});
		});

		it("parses circle() with closest-side radius", () => {
			const result = Parse.parse("circle(closest-side)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: "closest-side",
			});
		});

		it("parses circle() with farthest-side radius", () => {
			const result = Parse.parse("circle(farthest-side)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: "farthest-side",
			});
		});
	});

	describe("Position parsing", () => {
		it("parses circle() with position only", () => {
			const result = Parse.parse("circle(at center)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				position: { horizontal: "center", vertical: "center" },
			});
		});

		it("parses circle() with radius and position", () => {
			const result = Parse.parse("circle(50px at center)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "px" },
				position: { horizontal: "center", vertical: "center" },
			});
		});

		it("parses circle() with length-percentage position", () => {
			const result = Parse.parse("circle(at 30px 40%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				position: {
					horizontal: { value: 30, unit: "px" },
					vertical: { value: 40, unit: "%" },
				},
			});
		});

		it("parses circle() with mixed keyword and value position", () => {
			const result = Parse.parse("circle(closest-side at 30% top)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.kind).toBe("clip-path-circle");
			expect(result.value.radius).toBe("closest-side");
			expect(result.value.position).toBeDefined();
		});

		it("parses circle() with keyword position", () => {
			const result = Parse.parse("circle(at left top)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				position: { horizontal: "left", vertical: "top" },
			});
		});
	});

	describe("Edge cases", () => {
		it("parses zero radius", () => {
			const result = Parse.parse("circle(0)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 0, unit: "px" },
			});
		});

		it("parses zero percentage radius", () => {
			const result = Parse.parse("circle(0%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 0, unit: "%" },
			});
		});

		it("rejects negative radius", () => {
			const result = Parse.parse("circle(-10px)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("non-negative");
		});

		it("rejects negative percentage radius", () => {
			const result = Parse.parse("circle(-50%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("non-negative");
		});
	});

	describe("Error handling", () => {
		it("rejects non-circle function", () => {
			const result = Parse.parse("inset(10px)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("circle");
		});

		it("rejects missing position after 'at'", () => {
			const result = Parse.parse("circle(50px at)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("Expected position");
		});

		it("rejects invalid keyword", () => {
			const result = Parse.parse("circle(invalid)");
			expect(result.ok).toBe(false);
		});

		it("rejects extra content", () => {
			const result = Parse.parse("circle(50px at center extra)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("Unexpected");
		});

		it("rejects position without 'at'", () => {
			const result = Parse.parse("circle(50px center)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("'at'");
		});
	});

	describe("Whitespace handling", () => {
		it("handles extra whitespace", () => {
			const result = Parse.parse("circle(  50px   at   center  )");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "px" },
				position: { horizontal: "center", vertical: "center" },
			});
		});

		it("handles no whitespace", () => {
			const result = Parse.parse("circle(50px at center)");
			expect(result.ok).toBe(true);
		});
	});
});


=== File: src/parse/clip-path/circle.ts ===
// b_path:: src/parse/clip-path/circle.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunctionRaw } from "./utils";

/**
 * Parse circle() shape function.
 *
 * Syntax: circle( <length-percentage>? [ at <position> ]? )
 *
 * @param css - CSS string
 * @returns Result with ClipPathCircle IR or error
 *
 * @example
 * ```typescript
 * parse("circle()");
 * parse("circle(50px)");
 * parse("circle(closest-side at center)");
 * parse("circle(50% at 30px 40px)");
 * ```
 *
 * @public
 */
export function parse(css: string): Result<Type.ClipPathCircle, string> {
	return parseShapeFunctionRaw(css, "circle", parseCircleChildren);
}

function parseCircleChildren(children: CssNode[]): Result<Type.ClipPathCircle, string> {
	if (children.length === 0) {
		return ok({
			kind: "clip-path-circle",
		});
	}

	let idx = 0;
	let radius: Type.ClipPathCircle["radius"];

	// Parse optional radius (using utility, allow 'at' keyword)
	const radiusResult = ParseUtils.parseRadialSize(children[idx], "circle() radius", true);
	if (!radiusResult.ok) return radiusResult;
	if (radiusResult.value !== undefined) {
		radius = radiusResult.value;
		idx++;
	}

	// Parse optional position after 'at' (using utility)
	let position: Type.Position2D | undefined;
	if (idx < children.length) {
		const atResult = ParseUtils.parseAtPosition(children, idx);
		if (!atResult.ok) return atResult;

		// If position is undefined, there was content but no 'at' keyword
		if (atResult.value.position === undefined) {
			return err("Expected 'at' keyword before position");
		}

		position = atResult.value.position;
		idx = atResult.value.nextIdx;
	}

	// Check for extra content
	if (idx < children.length) {
		return err("Unexpected content after circle() arguments");
	}

	return ok({
		kind: "clip-path-circle",
		...(radius !== undefined && { radius }),
		...(position !== undefined && { position }),
	});
}


=== File: src/parse/clip-path/clip-path.test.ts ===
// b_path:: src/parse/clip-path/clip-path.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./clip-path";

describe("parse() - unified dispatcher", () => {
	describe("basic shapes", () => {
		it("detects circle()", () => {
			const result = parse("circle(50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-circle");
			}
		});

		it("detects ellipse()", () => {
			const result = parse("ellipse(50% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-ellipse");
			}
		});

		it("detects inset()", () => {
			const result = parse("inset(10px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-inset");
			}
		});

		it("detects polygon()", () => {
			const result = parse("polygon(0 0, 100% 0, 100% 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-polygon");
			}
		});

		it("detects rect()", () => {
			const result = parse("rect(10px 20px 30px 40px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-rect");
			}
		});

		it("detects xywh()", () => {
			const result = parse("xywh(10px 20px 30px 40px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-xywh");
			}
		});

		it("detects path()", () => {
			const result = parse('path("M 10 10 L 50 50")');
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-path");
			}
		});
	});

	describe("keywords", () => {
		it("detects none", () => {
			const result = parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-none");
			}
		});
	});

	describe("geometry-box keywords", () => {
		it("detects border-box", () => {
			const result = parse("border-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("border-box");
				}
			}
		});

		it("detects padding-box", () => {
			const result = parse("padding-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("padding-box");
				}
			}
		});

		it("detects content-box", () => {
			const result = parse("content-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("content-box");
				}
			}
		});

		it("detects fill-box", () => {
			const result = parse("fill-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("fill-box");
				}
			}
		});

		it("detects stroke-box", () => {
			const result = parse("stroke-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("stroke-box");
				}
			}
		});

		it("detects view-box", () => {
			const result = parse("view-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("view-box");
				}
			}
		});
	});

	describe("url reference", () => {
		it("detects url()", () => {
			const result = parse("url(#clip-shape)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("url");
				if (result.value?.kind === "url") {
					expect(result.value?.value).toBe("#clip-shape");
				}
			}
		});
	});

	describe("error cases", () => {
		it("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Empty");
			}
		});

		it("rejects unknown function", () => {
			const result = parse("unknown(10px)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown clip-path function");
			}
		});

		it("rejects invalid identifier", () => {
			const result = parse("invalid-keyword");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Invalid geometry-box value");
			}
		});
	});

	describe("case insensitivity", () => {
		it("handles CIRCLE()", () => {
			const result = parse("CIRCLE(50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-circle");
			}
		});

		it("handles Polygon()", () => {
			const result = parse("Polygon(0 0, 100% 0, 100% 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-polygon");
			}
		});
	});
});


=== File: src/parse/clip-path/clip-path.ts ===
// b_path:: src/parse/clip-path/clip-path.ts

import type { CssNode } from "css-tree";
import * as cssTree from "css-tree";
import { err, type ParseResult, parseErr, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as Circle from "./circle";
import * as Ellipse from "./ellipse";
import * as GeometryBox from "./geometry-box";
import * as Inset from "./inset";
import * as None from "./none";
import * as Path from "./path";
import * as Polygon from "./polygon";
import * as Rect from "./rect";
import * as Url from "./url";
import * as Xywh from "./xywh";

/**
 * Parse clip-path value with auto-detection.
 *
 * Automatically detects and parses any clip-path value:
 * - Basic shapes: circle(), ellipse(), inset(), polygon(), rect(), xywh(), path()
 * - Reference: url()
 * - Keyword: none
 * - Geometry box: border-box, padding-box, content-box, etc.
 *
 * @param value - CSS clip-path value string
 * @returns Result with ClipPathValue IR or error
 *
 * @example
 * ```typescript
 * parse("circle(50%)");           // Auto-detects circle
 * parse("polygon(0 0, 100% 0, 100% 100%)"); // Auto-detects polygon
 * parse("none");                  // Auto-detects keyword
 * parse("url(#clip)");            // Auto-detects reference
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Type.ClipPathValue> {
	const ast = cssTree.parse(value, { context: "value" }) as cssTree.Value;
	if (!ast.children) return parseErr("invalid-syntax", "Empty value");
	const first = ast.children.first;
	if (!first) return parseErr("invalid-syntax", "Empty value");
	const result = parseNode(first);
	return toParseResult(result);
}

/**
 * Parse clip-path AST node with auto-detection.
 *
 * @param node - CSS AST node
 * @returns Result with ClipPathValue IR or error
 *
 * @internal
 */
function parseNode(node: CssNode): Result<Type.ClipPathValue, string> {
	// Keyword: none
	if (node.type === "Identifier" && node.name === "none") {
		return None.parse("none");
	}

	// URL reference
	if (node.type === "Url") {
		const css = cssTree.generate(node);
		return Url.parse(css);
	}

	// Basic shapes (function)
	if (node.type === "Function") {
		const css = cssTree.generate(node);
		switch (node.name.toLowerCase()) {
			case "circle":
				return Circle.parse(css);
			case "ellipse":
				return Ellipse.parse(css);
			case "inset":
				return Inset.parse(css);
			case "polygon":
				return Polygon.parse(css);
			case "rect":
				return Rect.parse(css);
			case "xywh":
				return Xywh.parse(css);
			case "path":
				return Path.parse(css);
			default:
				return err(`Unknown clip-path function: ${node.name}`);
		}
	}

	// Geometry-box keyword
	if (node.type === "Identifier") {
		return GeometryBox.parse(node.name);
	}

	return err(`Invalid clip-path node type: ${node.type}`);
}


=== File: src/parse/clip-path/ellipse.test.ts ===
// b_path:: src/parse/clip-path/ellipse.test.ts
import { describe, expect, it } from "vitest";
import * as Ellipse from "./ellipse";

describe("parse/clip-path/ellipse", () => {
	describe("basic parsing", () => {
		it("should parse ellipse with no arguments", () => {
			const result = Ellipse.parse("ellipse()");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
				},
			});
		});

		it("should parse ellipse with single radius (both X and Y)", () => {
			const result = Ellipse.parse("ellipse(50px)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "px" },
				},
			});
		});

		it("should parse ellipse with two radii", () => {
			const result = Ellipse.parse("ellipse(50px 100px)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "px" },
					radiusY: { value: 100, unit: "px" },
				},
			});
		});

		it("should parse ellipse with percentage radii", () => {
			const result = Ellipse.parse("ellipse(50% 75%)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "%" },
					radiusY: { value: 75, unit: "%" },
				},
			});
		});

		it("should parse ellipse with mixed units", () => {
			const result = Ellipse.parse("ellipse(2rem 100px)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 2, unit: "rem" },
					radiusY: { value: 100, unit: "px" },
				},
			});
		});
	});

	describe("keyword radii", () => {
		it("should parse ellipse with closest-side keywords", () => {
			const result = Ellipse.parse("ellipse(closest-side closest-side)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: "closest-side",
					radiusY: "closest-side",
				},
			});
		});

		it("should parse ellipse with farthest-side keywords", () => {
			const result = Ellipse.parse("ellipse(farthest-side farthest-side)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: "farthest-side",
					radiusY: "farthest-side",
				},
			});
		});

		it("should parse ellipse with mixed keywords", () => {
			const result = Ellipse.parse("ellipse(closest-side farthest-side)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: "closest-side",
					radiusY: "farthest-side",
				},
			});
		});

		it("should parse ellipse with keyword and value", () => {
			const result = Ellipse.parse("ellipse(50px farthest-side)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "px" },
					radiusY: "farthest-side",
				},
			});
		});
	});

	describe("position parsing", () => {
		it("should parse ellipse with position only", () => {
			const result = Ellipse.parse("ellipse(at center center)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					position: {
						horizontal: "center",
						vertical: "center",
					},
				},
			});
		});

		it("should parse ellipse with radii and position", () => {
			const result = Ellipse.parse("ellipse(50px 100px at 30px 40px)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "px" },
					radiusY: { value: 100, unit: "px" },
					position: {
						horizontal: { value: 30, unit: "px" },
						vertical: { value: 40, unit: "px" },
					},
				},
			});
		});

		it("should parse ellipse with keywords and position", () => {
			const result = Ellipse.parse("ellipse(closest-side farthest-side at left top)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: "closest-side",
					radiusY: "farthest-side",
					position: {
						horizontal: "left",
						vertical: "top",
					},
				},
			});
		});

		it("should parse ellipse with mixed position", () => {
			const result = Ellipse.parse("ellipse(at 30% top)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					position: {
						horizontal: { value: 30, unit: "%" },
						vertical: "top",
					},
				},
			});
		});
	});

	describe("edge cases", () => {
		it("should parse ellipse with zero radii", () => {
			const result = Ellipse.parse("ellipse(0 0)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 0, unit: "px" },
					radiusY: { value: 0, unit: "px" },
				},
			});
		});

		it("should parse ellipse with unitless zero", () => {
			const result = Ellipse.parse("ellipse(0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.radiusX).toEqual({ value: 0, unit: "px" });
				expect(result.value.radiusY).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should reject negative radiusX", () => {
			const result = Ellipse.parse("ellipse(-50px 100px)");
			expect(result).toEqual({
				ok: false,
				error: "ellipse() radiusX must be non-negative",
			});
		});

		it("should reject negative radiusY", () => {
			const result = Ellipse.parse("ellipse(50px -100px)");
			expect(result).toEqual({
				ok: false,
				error: "ellipse() radiusY must be non-negative",
			});
		});
	});

	describe("error handling", () => {
		it("should reject non-ellipse function", () => {
			const result = Ellipse.parse("circle(50px)");
			expect(result.ok).toBe(false);
		});

		it("should reject missing position after at", () => {
			const result = Ellipse.parse("ellipse(50px 100px at)");
			expect(result).toEqual({
				ok: false,
				error: "Expected position after 'at'",
			});
		});

		it("should reject invalid syntax", () => {
			const result = Ellipse.parse("ellipse(50px 100px center)");
			expect(result).toEqual({
				ok: false,
				error: "Expected 'at' keyword before position",
			});
		});

		it("should reject extra content", () => {
			const result = Ellipse.parse("ellipse(50px 100px at center extra)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid keyword", () => {
			const result = Ellipse.parse("ellipse(invalid)");
			expect(result.ok).toBe(false);
		});
	});

	describe("whitespace handling", () => {
		it("should handle extra whitespace", () => {
			const result = Ellipse.parse("ellipse(  50px   100px   at   center   center  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.radiusX).toEqual({ value: 50, unit: "px" });
				expect(result.value.radiusY).toEqual({ value: 100, unit: "px" });
			}
		});

		it("should handle no whitespace", () => {
			const result = Ellipse.parse("ellipse(50px 100px at center center)");
			expect(result.ok).toBe(true);
		});
	});
});


=== File: src/parse/clip-path/ellipse.ts ===
// b_path:: src/parse/clip-path/ellipse.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunctionRaw } from "./utils";

/**
 * Parse ellipse() shape function.
 *
 * Syntax: ellipse( <radial-size>{2}? [ at <position> ]? )
 *
 * @param css - CSS string
 * @returns Result with ClipPathEllipse IR or error
 *
 * @example
 * ```typescript
 * parse("ellipse()");
 * parse("ellipse(50px 100px)");
 * parse("ellipse(closest-side farthest-side at center)");
 * parse("ellipse(50% 100% at 30px 40px)");
 * ```
 *
 * @public
 */
export function parse(css: string): Result<Type.ClipPathEllipse, string> {
	return parseShapeFunctionRaw(css, "ellipse", parseEllipseChildren);
}

function parseEllipseChildren(children: CssNode[]): Result<Type.ClipPathEllipse, string> {
	if (children.length === 0) {
		return ok({
			kind: "clip-path-ellipse",
		});
	}

	let idx = 0;
	let radiusX: Type.ClipPathEllipse["radiusX"];
	let radiusY: Type.ClipPathEllipse["radiusY"];

	// Parse optional radiusX (using utility, allow 'at' keyword)
	const radiusXResult = ParseUtils.parseRadialSize(children[idx], "ellipse() radiusX", true);
	if (!radiusXResult.ok) return radiusXResult;
	if (radiusXResult.value !== undefined) {
		radiusX = radiusXResult.value;
		idx++;
	}

	// Parse optional radiusY (if radiusX was parsed, also allow 'at' keyword)
	if (radiusX !== undefined && idx < children.length) {
		const radiusYResult = ParseUtils.parseRadialSize(children[idx], "ellipse() radiusY", true);
		if (!radiusYResult.ok) return radiusYResult;
		if (radiusYResult.value !== undefined) {
			radiusY = radiusYResult.value;
			idx++;
		}
	}

	// Parse optional position after 'at' (using utility)
	let position: Type.Position2D | undefined;
	if (idx < children.length) {
		const atResult = ParseUtils.parseAtPosition(children, idx);
		if (!atResult.ok) return atResult;

		// If position is undefined, there was content but no 'at' keyword
		if (atResult.value.position === undefined) {
			return err("Expected 'at' keyword before position");
		}

		position = atResult.value.position;
		idx = atResult.value.nextIdx;
	}

	// Check for extra content
	if (idx < children.length) {
		return err("Unexpected content after ellipse() arguments");
	}

	return ok({
		kind: "clip-path-ellipse",
		...(radiusX !== undefined && { radiusX }),
		...(radiusY !== undefined && { radiusY }),
		...(position !== undefined && { position }),
	});
}


=== File: src/parse/clip-path/geometry-box.test.ts ===
// b_path:: src/parse/clip-path/geometry-box.test.ts

import { describe, expect, test } from "vitest";
import * as Generate from "@/generate/clip-path/geometry-box";
import * as GeometryBox from "./geometry-box";

describe("Parse.ClipPath.GeometryBox", () => {
	describe("Visual box keywords", () => {
		test("content-box", () => {
			const result = GeometryBox.parse("content-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-geometry-box",
				value: "content-box",
			});
		});

		test("padding-box", () => {
			const result = GeometryBox.parse("padding-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-geometry-box",
				value: "padding-box",
			});
		});

		test("border-box", () => {
			const result = GeometryBox.parse("border-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-geometry-box",
				value: "border-box",
			});
		});
	});

	describe("Shape box keywords", () => {
		test("margin-box", () => {
			const result = GeometryBox.parse("margin-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-geometry-box",
				value: "margin-box",
			});
		});
	});

	describe("SVG box keywords", () => {
		test("fill-box", () => {
			const result = GeometryBox.parse("fill-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-geometry-box",
				value: "fill-box",
			});
		});

		test("stroke-box", () => {
			const result = GeometryBox.parse("stroke-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-geometry-box",
				value: "stroke-box",
			});
		});

		test("view-box", () => {
			const result = GeometryBox.parse("view-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-geometry-box",
				value: "view-box",
			});
		});
	});

	describe("Whitespace handling", () => {
		test("leading whitespace", () => {
			const result = GeometryBox.parse("  content-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.value).toBe("content-box");
		});

		test("trailing whitespace", () => {
			const result = GeometryBox.parse("padding-box  ");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.value).toBe("padding-box");
		});

		test("both leading and trailing whitespace", () => {
			const result = GeometryBox.parse("  border-box  ");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.value).toBe("border-box");
		});
	});

	describe("Invalid inputs", () => {
		test("invalid keyword", () => {
			const result = GeometryBox.parse("invalid-box");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("Invalid geometry-box value");
		});

		test("empty string", () => {
			const result = GeometryBox.parse("");
			expect(result.ok).toBe(false);
		});

		test("random text", () => {
			const result = GeometryBox.parse("not-a-box");
			expect(result.ok).toBe(false);
		});

		test("case sensitive - uppercase", () => {
			const result = GeometryBox.parse("CONTENT-BOX");
			expect(result.ok).toBe(false);
		});

		test("case sensitive - mixed case", () => {
			const result = GeometryBox.parse("Content-Box");
			expect(result.ok).toBe(false);
		});
	});

	describe("Round-trip validation", () => {
		test("content-box round-trip", () => {
			const parsed = GeometryBox.parse("content-box");
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = Generate.toCss(parsed.value);
			expect(css).toBe("content-box");

			const reparsed = GeometryBox.parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("padding-box round-trip", () => {
			const parsed = GeometryBox.parse("padding-box");
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = Generate.toCss(parsed.value);
			expect(css).toBe("padding-box");

			const reparsed = GeometryBox.parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("border-box round-trip", () => {
			const parsed = GeometryBox.parse("border-box");
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = Generate.toCss(parsed.value);
			expect(css).toBe("border-box");

			const reparsed = GeometryBox.parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("margin-box round-trip", () => {
			const parsed = GeometryBox.parse("margin-box");
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = Generate.toCss(parsed.value);
			expect(css).toBe("margin-box");

			const reparsed = GeometryBox.parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("fill-box round-trip", () => {
			const parsed = GeometryBox.parse("fill-box");
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = Generate.toCss(parsed.value);
			expect(css).toBe("fill-box");

			const reparsed = GeometryBox.parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("stroke-box round-trip", () => {
			const parsed = GeometryBox.parse("stroke-box");
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = Generate.toCss(parsed.value);
			expect(css).toBe("stroke-box");

			const reparsed = GeometryBox.parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("view-box round-trip", () => {
			const parsed = GeometryBox.parse("view-box");
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = Generate.toCss(parsed.value);
			expect(css).toBe("view-box");

			const reparsed = GeometryBox.parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});
	});
});


=== File: src/parse/clip-path/geometry-box.ts ===
// b_path:: src/parse/clip-path/geometry-box.ts

import { geometryBoxKeywordsSchema } from "@/core/keywords/geometry-box";
import { err, ok, type Result } from "@/core/result";
import type { ClipPathGeometryBox } from "@/core/types/clip-path";

/**
 * Parse geometry-box keyword for clip-path property.
 *
 * Parses box model keywords that define the clipping region reference box.
 * Supports visual boxes (content-box, padding-box, border-box), shape boxes
 * (adds margin-box), and SVG boxes (fill-box, stroke-box, view-box).
 *
 * @param input - CSS string like "content-box" or "padding-box"
 * @returns Result with ClipPathGeometryBox IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path#geometry-box}
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.ClipPath.GeometryBox.parse("content-box");
 * // { ok: true, value: { kind: "clip-path-geometry-box", value: "content-box" } }
 *
 * const result2 = Parse.ClipPath.GeometryBox.parse("fill-box");
 * // { ok: true, value: { kind: "clip-path-geometry-box", value: "fill-box" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<ClipPathGeometryBox, string> {
	const trimmed = input.trim();
	const result = geometryBoxKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid geometry-box value: "${input}"`);
	}

	return ok({
		kind: "clip-path-geometry-box",
		value: result.data,
	});
}


=== File: src/parse/clip-path/index.ts ===
// b_path:: src/parse/clip-path/index.ts

export * as Circle from "./circle";
export { parse } from "./clip-path";
export * as Ellipse from "./ellipse";
export * as GeometryBox from "./geometry-box";
export * as Inset from "./inset";
export * as None from "./none";
export * as Path from "./path";
export * as Polygon from "./polygon";
export * as Rect from "./rect";
export * as Url from "./url";
export * as Xywh from "./xywh";


=== File: src/parse/clip-path/inset.test.ts ===
// b_path:: src/parse/clip-path/inset.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./inset";

describe("parse inset()", () => {
	describe("basic TRBL", () => {
		it("should parse single value (all sides)", () => {
			const result = parse("inset(10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("clip-path-inset");
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius).toBeUndefined();
			}
		});

		it("should parse two values (vertical | horizontal)", () => {
			const result = parse("inset(10px 20px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse three values", () => {
			const result = parse("inset(10px 20px 30px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse four values (TRBL)", () => {
			const result = parse("inset(10px 20px 30px 40px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 40, unit: "px" });
			}
		});

		it("should handle mixed units", () => {
			const result = parse("inset(10% 20px 5em 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "%" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 5, unit: "em" });
				expect(result.value.left).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should handle unitless zero", () => {
			const result = parse("inset(0 10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should handle all zero", () => {
			const result = parse("inset(0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should handle percentage values", () => {
			const result = parse("inset(10% 20%)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "%" });
				expect(result.value.right).toEqual({ value: 20, unit: "%" });
			}
		});

		it("should handle negative insets", () => {
			const result = parse("inset(-10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: -10, unit: "px" });
			}
		});
	});

	describe("border-radius", () => {
		it("should parse single radius (all corners)", () => {
			const result = parse("inset(10px round 5px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse two radii (diagonal corners)", () => {
			const result = parse("inset(10px round 5px 10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse four radii (all corners)", () => {
			const result = parse("inset(10px round 5px 10px 15px 20px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 15, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse zero radius", () => {
			const result = parse("inset(10px round 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should parse mixed TRBL with radius", () => {
			const result = parse("inset(10px 20px round 5px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse full complex example", () => {
			const result = parse("inset(5% 10% 15% 20% round 2px 4px 6px 8px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 5, unit: "%" });
				expect(result.value.right).toEqual({ value: 10, unit: "%" });
				expect(result.value.bottom).toEqual({ value: 15, unit: "%" });
				expect(result.value.left).toEqual({ value: 20, unit: "%" });
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 2, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 4, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 6, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 8, unit: "px" });
			}
		});
	});

	describe("edge cases and errors", () => {
		it("should reject empty function", () => {
			const result = parse("inset()");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("at least one");
			}
		});

		it("should reject too many TRBL values", () => {
			const result = parse("inset(1px 2px 3px 4px 5px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("accepts 1-4");
			}
		});

		it("should reject round without value", () => {
			const result = parse("inset(10px round)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("after 'round'");
			}
		});

		it("should reject negative radius", () => {
			const result = parse("inset(10px round -5px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject invalid syntax", () => {
			const result = parse("inset(round 10px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBeTruthy();
			}
		});

		it("should reject invalid function name", () => {
			const result = parse("circle(10px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("inset");
			}
		});
	});
});


=== File: src/parse/clip-path/inset.ts ===
// b_path:: src/parse/clip-path/inset.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunction } from "./utils";

/**
 * Parse CSS inset() function for clip-path.
 *
 * Accepts 1-4 length-percentage values for inset offsets (TRBL),
 * optionally followed by 'round' keyword and border-radius values.
 *
 * Syntax: inset( <length-percentage>{1,4} [ round <border-radius> ]? )
 *
 * @param css - CSS inset() function (e.g., "inset(10px round 5px)")
 * @returns Result with ClipPathInset IR or error message
 *
 * @example
 * Simple inset:
 * ```typescript
 * const result = parse("inset(10px)");
 * // { kind: "clip-path-inset", top: 10px, right: 10px, bottom: 10px, left: 10px }
 * ```
 *
 * @example
 * With border-radius:
 * ```typescript
 * const result = parse("inset(10px 20px round 5px)");
 * // { kind: "clip-path-inset", top: 10px, right: 20px, ..., borderRadius: { ... } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/inset | MDN: inset()}
 */
export function parse(css: string): Result<Type.ClipPathInset, string> {
	return parseShapeFunction(css, "inset", parseInsetArgs);
}

function parseInsetArgs(args: CssNode[]): Result<Type.ClipPathInset, string> {
	if (args.length === 0) {
		return err("inset() requires at least one value");
	}

	// Parse optional border-radius (using utility)
	const roundResult = ParseUtils.parseRoundBorderRadius(args);
	if (!roundResult.ok) return roundResult;
	const { roundIndex, borderRadius } = roundResult.value;

	// Parse TRBL values (before 'round' or all args if no 'round')
	const trblNodes = roundIndex !== -1 ? args.slice(0, roundIndex) : args;

	if (trblNodes.length === 0 || trblNodes.length > 4) {
		return err("inset() accepts 1-4 length-percentage values");
	}

	// Parse each inset value
	const insetValues: Type.LengthPercentage[] = [];

	for (const node of trblNodes) {
		const lpResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lpResult.ok) {
			return err(`Invalid inset value: ${lpResult.error}`);
		}
		insetValues.push(lpResult.value);
	}

	// Expand TRBL values (1-4 values → 4 values)
	const [val0, val1, val2, val3] = insetValues;
	let top: Type.LengthPercentage;
	let right: Type.LengthPercentage;
	let bottom: Type.LengthPercentage;
	let left: Type.LengthPercentage;

	if (insetValues.length === 1 && val0) {
		top = right = bottom = left = val0;
	} else if (insetValues.length === 2 && val0 && val1) {
		top = bottom = val0;
		right = left = val1;
	} else if (insetValues.length === 3 && val0 && val1 && val2) {
		top = val0;
		right = left = val1;
		bottom = val2;
	} else if (insetValues.length === 4 && val0 && val1 && val2 && val3) {
		top = val0;
		right = val1;
		bottom = val2;
		left = val3;
	} else {
		return err("inset() requires valid values");
	}

	return ok({
		kind: "clip-path-inset",
		top,
		right,
		bottom,
		left,
		borderRadius,
	});
}


=== File: src/parse/clip-path/none.test.ts ===
// b_path:: src/parse/clip-path/none.test.ts

import { describe, expect, it } from "vitest";
import * as Generate from "@/generate/clip-path/none";
import { parse } from "./none";

describe("parse clip-path none", () => {
	it("parses none keyword", () => {
		const result = parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "clip-path-none",
			});
		}
	});

	it("handles whitespace", () => {
		const result = parse("  none  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("clip-path-none");
		}
	});

	it("rejects invalid keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("is case-sensitive", () => {
		const result = parse("None");
		expect(result.ok).toBe(false);
	});
});

describe("round-trip none", () => {
	it("round-trips: none", () => {
		const parsed = parse("none");
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generate.toCss(parsed.value);
			expect(generated).toBe("none");
			const reparsed = parse(generated);
			expect(reparsed.ok).toBe(true);
			if (reparsed.ok) {
				expect(reparsed.value).toEqual(parsed.value);
			}
		}
	});
});


=== File: src/parse/clip-path/none.ts ===
// b_path:: src/parse/clip-path/none.ts

import { err, ok, type Result } from "@/core/result";
import type { ClipPathNone } from "@/core/types/clip-path";

/**
 * Parse clip-path none keyword.
 *
 * Parses the "none" keyword which indicates no clipping is applied.
 * This is the initial/default value for clip-path.
 *
 * @param css - CSS string containing "none"
 * @returns Result with ClipPathNone IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.ClipPath.None.parse("none");
 * // { ok: true, value: { kind: "clip-path-none" } }
 * ```
 *
 * @public
 */
export function parse(css: string): Result<ClipPathNone, string> {
	const trimmed = css.trim();

	if (trimmed !== "none") {
		return err(`Invalid clip-path none value: "${css}"`);
	}

	return ok({ kind: "clip-path-none" });
}


=== File: src/parse/clip-path/path.test.ts ===
// b_path:: src/parse/clip-path/path.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./path";

describe("parse path()", () => {
	describe("basic path data", () => {
		it("should parse simple path", () => {
			const result = parse("path('M 10,10 L 90,10 L 50,90 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("clip-path-path");
				expect(result.value.pathData).toBe("M 10,10 L 90,10 L 50,90 Z");
				expect(result.value.fillRule).toBeUndefined();
			}
		});

		it("should parse path with lowercase commands", () => {
			const result = parse("path('m 10,10 l 80,0 l -40,80 z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("m 10,10 l 80,0 l -40,80 z");
			}
		});

		it("should parse compact path syntax", () => {
			const result = parse("path('M10 10L90 10L50 90z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M10 10L90 10L50 90z");
			}
		});

		it("should parse path with various commands", () => {
			const result = parse("path('M 0,0 H 100 V 100 L 0,100 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 0,0 H 100 V 100 L 0,100 Z");
			}
		});

		it("should parse path with curves", () => {
			const result = parse("path('M 10,10 C 20,20 40,20 50,10')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 10,10 C 20,20 40,20 50,10");
			}
		});

		it("should parse path with quadratic curves", () => {
			const result = parse("path('M 10,10 Q 25,5 40,10')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 10,10 Q 25,5 40,10");
			}
		});

		it("should parse path with arcs", () => {
			const result = parse("path('M 10,10 A 20,20 0 0,0 30,10')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 10,10 A 20,20 0 0,0 30,10");
			}
		});
	});

	describe("fill-rule", () => {
		it("should parse with nonzero fill-rule", () => {
			const result = parse("path(nonzero, 'M 10,10 L 90,10 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.fillRule).toBe("nonzero");
				expect(result.value.pathData).toBe("M 10,10 L 90,10 Z");
			}
		});

		it("should parse with evenodd fill-rule", () => {
			const result = parse("path(evenodd, 'M 10,10 L 90,10 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.fillRule).toBe("evenodd");
				expect(result.value.pathData).toBe("M 10,10 L 90,10 Z");
			}
		});

		it("should parse fill-rule case-insensitively", () => {
			const result = parse("path(EVENODD, 'M 10,10 L 90,10 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.fillRule).toBe("evenodd");
			}
		});
	});

	describe("edge cases", () => {
		it("should parse path with extra whitespace", () => {
			const result = parse("path('  M 10,10   L 90,10   Z  ')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("  M 10,10   L 90,10   Z  ");
			}
		});

		it("should parse path with negative coordinates", () => {
			const result = parse("path('M -10,-10 L 90,10 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M -10,-10 L 90,10 Z");
			}
		});

		it("should parse path with decimal coordinates", () => {
			const result = parse("path('M 10.5,10.5 L 90.5,10.5 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 10.5,10.5 L 90.5,10.5 Z");
			}
		});
	});

	describe("errors", () => {
		it("should error on empty function", () => {
			const result = parse("path()");
			expect(result.ok).toBe(false);
		});

		it("should error on non-string path data", () => {
			const result = parse("path(10px)");
			expect(result.ok).toBe(false);
		});

		it("should error on empty path data", () => {
			const result = parse("path('')");
			expect(result.ok).toBe(false);
		});

		it("should error on invalid fill-rule", () => {
			const result = parse("path(invalid, 'M 10,10 Z')");
			expect(result.ok).toBe(false);
		});

		it("should error on path without commands", () => {
			const result = parse("path('10,10 90,10')");
			expect(result.ok).toBe(false);
		});

		it("should error on path not starting with M/m", () => {
			const result = parse("path('L 10,10 Z')");
			expect(result.ok).toBe(false);
		});

		it("should error on non-path function", () => {
			const result = parse("circle(50px)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/clip-path/path.ts ===
// b_path:: src/parse/clip-path/path.ts
import type csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseShapeFunction } from "./utils";

/**
 * Parse CSS path() function for clip-path.
 *
 * Accepts an optional fill-rule keyword followed by an SVG path data string.
 *
 * Syntax: path( [<fill-rule>,]? <string> )
 *
 * @param css - CSS path() function (e.g., "path('M 10,10 L 90,10 L 50,90 Z')")
 * @returns Result with ClipPathPath IR or error message
 *
 * @example
 * Simple path:
 * ```typescript
 * const result = parse("path('M 10,10 L 90,10 L 50,90 Z')");
 * // { kind: "clip-path-path", pathData: "M 10,10 L 90,10 L 50,90 Z" }
 * ```
 *
 * @example
 * With fill-rule:
 * ```typescript
 * const result = parse("path(evenodd, 'M 10,10 L 90,10 Z')");
 * // { kind: "clip-path-path", fillRule: "evenodd", pathData: "M 10,10 L 90,10 Z" }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/path | MDN: path()}
 */
export function parse(css: string): Result<Type.ClipPathPath, string> {
	return parseShapeFunction(css, "path", parsePathArgs);
}

function parsePathArgs(args: csstree.CssNode[]): Result<Type.ClipPathPath, string> {
	if (args.length === 0) {
		return err("path() requires a path data string");
	}

	// Check if first argument is fill-rule keyword
	let fillRule: "nonzero" | "evenodd" | undefined;
	let pathDataNode: csstree.CssNode;

	if (args.length === 1) {
		// Only path data
		const arg0 = args[0];
		if (!arg0) {
			return err("path() requires a path data string");
		}
		pathDataNode = arg0;
	} else if (args.length >= 2) {
		// Check if first argument is fill-rule
		const firstArg = args[0];
		const secondArg = args[1];

		if (!firstArg || !secondArg) {
			return err("path() requires valid arguments");
		}

		if (firstArg.type === "Identifier") {
			const keyword = firstArg.name.toLowerCase();
			if (keyword === "nonzero" || keyword === "evenodd") {
				fillRule = keyword;
				pathDataNode = secondArg;
			} else {
				return err(`Invalid fill-rule: ${firstArg.name}. Expected 'nonzero' or 'evenodd'`);
			}
		} else {
			return err("First argument must be fill-rule keyword or path data string");
		}
	} else {
		return err("path() requires a path data string");
	}

	// Extract string value
	if (pathDataNode.type !== "String") {
		return err("Path data must be a string");
	}

	const pathData = pathDataNode.value;

	// Validate path data contains valid SVG commands
	const validationResult = validatePathData(pathData);
	if (!validationResult.ok) {
		return err(validationResult.error);
	}

	return ok({
		kind: "clip-path-path",
		fillRule,
		pathData,
	});
}

/**
 * Validate SVG path data string.
 *
 * Checks for valid SVG path commands (M, L, H, V, C, S, Q, T, A, Z).
 * Does not perform deep validation of coordinate syntax.
 *
 * @internal
 */
function validatePathData(pathData: string): Result<void, string> {
	if (!pathData || pathData.trim() === "") {
		return err("Path data cannot be empty");
	}

	// Check for valid SVG path commands
	const pathCommandRegex = /[MmLlHhVvCcSsQqTtAaZz]/;
	if (!pathCommandRegex.test(pathData)) {
		return err("Path data must contain valid SVG commands (M, L, H, V, C, S, Q, T, A, Z)");
	}

	// Path data should start with M or m (moveto)
	const trimmed = pathData.trim();
	if (!trimmed.match(/^[Mm]/)) {
		return err("Path data should start with M or m (moveto) command");
	}

	return ok(undefined);
}


=== File: src/parse/clip-path/polygon.test.ts ===
// b_path:: src/parse/clip-path/polygon.test.ts

import { describe, expect, it } from "vitest";
import * as Polygon from "./polygon";

describe("Parse.ClipPath.Polygon.parse", () => {
	describe("basic parsing", () => {
		it("should parse 3-point triangle", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 100%, 0% 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-polygon",
				points: [
					{ x: { value: 50, unit: "%" }, y: { value: 0, unit: "%" } },
					{ x: { value: 100, unit: "%" }, y: { value: 100, unit: "%" } },
					{ x: { value: 0, unit: "%" }, y: { value: 100, unit: "%" } },
				],
			});
		});

		it("should parse 4-point square", () => {
			const result = Polygon.parse("polygon(0px 0px, 100px 0px, 100px 100px, 0px 100px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(4);
			expect(result.value.points[0]).toEqual({ x: { value: 0, unit: "px" }, y: { value: 0, unit: "px" } });
			expect(result.value.points[3]).toEqual({ x: { value: 0, unit: "px" }, y: { value: 100, unit: "px" } });
		});

		it("should parse 5-point pentagon", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(5);
		});

		it("should parse polygon with mixed units", () => {
			const result = Polygon.parse("polygon(10px 20%, 50% 30px, 100px 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toEqual([
				{ x: { value: 10, unit: "px" }, y: { value: 20, unit: "%" } },
				{ x: { value: 50, unit: "%" }, y: { value: 30, unit: "px" } },
				{ x: { value: 100, unit: "px" }, y: { value: 100, unit: "%" } },
			]);
		});

		it("should parse polygon with unitless zero", () => {
			const result = Polygon.parse("polygon(0 0, 100px 0, 100px 100px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points[0]).toEqual({ x: { value: 0, unit: "px" }, y: { value: 0, unit: "px" } });
		});
	});

	describe("fill-rule parsing", () => {
		it("should parse nonzero fill-rule", () => {
			const result = Polygon.parse("polygon(nonzero, 50% 0%, 100% 50%, 50% 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.fillRule).toBe("nonzero");
			expect(result.value.points).toHaveLength(3);
		});

		it("should parse evenodd fill-rule", () => {
			const result = Polygon.parse("polygon(evenodd, 0px 0px, 100px 0px, 100px 100px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.fillRule).toBe("evenodd");
			expect(result.value.points).toHaveLength(3);
		});

		it("should parse polygon without fill-rule", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 50%, 50% 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.fillRule).toBeUndefined();
		});
	});

	describe("complex shapes", () => {
		it("should parse 6-point star", () => {
			const result = Polygon.parse(
				"polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)",
			);
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(10);
		});

		it("should parse 6-sided hexagon", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(6);
		});
	});

	describe("edge cases", () => {
		it("should handle minimum 3 points", () => {
			const result = Polygon.parse("polygon(0px 0px, 50px 50px, 100px 0px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(3);
		});

		it("should handle many points", () => {
			const points = Array.from({ length: 20 }, (_, i) => `${i * 5}% ${(i * 3) % 100}%`).join(", ");
			const result = Polygon.parse(`polygon(${points})`);
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(20);
		});
	});

	describe("error handling", () => {
		it("should reject too few points", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 50%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("at least 3 points");
		});

		it("should reject odd number of coordinates", () => {
			const result = Polygon.parse("polygon(50% 0%, 100%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("coordinate");
		});

		it("should reject invalid fill-rule", () => {
			const result = Polygon.parse("polygon(invalid, 50% 0%, 100% 50%, 50% 100%)");
			expect(result.ok).toBe(false);
		});

		it("should reject wrong function name", () => {
			const result = Polygon.parse("circle(50%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("polygon");
		});

		it("should reject missing comma after fill-rule", () => {
			const result = Polygon.parse("polygon(nonzero 50% 0%, 100% 50%, 50% 100%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("comma");
		});
	});

	describe("whitespace handling", () => {
		it("should handle extra spaces", () => {
			const result = Polygon.parse("polygon(  50%   0%  ,  100%   50%  ,  50%   100%  )");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(3);
		});

		it("should handle no spaces", () => {
			const result = Polygon.parse("polygon(50% 0%,100% 50%,50% 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(3);
		});
	});
});


=== File: src/parse/clip-path/polygon.ts ===
// b_path:: src/parse/clip-path/polygon.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunctionRaw } from "./utils";

/**
 * Parse polygon() basic shape function.
 *
 * Syntax: polygon( <fill-rule>? , <shape-arg># )
 *
 * where:
 *   <fill-rule> = nonzero | evenodd
 *   <shape-arg> = <length-percentage> <length-percentage>
 *
 * @example
 * parse("polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)");
 * // { kind: "clip-path-polygon", points: [{x: 50%, y: 0%}, {x: 100%, y: 50%}, ...] }
 *
 * parse("polygon(nonzero, 0px 0px, 100px 0px, 100px 100px)");
 * // { kind: "clip-path-polygon", fillRule: "nonzero", points: [...] }
 *
 * @public
 */
export function parse(css: string): Result<Type.ClipPathPolygon, string> {
	return parseShapeFunctionRaw(css, "polygon", parsePolygonChildren);
}

function parsePolygonChildren(children: CssNode[]): Result<Type.ClipPathPolygon, string> {
	let idx = 0;

	let fillRule: Type.ClipPathPolygon["fillRule"];
	const points: Type.ClipPathPolygon["points"] = [];

	// Check for optional fill-rule keyword
	if (idx < children.length) {
		const firstNode = children[idx];
		if (firstNode?.type === "Identifier") {
			const keyword = firstNode.name.toLowerCase();
			if (keyword === "nonzero" || keyword === "evenodd") {
				fillRule = keyword;
				idx++;

				// After fill-rule, require a comma
				if (!AstUtils.isCommaAt(children, idx)) {
					return err("Expected comma after fill-rule");
				}
				idx = AstUtils.skipComma(children, idx);
			}
		}
	}

	// Split remaining nodes into point pairs (x y, x y, ...)
	const pointGroups = AstUtils.splitNodesByComma(children, {
		startIndex: idx,
	});

	// Parse each point pair
	for (const group of pointGroups) {
		if (group.length !== 2) {
			return err("Each point must have exactly 2 coordinates (x y), separated by spaces");
		}

		const xNode = group[0];
		const yNode = group[1];
		if (!xNode || !yNode) {
			return err("Invalid point coordinates");
		}

		const xResult = ParseUtils.parseLengthPercentageNode(xNode);
		if (!xResult.ok) return xResult;

		const yResult = ParseUtils.parseLengthPercentageNode(yNode);
		if (!yResult.ok) return yResult;

		points.push({ x: xResult.value, y: yResult.value });
	}

	// Validate minimum 3 points
	if (points.length < 3) {
		return err("polygon() requires at least 3 points");
	}

	const polygon: Type.ClipPathPolygon = {
		kind: "clip-path-polygon",
		...(fillRule !== undefined && { fillRule }),
		points,
	};

	const validated = Type.clipPathPolygonSchema.safeParse(polygon);
	if (!validated.success) {
		return err(`Invalid polygon: ${validated.error.message}`);
	}

	return ok(validated.data);
}


=== File: src/parse/clip-path/rect.test.ts ===
// b_path:: src/parse/clip-path/rect.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./rect";

describe("parse rect()", () => {
	describe("basic TRBL", () => {
		it("should parse single value (all sides)", () => {
			const result = parse("rect(10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("clip-path-rect");
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius).toBeUndefined();
			}
		});

		it("should parse two values (vertical | horizontal)", () => {
			const result = parse("rect(10px 20px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse three values", () => {
			const result = parse("rect(10px 20px 30px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse four values (TRBL)", () => {
			const result = parse("rect(10px 20px 30px 40px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 40, unit: "px" });
			}
		});
	});

	describe("auto keyword", () => {
		it("should parse auto for all sides", () => {
			const result = parse("rect(auto)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toBe("auto");
				expect(result.value.right).toBe("auto");
				expect(result.value.bottom).toBe("auto");
				expect(result.value.left).toBe("auto");
			}
		});

		it("should parse mixed auto and length values", () => {
			const result = parse("rect(10px auto 20px auto)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toBe("auto");
				expect(result.value.bottom).toEqual({ value: 20, unit: "px" });
				expect(result.value.left).toBe("auto");
			}
		});

		it("should parse auto with percentage", () => {
			const result = parse("rect(auto 50% auto 25%)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toBe("auto");
				expect(result.value.right).toEqual({ value: 50, unit: "%" });
				expect(result.value.bottom).toBe("auto");
				expect(result.value.left).toEqual({ value: 25, unit: "%" });
			}
		});
	});

	describe("border-radius", () => {
		it("should parse with single border-radius", () => {
			const result = parse("rect(10px round 5px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse with multiple border-radius values", () => {
			const result = parse("rect(10px 20px round 5px 10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse with auto and border-radius", () => {
			const result = parse("rect(auto 10px round 8px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toBe("auto");
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius).toBeDefined();
			}
		});
	});

	describe("edge cases", () => {
		it("should parse zero values", () => {
			const result = parse("rect(0 0 0 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should parse percentages", () => {
			const result = parse("rect(10% 20% 30% 40%)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "%" });
				expect(result.value.right).toEqual({ value: 20, unit: "%" });
			}
		});

		it("should parse mixed units", () => {
			const result = parse("rect(10px 5em 20% 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 5, unit: "em" });
				expect(result.value.bottom).toEqual({ value: 20, unit: "%" });
				expect(result.value.left).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("errors", () => {
		it("should error on empty function", () => {
			const result = parse("rect()");
			expect(result.ok).toBe(false);
		});

		it("should error on too many values", () => {
			const result = parse("rect(1px 2px 3px 4px 5px)");
			expect(result.ok).toBe(false);
		});

		it("should error on invalid value", () => {
			const result = parse("rect(invalid)");
			expect(result.ok).toBe(false);
		});

		it("should error on round without radius", () => {
			const result = parse("rect(10px round)");
			expect(result.ok).toBe(false);
		});

		it("should error on non-rect function", () => {
			const result = parse("circle(50px)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/clip-path/rect.ts ===
// b_path:: src/parse/clip-path/rect.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunction } from "./utils";

/**
 * Parse CSS rect() function for clip-path.
 *
 * Accepts 1-4 length-percentage or 'auto' values for edge offsets (TRBL),
 * optionally followed by 'round' keyword and border-radius values.
 *
 * Syntax: rect( [<length-percentage> | auto]{1,4} [ round <border-radius> ]? )
 *
 * @param css - CSS rect() function (e.g., "rect(10px auto 20px auto round 5px)")
 * @returns Result with ClipPathRect IR or error message
 *
 * @example
 * Simple rect:
 * ```typescript
 * const result = parse("rect(10px 20px 30px 40px)");
 * // { kind: "clip-path-rect", top: 10px, right: 20px, bottom: 30px, left: 40px }
 * ```
 *
 * @example
 * With auto:
 * ```typescript
 * const result = parse("rect(10px auto 20px auto)");
 * // { kind: "clip-path-rect", top: 10px, right: "auto", bottom: 20px, left: "auto" }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/rect | MDN: rect()}
 */
export function parse(css: string): Result<Type.ClipPathRect, string> {
	return parseShapeFunction(css, "rect", parseRectArgs);
}

function parseRectArgs(args: CssNode[]): Result<Type.ClipPathRect, string> {
	if (args.length === 0) {
		return err("rect() requires at least one value");
	}

	// Parse optional border-radius (using utility)
	const roundResult = ParseUtils.parseRoundBorderRadius(args);
	if (!roundResult.ok) return roundResult;
	const { roundIndex, borderRadius } = roundResult.value;

	// Parse TRBL values (before 'round' or all args if no 'round')
	const trblNodes = roundIndex !== -1 ? args.slice(0, roundIndex) : args;

	if (trblNodes.length === 0) {
		return err("rect() requires at least one edge value");
	}

	// Parse each edge value (can be length-percentage or 'auto')
	const edgeValues: (Type.LengthPercentage | "auto")[] = [];

	for (const node of trblNodes) {
		// Check for 'auto' keyword
		if (node.type === "Identifier" && node.name.toLowerCase() === "auto") {
			edgeValues.push("auto");
			continue;
		}

		// Parse as length-percentage
		const lpResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lpResult.ok) {
			return err(`Invalid edge value: ${lpResult.error}`);
		}

		edgeValues.push(lpResult.value);
	}

	// Expand TRBL values (1-4 values → 4 values)
	if (edgeValues.length < 1 || edgeValues.length > 4) {
		return err("rect() accepts 1-4 edge values");
	}

	const [val0, val1, val2, val3] = edgeValues;
	let top: Type.LengthPercentage | "auto";
	let right: Type.LengthPercentage | "auto";
	let bottom: Type.LengthPercentage | "auto";
	let left: Type.LengthPercentage | "auto";

	if (edgeValues.length === 1 && val0) {
		top = right = bottom = left = val0;
	} else if (edgeValues.length === 2 && val0 && val1) {
		top = bottom = val0;
		right = left = val1;
	} else if (edgeValues.length === 3 && val0 && val1 && val2) {
		top = val0;
		right = left = val1;
		bottom = val2;
	} else if (edgeValues.length === 4 && val0 && val1 && val2 && val3) {
		top = val0;
		right = val1;
		bottom = val2;
		left = val3;
	} else {
		return err("rect() requires valid edge values");
	}

	return ok({
		kind: "clip-path-rect",
		top,
		right,
		bottom,
		left,
		borderRadius,
	});
}


=== File: src/parse/clip-path/url.test.ts ===
// b_path:: src/parse/clip-path/url.test.ts

import { describe, expect, it } from "vitest";
import * as Generate from "@/generate/clip-path/url";
import { parse } from "./url";

describe("parse clip-path url()", () => {
	it("parses url with fragment ID", () => {
		const result = parse("url(#clip-shape)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "url",
				value: "#clip-shape",
			});
		}
	});

	it("parses url with single quotes", () => {
		const result = parse("url('#clip-shape')");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("#clip-shape");
		}
	});

	it("parses url with double quotes", () => {
		const result = parse('url("#clip-shape")');
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("#clip-shape");
		}
	});

	it("parses url with file path", () => {
		const result = parse("url(shapes.svg#clip-id)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("shapes.svg#clip-id");
		}
	});

	it("parses url with quoted file path", () => {
		const result = parse("url('shapes.svg#clip-id')");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("shapes.svg#clip-id");
		}
	});

	it("parses url with relative path", () => {
		const result = parse("url('../assets/shapes.svg#clip')");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("../assets/shapes.svg#clip");
		}
	});

	it("handles whitespace", () => {
		const result = parse("  url(#clip)  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("#clip");
		}
	});

	it("rejects invalid syntax", () => {
		const result = parse("notaurl");
		expect(result.ok).toBe(false);
	});

	it("rejects empty url", () => {
		const result = parse("url()");
		expect(result.ok).toBe(false);
	});
});

describe("round-trip url", () => {
	const cases = [
		"url(#clip-shape)",
		"url('#clip-shape')",
		"url(shapes.svg#clip-id)",
		"url('../assets/shapes.svg#clip')",
	];

	for (const css of cases) {
		it(`round-trips: ${css}`, () => {
			const parsed = parse(css);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				const reparsed = parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	}
});


=== File: src/parse/clip-path/url.ts ===
// b_path:: src/parse/clip-path/url.ts

import type { Result } from "@/core/result";
import type { Url } from "@/core/types/url";
import { parseUrl } from "@/utils/parse/url";

/**
 * Parse CSS url() for clip-path property.
 *
 * Parses URL references to SVG clipping paths.
 * Accepts fragment identifiers (#id) or file paths.
 * Supports quoted and unquoted URLs.
 *
 * @param input - CSS string like "url(#clip)" or "url('shapes.svg#clip')"
 * @returns Result with Url IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.ClipPath.Url.parse("url(#clip-shape)");
 * // { ok: true, value: { kind: "url", value: "#clip-shape" } }
 *
 * const result2 = Parse.ClipPath.Url.parse("url('shapes.svg#clip')");
 * // { ok: true, value: { kind: "url", value: "shapes.svg#clip" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<Url, string> {
	return parseUrl(input);
}


=== File: src/parse/clip-path/utils.ts ===
// b_path:: src/parse/clip-path/utils.ts
import type { CssNode } from "css-tree";
import { err, type Result } from "@/core/result";
import * as AstUtils from "@/utils/ast";

/**
 * Common wrapper for parsing CSS basic shape functions.
 *
 * Eliminates boilerplate of:
 * - Parsing CSS string to AST
 * - Finding the function node
 * - Extracting function arguments
 * - Error handling and try/catch
 *
 * @param css - CSS string to parse (e.g., "rect(10px 20px 30px 40px)")
 * @param functionName - Name of the shape function (e.g., "rect", "circle")
 * @param parser - Function to parse shape-specific arguments
 * @returns Result with parsed shape IR or error
 *
 * @example
 * Basic usage:
 * ```typescript
 * export function parse(css: string): Result<ClipPathRect, string> {
 *   return parseShapeFunction(css, "rect", parseRectArgs);
 * }
 *
 * function parseRectArgs(args: CssNode[]): Result<ClipPathRect, string> {
 *   // Parse rect-specific arguments
 *   return ok({ kind: "clip-path-rect", ... });
 * }
 * ```
 *
 * @example
 * With error handling:
 * ```typescript
 * function parseRectArgs(args: CssNode[]): Result<ClipPathRect, string> {
 *   if (args.length === 0) {
 *     return err("rect() requires at least one value");
 *   }
 *   // ... parse logic ...
 * }
 * ```
 *
 * @public
 */
export function parseShapeFunction<T>(
	css: string,
	functionName: string,
	parser: (args: CssNode[]) => Result<T, string>,
): Result<T, string> {
	try {
		// Parse CSS string to AST
		const astResult = AstUtils.parseCssString(css);
		if (!astResult.ok) {
			return err(astResult.error);
		}

		// Find the shape function node
		const fnResult = AstUtils.findFunctionNode(astResult.value, functionName);
		if (!fnResult.ok) {
			return err(fnResult.error);
		}

		// Extract function arguments (commas removed)
		const args = AstUtils.parseFunctionArguments(fnResult.value);

		// Delegate to shape-specific parser
		return parser(args);
	} catch (e) {
		return err(`Failed to parse ${functionName}(): ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Similar to parseShapeFunction but returns raw AST children.
 *
 * Use this variant when you need direct access to AST nodes with commas
 * preserved (e.g., polygon needs to split by commas manually).
 *
 * @param css - CSS string to parse
 * @param functionName - Name of the shape function
 * @param parser - Function to parse raw AST children
 * @returns Result with parsed shape IR or error
 *
 * @example
 * For shapes that need comma handling:
 * ```typescript
 * export function parse(css: string): Result<ClipPathPolygon, string> {
 *   return parseShapeFunctionRaw(css, "polygon", parsePolygonChildren);
 * }
 *
 * function parsePolygonChildren(children: CssNode[]): Result<ClipPathPolygon, string> {
 *   // Split by commas manually
 *   const pointGroups = AstUtils.splitNodesByComma(children);
 *   // ... parse points ...
 * }
 * ```
 *
 * @public
 */
export function parseShapeFunctionRaw<T>(
	css: string,
	functionName: string,
	parser: (children: CssNode[]) => Result<T, string>,
): Result<T, string> {
	try {
		// Parse CSS string to AST
		const astResult = AstUtils.parseCssString(css);
		if (!astResult.ok) {
			return err(astResult.error);
		}

		// Find the shape function node
		const fnResult = AstUtils.findFunctionNode(astResult.value, functionName);
		if (!fnResult.ok) {
			return err(fnResult.error);
		}

		// Get raw children (commas included)
		const children = fnResult.value.children ? Array.from(fnResult.value.children) : [];

		// Delegate to shape-specific parser
		return parser(children);
	} catch (e) {
		return err(`Failed to parse ${functionName}(): ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/clip-path/xywh.test.ts ===
// b_path:: src/parse/clip-path/xywh.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./xywh";

describe("parse xywh()", () => {
	describe("basic position and size", () => {
		it("should parse all four values", () => {
			const result = parse("xywh(10px 20px 100px 50px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("clip-path-xywh");
				expect(result.value.x).toEqual({ value: 10, unit: "px" });
				expect(result.value.y).toEqual({ value: 20, unit: "px" });
				expect(result.value.width).toEqual({ value: 100, unit: "px" });
				expect(result.value.height).toEqual({ value: 50, unit: "px" });
				expect(result.value.borderRadius).toBeUndefined();
			}
		});

		it("should parse with percentages", () => {
			const result = parse("xywh(0% 0% 100% 100%)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.x).toEqual({ value: 0, unit: "%" });
				expect(result.value.y).toEqual({ value: 0, unit: "%" });
				expect(result.value.width).toEqual({ value: 100, unit: "%" });
				expect(result.value.height).toEqual({ value: 100, unit: "%" });
			}
		});

		it("should parse with mixed units", () => {
			const result = parse("xywh(10px 5em 50% 80px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.x).toEqual({ value: 10, unit: "px" });
				expect(result.value.y).toEqual({ value: 5, unit: "em" });
				expect(result.value.width).toEqual({ value: 50, unit: "%" });
				expect(result.value.height).toEqual({ value: 80, unit: "px" });
			}
		});

		it("should parse zero values", () => {
			const result = parse("xywh(0 0 0 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.x).toEqual({ value: 0, unit: "px" });
				expect(result.value.width).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("border-radius", () => {
		it("should parse with single border-radius", () => {
			const result = parse("xywh(10px 20px 100px 50px round 5px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse with multiple border-radius values", () => {
			const result = parse("xywh(0 0 100% 100% round 5px 10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse with full border-radius", () => {
			const result = parse("xywh(10% 20% 50px 80px round 5px 10px 15px 20px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 15, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 20, unit: "px" });
			}
		});
	});

	describe("validation", () => {
		it("should reject negative width", () => {
			const result = parse("xywh(10px 20px -100px 50px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Width must be non-negative");
			}
		});

		it("should reject negative height", () => {
			const result = parse("xywh(10px 20px 100px -50px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Height must be non-negative");
			}
		});

		it("should allow negative x position", () => {
			const result = parse("xywh(-10px 20px 100px 50px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.x).toEqual({ value: -10, unit: "px" });
			}
		});

		it("should allow negative y position", () => {
			const result = parse("xywh(10px -20px 100px 50px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.y).toEqual({ value: -20, unit: "px" });
			}
		});
	});

	describe("errors", () => {
		it("should error on empty function", () => {
			const result = parse("xywh()");
			expect(result.ok).toBe(false);
		});

		it("should error on too few values", () => {
			const result = parse("xywh(10px 20px)");
			expect(result.ok).toBe(false);
		});

		it("should error on too many values", () => {
			const result = parse("xywh(10px 20px 100px 50px 30px)");
			expect(result.ok).toBe(false);
		});

		it("should error on invalid value", () => {
			const result = parse("xywh(invalid 20px 100px 50px)");
			expect(result.ok).toBe(false);
		});

		it("should error on round without radius", () => {
			const result = parse("xywh(10px 20px 100px 50px round)");
			expect(result.ok).toBe(false);
		});

		it("should error on non-xywh function", () => {
			const result = parse("rect(10px 20px 30px 40px)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/clip-path/xywh.ts ===
// b_path:: src/parse/clip-path/xywh.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunction } from "./utils";

/**
 * Parse CSS xywh() function for clip-path.
 *
 * Accepts 4 length-percentage values for position (x, y) and dimensions (width, height),
 * optionally followed by 'round' keyword and border-radius values.
 *
 * Syntax: xywh( <length-percentage>{4} [ round <border-radius> ]? )
 *
 * @param css - CSS xywh() function (e.g., "xywh(10px 20px 100px 50px round 5px)")
 * @returns Result with ClipPathXywh IR or error message
 *
 * @example
 * Simple xywh:
 * ```typescript
 * const result = parse("xywh(10px 20px 100px 50px)");
 * // { kind: "clip-path-xywh", x: 10px, y: 20px, width: 100px, height: 50px }
 * ```
 *
 * @example
 * With border-radius:
 * ```typescript
 * const result = parse("xywh(0 0 100% 100% round 10px)");
 * // { kind: "clip-path-xywh", x: 0, y: 0, ..., borderRadius: { ... } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/xywh | MDN: xywh()}
 */
export function parse(css: string): Result<Type.ClipPathXywh, string> {
	return parseShapeFunction(css, "xywh", parseXywhArgs);
}

function parseXywhArgs(args: CssNode[]): Result<Type.ClipPathXywh, string> {
	if (args.length === 0) {
		return err("xywh() requires exactly 4 values");
	}

	// Parse optional border-radius (using utility)
	const roundResult = ParseUtils.parseRoundBorderRadius(args);
	if (!roundResult.ok) return roundResult;
	const { roundIndex, borderRadius } = roundResult.value;

	// Parse position/size values (before 'round' or all args if no 'round')
	const xywhNodes = roundIndex !== -1 ? args.slice(0, roundIndex) : args;

	if (xywhNodes.length !== 4) {
		return err("xywh() requires exactly 4 values (x, y, width, height)");
	}

	// Parse x, y, width, height
	const [xNode, yNode, widthNode, heightNode] = xywhNodes;

	if (!xNode || !yNode || !widthNode || !heightNode) {
		return err("xywh() requires exactly 4 values (x, y, width, height)");
	}

	const xResult = ParseUtils.parseLengthPercentageNode(xNode);
	if (!xResult.ok) {
		return err(`Invalid x value: ${xResult.error}`);
	}

	const yResult = ParseUtils.parseLengthPercentageNode(yNode);
	if (!yResult.ok) {
		return err(`Invalid y value: ${yResult.error}`);
	}

	const widthResult = ParseUtils.parseLengthPercentageNode(widthNode);
	if (!widthResult.ok) {
		return err(`Invalid width value: ${widthResult.error}`);
	}

	const heightResult = ParseUtils.parseLengthPercentageNode(heightNode);
	if (!heightResult.ok) {
		return err(`Invalid height value: ${heightResult.error}`);
	}

	// Validate non-negative width and height
	if (widthResult.value.value < 0) {
		return err("Width must be non-negative");
	}

	if (heightResult.value.value < 0) {
		return err("Height must be non-negative");
	}

	return ok({
		kind: "clip-path-xywh",
		x: xResult.value,
		y: yResult.value,
		width: widthResult.value,
		height: heightResult.value,
		borderRadius,
	});
}


=== File: src/parse/color/color-function.test.ts ===
// b_path:: src/parse/color/color-function.test.ts
import { describe, expect, test } from "vitest";
import * as ColorFunction from "./color-function";

describe("parse() - color() function parser", () => {
	describe("Color Spaces", () => {
		test("srgb color space", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "srgb",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("srgb-linear color space", () => {
			const result = ColorFunction.parse("color(srgb-linear 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "srgb-linear",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("display-p3 color space", () => {
			const result = ColorFunction.parse("color(display-p3 0.928 0.322 0.203)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "display-p3",
					channels: [0.928, 0.322, 0.203],
				});
			}
		});

		test("a98-rgb color space", () => {
			const result = ColorFunction.parse("color(a98-rgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "a98-rgb",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("prophoto-rgb color space", () => {
			const result = ColorFunction.parse("color(prophoto-rgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "prophoto-rgb",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("rec2020 color space", () => {
			const result = ColorFunction.parse("color(rec2020 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "rec2020",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("xyz color space", () => {
			const result = ColorFunction.parse("color(xyz 0.3 0.4 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "xyz",
					channels: [0.3, 0.4, 0.5],
				});
			}
		});

		test("xyz-d50 color space", () => {
			const result = ColorFunction.parse("color(xyz-d50 0.3 0.4 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "xyz-d50",
					channels: [0.3, 0.4, 0.5],
				});
			}
		});

		test("xyz-d65 color space", () => {
			const result = ColorFunction.parse("color(xyz-d65 0.3 0.4 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "xyz-d65",
					channels: [0.3, 0.4, 0.5],
				});
			}
		});
	});

	describe("Channel Formats", () => {
		test("numeric channel values", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.5, 0.2, 0.8]);
			}
		});

		test("percentage channel values", () => {
			const result = ColorFunction.parse("color(srgb 50% 20% 80%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.5, 0.2, 0.8]);
			}
		});

		test("mixed numeric and percentage values", () => {
			const result = ColorFunction.parse("color(srgb 0.5 20% 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.5, 0.2, 0.8]);
			}
		});
	});

	describe("Alpha Channel", () => {
		test("color with numeric alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "srgb",
					channels: [0.5, 0.2, 0.8],
					alpha: 0.5,
				});
			}
		});

		test("color with percentage alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});

		test("color without alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBeUndefined();
			}
		});
	});

	describe("Edge Cases", () => {
		test("zero values", () => {
			const result = ColorFunction.parse("color(srgb 0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0, 0, 0]);
			}
		});

		test("one values", () => {
			const result = ColorFunction.parse("color(srgb 1 1 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([1, 1, 1]);
			}
		});

		test("values with high precision", () => {
			const result = ColorFunction.parse("color(srgb 0.123456 0.789012 0.345678)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.123456, 0.789012, 0.345678]);
			}
		});

		test("negative values (allowed for some spaces)", () => {
			const result = ColorFunction.parse("color(xyz -0.1 0.5 -0.2)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([-0.1, 0.5, -0.2]);
			}
		});

		test("values over 1 (allowed for some spaces)", () => {
			const result = ColorFunction.parse("color(xyz 1.5 2.0 1.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([1.5, 2.0, 1.8]);
			}
		});

		test("case insensitive color space", () => {
			const result = ColorFunction.parse("color(SRGB 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.colorSpace).toBe("srgb");
			}
		});

		test("extra whitespace", () => {
			const result = ColorFunction.parse("color(  srgb   0.5   0.2   0.8  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.5, 0.2, 0.8]);
			}
		});
	});

	describe("Error Cases", () => {
		test("invalid color space", () => {
			const result = ColorFunction.parse("color(invalid 0.5 0.2 0.8)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid color space");
			}
		});

		test("missing color space", () => {
			const result = ColorFunction.parse("color(0.5 0.2 0.8)");
			expect(result.ok).toBe(false);
		});

		test("missing channels", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("requires at least 4 arguments");
			}
		});

		test("too few channels", () => {
			const result = ColorFunction.parse("color(srgb 0.5)");
			expect(result.ok).toBe(false);
		});

		test("invalid alpha value", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 / 1.5)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Alpha must be between 0 and 1");
			}
		});

		test("negative alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 / -0.1)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Alpha must be between 0 and 1");
			}
		});

		test("slash without alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 /)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected alpha value after /");
			}
		});

		test("not a color function", () => {
			const result = ColorFunction.parse("rgb(255 0 0)");
			expect(result.ok).toBe(false);
		});

		test("empty string", () => {
			const result = ColorFunction.parse("");
			expect(result.ok).toBe(false);
		});

		test("invalid syntax", () => {
			const result = ColorFunction.parse("color(srgb 0.5, 0.2, 0.8)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/color/color-function.ts ===
// b_path:: src/parse/color/color-function.ts
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";

/**
 * Parse color() function with explicit color space.
 *
 * Syntax: color(colorspace c1 c2 c3 [ / alpha ]?)
 *
 * @param input - CSS color() function string
 * @returns Result with ColorFunction IR or error
 *
 * @example
 * ```typescript
 * parse("color(display-p3 0.928 0.322 0.203)");
 * parse("color(srgb 0.5 0.2 0.8 / 0.8)");
 * parse("color(xyz-d50 0.3 0.4 0.5)");
 * ```
 *
 * @public
 */
export function parse(input: string): Result<Type.ColorFunction, string> {
	try {
		const astResult = AstUtils.parseCssString(input);
		if (!astResult.ok) return err(astResult.error);

		const fnResult = AstUtils.findFunctionNode(astResult.value, "color");
		if (!fnResult.ok) return err(fnResult.error);

		const children = fnResult.value.children.toArray();

		if (children.length < 4) {
			return err("color() requires at least 4 arguments: colorspace + 3 channels");
		}

		// 1. Parse color space
		const colorSpaceNode = children[0];
		if (!colorSpaceNode || colorSpaceNode.type !== "Identifier") {
			return err("Expected color space identifier");
		}

		const colorSpace = colorSpaceNode.name.toLowerCase();
		const validSpaces = [
			"srgb",
			"srgb-linear",
			"display-p3",
			"a98-rgb",
			"prophoto-rgb",
			"rec2020",
			"xyz",
			"xyz-d50",
			"xyz-d65",
		];

		if (!validSpaces.includes(colorSpace)) {
			return err(`Invalid color space: ${colorSpace}`);
		}

		// 2. Parse 3 channel values
		const channels: [number, number, number] = [0, 0, 0];

		for (let i = 0; i < 3; i++) {
			const channelNode = children[i + 1];
			if (!channelNode) {
				return err(`Missing channel ${i + 1}`);
			}

			if (channelNode.type === "Number") {
				const value = Number.parseFloat(channelNode.value);
				if (Number.isNaN(value)) {
					return err(`Invalid channel ${i + 1} value`);
				}
				channels[i] = value;
			} else if (channelNode.type === "Percentage") {
				const value = Number.parseFloat(channelNode.value) / 100;
				if (Number.isNaN(value)) {
					return err(`Invalid channel ${i + 1} percentage`);
				}
				channels[i] = value;
			} else {
				return err(`Expected number or percentage for channel ${i + 1}`);
			}
		}

		// 3. Parse optional alpha after /
		let alpha: number | undefined;
		let idx = 4;

		if (idx < children.length) {
			const slashNode = children[idx];
			if (slashNode?.type === "Operator" && slashNode.value === "/") {
				idx++;
				const alphaNode = children[idx];
				if (!alphaNode) {
					return err("Expected alpha value after /");
				}

				if (alphaNode.type === "Number") {
					alpha = Number.parseFloat(alphaNode.value);
				} else if (alphaNode.type === "Percentage") {
					alpha = Number.parseFloat(alphaNode.value) / 100;
				} else {
					return err("Expected number or percentage for alpha");
				}

				if (Number.isNaN(alpha) || alpha < 0 || alpha > 1) {
					return err("Alpha must be between 0 and 1");
				}
			}
		}

		return ok({
			kind: "color",
			colorSpace: colorSpace as Type.ColorFunction["colorSpace"],
			channels,
			...(alpha !== undefined && { alpha }),
		});
	} catch (e) {
		return err(`Failed to parse color(): ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/color/color.test.ts ===
// b_path:: src/parse/color/color.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./color";

describe("parse() - unified color dispatcher", () => {
	describe("hex colors", () => {
		it("detects 3-digit hex", () => {
			const result = parse("#abc");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hex");
			}
		});

		it("detects 6-digit hex", () => {
			const result = parse("#ff5733");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hex");
			}
		});

		it("detects 8-digit hex with alpha", () => {
			const result = parse("#ff573380");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hex");
			}
		});
	});

	describe("rgb/rgba functions", () => {
		it("detects rgb()", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("rgb");
			}
		});

		it("detects rgba()", () => {
			const result = parse("rgba(255, 0, 0, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("rgb");
			}
		});

		it("detects modern rgb with alpha", () => {
			const result = parse("rgb(255 0 0 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("rgb");
			}
		});
	});

	describe("hsl/hsla functions", () => {
		it("detects hsl()", () => {
			const result = parse("hsl(0, 100%, 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hsl");
			}
		});

		it("detects hsla()", () => {
			const result = parse("hsla(120, 100%, 50%, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hsl");
			}
		});

		it("detects modern hsl with alpha", () => {
			const result = parse("hsl(240 100% 50% / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hsl");
			}
		});
	});

	describe("hwb function", () => {
		it("detects hwb()", () => {
			const result = parse("hwb(0 0% 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hwb");
			}
		});

		it("detects hwb with alpha", () => {
			const result = parse("hwb(120 30% 40% / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hwb");
			}
		});
	});

	describe("lab function", () => {
		it("detects lab()", () => {
			const result = parse("lab(50% 40 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("lab");
			}
		});

		it("detects lab with alpha", () => {
			const result = parse("lab(50% 40 30 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("lab");
			}
		});
	});

	describe("lch function", () => {
		it("detects lch()", () => {
			const result = parse("lch(50% 40 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("lch");
			}
		});

		it("detects lch with alpha", () => {
			const result = parse("lch(50% 40 30 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("lch");
			}
		});
	});

	describe("oklab function", () => {
		it("detects oklab()", () => {
			const result = parse("oklab(0.5 0.4 0.3)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklab");
			}
		});

		it("detects oklab with alpha", () => {
			const result = parse("oklab(0.5 0.4 0.3 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklab");
			}
		});
	});

	describe("oklch function", () => {
		it("detects oklch()", () => {
			const result = parse("oklch(0.5 0.4 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklch");
			}
		});

		it("detects oklch with alpha", () => {
			const result = parse("oklch(0.5 0.4 30 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklch");
			}
		});
	});

	describe("color function", () => {
		it("detects color() with srgb", () => {
			const result = parse("color(srgb 1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("color");
			}
		});

		it("detects color() with display-p3", () => {
			const result = parse("color(display-p3 1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("color");
			}
		});
	});

	describe("named colors", () => {
		it("detects basic named color", () => {
			const result = parse("red");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("named");
				if (result.value?.kind === "named") {
					expect(result.value?.name).toBe("red");
				}
			}
		});

		it("detects extended named color", () => {
			const result = parse("cornflowerblue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("named");
				if (result.value?.kind === "named") {
					expect(result.value?.name).toBe("cornflowerblue");
				}
			}
		});

		it("handles case insensitivity", () => {
			const result = parse("BLUE");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("named");
			}
		});
	});

	describe("special colors", () => {
		it("detects transparent", () => {
			const result = parse("transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("special");
				if (result.value?.kind === "special") {
					expect(result.value?.keyword).toBe("transparent");
				}
			}
		});

		it("detects currentcolor", () => {
			const result = parse("currentcolor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("special");
				if (result.value?.kind === "special") {
					expect(result.value?.keyword).toBe("currentcolor");
				}
			}
		});

		it("handles case insensitivity for special", () => {
			const result = parse("CurrentColor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("special");
			}
		});
	});

	describe("system colors", () => {
		it("detects Canvas", () => {
			const result = parse("Canvas");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("system");
			}
		});

		it("detects ButtonText", () => {
			const result = parse("ButtonText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("system");
			}
		});
	});

	describe("error cases", () => {
		it("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Empty");
			}
		});

		it("rejects unknown function", () => {
			const result = parse("unknown(10, 20, 30)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown color function");
			}
		});

		it("rejects invalid identifier", () => {
			const result = parse("notacolor");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("color name");
			}
		});

		it("rejects invalid hex", () => {
			const result = parse("#gggggg");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Invalid hex");
			}
		});
	});

	describe("case insensitivity", () => {
		it("handles RGB()", () => {
			const result = parse("RGB(255, 0, 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("rgb");
			}
		});

		it("handles HSL()", () => {
			const result = parse("HSL(0, 100%, 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hsl");
			}
		});

		it("handles OKLCH()", () => {
			const result = parse("OKLCH(0.5 0.4 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklch");
			}
		});
	});
});


=== File: src/parse/color/color.ts ===
// b_path:: src/parse/color/color.ts

import type { CssNode } from "css-tree";
import * as cssTree from "css-tree";
import { err, type ParseResult, parseErr, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as ColorFunction from "./color-function";
import * as Hex from "./hex";
import * as Hsl from "./hsl";
import * as Hwb from "./hwb";
import * as Lab from "./lab";
import * as Lch from "./lch";
import * as Named from "./named";
import * as Oklab from "./oklab";
import * as Oklch from "./oklch";
import * as Rgb from "./rgb";
import * as Special from "./special";
import * as System from "./system";

/**
 * Parse color value with auto-detection.
 *
 * Automatically detects and parses any CSS color format:
 * - Hex: #rgb, #rrggbb, #rrggbbaa
 * - RGB: rgb(), rgba()
 * - HSL: hsl(), hsla()
 * - HWB: hwb()
 * - LAB: lab()
 * - LCH: lch()
 * - OKLab: oklab()
 * - OKLCH: oklch()
 * - Color function: color()
 * - Named colors: red, blue, cornflowerblue, etc.
 * - Special: transparent, currentcolor
 * - System colors: Canvas, ButtonText, etc.
 *
 * @param value - CSS color value string
 * @returns Result with Color IR or error
 *
 * @example
 * ```typescript
 * parse("#ff0000");              // Auto-detects hex
 * parse("rgb(255, 0, 0)");       // Auto-detects rgb
 * parse("hsl(0, 100%, 50%)");    // Auto-detects hsl
 * parse("red");                  // Auto-detects named
 * parse("transparent");          // Auto-detects special
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Type.Color> {
	const ast = cssTree.parse(value, { context: "value" }) as cssTree.Value;
	if (!ast.children) return parseErr("invalid-syntax", "Empty value");
	const first = ast.children.first;
	if (!first) return parseErr("invalid-syntax", "Empty value");
	const result = parseNode(first);
	return toParseResult(result);
}

/**
 * Parse color AST node with auto-detection.
 *
 * @param node - CSS AST node
 * @returns Result with Color IR or error
 *
 * @internal
 */
function parseNode(node: CssNode): Result<Type.Color, string> {
	// 1. Hex color (Hash node)
	if (node.type === "Hash") {
		const css = `#${node.value}`;
		return Hex.parse(css);
	}

	// 2. Color functions
	if (node.type === "Function") {
		const css = cssTree.generate(node);
		switch (node.name.toLowerCase()) {
			case "rgb":
			case "rgba":
				return Rgb.parse(css);
			case "hsl":
			case "hsla":
				return Hsl.parse(css);
			case "hwb":
				return Hwb.parse(css);
			case "lab":
				return Lab.parse(css);
			case "lch":
				return Lch.parse(css);
			case "oklab":
				return Oklab.parse(css);
			case "oklch":
				return Oklch.parse(css);
			case "color":
				return ColorFunction.parse(css);
			default:
				return err(`Unknown color function: ${node.name}`);
		}
	}

	// 3. Identifier (named, special, or system colors)
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();

		// Special keywords (transparent, currentcolor)
		if (keyword === "transparent" || keyword === "currentcolor") {
			return Special.parse(node.name);
		}

		// Try system colors first (smaller set, more specific)
		const systemResult = System.parse(node.name);
		if (systemResult.ok) return systemResult;

		// Fallback to named colors (larger set)
		return Named.parse(node.name);
	}

	return err(`Invalid color node type: ${node.type}`);
}


=== File: src/parse/color/hex.test.ts ===
// b_path:: src/parse/color/hex.test.ts
import { describe, expect, it } from "vitest";
import * as Gen from "@/generate/color/hex";
import * as Hex from "./hex";

describe("hex color parser", () => {
	describe("3-digit hex (#RGB)", () => {
		it("parses #abc", () => {
			const result = Hex.parse("#abc");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("hex");
				expect(result.value.value).toBe("#AABBCC");
			}
		});

		it("parses #000", () => {
			const result = Hex.parse("#000");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#000000");
			}
		});

		it("parses #fff", () => {
			const result = Hex.parse("#fff");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#FFFFFF");
			}
		});

		it("parses #123", () => {
			const result = Hex.parse("#123");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#112233");
			}
		});
	});

	describe("4-digit hex (#RGBA)", () => {
		it("parses #abcd", () => {
			const result = Hex.parse("#abcd");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("hex");
				expect(result.value.value).toBe("#AABBCCDD");
			}
		});

		it("parses #0008", () => {
			const result = Hex.parse("#0008");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#00000088");
			}
		});

		it("parses #fff0", () => {
			const result = Hex.parse("#fff0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#FFFFFF00");
			}
		});
	});

	describe("6-digit hex (#RRGGBB)", () => {
		it("parses #ff5733", () => {
			const result = Hex.parse("#ff5733");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("hex");
				expect(result.value.value).toBe("#FF5733");
			}
		});

		it("parses #000000", () => {
			const result = Hex.parse("#000000");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#000000");
			}
		});

		it("parses #FFFFFF", () => {
			const result = Hex.parse("#FFFFFF");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#FFFFFF");
			}
		});

		it("preserves case by uppercasing", () => {
			const result = Hex.parse("#aAbBcC");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#AABBCC");
			}
		});
	});

	describe("8-digit hex (#RRGGBBAA)", () => {
		it("parses #ff573380", () => {
			const result = Hex.parse("#ff573380");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("hex");
				expect(result.value.value).toBe("#FF573380");
			}
		});

		it("parses #00000000", () => {
			const result = Hex.parse("#00000000");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#00000000");
			}
		});

		it("parses #FFFFFFFF", () => {
			const result = Hex.parse("#FFFFFFFF");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#FFFFFFFF");
			}
		});

		it("parses #ff5733ff (opaque)", () => {
			const result = Hex.parse("#ff5733ff");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("#FF5733FF");
			}
		});
	});

	describe("error handling", () => {
		it("rejects missing #", () => {
			const result = Hex.parse("ff5733");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Hex color must start with #");
			}
		});

		it("rejects invalid length (1 char)", () => {
			const result = Hex.parse("#f");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Hex color must be #RGB, #RRGGBB, #RGBA, or #RRGGBBAA");
			}
		});

		it("rejects invalid length (2 chars)", () => {
			const result = Hex.parse("#ff");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Hex color must be #RGB, #RRGGBB, #RGBA, or #RRGGBBAA");
			}
		});

		it("rejects invalid length (5 chars)", () => {
			const result = Hex.parse("#ff573");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Hex color must be #RGB, #RRGGBB, #RGBA, or #RRGGBBAA");
			}
		});

		it("rejects invalid length (7 chars)", () => {
			const result = Hex.parse("#ff57338");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Hex color must be #RGB, #RRGGBB, #RGBA, or #RRGGBBAA");
			}
		});

		it("rejects invalid characters in 3-digit", () => {
			const result = Hex.parse("#ggf");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Invalid hex color format");
			}
		});

		it("rejects invalid characters in 4-digit", () => {
			const result = Hex.parse("#ggff");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Invalid hex color format");
			}
		});

		it("rejects invalid characters in 6-digit", () => {
			const result = Hex.parse("#gg5733");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Invalid hex color format");
			}
		});

		it("rejects invalid characters in 8-digit", () => {
			const result = Hex.parse("#gg573380");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Invalid hex color format");
			}
		});

		it("rejects special characters", () => {
			const result = Hex.parse("#ff@733");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Invalid hex color format");
			}
		});
	});

	describe("round-trip accuracy", () => {
		it("maintains 3-digit normalized to 6-digit", () => {
			const result = Hex.parse("#abc");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("#AABBCC");
			}
		});

		it("maintains 4-digit normalized to 8-digit", () => {
			const result = Hex.parse("#abcd");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("#AABBCCDD");
			}
		});

		it("maintains 6-digit uppercase", () => {
			const original = "#FF5733";
			const result = Hex.parse(original);
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe(original);
			}
		});

		it("maintains 8-digit uppercase", () => {
			const original = "#FF573380";
			const result = Hex.parse(original);
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe(original);
			}
		});

		it("normalizes lowercase to uppercase", () => {
			const result = Hex.parse("#ff5733");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("#FF5733");
			}
		});
	});
});


=== File: src/parse/color/hex.ts ===
// b_path:: src/parse/color/hex.ts
import { err, ok, type Result } from "@/core/result";
import type { HexColor } from "@/core/types/color";

/**
 * Parse a CSS hex color value.
 *
 * Accepts #RGB, #RRGGBB, #RGBA, or #RRGGBBAA formats.
 * Normalizes short forms to long forms and converts to uppercase.
 *
 * @param input - The hex color string to parse (e.g., "#abc", "#ff5733", "#ff573380")
 * @returns Result containing the parsed HexColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/hex";
 *
 * // Short form
 * const color1 = parse("#abc");
 * // => { ok: true, value: { kind: "hex", value: "#AABBCC" } }
 *
 * // Long form
 * const color2 = parse("#ff5733");
 * // => { ok: true, value: { kind: "hex", value: "#FF5733" } }
 *
 * // With alpha
 * const color3 = parse("#ff573380");
 * // => { ok: true, value: { kind: "hex", value: "#FF573380" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<HexColor, string> {
	if (!input.startsWith("#")) {
		return err("Hex color must start with #");
	}

	const hex = input.slice(1);

	// #RGB → #RRGGBB
	if (hex.length === 3) {
		if (!/^[0-9A-Fa-f]{3}$/.test(hex)) {
			return err("Invalid hex color format");
		}
		const normalized = hex
			.split("")
			.map((c) => c + c)
			.join("");
		return ok({ kind: "hex", value: `#${normalized.toUpperCase()}` });
	}

	// #RGBA → #RRGGBBAA
	if (hex.length === 4) {
		if (!/^[0-9A-Fa-f]{4}$/.test(hex)) {
			return err("Invalid hex color format");
		}
		const normalized = hex
			.split("")
			.map((c) => c + c)
			.join("");
		return ok({ kind: "hex", value: `#${normalized.toUpperCase()}` });
	}

	// #RRGGBB or #RRGGBBAA
	if (hex.length === 6 || hex.length === 8) {
		if (!/^[0-9A-Fa-f]+$/.test(hex)) {
			return err("Invalid hex color format");
		}
		return ok({ kind: "hex", value: `#${hex.toUpperCase()}` });
	}

	return err("Hex color must be #RGB, #RRGGBB, #RGBA, or #RRGGBBAA");
}


=== File: src/parse/color/hsl.test.ts ===
// b_path:: src/parse/color/hsl.test.ts
import { describe, expect, it } from "vitest";
import * as Gen from "@/generate/color/hsl";
import * as HSL from "./hsl";

describe("hsl color parser", () => {
	describe("modern space-separated syntax", () => {
		it("parses hsl(120 100% 50%)", () => {
			const result = HSL.parse("hsl(120 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("hsl");
				expect(result.value.h).toBe(120);
				expect(result.value.s).toBe(100);
				expect(result.value.l).toBe(50);
				expect(result.value.alpha).toBeUndefined();
			}
		});

		it("parses hsl(0 0% 0%) - black", () => {
			const result = HSL.parse("hsl(0 0% 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
				expect(result.value.s).toBe(0);
				expect(result.value.l).toBe(0);
			}
		});

		it("parses hsl(0 0% 100%) - white", () => {
			const result = HSL.parse("hsl(0 0% 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
				expect(result.value.s).toBe(0);
				expect(result.value.l).toBe(100);
			}
		});

		it("parses hsl(240 100% 50%) - blue", () => {
			const result = HSL.parse("hsl(240 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(240);
				expect(result.value.s).toBe(100);
				expect(result.value.l).toBe(50);
			}
		});
	});

	describe("angle units", () => {
		it("parses hsl(120deg 100% 50%)", () => {
			const result = HSL.parse("hsl(120deg 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(120);
			}
		});

		it("parses hsl(1turn 100% 50%)", () => {
			const result = HSL.parse("hsl(1turn 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0); // 360 degrees wraps to 0
			}
		});

		it("parses hsl(0.5turn 100% 50%)", () => {
			const result = HSL.parse("hsl(0.5turn 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("parses hsl(200grad 100% 50%)", () => {
			const result = HSL.parse("hsl(200grad 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180); // 200grad = 180deg
			}
		});

		it("parses hsl(3.14159rad 100% 50%)", () => {
			const result = HSL.parse("hsl(3.14159rad 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBeCloseTo(180, 0); // π rad ≈ 180deg
			}
		});

		it("parses hsl(1.57rad 100% 50%)", () => {
			const result = HSL.parse("hsl(1.57rad 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBeCloseTo(90, 0); // π/2 rad ≈ 90deg
			}
		});
	});

	describe("hue wrapping", () => {
		it("wraps 360deg to 0", () => {
			const result = HSL.parse("hsl(360 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("wraps 720deg to 0", () => {
			const result = HSL.parse("hsl(720 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("wraps 450deg to 90deg", () => {
			const result = HSL.parse("hsl(450 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(90);
			}
		});

		it("wraps negative -90deg to 270deg", () => {
			const result = HSL.parse("hsl(-90 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(270);
			}
		});

		it("wraps negative -360deg to 0", () => {
			const result = HSL.parse("hsl(-360 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("wraps negative -450deg to 270deg", () => {
			const result = HSL.parse("hsl(-450 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(270);
			}
		});
	});

	describe("modern syntax with alpha", () => {
		it("parses hsl(120 100% 50% / 0.5)", () => {
			const result = HSL.parse("hsl(120 100% 50% / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(120);
				expect(result.value.s).toBe(100);
				expect(result.value.l).toBe(50);
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("parses hsl(120 100% 50% / 0)", () => {
			const result = HSL.parse("hsl(120 100% 50% / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("parses hsl(120 100% 50% / 1)", () => {
			const result = HSL.parse("hsl(120 100% 50% / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("parses hsl(120 100% 50% / 50%)", () => {
			const result = HSL.parse("hsl(120 100% 50% / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});
	});

	describe("legacy comma-separated syntax", () => {
		it("parses hsl(120, 100%, 50%)", () => {
			const result = HSL.parse("hsl(120, 100%, 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(120);
				expect(result.value.s).toBe(100);
				expect(result.value.l).toBe(50);
			}
		});

		it("parses hsl(240, 50%, 75%)", () => {
			const result = HSL.parse("hsl(240, 50%, 75%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(240);
				expect(result.value.s).toBe(50);
				expect(result.value.l).toBe(75);
			}
		});

		it("parses hsla(120, 100%, 50%, 0.5)", () => {
			const result = HSL.parse("hsla(120, 100%, 50%, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(120);
				expect(result.value.s).toBe(100);
				expect(result.value.l).toBe(50);
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("parses hsla(240, 50%, 75%, 0.25)", () => {
			const result = HSL.parse("hsla(240, 50%, 75%, 0.25)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(240);
				expect(result.value.s).toBe(50);
				expect(result.value.l).toBe(75);
				expect(result.value.alpha).toBe(0.25);
			}
		});
	});

	describe("percentage clamping", () => {
		it("clamps saturation > 100%", () => {
			const result = HSL.parse("hsl(120 150% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.s).toBe(100); // Clamped
			}
		});

		it("clamps saturation < 0%", () => {
			const result = HSL.parse("hsl(120 -10% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.s).toBe(0); // Clamped
			}
		});

		it("clamps lightness > 100%", () => {
			const result = HSL.parse("hsl(120 100% 150%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100); // Clamped
			}
		});

		it("clamps lightness < 0%", () => {
			const result = HSL.parse("hsl(120 100% -10%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0); // Clamped
			}
		});
	});

	describe("error handling", () => {
		it("rejects missing function", () => {
			const result = HSL.parse("120 100% 50%");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("No function found");
			}
		});

		it("rejects too few arguments", () => {
			const result = HSL.parse("hsl(120 100%)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 3 HSL values");
			}
		});

		it("rejects alpha > 1", () => {
			const result = HSL.parse("hsl(120 100% 50% / 1.5)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Alpha value must be between 0 and 1");
			}
		});

		it("rejects negative alpha", () => {
			const result = HSL.parse("hsl(120 100% 50% / -0.5)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Alpha value must be between 0 and 1");
			}
		});

		it("rejects invalid syntax", () => {
			const result = HSL.parse("hsl(");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip accuracy", () => {
		it("maintains hsl(120 100% 50%)", () => {
			const result = HSL.parse("hsl(120 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(120 100% 50%)");
			}
		});

		it("maintains hsl(240 50% 75%)", () => {
			const result = HSL.parse("hsl(240 50% 75%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(240 50% 75%)");
			}
		});

		it("maintains alpha hsl(120 100% 50% / 0.5)", () => {
			const result = HSL.parse("hsl(120 100% 50% / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(120 100% 50% / 0.5)");
			}
		});

		it("normalizes comma syntax to space syntax", () => {
			const result = HSL.parse("hsl(120, 100%, 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(120 100% 50%)");
			}
		});

		it("normalizes hsla to hsl", () => {
			const result = HSL.parse("hsla(120, 100%, 50%, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(120 100% 50% / 0.5)");
			}
		});

		it("normalizes angle units to degrees", () => {
			const result = HSL.parse("hsl(0.5turn 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(180 100% 50%)");
			}
		});

		it("normalizes wrapped hue", () => {
			const result = HSL.parse("hsl(450 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(90 100% 50%)");
			}
		});

		it("normalizes negative hue", () => {
			const result = HSL.parse("hsl(-90 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(270 100% 50%)");
			}
		});

		it("omits alpha when 1", () => {
			const result = HSL.parse("hsl(120 100% 50% / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("hsl(120 100% 50%)");
			}
		});
	});
});


=== File: src/parse/color/hsl.ts ===
// b_path:: src/parse/color/hsl.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { HSLColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS HSL color value.
 *
 * Supports all HSL syntax variations:
 * - Modern space-separated: `hsl(120 100% 50%)`, `hsl(120deg 100% 50%)`
 * - Modern with alpha: `hsl(120 100% 50% / 0.5)`
 * - Legacy comma-separated: `hsl(120, 100%, 50%)`
 * - Legacy hsla: `hsla(120, 100%, 50%, 0.5)`
 * - Angle units: deg, rad, grad, turn (or unitless defaults to deg)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 *
 * @param input - The HSL color string to parse
 * @returns Result containing the parsed HSLColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/hsl";
 *
 * // Modern syntax
 * const color1 = parse("hsl(120 100% 50%)");
 * // => { ok: true, value: { kind: "hsl", h: 120, s: 100, l: 50 } }
 *
 * // With angle unit
 * const color2 = parse("hsl(1turn 100% 50%)");
 * // => { ok: true, value: { kind: "hsl", h: 360, s: 100, l: 50 } }
 *
 * // With alpha
 * const color3 = parse("hsl(120 100% 50% / 0.5)");
 * // => { ok: true, value: { kind: "hsl", h: 120, s: 100, l: 50, alpha: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<HSLColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find hsl() or hsla() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["hsl", "hsla"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - handle both comma and space syntax
	return parseHSLArguments(children);
}

/**
 * Parse HSL function arguments from AST nodes.
 *
 * @internal
 */
function parseHSLArguments(nodes: csstree.CssNode[]): Result<HSLColor, string> {
	// Check if we have comma separators (legacy syntax)
	const hasComma = nodes.some((node) => node.type === "Operator" && "value" in node && node.value === ",");

	if (hasComma) {
		return parseCommaHSL(nodes);
	}
	return parseSpaceHSL(nodes);
}

/**
 * Parse space-separated HSL syntax: hsl(H S% L%) or hsl(H S% L% / A)
 *
 * @internal
 */
function parseSpaceHSL(nodes: csstree.CssNode[]): Result<HSLColor, string> {
	let h: number | undefined;
	let s: number | undefined;
	let l: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			const alphaResult = ParseUtils.parseAlpha(node);
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			break;
		}

		// Parse H, S, L components
		if (componentIndex === 0) {
			// Hue (angle or unitless number)
			const hueResult = ParseUtils.parseHue(node);
			if (!hueResult.ok) {
				return err(hueResult.error);
			}
			h = hueResult.value;
		} else if (componentIndex === 1 || componentIndex === 2) {
			// Saturation or Lightness (percentage)
			const percentResult = ParseUtils.parsePercentage(node, { clamp: true });
			if (!percentResult.ok) {
				return err(percentResult.error);
			}
			if (componentIndex === 1) {
				s = percentResult.value;
			} else {
				l = percentResult.value;
			}
		}
		componentIndex++;
	}

	if (h === undefined || s === undefined || l === undefined) {
		return err("Expected 3 HSL values (hue, saturation, lightness)");
	}

	const color: HSLColor = { kind: "hsl", h, s, l };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse comma-separated HSL syntax: hsl(H, S%, L%) or hsla(H, S%, L%, A)
 *
 * @internal
 */
function parseCommaHSL(nodes: csstree.CssNode[]): Result<HSLColor, string> {
	// Filter out comma operators
	const valueNodes = nodes.filter((node) => !(node.type === "Operator" && "value" in node && node.value === ","));

	if (valueNodes.length !== 3 && valueNodes.length !== 4) {
		return err(`Expected 3 or 4 values (H, S, L, [A]), got ${valueNodes.length}`);
	}

	// Parse hue
	const hueNode = valueNodes[0];
	if (!hueNode) {
		return err("Missing hue value");
	}
	const hueResult = ParseUtils.parseHue(hueNode);
	if (!hueResult.ok) {
		return err(hueResult.error);
	}
	const h = hueResult.value;

	// Parse saturation
	const satNode = valueNodes[1];
	if (!satNode) {
		return err("Missing saturation value");
	}
	const satResult = ParseUtils.parsePercentage(satNode);
	if (!satResult.ok) {
		return err(satResult.error);
	}
	const s = satResult.value;

	// Parse lightness
	const lightNode = valueNodes[2];
	if (!lightNode) {
		return err("Missing lightness value");
	}
	const lightResult = ParseUtils.parsePercentage(lightNode);
	if (!lightResult.ok) {
		return err(lightResult.error);
	}
	const l = lightResult.value;

	const color: HSLColor = { kind: "hsl", h, s, l };

	// Parse alpha if present (4th value)
	if (valueNodes.length === 4) {
		const alphaNode = valueNodes[3];
		if (!alphaNode) {
			return err("Invalid alpha value");
		}
		const alphaResult = ParseUtils.parseAlpha(alphaNode);
		if (!alphaResult.ok) {
			return err(alphaResult.error);
		}
		color.alpha = alphaResult.value;
	}

	return ok(color);
}


=== File: src/parse/color/hwb.test.ts ===
// b_path:: src/parse/color/hwb.test.ts
import { describe, expect, it } from "vitest";
import * as Generate from "@/generate/color/hwb";
import * as Parse from "@/parse/color/hwb";

describe("Parse.Color.HWB", () => {
	describe("Basic space-separated syntax", () => {
		it("parses hwb(120 20% 30%)", () => {
			const result = Parse.parse("hwb(120 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "hwb",
					h: 120,
					w: 20,
					b: 30,
				});
			}
		});

		it("parses hwb(0 0% 0%) - white", () => {
			const result = Parse.parse("hwb(0 0% 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "hwb",
					h: 0,
					w: 0,
					b: 0,
				});
			}
		});

		it("parses hwb(0 100% 0%) - white", () => {
			const result = Parse.parse("hwb(0 100% 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "hwb",
					h: 0,
					w: 100,
					b: 0,
				});
			}
		});

		it("parses hwb(0 0% 100%) - black", () => {
			const result = Parse.parse("hwb(0 0% 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "hwb",
					h: 0,
					w: 0,
					b: 100,
				});
			}
		});
	});

	describe("Angle units", () => {
		it("parses hwb(120deg 20% 30%)", () => {
			const result = Parse.parse("hwb(120deg 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(120);
			}
		});

		it("parses hwb(1turn 20% 30%) - 360 degrees", () => {
			const result = Parse.parse("hwb(1turn 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0); // 360 wraps to 0
			}
		});

		it("parses hwb(0.5turn 20% 30%) - 180 degrees", () => {
			const result = Parse.parse("hwb(0.5turn 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("parses hwb(100grad 20% 30%) - 90 degrees", () => {
			const result = Parse.parse("hwb(100grad 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(90);
			}
		});

		it("parses hwb(1.5708rad 20% 30%) - ~90 degrees", () => {
			const result = Parse.parse("hwb(1.5708rad 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBeCloseTo(90, 1);
			}
		});

		it("parses unitless hue as degrees", () => {
			const result = Parse.parse("hwb(240 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(240);
			}
		});
	});

	describe("Hue wrapping", () => {
		it("wraps 360deg to 0", () => {
			const result = Parse.parse("hwb(360 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("wraps 450deg to 90", () => {
			const result = Parse.parse("hwb(450 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(90);
			}
		});

		it("wraps -90deg to 270", () => {
			const result = Parse.parse("hwb(-90 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(270);
			}
		});

		it("wraps -180deg to 180", () => {
			const result = Parse.parse("hwb(-180 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("wraps 720deg to 0", () => {
			const result = Parse.parse("hwb(720 20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});
	});

	describe("Alpha channel", () => {
		it("parses hwb(120 20% 30% / 0.5)", () => {
			const result = Parse.parse("hwb(120 20% 30% / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "hwb",
					h: 120,
					w: 20,
					b: 30,
					alpha: 0.5,
				});
			}
		});

		it("parses hwb(120 20% 30% / 0)", () => {
			const result = Parse.parse("hwb(120 20% 30% / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("parses hwb(120 20% 30% / 1) and omits alpha", () => {
			const result = Parse.parse("hwb(120 20% 30% / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBeUndefined();
			}
		});

		it("clamps alpha > 1 to 1", () => {
			const result = Parse.parse("hwb(120 20% 30% / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBeUndefined(); // 1 is omitted
			}
		});

		it("clamps alpha < 0 to 0", () => {
			const result = Parse.parse("hwb(120 20% 30% / -0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});
	});

	describe("Percentage clamping", () => {
		it("clamps whiteness > 100% to 100", () => {
			const result = Parse.parse("hwb(120 150% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.w).toBe(100);
			}
		});

		it("clamps whiteness < 0% to 0", () => {
			const result = Parse.parse("hwb(120 -20% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.w).toBe(0);
			}
		});

		it("clamps blackness > 100% to 100", () => {
			const result = Parse.parse("hwb(120 20% 150%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(100);
			}
		});

		it("clamps blackness < 0% to 0", () => {
			const result = Parse.parse("hwb(120 20% -30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(0);
			}
		});
	});

	describe("Error handling", () => {
		it("rejects invalid function name", () => {
			const result = Parse.parse("rgb(120 20% 30%)");
			expect(result.ok).toBe(false);
		});

		it("rejects too few arguments", () => {
			const result = Parse.parse("hwb(120 20%)");
			expect(result.ok).toBe(false);
		});

		it("rejects too many arguments", () => {
			const result = Parse.parse("hwb(120 20% 30% 40%)");
			expect(result.ok).toBe(false);
		});

		it("rejects missing alpha after slash", () => {
			const result = Parse.parse("hwb(120 20% 30% /)");
			expect(result.ok).toBe(false);
		});

		it("rejects non-percentage whiteness", () => {
			const result = Parse.parse("hwb(120 20 30%)");
			expect(result.ok).toBe(false);
		});

		it("rejects non-percentage blackness", () => {
			const result = Parse.parse("hwb(120 20% 30)");
			expect(result.ok).toBe(false);
		});
	});

	describe("Round-trip (parse → generate → parse)", () => {
		it("round-trips hwb(120 20% 30%)", () => {
			const original = "hwb(120 20% 30%)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe(original);

				const reparsed = Parse.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("round-trips hwb(0 0% 0%)", () => {
			const original = "hwb(0 0% 0%)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("round-trips hwb(240 50% 10%)", () => {
			const original = "hwb(240 50% 10%)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("round-trips with alpha", () => {
			const original = "hwb(120 20% 30% / 0.5)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("normalizes angle units to degrees", () => {
			const input = "hwb(0.5turn 20% 30%)";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe("hwb(180 20% 30%)");
			}
		});

		it("normalizes wrapped hue", () => {
			const input = "hwb(450 20% 30%)";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe("hwb(90 20% 30%)");
			}
		});

		it("normalizes negative hue", () => {
			const input = "hwb(-90 20% 30%)";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe("hwb(270 20% 30%)");
			}
		});

		it("omits alpha when 1", () => {
			const input = "hwb(120 20% 30% / 1)";
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.toCss(parsed.value);
				expect(generated).toBe("hwb(120 20% 30%)");
			}
		});
	});
});


=== File: src/parse/color/hwb.ts ===
// b_path:: src/parse/color/hwb.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { HWBColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS HWB color value.
 *
 * Supports HWB syntax (modern only, no legacy comma syntax):
 * - Space-separated: `hwb(120 20% 30%)`, `hwb(120deg 20% 30%)`
 * - With alpha: `hwb(120 20% 30% / 0.5)`
 * - Angle units: deg, rad, grad, turn (or unitless defaults to deg)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 * Whiteness and blackness are clamped to 0-100%.
 *
 * @param input - The HWB color string to parse
 * @returns Result containing the parsed HWBColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/hwb";
 *
 * // Basic syntax
 * const color1 = parse("hwb(120 20% 30%)");
 * // => { ok: true, value: { kind: "hwb", h: 120, w: 20, b: 30 } }
 *
 * // With angle unit
 * const color2 = parse("hwb(0.5turn 20% 30%)");
 * // => { ok: true, value: { kind: "hwb", h: 180, w: 20, b: 30 } }
 *
 * // With alpha
 * const color3 = parse("hwb(120 20% 30% / 0.5)");
 * // => { ok: true, value: { kind: "hwb", h: 120, w: 20, b: 30, alpha: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<HWBColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find hwb() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["hwb"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (HWB is modern, no legacy syntax)
	return parseHWBArguments(children);
}

/**
 * Parse HWB function arguments from AST nodes.
 * HWB only supports space-separated syntax: hwb(H W% B%) or hwb(H W% B% / A)
 *
 * @internal
 */
function parseHWBArguments(nodes: csstree.CssNode[]): Result<HWBColor, string> {
	// Filter out whitespace nodes
	const valueNodes = nodes.filter((node) => node.type !== "WhiteSpace");

	// Check for slash separator for alpha
	const slashIndex = valueNodes.findIndex((node) => node.type === "Operator" && "value" in node && node.value === "/");

	if (slashIndex !== -1) {
		// Has alpha: hwb(H W% B% / A)
		if (slashIndex !== 3) {
			return err("Invalid HWB syntax: expected 3 values before '/'");
		}
		if (valueNodes.length !== 5) {
			return err("Invalid HWB syntax: expected alpha value after '/'");
		}
		const [hueNode, whitenessNode, blacknessNode, , alphaNode] = valueNodes;
		if (!hueNode || !whitenessNode || !blacknessNode || !alphaNode) {
			return err("Invalid HWB syntax: missing required values");
		}

		// Parse hue
		const hueResult = ParseUtils.parseHue(hueNode);
		if (!hueResult.ok) {
			return err(`Invalid hue: ${hueResult.error}`);
		}
		const h = hueResult.value;

		// Parse whiteness (percentage)
		const wResult = ParseUtils.parsePercentage(whitenessNode, { clamp: true });
		if (!wResult.ok) {
			return err(`Invalid whiteness: ${wResult.error}`);
		}
		const w = wResult.value;

		// Parse blackness (percentage)
		const bResult = ParseUtils.parsePercentage(blacknessNode, { clamp: true });
		if (!bResult.ok) {
			return err(`Invalid blackness: ${bResult.error}`);
		}
		const b = bResult.value;

		// Parse alpha
		const alphaResult = ParseUtils.parseAlpha(alphaNode, { clamp: true });
		if (!alphaResult.ok) {
			return err(`Invalid alpha: ${alphaResult.error}`);
		}
		const alpha = alphaResult.value;

		const color: HWBColor = { kind: "hwb", h, w, b };
		if (alpha !== undefined && alpha !== 1) {
			color.alpha = alpha;
		}
		return ok(color);
	} else {
		// No alpha: hwb(H W% B%)
		if (valueNodes.length !== 3) {
			return err(`Invalid HWB syntax: expected 3 values, got ${valueNodes.length}`);
		}
		const [hueNode, whitenessNode, blacknessNode] = valueNodes;
		if (!hueNode || !whitenessNode || !blacknessNode) {
			return err("Invalid HWB syntax: missing required values");
		}

		// Parse hue
		const hueResult = ParseUtils.parseHue(hueNode);
		if (!hueResult.ok) {
			return err(`Invalid hue: ${hueResult.error}`);
		}
		const h = hueResult.value;

		// Parse whiteness (percentage)
		const wResult = ParseUtils.parsePercentage(whitenessNode, { clamp: true });
		if (!wResult.ok) {
			return err(`Invalid whiteness: ${wResult.error}`);
		}
		const w = wResult.value;

		// Parse blackness (percentage)
		const bResult = ParseUtils.parsePercentage(blacknessNode, { clamp: true });
		if (!bResult.ok) {
			return err(`Invalid blackness: ${bResult.error}`);
		}
		const b = bResult.value;

		return ok({ kind: "hwb", h, w, b });
	}
}


=== File: src/parse/color/index.ts ===
// b_path:: src/parse/color/index.ts

/**
 * CSS color parsers - convert color strings to structured IR.
 *
 * All color parsers return Result<T, string> for type-safe error handling.
 *
 * @module Parse.Color
 * @public
 */

export { parse } from "./color";

/**
 * Parse color() function values.
 *
 * @see {@link ColorFunction.parse}
 */
export * as ColorFunction from "./color-function";
/**
 * Parse hex color values.
 *
 * @see {@link Hex.parse}
 */
export * as Hex from "./hex";
/**
 * Parse HSL color values.
 *
 * @see {@link Hsl.parse}
 */
export * as Hsl from "./hsl";
/**
 * Parse HWB color values.
 *
 * @see {@link Hwb.parse}
 */
export * as Hwb from "./hwb";
/**
 * Parse LAB color values.
 *
 * @see {@link Lab.parse}
 */
export * as Lab from "./lab";
/**
 * Parse LCH color values.
 *
 * @see {@link Lch.parse}
 */
export * as Lch from "./lch";
/**
 * Parse named color values.
 *
 * @see {@link Named.parse}
 */
export * as Named from "./named";
/**
 * Parse OKLab color values.
 *
 * @see {@link Oklab.parse}
 */
export * as Oklab from "./oklab";
/**
 * Parse OKLCH color values.
 *
 * @see {@link Oklch.parse}
 */
export * as Oklch from "./oklch";
/**
 * Parse RGB color values.
 *
 * @see {@link Rgb.parse}
 */
export * as Rgb from "./rgb";
/**
 * Parse special color values (transparent, currentcolor).
 *
 * @see {@link Special.parse}
 */
export * as Special from "./special";
/**
 * Parse system color values.
 *
 * @see {@link System.parse}
 */
export * as System from "./system";


=== File: src/parse/color/lab.test.ts ===
// b_path:: src/parse/color/lab.test.ts
import { describe, expect, it } from "vitest";
import type { LABColor } from "@/core/types/color";
import * as LABGenerator from "@/generate/color/lab";
import * as LABParser from "./lab";

describe("LAB Color Parser", () => {
	describe("basic space-separated syntax", () => {
		it("should parse lab with percentage lightness", () => {
			const result = LABParser.parse("lab(50% -20 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
				});
			}
		});

		it("should parse lab with number lightness", () => {
			const result = LABParser.parse("lab(50 -20 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
				});
			}
		});

		it("should parse lab with positive a and b values", () => {
			const result = LABParser.parse("lab(75% 40 60)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 75,
					a: 40,
					b: 60,
				});
			}
		});

		it("should parse lab with zero values", () => {
			const result = LABParser.parse("lab(0% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 0,
					a: 0,
					b: 0,
				});
			}
		});
	});

	describe("lightness handling", () => {
		it("should clamp lightness percentage above 100%", () => {
			const result = LABParser.parse("lab(150% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100);
			}
		});

		it("should clamp lightness number above 100", () => {
			const result = LABParser.parse("lab(120 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100);
			}
		});

		it("should clamp negative lightness to 0", () => {
			const result = LABParser.parse("lab(-10% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0);
			}
		});
	});

	describe("axis value clamping", () => {
		it("should clamp a value above 125", () => {
			const result = LABParser.parse("lab(50% 150 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.a).toBe(125);
			}
		});

		it("should clamp a value below -125", () => {
			const result = LABParser.parse("lab(50% -200 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.a).toBe(-125);
			}
		});

		it("should clamp b value above 125", () => {
			const result = LABParser.parse("lab(50% 0 200)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(125);
			}
		});

		it("should clamp b value below -125", () => {
			const result = LABParser.parse("lab(50% 0 -150)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(-125);
			}
		});
	});

	describe("alpha channel", () => {
		it("should parse lab with alpha as number", () => {
			const result = LABParser.parse("lab(50% -20 30 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
					alpha: 0.5,
				});
			}
		});

		it("should parse lab with alpha as percentage", () => {
			const result = LABParser.parse("lab(50% -20 30 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
					alpha: 0.5,
				});
			}
		});

		it("should parse lab with alpha 0", () => {
			const result = LABParser.parse("lab(50% -20 30 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("should parse lab with alpha 1", () => {
			const result = LABParser.parse("lab(50% -20 30 / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("should parse lab with alpha 100%", () => {
			const result = LABParser.parse("lab(50% -20 30 / 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});
	});

	describe("edge cases", () => {
		it("should parse pure white (L=100, a=0, b=0)", () => {
			const result = LABParser.parse("lab(100% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 100,
					a: 0,
					b: 0,
				});
			}
		});

		it("should parse pure black (L=0, a=0, b=0)", () => {
			const result = LABParser.parse("lab(0% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 0,
					a: 0,
					b: 0,
				});
			}
		});

		it("should parse decimal values", () => {
			const result = LABParser.parse("lab(53.5% -12.3 45.7)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBeCloseTo(53.5);
				expect(result.value.a).toBeCloseTo(-12.3);
				expect(result.value.b).toBeCloseTo(45.7);
			}
		});

		it("should handle extra whitespace", () => {
			const result = LABParser.parse("lab(  50%   -20   30  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
				});
			}
		});
	});

	describe("error handling", () => {
		it("should reject invalid function name", () => {
			const result = LABParser.parse("rgb(50% 0 0)");
			expect(result.ok).toBe(false);
		});

		it("should reject missing values", () => {
			const result = LABParser.parse("lab(50% -20)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values without alpha", () => {
			const result = LABParser.parse("lab(50% -20 30 40)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid alpha value > 1", () => {
			const result = LABParser.parse("lab(50% -20 30 / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.alpha).toBe(1);
		});

		it("should reject invalid alpha percentage > 100%", () => {
			const result = LABParser.parse("lab(50% -20 30 / 150%)");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.alpha).toBe(1);
		});

		it("should reject non-numeric values", () => {
			const result = LABParser.parse("lab(50% abc 30)");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip with generator", () => {
		const testCases: Array<{ input: string; expected: LABColor }> = [
			{
				input: "lab(50 -20 30)",
				expected: { kind: "lab", l: 50, a: -20, b: 30 },
			},
			{
				input: "lab(75 40 60)",
				expected: { kind: "lab", l: 75, a: 40, b: 60 },
			},
			{
				input: "lab(0 0 0)",
				expected: { kind: "lab", l: 0, a: 0, b: 0 },
			},
			{
				input: "lab(100 0 0)",
				expected: { kind: "lab", l: 100, a: 0, b: 0 },
			},
			{
				input: "lab(50 -20 30 / 0.5)",
				expected: { kind: "lab", l: 50, a: -20, b: 30, alpha: 0.5 },
			},
			{
				input: "lab(50 -20 30 / 0)",
				expected: { kind: "lab", l: 50, a: -20, b: 30, alpha: 0 },
			},
		];

		for (const { input, expected } of testCases) {
			it(`should round-trip: ${input}`, () => {
				const parseResult = LABParser.parse(input);
				expect(parseResult.ok).toBe(true);
				if (parseResult.ok) {
					expect(parseResult.value).toEqual(expected);
					const generated = LABGenerator.toCss(parseResult.value);
					const reparsed = LABParser.parse(generated);
					expect(reparsed.ok).toBe(true);
					if (reparsed.ok) {
						expect(reparsed.value).toEqual(expected);
					}
				}
			});
		}
	});
});


=== File: src/parse/color/lab.ts ===
// b_path:: src/parse/color/lab.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { LABColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS LAB color value.
 *
 * Supports LAB syntax (modern only, no legacy comma syntax):
 * - Space-separated: `lab(50% -20 30)`, `lab(50 -20 30)`
 * - With alpha: `lab(50% -20 30 / 0.5)`
 * - Lightness can be percentage (0-100%) or number (0-100)
 * - a and b axes: -125 to 125 (clamped)
 *
 * @param input - The LAB color string to parse
 * @returns Result containing the parsed LABColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/lab";
 *
 * // Basic syntax
 * const color1 = parse("lab(50% -20 30)");
 * // => { ok: true, value: { kind: "lab", l: 50, a: -20, b: 30 } }
 *
 * // With alpha
 * const color2 = parse("lab(50% -20 30 / 0.5)");
 * // => { ok: true, value: { kind: "lab", l: 50, a: -20, b: 30, alpha: 0.5 } }
 *
 * // Lightness as number
 * const color3 = parse("lab(50 -20 30)");
 * // => { ok: true, value: { kind: "lab", l: 50, a: -20, b: 30 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<LABColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find lab() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["lab"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (LAB is modern, no legacy syntax)
	return parseLABArguments(children);
}

/**
 * Parse LAB function arguments from AST nodes.
 * LAB only supports space-separated syntax: lab(L a b) or lab(L a b / A)
 *
 * @internal
 */
function parseLABArguments(nodes: csstree.CssNode[]): Result<LABColor, string> {
	let l: number | undefined;
	let a: number | undefined;
	let b: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			if (alpha !== undefined) {
				return err("Too many values after '/' in LAB color");
			}
			const alphaResult = ParseUtils.parseAlpha(node, { clamp: true });
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			continue;
		}

		// Parse L, a, b components
		if (componentIndex === 0) {
			// Lightness (percentage or number)
			const lightnessResult = ParseUtils.parseLightness(node, "0-100");
			if (!lightnessResult.ok) {
				return err(lightnessResult.error);
			}
			l = lightnessResult.value;
		} else if (componentIndex === 1) {
			// a axis (number)
			const axisResult = parseAxisValue(node);
			if (!axisResult.ok) {
				return err(axisResult.error);
			}
			a = axisResult.value;
		} else if (componentIndex === 2) {
			// b axis (number)
			const axisResult = parseAxisValue(node);
			if (!axisResult.ok) {
				return err(axisResult.error);
			}
			b = axisResult.value;
		} else {
			// Too many values (more than 3 before slash)
			return err("Too many values in LAB color (expected 3: lightness, a, b)");
		}
		componentIndex++;
	}

	if (l === undefined || a === undefined || b === undefined) {
		return err("Expected 3 LAB values (lightness, a, b)");
	}

	const color: LABColor = { kind: "lab", l, a, b };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse an axis value (a or b).
 *
 * Accepts: number (typically -125 to 125, but clamped)
 *
 * @internal
 */
function parseAxisValue(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Clamp to -125 to 125 range (CSS spec)
		const clamped = Math.max(-125, Math.min(125, value));
		return ok(clamped);
	}

	return err(`Expected number for axis value, got ${node.type}`);
}


=== File: src/parse/color/lch.test.ts ===
// b_path:: src/parse/color/lch.test.ts
import { describe, expect, it } from "vitest";
import type { LCHColor } from "@/core/types/color";
import * as LCHGenerator from "@/generate/color/lch";
import * as LCHParser from "./lch";

describe("LCH Color Parser", () => {
	describe("basic space-separated syntax", () => {
		it("should parse lch with percentage lightness", () => {
			const result = LCHParser.parse("lch(50% 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
				});
			}
		});

		it("should parse lch with number lightness", () => {
			const result = LCHParser.parse("lch(50 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
				});
			}
		});

		it("should parse lch with unitless hue", () => {
			const result = LCHParser.parse("lch(75% 60 270)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 75,
					c: 60,
					h: 270,
				});
			}
		});

		it("should parse lch with zero values", () => {
			const result = LCHParser.parse("lch(0% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 0,
					c: 0,
					h: 0,
				});
			}
		});
	});

	describe("angle units", () => {
		it("should parse hue with deg unit", () => {
			const result = LCHParser.parse("lch(50% 50 180deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with turn unit", () => {
			const result = LCHParser.parse("lch(50% 50 0.5turn)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with rad unit", () => {
			const result = LCHParser.parse("lch(50% 50 3.14159rad)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBeCloseTo(180, 0);
			}
		});

		it("should parse hue with grad unit", () => {
			const result = LCHParser.parse("lch(50% 50 200grad)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with 1turn", () => {
			const result = LCHParser.parse("lch(50% 50 1turn)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0); // 360 wraps to 0
			}
		});
	});

	describe("hue wrapping", () => {
		it("should wrap hue 360deg to 0", () => {
			const result = LCHParser.parse("lch(50% 50 360)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("should wrap hue 450deg to 90deg", () => {
			const result = LCHParser.parse("lch(50% 50 450)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(90);
			}
		});

		it("should wrap negative hue -90deg to 270deg", () => {
			const result = LCHParser.parse("lch(50% 50 -90)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(270);
			}
		});

		it("should wrap negative hue -180deg to 180deg", () => {
			const result = LCHParser.parse("lch(50% 50 -180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should wrap large positive hue", () => {
			const result = LCHParser.parse("lch(50% 50 720)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0); // 720 = 2 * 360
			}
		});
	});

	describe("lightness handling", () => {
		it("should clamp lightness percentage above 100%", () => {
			const result = LCHParser.parse("lch(150% 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100);
			}
		});

		it("should clamp lightness number above 100", () => {
			const result = LCHParser.parse("lch(120 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100);
			}
		});

		it("should clamp negative lightness to 0", () => {
			const result = LCHParser.parse("lch(-10% 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0);
			}
		});
	});

	describe("chroma clamping", () => {
		it("should clamp chroma above 150", () => {
			const result = LCHParser.parse("lch(50% 200 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(150);
			}
		});

		it("should clamp negative chroma to 0", () => {
			const result = LCHParser.parse("lch(50% -10 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(0);
			}
		});

		it("should accept chroma at max value 150", () => {
			const result = LCHParser.parse("lch(50% 150 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(150);
			}
		});
	});

	describe("alpha channel", () => {
		it("should parse lch with alpha as number", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
					alpha: 0.5,
				});
			}
		});

		it("should parse lch with alpha as percentage", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
					alpha: 0.5,
				});
			}
		});

		it("should parse lch with alpha 0", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("should parse lch with alpha 1", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("should parse lch with alpha 100%", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});
	});

	describe("edge cases", () => {
		it("should parse pure white (L=100, C=0, H=0)", () => {
			const result = LCHParser.parse("lch(100% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 100,
					c: 0,
					h: 0,
				});
			}
		});

		it("should parse pure black (L=0, C=0, H=0)", () => {
			const result = LCHParser.parse("lch(0% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 0,
					c: 0,
					h: 0,
				});
			}
		});

		it("should parse decimal values", () => {
			const result = LCHParser.parse("lch(53.5% 62.3 135.7)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBeCloseTo(53.5);
				expect(result.value.c).toBeCloseTo(62.3);
				expect(result.value.h).toBeCloseTo(135.7);
			}
		});

		it("should handle extra whitespace", () => {
			const result = LCHParser.parse("lch(  50%   50   180  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
				});
			}
		});
	});

	describe("error handling", () => {
		it("should reject invalid function name", () => {
			const result = LCHParser.parse("rgb(50% 50 180)");
			expect(result.ok).toBe(false);
		});

		it("should reject missing values", () => {
			const result = LCHParser.parse("lch(50% 50)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values without alpha", () => {
			const result = LCHParser.parse("lch(50% 50 180 90)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid alpha value > 1", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.alpha).toBe(1);
		});

		it("should reject invalid alpha percentage > 100%", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 150%)");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.alpha).toBe(1);
		});

		it("should reject non-numeric values", () => {
			const result = LCHParser.parse("lch(50% abc 180)");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip with generator", () => {
		const testCases: Array<{ input: string; expected: LCHColor }> = [
			{
				input: "lch(50 50 180)",
				expected: { kind: "lch", l: 50, c: 50, h: 180 },
			},
			{
				input: "lch(75 60 270)",
				expected: { kind: "lch", l: 75, c: 60, h: 270 },
			},
			{
				input: "lch(0 0 0)",
				expected: { kind: "lch", l: 0, c: 0, h: 0 },
			},
			{
				input: "lch(100 0 0)",
				expected: { kind: "lch", l: 100, c: 0, h: 0 },
			},
			{
				input: "lch(50 50 180 / 0.5)",
				expected: { kind: "lch", l: 50, c: 50, h: 180, alpha: 0.5 },
			},
			{
				input: "lch(50 50 180 / 0)",
				expected: { kind: "lch", l: 50, c: 50, h: 180, alpha: 0 },
			},
			{
				input: "lch(50 50 90)",
				expected: { kind: "lch", l: 50, c: 50, h: 90 },
			},
			{
				input: "lch(50 50 360)",
				expected: { kind: "lch", l: 50, c: 50, h: 0 }, // wrapped
			},
		];

		for (const { input, expected } of testCases) {
			it(`should round-trip: ${input}`, () => {
				const parseResult = LCHParser.parse(input);
				expect(parseResult.ok).toBe(true);
				if (parseResult.ok) {
					expect(parseResult.value).toEqual(expected);
					const generated = LCHGenerator.toCss(parseResult.value);
					const reparsed = LCHParser.parse(generated);
					expect(reparsed.ok).toBe(true);
					if (reparsed.ok) {
						expect(reparsed.value).toEqual(expected);
					}
				}
			});
		}
	});
});


=== File: src/parse/color/lch.ts ===
// b_path:: src/parse/color/lch.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { LCHColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS LCH color value.
 *
 * Supports LCH syntax (modern only, no legacy comma syntax):
 * - Space-separated: `lch(50% 50 180deg)`, `lch(50 50 180)`
 * - With alpha: `lch(50% 50 180 / 0.5)`
 * - Lightness can be percentage (0-100%) or number (0-100)
 * - Chroma: 0-150 (clamped)
 * - Hue: angle with deg, rad, grad, turn units (or unitless defaults to deg)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 *
 * @param input - The LCH color string to parse
 * @returns Result containing the parsed LCHColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/lch";
 *
 * // Basic syntax
 * const color1 = parse("lch(50% 50 180)");
 * // => { ok: true, value: { kind: "lch", l: 50, c: 50, h: 180 } }
 *
 * // With angle unit
 * const color2 = parse("lch(50% 50 0.5turn)");
 * // => { ok: true, value: { kind: "lch", l: 50, c: 50, h: 180 } }
 *
 * // With alpha
 * const color3 = parse("lch(50% 50 180 / 0.5)");
 * // => { ok: true, value: { kind: "lch", l: 50, c: 50, h: 180, alpha: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<LCHColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find lch() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["lch"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (LCH is modern, no legacy syntax)
	return parseLCHArguments(children);
}

/**
 * Parse LCH function arguments from AST nodes.
 * LCH only supports space-separated syntax: lch(L C H) or lch(L C H / A)
 *
 * @internal
 */
function parseLCHArguments(nodes: csstree.CssNode[]): Result<LCHColor, string> {
	let l: number | undefined;
	let c: number | undefined;
	let h: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			if (alpha !== undefined) {
				return err("Too many values after '/' in LCH color");
			}
			const alphaResult = ParseUtils.parseAlpha(node, { clamp: true });
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			continue;
		}

		// Parse L, C, H components
		if (componentIndex === 0) {
			// Lightness (percentage or number)
			const lightnessResult = ParseUtils.parseLightness(node, "0-100");
			if (!lightnessResult.ok) {
				return err(lightnessResult.error);
			}
			l = lightnessResult.value;
		} else if (componentIndex === 1) {
			// Chroma (number)
			const chromaResult = parseChroma(node);
			if (!chromaResult.ok) {
				return err(chromaResult.error);
			}
			c = chromaResult.value;
		} else if (componentIndex === 2) {
			// Hue (angle or unitless number)
			const hueResult = ParseUtils.parseHue(node);
			if (!hueResult.ok) {
				return err(hueResult.error);
			}
			h = hueResult.value;
		} else {
			// Too many values (more than 3 before slash)
			return err("Too many values in LCH color (expected 3: lightness, chroma, hue)");
		}
		componentIndex++;
	}

	if (l === undefined || c === undefined || h === undefined) {
		return err("Expected 3 LCH values (lightness, chroma, hue)");
	}

	const color: LCHColor = { kind: "lch", l, c, h };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse a chroma value.
 *
 * Accepts: number (0-150, clamped)
 *
 * @internal
 */
function parseChroma(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Clamp to 0-150 range (CSS spec)
		const clamped = Math.max(0, Math.min(150, value));
		return ok(clamped);
	}

	return err(`Expected number for chroma, got ${node.type}`);
}


=== File: src/parse/color/named.test.ts ===
// b_path:: src/parse/color/named.test.ts
import { describe, expect, it } from "vitest";
import * as Gen from "@/generate/color/named";
import * as Named from "./named";

describe("named color parser", () => {
	describe("basic colors", () => {
		it("parses 'red'", () => {
			const result = Named.parse("red");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("named");
				expect(result.value.name).toBe("red");
			}
		});

		it("parses 'blue'", () => {
			const result = Named.parse("blue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("blue");
			}
		});

		it("parses 'green'", () => {
			const result = Named.parse("green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("green");
			}
		});

		it("parses 'yellow'", () => {
			const result = Named.parse("yellow");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("yellow");
			}
		});

		it("parses 'black'", () => {
			const result = Named.parse("black");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("black");
			}
		});

		it("parses 'white'", () => {
			const result = Named.parse("white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("white");
			}
		});

		it("parses 'gray'", () => {
			const result = Named.parse("gray");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("gray");
			}
		});

		it("parses 'grey'", () => {
			const result = Named.parse("grey");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("grey");
			}
		});
	});

	describe("extended colors", () => {
		it("parses 'cornflowerblue'", () => {
			const result = Named.parse("cornflowerblue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("named");
				expect(result.value.name).toBe("cornflowerblue");
			}
		});

		it("parses 'aliceblue'", () => {
			const result = Named.parse("aliceblue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("aliceblue");
			}
		});

		it("parses 'antiquewhite'", () => {
			const result = Named.parse("antiquewhite");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("antiquewhite");
			}
		});

		it("parses 'aquamarine'", () => {
			const result = Named.parse("aquamarine");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("aquamarine");
			}
		});

		it("parses 'blanchedalmond'", () => {
			const result = Named.parse("blanchedalmond");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("blanchedalmond");
			}
		});

		it("parses 'darkorchid'", () => {
			const result = Named.parse("darkorchid");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("darkorchid");
			}
		});

		it("parses 'mediumspringgreen'", () => {
			const result = Named.parse("mediumspringgreen");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("mediumspringgreen");
			}
		});
	});

	describe("case insensitivity", () => {
		it("parses 'RED'", () => {
			const result = Named.parse("RED");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("red");
			}
		});

		it("parses 'Blue'", () => {
			const result = Named.parse("Blue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("blue");
			}
		});

		it("parses 'CORNFLOWERBLUE'", () => {
			const result = Named.parse("CORNFLOWERBLUE");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("cornflowerblue");
			}
		});

		it("parses 'AliceBlue'", () => {
			const result = Named.parse("AliceBlue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("aliceblue");
			}
		});

		it("parses 'MediumSpringGreen'", () => {
			const result = Named.parse("MediumSpringGreen");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe("mediumspringgreen");
			}
		});
	});

	describe("error handling", () => {
		it("rejects unknown color name", () => {
			const result = Named.parse("notacolor");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Unknown color name: notacolor");
			}
		});

		it("rejects empty string", () => {
			const result = Named.parse("");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Unknown color name: ");
			}
		});

		it("rejects numbers", () => {
			const result = Named.parse("123");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Unknown color name: 123");
			}
		});

		it("rejects special characters", () => {
			const result = Named.parse("red@blue");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Unknown color name: red@blue");
			}
		});

		it("rejects hex-like strings", () => {
			const result = Named.parse("#ff5733");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe("Unknown color name: #ff5733");
			}
		});
	});

	describe("round-trip accuracy", () => {
		it("maintains 'red'", () => {
			const result = Named.parse("red");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("red");
			}
		});

		it("normalizes uppercase to lowercase", () => {
			const result = Named.parse("BLUE");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("blue");
			}
		});

		it("maintains 'cornflowerblue'", () => {
			const result = Named.parse("cornflowerblue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("cornflowerblue");
			}
		});

		it("normalizes mixed case", () => {
			const result = Named.parse("AliceBlue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("aliceblue");
			}
		});

		it("maintains 'mediumspringgreen'", () => {
			const result = Named.parse("mediumspringgreen");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("mediumspringgreen");
			}
		});
	});
});


=== File: src/parse/color/named.ts ===
// b_path:: src/parse/color/named.ts

import { BASIC_NAMED_COLOR_KEYWORDS, EXTENDED_NAMED_COLOR_KEYWORDS } from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type { NamedColor } from "@/core/types/color";

/**
 * Set of all valid CSS named colors.
 * Includes both basic (22) and extended (126) color keywords.
 */
const ALL_NAMED_COLORS = new Set<string>([...BASIC_NAMED_COLOR_KEYWORDS, ...EXTENDED_NAMED_COLOR_KEYWORDS]);

/**
 * Parse a CSS named color value.
 *
 * Accepts any valid CSS color keyword name (case-insensitive).
 * Includes basic colors (red, blue, etc.) and extended X11/SVG colors.
 *
 * @param input - The color name to parse (e.g., "red", "cornflowerblue")
 * @returns Result containing the parsed NamedColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/named";
 *
 * // Basic color
 * const color1 = parse("red");
 * // => { ok: true, value: { kind: "named", name: "red" } }
 *
 * // Extended color
 * const color2 = parse("cornflowerblue");
 * // => { ok: true, value: { kind: "named", name: "cornflowerblue" } }
 *
 * // Case-insensitive
 * const color3 = parse("BLUE");
 * // => { ok: true, value: { kind: "named", name: "blue" } }
 *
 * // Invalid color
 * const invalid = parse("notacolor");
 * // => { ok: false, error: "Unknown color name: notacolor" }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<NamedColor, string> {
	const lower = input.toLowerCase();

	if (ALL_NAMED_COLORS.has(lower)) {
		return ok({ kind: "named", name: lower });
	}

	return err(`Unknown color name: ${input}`);
}


=== File: src/parse/color/oklab.test.ts ===
// b_path:: src/parse/color/oklab.test.ts
import { describe, expect, it } from "vitest";
import * as OKLabGenerator from "@/generate/color/oklab";
import * as OKLabParser from "./oklab";

describe("OKLab Color Parser", () => {
	describe("basic space-separated syntax", () => {
		it("should parse oklab with number lightness", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.5,
					a: -0.2,
					b: 0.3,
				});
			}
		});

		it("should parse oklab with percentage lightness", () => {
			const result = OKLabParser.parse("oklab(50% -0.2 0.3)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.5,
					a: -0.2,
					b: 0.3,
				});
			}
		});

		it("should parse oklab with positive a and b values", () => {
			const result = OKLabParser.parse("oklab(0.75 0.1 0.2)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.75,
					a: 0.1,
					b: 0.2,
				});
			}
		});

		it("should parse oklab with zero values", () => {
			const result = OKLabParser.parse("oklab(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0,
					a: 0,
					b: 0,
				});
			}
		});
	});

	describe("lightness handling", () => {
		it("should convert percentage lightness to 0-1 range", () => {
			const result = OKLabParser.parse("oklab(100% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp lightness percentage above 100%", () => {
			const result = OKLabParser.parse("oklab(150% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp lightness number above 1", () => {
			const result = OKLabParser.parse("oklab(1.5 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp negative lightness to 0", () => {
			const result = OKLabParser.parse("oklab(-0.1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0);
			}
		});
	});

	describe("axis value clamping", () => {
		it("should clamp a value above 0.4", () => {
			const result = OKLabParser.parse("oklab(0.5 0.5 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.a).toBe(0.4);
			}
		});

		it("should clamp a value below -0.4", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.6 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.a).toBe(-0.4);
			}
		});

		it("should clamp b value above 0.4", () => {
			const result = OKLabParser.parse("oklab(0.5 0 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(0.4);
			}
		});

		it("should clamp b value below -0.4", () => {
			const result = OKLabParser.parse("oklab(0.5 0 -0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(-0.4);
			}
		});
	});

	describe("alpha channel", () => {
		it("should parse alpha with number", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.5,
					a: -0.2,
					b: 0.3,
					alpha: 0.5,
				});
			}
		});

		it("should parse alpha with percentage", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("should clamp alpha above 1", () => {
			const result = OKLabParser.parse("oklab(0.5 0 0 / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("should clamp alpha below 0", () => {
			const result = OKLabParser.parse("oklab(0.5 0 0 / -0.1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("should parse alpha of 0", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});
	});

	describe("edge cases", () => {
		it("should parse white (maximum lightness)", () => {
			const result = OKLabParser.parse("oklab(1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 1,
					a: 0,
					b: 0,
				});
			}
		});

		it("should parse black (minimum lightness)", () => {
			const result = OKLabParser.parse("oklab(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0,
					a: 0,
					b: 0,
				});
			}
		});

		it("should parse decimal values", () => {
			const result = OKLabParser.parse("oklab(0.123 -0.234 0.345)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBeCloseTo(0.123);
				expect(result.value.a).toBeCloseTo(-0.234);
				expect(result.value.b).toBeCloseTo(0.345);
			}
		});

		it("should handle extra whitespace", () => {
			const result = OKLabParser.parse("oklab(  0.5   -0.2   0.3  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.5,
					a: -0.2,
					b: 0.3,
				});
			}
		});
	});

	describe("error handling", () => {
		it("should reject missing values", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values before slash", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 0.4)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values after slash", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 / 0.5 0.6)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid function name", () => {
			const result = OKLabParser.parse("oklabs(0.5 -0.2 0.3)");
			expect(result.ok).toBe(false);
		});

		it("should reject non-numeric values", () => {
			const result = OKLabParser.parse("oklab(red 0 0)");
			expect(result.ok).toBe(false);
		});

		it("should reject empty function", () => {
			const result = OKLabParser.parse("oklab()");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip (parse -> generate -> parse)", () => {
		it("should round-trip oklab with number lightness", () => {
			const input = "oklab(0.5 -0.2 0.3)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.toCss(parsed.value);
				const reparsed = OKLabParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklab with percentage lightness (normalizes to number)", () => {
			const input = "oklab(50% -0.2 0.3)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.toCss(parsed.value);
				const reparsed = OKLabParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklab with alpha", () => {
			const input = "oklab(0.5 -0.2 0.3 / 0.5)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.toCss(parsed.value);
				const reparsed = OKLabParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklab with clamped values", () => {
			const input = "oklab(1.5 0.5 -0.6)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.toCss(parsed.value);
				const reparsed = OKLabParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip white", () => {
			const input = "oklab(1 0 0)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.toCss(parsed.value);
				const reparsed = OKLabParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip black", () => {
			const input = "oklab(0 0 0)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.toCss(parsed.value);
				const reparsed = OKLabParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/parse/color/oklab.ts ===
// b_path:: src/parse/color/oklab.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { OKLabColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS OKLab color value.
 *
 * Supports OKLab syntax (modern only, no legacy comma syntax):
 * - Space-separated: `oklab(0.5 -0.2 0.3)`, `oklab(50% -0.2 0.3)`
 * - With alpha: `oklab(0.5 -0.2 0.3 / 0.5)`
 * - Lightness can be percentage (0-100%) or number (0-1)
 * - a and b axes: -0.4 to 0.4 (clamped)
 *
 * @param input - The OKLab color string to parse
 * @returns Result containing the parsed OKLabColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/oklab";
 *
 * // Basic syntax with number lightness
 * const color1 = parse("oklab(0.5 -0.2 0.3)");
 * // => { ok: true, value: { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 } }
 *
 * // With alpha
 * const color2 = parse("oklab(0.5 -0.2 0.3 / 0.5)");
 * // => { ok: true, value: { kind: "oklab", l: 0.5, a: -0.2, b: 0.3, alpha: 0.5 } }
 *
 * // Lightness as percentage
 * const color3 = parse("oklab(50% -0.2 0.3)");
 * // => { ok: true, value: { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<OKLabColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find oklab() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["oklab"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (OKLab is modern, no legacy syntax)
	return parseOKLabArguments(children);
}

/**
 * Parse OKLab function arguments from AST nodes.
 * OKLab only supports space-separated syntax: oklab(L a b) or oklab(L a b / A)
 *
 * @internal
 */
function parseOKLabArguments(nodes: csstree.CssNode[]): Result<OKLabColor, string> {
	let l: number | undefined;
	let a: number | undefined;
	let b: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			if (alpha !== undefined) {
				return err("Too many values after '/' in OKLab color");
			}
			const alphaResult = ParseUtils.parseAlpha(node, { clamp: true });
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			continue;
		}

		// Parse L, a, b components
		if (componentIndex === 0) {
			// Lightness (percentage or number)
			const lightnessResult = ParseUtils.parseLightness(node, "0-1");
			if (!lightnessResult.ok) {
				return err(lightnessResult.error);
			}
			l = lightnessResult.value;
		} else if (componentIndex === 1) {
			// a axis (number)
			const axisResult = parseAxisValue(node);
			if (!axisResult.ok) {
				return err(axisResult.error);
			}
			a = axisResult.value;
		} else if (componentIndex === 2) {
			// b axis (number)
			const axisResult = parseAxisValue(node);
			if (!axisResult.ok) {
				return err(axisResult.error);
			}
			b = axisResult.value;
		} else {
			// Too many values (more than 3 before slash)
			return err("Too many values in OKLab color (expected 3: lightness, a, b)");
		}
		componentIndex++;
	}

	if (l === undefined || a === undefined || b === undefined) {
		return err("Expected 3 OKLab values (lightness, a, b)");
	}

	const color: OKLabColor = { kind: "oklab", l, a, b };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse an axis value (a or b).
 *
 * Accepts: number (typically -0.4 to 0.4, but clamped)
 *
 * @internal
 */
function parseAxisValue(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Clamp to -0.4 to 0.4 range (CSS spec)
		const clamped = Math.max(-0.4, Math.min(0.4, value));
		return ok(clamped);
	}

	return err(`Expected number for axis value, got ${node.type}`);
}


=== File: src/parse/color/oklch.test.ts ===
// b_path:: src/parse/color/oklch.test.ts
import { describe, expect, it } from "vitest";
import * as OKLCHGenerator from "@/generate/color/oklch";
import * as OKLCHParser from "./oklch";

describe("OKLCH Color Parser", () => {
	describe("basic space-separated syntax", () => {
		it("should parse oklch with number lightness", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.5,
					c: 0.2,
					h: 180,
				});
			}
		});

		it("should parse oklch with percentage lightness", () => {
			const result = OKLCHParser.parse("oklch(50% 0.2 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.5,
					c: 0.2,
					h: 180,
				});
			}
		});

		it("should parse oklch with unitless hue", () => {
			const result = OKLCHParser.parse("oklch(0.75 0.15 270)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.75,
					c: 0.15,
					h: 270,
				});
			}
		});

		it("should parse oklch with zero values", () => {
			const result = OKLCHParser.parse("oklch(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0,
					c: 0,
					h: 0,
				});
			}
		});
	});

	describe("angle units", () => {
		it("should parse hue with deg unit", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with turn unit", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 0.5turn)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with rad unit", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 3.14159rad)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBeCloseTo(180, 0);
			}
		});

		it("should parse hue with grad unit", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 200grad)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with 1turn", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 1turn)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0); // 360 wraps to 0
			}
		});
	});

	describe("hue wrapping", () => {
		it("should wrap hue 360deg to 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 360)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("should wrap hue 450deg to 90deg", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 450)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(90);
			}
		});

		it("should wrap hue 720deg to 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 720)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("should wrap negative hue -90deg to 270deg", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 -90)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(270);
			}
		});

		it("should wrap negative hue -360deg to 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 -360)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});
	});

	describe("lightness handling", () => {
		it("should convert percentage lightness to 0-1 range", () => {
			const result = OKLCHParser.parse("oklch(100% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp lightness percentage above 100%", () => {
			const result = OKLCHParser.parse("oklch(150% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp lightness number above 1", () => {
			const result = OKLCHParser.parse("oklch(1.5 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp negative lightness to 0", () => {
			const result = OKLCHParser.parse("oklch(-0.1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0);
			}
		});
	});

	describe("chroma clamping", () => {
		it("should clamp chroma above 0.4", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.8 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(0.4);
			}
		});

		it("should clamp negative chroma to 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 -0.1 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(0);
			}
		});

		it("should accept chroma of 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(0);
			}
		});
	});

	describe("alpha channel", () => {
		it("should parse alpha with number", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.5,
					c: 0.2,
					h: 180,
					alpha: 0.5,
				});
			}
		});

		it("should parse alpha with percentage", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("should clamp alpha above 1", () => {
			const result = OKLCHParser.parse("oklch(0.5 0 0 / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("should clamp alpha below 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0 0 / -0.1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("should parse alpha of 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});
	});

	describe("edge cases", () => {
		it("should parse white (maximum lightness)", () => {
			const result = OKLCHParser.parse("oklch(1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 1,
					c: 0,
					h: 0,
				});
			}
		});

		it("should parse black (minimum lightness)", () => {
			const result = OKLCHParser.parse("oklch(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0,
					c: 0,
					h: 0,
				});
			}
		});

		it("should parse decimal values", () => {
			const result = OKLCHParser.parse("oklch(0.123 0.234 123.45)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBeCloseTo(0.123);
				expect(result.value.c).toBeCloseTo(0.234);
				expect(result.value.h).toBeCloseTo(123.45);
			}
		});

		it("should handle extra whitespace", () => {
			const result = OKLCHParser.parse("oklch(  0.5   0.2   180  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.5,
					c: 0.2,
					h: 180,
				});
			}
		});
	});

	describe("error handling", () => {
		it("should reject missing values", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values before slash", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 90)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values after slash", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 / 0.5 0.6)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid function name", () => {
			const result = OKLCHParser.parse("oklchs(0.5 0.2 180)");
			expect(result.ok).toBe(false);
		});

		it("should reject non-numeric values", () => {
			const result = OKLCHParser.parse("oklch(red 0 0)");
			expect(result.ok).toBe(false);
		});

		it("should reject empty function", () => {
			const result = OKLCHParser.parse("oklch()");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip (parse -> generate -> parse)", () => {
		it("should round-trip oklch with number lightness", () => {
			const input = "oklch(0.5 0.2 180)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.toCss(parsed.value);
				const reparsed = OKLCHParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with percentage lightness (normalizes to number)", () => {
			const input = "oklch(50% 0.2 180)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.toCss(parsed.value);
				const reparsed = OKLCHParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with angle units (normalizes to unitless)", () => {
			const input = "oklch(0.5 0.2 0.5turn)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.toCss(parsed.value);
				const reparsed = OKLCHParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with alpha", () => {
			const input = "oklch(0.5 0.2 180 / 0.5)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.toCss(parsed.value);
				const reparsed = OKLCHParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with wrapped hue", () => {
			const input = "oklch(0.5 0.2 450)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.toCss(parsed.value);
				const reparsed = OKLCHParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with clamped values", () => {
			const input = "oklch(1.5 0.8 -90)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.toCss(parsed.value);
				const reparsed = OKLCHParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip white", () => {
			const input = "oklch(1 0 0)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.toCss(parsed.value);
				const reparsed = OKLCHParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip black", () => {
			const input = "oklch(0 0 0)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.toCss(parsed.value);
				const reparsed = OKLCHParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/parse/color/oklch.ts ===
// b_path:: src/parse/color/oklch.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { OKLCHColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS OKLCH color value.
 *
 * Supports OKLCH syntax (modern only, no legacy comma syntax):
 * - Space-separated: `oklch(0.5 0.2 180deg)`, `oklch(50% 0.2 180)`
 * - With alpha: `oklch(0.5 0.2 180 / 0.5)`
 * - Lightness can be percentage (0-100%) or number (0-1)
 * - Chroma: 0-0.4 (clamped)
 * - Hue: angle with deg, rad, grad, turn units (or unitless defaults to deg)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 *
 * @param input - The OKLCH color string to parse
 * @returns Result containing the parsed OKLCHColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/oklch";
 *
 * // Basic syntax with number lightness
 * const color1 = parse("oklch(0.5 0.2 180)");
 * // => { ok: true, value: { kind: "oklch", l: 0.5, c: 0.2, h: 180 } }
 *
 * // With angle unit
 * const color2 = parse("oklch(0.5 0.2 0.5turn)");
 * // => { ok: true, value: { kind: "oklch", l: 0.5, c: 0.2, h: 180 } }
 *
 * // With alpha
 * const color3 = parse("oklch(0.5 0.2 180 / 0.5)");
 * // => { ok: true, value: { kind: "oklch", l: 0.5, c: 0.2, h: 180, alpha: 0.5 } }
 *
 * // Lightness as percentage
 * const color4 = parse("oklch(50% 0.2 180)");
 * // => { ok: true, value: { kind: "oklch", l: 0.5, c: 0.2, h: 180 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<OKLCHColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find oklch() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["oklch"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (OKLCH is modern, no legacy syntax)
	return parseOKLCHArguments(children);
}

/**
 * Parse OKLCH function arguments from AST nodes.
 * OKLCH only supports space-separated syntax: oklch(L C H) or oklch(L C H / A)
 *
 * @internal
 */
function parseOKLCHArguments(nodes: csstree.CssNode[]): Result<OKLCHColor, string> {
	let l: number | undefined;
	let c: number | undefined;
	let h: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			if (alpha !== undefined) {
				return err("Too many values after '/' in OKLCH color");
			}
			const alphaResult = ParseUtils.parseAlpha(node, { clamp: true });
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			continue;
		}

		// Parse L, C, H components
		if (componentIndex === 0) {
			// Lightness (percentage or number)
			const lightnessResult = ParseUtils.parseLightness(node, "0-1");
			if (!lightnessResult.ok) {
				return err(lightnessResult.error);
			}
			l = lightnessResult.value;
		} else if (componentIndex === 1) {
			// Chroma (number)
			const chromaResult = parseChroma(node);
			if (!chromaResult.ok) {
				return err(chromaResult.error);
			}
			c = chromaResult.value;
		} else if (componentIndex === 2) {
			// Hue (angle or unitless number)
			const hueResult = ParseUtils.parseHue(node);
			if (!hueResult.ok) {
				return err(hueResult.error);
			}
			h = hueResult.value;
		} else {
			// Too many values (more than 3 before slash)
			return err("Too many values in OKLCH color (expected 3: lightness, chroma, hue)");
		}
		componentIndex++;
	}

	if (l === undefined || c === undefined || h === undefined) {
		return err("Expected 3 OKLCH values (lightness, chroma, hue)");
	}

	const color: OKLCHColor = { kind: "oklch", l, c, h };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse a chroma value.
 *
 * Accepts: number (0-0.4, clamped)
 *
 * @internal
 */
function parseChroma(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Clamp to 0-0.4 range (CSS spec)
		const clamped = Math.max(0, Math.min(0.4, value));
		return ok(clamped);
	}

	return err(`Expected number for chroma, got ${node.type}`);
}


=== File: src/parse/color/rgb.test.ts ===
// b_path:: src/parse/color/rgb.test.ts
import { describe, expect, it } from "vitest";
import * as Gen from "@/generate/color/rgb";
import * as RGB from "./rgb";

describe("rgb color parser", () => {
	describe("modern space-separated syntax", () => {
		it("parses rgb(255 0 0)", () => {
			const result = RGB.parse("rgb(255 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("rgb");
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
				expect(result.value.alpha).toBeUndefined();
			}
		});

		it("parses rgb(0 128 255)", () => {
			const result = RGB.parse("rgb(0 128 255)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(0);
				expect(result.value.g).toBe(128);
				expect(result.value.b).toBe(255);
			}
		});

		it("parses rgb(100 200 50)", () => {
			const result = RGB.parse("rgb(100 200 50)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(100);
				expect(result.value.g).toBe(200);
				expect(result.value.b).toBe(50);
			}
		});

		it("parses black rgb(0 0 0)", () => {
			const result = RGB.parse("rgb(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(0);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
			}
		});

		it("parses white rgb(255 255 255)", () => {
			const result = RGB.parse("rgb(255 255 255)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(255);
				expect(result.value.b).toBe(255);
			}
		});
	});

	describe("modern syntax with alpha (slash)", () => {
		it("parses rgb(255 0 0 / 0.5)", () => {
			const result = RGB.parse("rgb(255 0 0 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("parses rgb(100 200 50 / 0)", () => {
			const result = RGB.parse("rgb(100 200 50 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("parses rgb(100 200 50 / 1)", () => {
			const result = RGB.parse("rgb(100 200 50 / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("parses rgb(255 0 0 / 0.25)", () => {
			const result = RGB.parse("rgb(255 0 0 / 0.25)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.25);
			}
		});

		it("parses rgb(255 0 0 / 0.75)", () => {
			const result = RGB.parse("rgb(255 0 0 / 0.75)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.75);
			}
		});
	});

	describe("modern syntax with percentage alpha", () => {
		it("parses rgb(255 0 0 / 50%)", () => {
			const result = RGB.parse("rgb(255 0 0 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("parses rgb(255 0 0 / 0%)", () => {
			const result = RGB.parse("rgb(255 0 0 / 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("parses rgb(255 0 0 / 100%)", () => {
			const result = RGB.parse("rgb(255 0 0 / 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});
	});

	describe("legacy comma-separated syntax", () => {
		it("parses rgb(255, 0, 0)", () => {
			const result = RGB.parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
				expect(result.value.alpha).toBeUndefined();
			}
		});

		it("parses rgb(100, 200, 50)", () => {
			const result = RGB.parse("rgb(100, 200, 50)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(100);
				expect(result.value.g).toBe(200);
				expect(result.value.b).toBe(50);
			}
		});

		it("parses rgba(255, 0, 0, 0.5)", () => {
			const result = RGB.parse("rgba(255, 0, 0, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("parses rgba(100, 200, 50, 0.25)", () => {
			const result = RGB.parse("rgba(100, 200, 50, 0.25)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(100);
				expect(result.value.g).toBe(200);
				expect(result.value.b).toBe(50);
				expect(result.value.alpha).toBe(0.25);
			}
		});

		it("parses rgba(0, 0, 0, 1)", () => {
			const result = RGB.parse("rgba(0, 0, 0, 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});
	});

	describe("percentage values", () => {
		it("parses rgb(100% 0% 0%)", () => {
			const result = RGB.parse("rgb(100% 0% 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
			}
		});

		it("parses rgb(50% 50% 50%)", () => {
			const result = RGB.parse("rgb(50% 50% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(128);
				expect(result.value.g).toBe(128);
				expect(result.value.b).toBe(128);
			}
		});

		it("parses rgb(0% 100% 50%)", () => {
			const result = RGB.parse("rgb(0% 100% 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(0);
				expect(result.value.g).toBe(255);
				expect(result.value.b).toBe(128);
			}
		});

		it("parses rgb(100%, 0%, 0%) with commas", () => {
			const result = RGB.parse("rgb(100%, 0%, 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
			}
		});

		it("parses rgb(100% 0% 0% / 50%)", () => {
			const result = RGB.parse("rgb(100% 0% 0% / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
				expect(result.value.alpha).toBe(0.5);
			}
		});
	});

	describe("decimal values", () => {
		it("parses rgb(255.5 128.7 64.2)", () => {
			const result = RGB.parse("rgb(255.5 128.7 64.2)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				// Should round and clamp to valid range
				expect(result.value.r).toBe(255); // Clamped to 255
				expect(result.value.g).toBe(129);
				expect(result.value.b).toBe(64);
			}
		});

		it("parses rgb(100.1 200.9 50.5)", () => {
			const result = RGB.parse("rgb(100.1 200.9 50.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(100);
				expect(result.value.g).toBe(201);
				expect(result.value.b).toBe(51);
			}
		});

		it("clamps values > 255", () => {
			const result = RGB.parse("rgb(300 128 50)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255); // Clamped
			}
		});

		it("clamps negative values", () => {
			const result = RGB.parse("rgb(-10 128 50)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(0); // Clamped
			}
		});
	});

	describe("error handling", () => {
		it("rejects alpha > 1", () => {
			const result = RGB.parse("rgb(255 0 0 / 1.5)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Alpha value must be between 0 and 1");
			}
		});

		it("rejects negative alpha", () => {
			const result = RGB.parse("rgb(255 0 0 / -0.5)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Alpha value must be between 0 and 1");
			}
		});

		it("rejects alpha percentage > 100%", () => {
			const result = RGB.parse("rgb(255 0 0 / 150%)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("must be between 0% and 100%");
			}
		});

		it("rejects too few arguments", () => {
			const result = RGB.parse("rgb(255 0)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 3 RGB values");
			}
		});

		it("rejects too many arguments", () => {
			const result = RGB.parse("rgb(255 0 0 0)");
			expect(result.ok).toBe(false);
		});

		it("rejects missing function", () => {
			const result = RGB.parse("255 0 0");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("No function found");
			}
		});

		it("rejects invalid syntax", () => {
			const result = RGB.parse("rgb(");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip accuracy", () => {
		it("maintains rgb(255 0 0)", () => {
			const result = RGB.parse("rgb(255 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("rgb(255 0 0)");
			}
		});

		it("maintains rgb(100 200 50)", () => {
			const result = RGB.parse("rgb(100 200 50)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("rgb(100 200 50)");
			}
		});

		it("maintains alpha rgb(255 0 0 / 0.5)", () => {
			const result = RGB.parse("rgb(255 0 0 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("rgb(255 0 0 / 0.5)");
			}
		});

		it("normalizes comma syntax to space syntax", () => {
			const result = RGB.parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("rgb(255 0 0)");
			}
		});

		it("normalizes rgba to rgb", () => {
			const result = RGB.parse("rgba(255, 0, 0, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("rgb(255 0 0 / 0.5)");
			}
		});

		it("normalizes percentages to integers", () => {
			const result = RGB.parse("rgb(100% 0% 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("rgb(255 0 0)");
			}
		});

		it("omits alpha when 1", () => {
			const result = RGB.parse("rgb(255 0 0 / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("rgb(255 0 0)");
			}
		});

		it("rounds decimal values", () => {
			const result = RGB.parse("rgb(100.4 200.6 50.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const css = Gen.toCss(result.value);
				expect(css).toBe("rgb(100 201 51)");
			}
		});
	});

	describe("edge cases", () => {
		it("parses gray rgb(128 128 128)", () => {
			const result = RGB.parse("rgb(128 128 128)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(128);
				expect(result.value.g).toBe(128);
				expect(result.value.b).toBe(128);
			}
		});

		it("parses transparent black rgb(0 0 0 / 0)", () => {
			const result = RGB.parse("rgb(0 0 0 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(0);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
				expect(result.value.alpha).toBe(0);
			}
		});

		it("parses with extra whitespace", () => {
			const result = RGB.parse("rgb(  255   0   0  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
			}
		});

		it("parses with mixed case function name", () => {
			const result = RGB.parse("RGB(255 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
			}
		});

		it("parses RGBA with mixed case", () => {
			const result = RGB.parse("RGBA(255, 0, 0, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("handles zero values", () => {
			const result = RGB.parse("rgb(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(0);
				expect(result.value.g).toBe(0);
				expect(result.value.b).toBe(0);
			}
		});

		it("handles max values", () => {
			const result = RGB.parse("rgb(255 255 255)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(255);
				expect(result.value.g).toBe(255);
				expect(result.value.b).toBe(255);
			}
		});

		it("handles mid-range values", () => {
			const result = RGB.parse("rgb(127 127 127)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.r).toBe(127);
				expect(result.value.g).toBe(127);
				expect(result.value.b).toBe(127);
			}
		});
	});
});


=== File: src/parse/color/rgb.ts ===
// b_path:: src/parse/color/rgb.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { RGBColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS RGB color value.
 *
 * Supports all RGB syntax variations:
 * - Modern space-separated: `rgb(255 0 0)`, `rgb(255 0 0 / 0.5)`
 * - Legacy comma-separated: `rgb(255, 0, 0)`, `rgba(255, 0, 0, 0.5)`
 * - Percentage values: `rgb(100% 0% 0%)`
 * - Mixed formats handled according to CSS spec
 *
 * @param input - The RGB color string to parse
 * @returns Result containing the parsed RGBColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/rgb";
 *
 * // Modern syntax
 * const color1 = parse("rgb(255 0 0)");
 * // => { ok: true, value: { kind: "rgb", r: 255, g: 0, b: 0 } }
 *
 * // With alpha
 * const color2 = parse("rgb(255 0 0 / 0.5)");
 * // => { ok: true, value: { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 } }
 *
 * // Legacy comma syntax
 * const color3 = parse("rgb(255, 0, 0)");
 * // => { ok: true, value: { kind: "rgb", r: 255, g: 0, b: 0 } }
 *
 * // Percentage values
 * const color4 = parse("rgb(100% 0% 0%)");
 * // => { ok: true, value: { kind: "rgb", r: 255, g: 0, b: 0 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<RGBColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find rgb() or rgba() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["rgb", "rgba"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get all children nodes (arguments)
	const children = fn.children.toArray();

	// Parse arguments - handle both comma and space syntax
	return parseRGBArguments(children);
}

/**
 * Parse RGB function arguments from AST nodes.
 *
 * Handles both comma-separated and space-separated syntax:
 * - Space: rgb(255 0 0) or rgb(255 0 0 / 0.5)
 * - Comma: rgb(255, 0, 0) or rgba(255, 0, 0, 0.5)
 *
 * @param nodes - Array of CSS AST nodes from function arguments
 * @returns Result containing parsed RGBColor or error message
 *
 * @internal
 */
function parseRGBArguments(nodes: csstree.CssNode[]): Result<RGBColor, string> {
	// Check if we have comma separators (legacy syntax)
	const hasComma = nodes.some((node) => node.type === "Operator" && "value" in node && node.value === ",");

	if (hasComma) {
		return parseCommaRGB(nodes);
	}
	return parseSpaceRGB(nodes);
}

/**
 * Parse space-separated RGB syntax: rgb(255 0 0) or rgb(255 0 0 / 0.5)
 *
 * @internal
 */
function parseSpaceRGB(nodes: csstree.CssNode[]): Result<RGBColor, string> {
	const values: number[] = [];
	let alpha: number | undefined;
	let foundSlash = false;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			const alphaResult = ParseUtils.parseAlpha(node);
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			break;
		}

		// Parse RGB component (number or percentage)
		const componentResult = parseRGBComponent(node);
		if (!componentResult.ok) {
			return err(componentResult.error);
		}
		values.push(componentResult.value);
	}

	if (values.length !== 3) {
		return err(`Expected 3 RGB values, got ${values.length}`);
	}

	const [r, g, b] = values;
	if (r === undefined || g === undefined || b === undefined) {
		return err("Missing RGB values");
	}

	const color: RGBColor = { kind: "rgb", r, g, b };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse comma-separated RGB syntax: rgb(255, 0, 0) or rgba(255, 0, 0, 0.5)
 *
 * @internal
 */
function parseCommaRGB(nodes: csstree.CssNode[]): Result<RGBColor, string> {
	// Filter out comma operators
	const valueNodes = nodes.filter((node) => !(node.type === "Operator" && "value" in node && node.value === ","));

	if (valueNodes.length !== 3 && valueNodes.length !== 4) {
		return err(`Expected 3 or 4 values (R, G, B, [A]), got ${valueNodes.length}`);
	}

	const values: number[] = [];

	// Parse RGB components
	for (let i = 0; i < 3; i++) {
		const node = valueNodes[i];
		if (!node) {
			return err(`Missing RGB component at position ${i}`);
		}
		const componentResult = parseRGBComponent(node);
		if (!componentResult.ok) {
			return err(componentResult.error);
		}
		values.push(componentResult.value);
	}

	const [r, g, b] = values;
	if (r === undefined || g === undefined || b === undefined) {
		return err("Missing RGB values");
	}

	const color: RGBColor = { kind: "rgb", r, g, b };

	// Parse alpha if present (4th value)
	if (valueNodes.length === 4) {
		const alphaNode = valueNodes[3];
		if (!alphaNode) {
			return err("Invalid alpha value");
		}
		const alphaResult = ParseUtils.parseAlpha(alphaNode);
		if (!alphaResult.ok) {
			return err(alphaResult.error);
		}
		color.alpha = alphaResult.value;
	}

	return ok(color);
}

/**
 * Parse an RGB component (R, G, or B value).
 *
 * Accepts:
 * - Integer: 0-255 (values are clamped to range after rounding)
 * - Percentage: 0%-100% (converted to 0-255, clamped)
 *
 * @internal
 */
function parseRGBComponent(node: csstree.CssNode): Result<number, string> {
	// Try parsing as number (0-255)
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Round first, then clamp to 0-255 range
		const rounded = Math.round(value);
		const clamped = Math.max(0, Math.min(255, rounded));
		return ok(clamped);
	}

	// Try parsing as percentage (0%-100%)
	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value");
		}
		// Convert percentage to 0-255 range, then clamp
		const converted = (value / 100) * 255;
		const rounded = Math.round(converted);
		const clamped = Math.max(0, Math.min(255, rounded));
		return ok(clamped);
	}

	return err(`Expected number or percentage for RGB component, got ${node.type}`);
}


=== File: src/parse/color/special.test.ts ===
// b_path:: src/parse/color/special.test.ts
import { describe, expect, it } from "vitest";
import * as SpecialGenerator from "@/generate/color/special";
import * as SpecialParser from "./special";

describe("Special Color Parser", () => {
	describe("valid special color keywords", () => {
		it("should parse transparent", () => {
			const result = SpecialParser.parse("transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "special",
					keyword: "transparent",
				});
			}
		});

		it("should parse currentcolor", () => {
			const result = SpecialParser.parse("currentcolor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "special",
					keyword: "currentcolor",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse TRANSPARENT in uppercase", () => {
			const result = SpecialParser.parse("TRANSPARENT");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("transparent");
			}
		});

		it("should parse CurrentColor in mixed case", () => {
			const result = SpecialParser.parse("CurrentColor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("currentcolor");
			}
		});

		it("should parse CURRENTCOLOR in uppercase", () => {
			const result = SpecialParser.parse("CURRENTCOLOR");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("currentcolor");
			}
		});

		it("should parse Transparent in mixed case", () => {
			const result = SpecialParser.parse("Transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("transparent");
			}
		});
	});

	describe("whitespace handling", () => {
		it("should handle leading whitespace", () => {
			const result = SpecialParser.parse("  transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("transparent");
			}
		});

		it("should handle trailing whitespace", () => {
			const result = SpecialParser.parse("currentcolor  ");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("currentcolor");
			}
		});

		it("should handle leading and trailing whitespace", () => {
			const result = SpecialParser.parse("  transparent  ");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("transparent");
			}
		});
	});

	describe("error handling", () => {
		it("should reject invalid keyword", () => {
			const result = SpecialParser.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("should reject named color", () => {
			const result = SpecialParser.parse("red");
			expect(result.ok).toBe(false);
		});

		it("should reject system color", () => {
			const result = SpecialParser.parse("ButtonText");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = SpecialParser.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject whitespace only", () => {
			const result = SpecialParser.parse("   ");
			expect(result.ok).toBe(false);
		});

		it("should reject partial match", () => {
			const result = SpecialParser.parse("trans");
			expect(result.ok).toBe(false);
		});

		it("should reject similar keyword", () => {
			const result = SpecialParser.parse("current");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip (parse -> generate -> parse)", () => {
		it("should round-trip transparent", () => {
			const input = "transparent";
			const parsed = SpecialParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = SpecialGenerator.toCss(parsed.value);
				expect(generated).toBe("transparent");
				const reparsed = SpecialParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip currentcolor", () => {
			const input = "currentcolor";
			const parsed = SpecialParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = SpecialGenerator.toCss(parsed.value);
				expect(generated).toBe("currentcolor");
				const reparsed = SpecialParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should normalize case in round-trip", () => {
			const input = "TRANSPARENT";
			const parsed = SpecialParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = SpecialGenerator.toCss(parsed.value);
				expect(generated).toBe("transparent");
				const reparsed = SpecialParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should normalize CurrentColor case in round-trip", () => {
			const input = "CurrentColor";
			const parsed = SpecialParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = SpecialGenerator.toCss(parsed.value);
				expect(generated).toBe("currentcolor");
				const reparsed = SpecialParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});

	describe("semantic meaning", () => {
		it("should parse transparent (fully transparent color)", () => {
			const result = SpecialParser.parse("transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("special");
				expect(result.value.keyword).toBe("transparent");
			}
		});

		it("should parse currentcolor (current color property value)", () => {
			const result = SpecialParser.parse("currentcolor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("special");
				expect(result.value.keyword).toBe("currentcolor");
			}
		});
	});
});


=== File: src/parse/color/special.ts ===
// b_path:: src/parse/color/special.ts

import { SPECIAL_COLOR_KEYWORDS } from "@/core/keywords/color-keywords";
import { err, ok, type Result } from "@/core/result";
import type { SpecialColor } from "@/core/types/color";

/**
 * Parse a CSS special color keyword.
 *
 * Special color keywords have unique behavior:
 * - `transparent`: Fully transparent color (rgba(0, 0, 0, 0))
 * - `currentcolor`: Uses the current value of the color property
 *
 * These values are case-insensitive.
 *
 * @param input - The special color keyword to parse
 * @returns Result containing the parsed SpecialColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/special";
 *
 * const color1 = parse("transparent");
 * // => { ok: true, value: { kind: "special", keyword: "transparent" } }
 *
 * const color2 = parse("CurrentColor"); // case-insensitive
 * // => { ok: true, value: { kind: "special", keyword: "currentcolor" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<SpecialColor, string> {
	const trimmed = input.trim();

	// Special color keywords are case-insensitive in CSS
	const lowerInput = trimmed.toLowerCase();

	// Check if it's a valid special color keyword
	if (SPECIAL_COLOR_KEYWORDS.includes(lowerInput as (typeof SPECIAL_COLOR_KEYWORDS)[number])) {
		return ok({
			kind: "special",
			keyword: lowerInput as "transparent" | "currentcolor",
		});
	}

	return err(`Invalid special color keyword: ${trimmed}`);
}


=== File: src/parse/color/system.test.ts ===
// b_path:: src/parse/color/system.test.ts
import { describe, expect, it } from "vitest";
import * as SystemGenerator from "@/generate/color/system";
import * as SystemParser from "./system";

describe("System Color Parser", () => {
	describe("valid system color keywords", () => {
		it("should parse AccentColor", () => {
			const result = SystemParser.parse("AccentColor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "AccentColor",
				});
			}
		});

		it("should parse AccentColorText", () => {
			const result = SystemParser.parse("AccentColorText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "AccentColorText",
				});
			}
		});

		it("should parse ButtonText", () => {
			const result = SystemParser.parse("ButtonText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "ButtonText",
				});
			}
		});

		it("should parse Canvas", () => {
			const result = SystemParser.parse("Canvas");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "Canvas",
				});
			}
		});

		it("should parse CanvasText", () => {
			const result = SystemParser.parse("CanvasText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "CanvasText",
				});
			}
		});

		it("should parse LinkText", () => {
			const result = SystemParser.parse("LinkText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "LinkText",
				});
			}
		});

		it("should parse VisitedText", () => {
			const result = SystemParser.parse("VisitedText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "VisitedText",
				});
			}
		});

		it("should parse Highlight", () => {
			const result = SystemParser.parse("Highlight");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "Highlight",
				});
			}
		});

		it("should parse HighlightText", () => {
			const result = SystemParser.parse("HighlightText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "HighlightText",
				});
			}
		});

		it("should parse GrayText", () => {
			const result = SystemParser.parse("GrayText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "system",
					keyword: "GrayText",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse lowercase buttontext", () => {
			const result = SystemParser.parse("buttontext");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("ButtonText");
			}
		});

		it("should parse uppercase CANVAS", () => {
			const result = SystemParser.parse("CANVAS");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("Canvas");
			}
		});

		it("should parse mixed case lInKtExT", () => {
			const result = SystemParser.parse("lInKtExT");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("LinkText");
			}
		});
	});

	describe("whitespace handling", () => {
		it("should handle leading whitespace", () => {
			const result = SystemParser.parse("  ButtonText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("ButtonText");
			}
		});

		it("should handle trailing whitespace", () => {
			const result = SystemParser.parse("Canvas  ");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("Canvas");
			}
		});

		it("should handle leading and trailing whitespace", () => {
			const result = SystemParser.parse("  LinkText  ");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe("LinkText");
			}
		});
	});

	describe("error handling", () => {
		it("should reject invalid keyword", () => {
			const result = SystemParser.parse("InvalidColor");
			expect(result.ok).toBe(false);
		});

		it("should reject named color as system color", () => {
			const result = SystemParser.parse("red");
			expect(result.ok).toBe(false);
		});

		it("should reject special color as system color", () => {
			const result = SystemParser.parse("transparent");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = SystemParser.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject whitespace only", () => {
			const result = SystemParser.parse("   ");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip (parse -> generate -> parse)", () => {
		it("should round-trip ButtonText", () => {
			const input = "ButtonText";
			const parsed = SystemParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = SystemGenerator.toCss(parsed.value);
				const reparsed = SystemParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip Canvas", () => {
			const input = "Canvas";
			const parsed = SystemParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = SystemGenerator.toCss(parsed.value);
				const reparsed = SystemParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip case-insensitive input", () => {
			const input = "linktext";
			const parsed = SystemParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = SystemGenerator.toCss(parsed.value);
				expect(generated).toBe("LinkText");
				const reparsed = SystemParser.parse(generated);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});

	describe("all system color keywords", () => {
		it("should parse all defined system color keywords", () => {
			const keywords = [
				"AccentColor",
				"AccentColorText",
				"ActiveText",
				"ButtonBorder",
				"ButtonFace",
				"ButtonText",
				"Canvas",
				"CanvasText",
				"Field",
				"FieldText",
				"GrayText",
				"Highlight",
				"HighlightText",
				"LinkText",
				"Mark",
				"MarkText",
				"SelectedItem",
				"SelectedItemText",
				"VisitedText",
			];

			for (const keyword of keywords) {
				const result = SystemParser.parse(keyword);
				expect(result.ok).toBe(true);
				if (result.ok) {
					expect(result.value.keyword).toBe(keyword);
				}
			}
		});
	});
});


=== File: src/parse/color/system.ts ===
// b_path:: src/parse/color/system.ts

import { SYSTEM_COLOR_KEYWORDS } from "@/core/keywords/system-color-keywords";
import { err, ok, type Result } from "@/core/result";
import type { SystemColor } from "@/core/types/color";

/**
 * Parse a CSS system color keyword.
 *
 * System colors represent colors from the user's operating system or browser theme.
 * These values are case-insensitive.
 *
 * Supported keywords:
 * - AccentColor, AccentColorText, ActiveText
 * - ButtonBorder, ButtonFace, ButtonText
 * - Canvas, CanvasText
 * - Field, FieldText
 * - GrayText, Highlight, HighlightText
 * - LinkText, Mark, MarkText
 * - SelectedItem, SelectedItemText
 * - VisitedText
 *
 * @param input - The system color keyword to parse
 * @returns Result containing the parsed SystemColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/system";
 *
 * const color1 = parse("ButtonText");
 * // => { ok: true, value: { kind: "system", keyword: "ButtonText" } }
 *
 * const color2 = parse("canvas"); // case-insensitive
 * // => { ok: true, value: { kind: "system", keyword: "Canvas" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<SystemColor, string> {
	const trimmed = input.trim();

	// System color keywords are case-insensitive in CSS
	const lowerInput = trimmed.toLowerCase();

	// Find matching keyword (case-insensitive comparison)
	const matchedKeyword = SYSTEM_COLOR_KEYWORDS.find((keyword) => keyword.toLowerCase() === lowerInput);

	if (matchedKeyword) {
		return ok({ kind: "system", keyword: matchedKeyword });
	}

	return err(`Invalid system color keyword: ${trimmed}`);
}


=== File: src/parse/filter/blur.test.ts ===
// b_path:: src/parse/filter/blur.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/blur";
import { parse } from "./blur";

describe("parse()", () => {
	it("parses blur with px", () => {
		const result = parse("blur(5px)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "blur", radius: { value: 5, unit: "px" } },
		});
	});

	it("parses blur with em", () => {
		const result = parse("blur(1em)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "blur", radius: { value: 1, unit: "em" } },
		});
	});

	it("parses blur with rem", () => {
		const result = parse("blur(2rem)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "blur", radius: { value: 2, unit: "rem" } },
		});
	});

	it("parses blur with 0px", () => {
		const result = parse("blur(0px)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "blur", radius: { value: 0, unit: "px" } },
		});
	});

	it("parses blur with decimal", () => {
		const result = parse("blur(2.5px)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "blur", radius: { value: 2.5, unit: "px" } },
		});
	});

	it("parses blur with vw", () => {
		const result = parse("blur(1vw)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "blur", radius: { value: 1, unit: "vw" } },
		});
	});

	it("rejects blur with negative value", () => {
		const result = parse("blur(-5px)");
		expect(result).toEqual({
			ok: false,
			error: "blur() radius must be non-negative, got -5px",
		});
	});

	it("rejects blur without unit", () => {
		const result = parse("blur(5)");
		expect(result).toEqual({
			ok: false,
			error: "Expected length dimension",
		});
	});

	it("rejects blur with wrong function name", () => {
		const result = parse("brightness(5px)");
		expect(result).toEqual({
			ok: false,
			error: "No function found with name(s): blur",
		});
	});

	it("rejects blur with no arguments", () => {
		const result = parse("blur()");
		expect(result).toEqual({
			ok: false,
			error: "blur() expects 1 argument, got 0",
		});
	});

	it("rejects blur with too many arguments", () => {
		const result = parse("blur(5px, 10px)");
		expect(result).toEqual({
			ok: false,
			error: "blur() expects 1 argument, got 2",
		});
	});

	it("rejects blur with percentage", () => {
		const result = parse("blur(50%)");
		expect(result).toEqual({
			ok: false,
			error: "Expected length dimension",
		});
	});
});

describe("toCss()", () => {
	it("generates CSS for blur with px", () => {
		const css = toCss({ kind: "blur", radius: { value: 5, unit: "px" } });
		expect(css).toBe("blur(5px)");
	});

	it("generates CSS for blur with em", () => {
		const css = toCss({ kind: "blur", radius: { value: 1, unit: "em" } });
		expect(css).toBe("blur(1em)");
	});

	it("generates CSS for blur with 0px", () => {
		const css = toCss({ kind: "blur", radius: { value: 0, unit: "px" } });
		expect(css).toBe("blur(0px)");
	});
});

describe("round-trip", () => {
	it("round-trips blur(5px)", () => {
		const input = "blur(5px)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips blur(1em)", () => {
		const input = "blur(1em)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips blur(2.5px)", () => {
		const input = "blur(2.5px)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});
});


=== File: src/parse/filter/blur.ts ===
// b_path:: src/parse/filter/blur.ts
import { err, ok, type Result } from "@/core/result";
import type { BlurFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS blur() filter function.
 *
 * Parses blur filter with length value (px, em, rem, etc.).
 * Value: Length dimension representing blur radius.
 * Negative values are not allowed.
 *
 * @param input - CSS string like "blur(5px)" or "blur(1rem)"
 * @returns Result with BlurFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/blur";
 *
 * const result = parse("blur(5px)");
 * // { ok: true, value: { kind: "blur", radius: { value: 5, unit: "px" } } }
 *
 * const result2 = parse("blur(1rem)");
 * // { ok: true, value: { kind: "blur", radius: { value: 1, unit: "rem" } } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<BlurFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find blur() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "blur");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`blur() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("blur() expects 1 argument");
	}

	// Parse length value
	const lengthResult = ParseUtils.parseLengthNode(valueNode);
	if (!lengthResult.ok) {
		return err(lengthResult.error);
	}

	const radius = lengthResult.value;

	// Validate non-negative
	if (radius.value < 0) {
		return err(`blur() radius must be non-negative, got ${radius.value}${radius.unit}`);
	}

	return ok({ kind: "blur", radius });
}


=== File: src/parse/filter/brightness.test.ts ===
// b_path:: src/parse/filter/brightness.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/brightness";
import { parse } from "./brightness";

describe("parse()", () => {
	it("parses brightness with number", () => {
		const result = parse("brightness(1.5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "brightness", value: 1.5 },
		});
	});

	it("parses brightness with percentage", () => {
		const result = parse("brightness(150%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "brightness", value: 1.5 },
		});
	});

	it("parses brightness(0)", () => {
		const result = parse("brightness(0)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "brightness", value: 0 },
		});
	});

	it("parses brightness(1)", () => {
		const result = parse("brightness(1)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "brightness", value: 1 },
		});
	});

	it("parses brightness with 100%", () => {
		const result = parse("brightness(100%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "brightness", value: 1 },
		});
	});

	it("parses brightness with 50%", () => {
		const result = parse("brightness(50%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "brightness", value: 0.5 },
		});
	});

	it("parses brightness with large value", () => {
		const result = parse("brightness(5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "brightness", value: 5 },
		});
	});

	it("rejects negative value", () => {
		const result = parse("brightness(-1)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("non-negative");
		}
	});

	it("rejects wrong function name", () => {
		const result = parse("contrast(1.5)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("brightness");
		}
	});

	it("rejects no arguments", () => {
		const result = parse("brightness()");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("1 argument");
		}
	});

	it("rejects multiple arguments", () => {
		const result = parse("brightness(1, 2)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("1 argument");
		}
	});

	it("rejects invalid value type", () => {
		const result = parse("brightness(red)");
		expect(result.ok).toBe(false);
	});
});

describe("toCss()", () => {
	it("generates CSS for brightness", () => {
		const css = toCss({ kind: "brightness", value: 1.5 });
		expect(css).toBe("brightness(1.5)");
	});

	it("generates CSS for brightness(0)", () => {
		const css = toCss({ kind: "brightness", value: 0 });
		expect(css).toBe("brightness(0)");
	});

	it("generates CSS for brightness(1)", () => {
		const css = toCss({ kind: "brightness", value: 1 });
		expect(css).toBe("brightness(1)");
	});

	it("generates CSS for fractional value", () => {
		const css = toCss({ kind: "brightness", value: 0.5 });
		expect(css).toBe("brightness(0.5)");
	});
});

describe("round-trip", () => {
	it("round-trip: parse → generate → parse", () => {
		const input = "brightness(1.5)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});

	it("round-trip: percentage normalizes to number", () => {
		const input = "brightness(150%)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		expect(generated).toBe("brightness(1.5)");

		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});
});


=== File: src/parse/filter/brightness.ts ===
// b_path:: src/parse/filter/brightness.ts
import { err, ok, type Result } from "@/core/result";
import type { BrightnessFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS brightness() filter function.
 *
 * Parses brightness filter with number or percentage value.
 * Number values: 1 = 100% brightness (no change)
 * Percentage values: converted to decimal (150% → 1.5)
 * Value range: 0 to infinity (0 = completely black)
 *
 * @param input - CSS string like "brightness(1.5)" or "brightness(150%)"
 * @returns Result with BrightnessFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/brightness";
 *
 * const result = parse("brightness(1.5)");
 * // { ok: true, value: { kind: "brightness", value: 1.5 } }
 *
 * const result2 = parse("brightness(150%)");
 * // { ok: true, value: { kind: "brightness", value: 1.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<BrightnessFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find brightness() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "brightness");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`brightness() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("brightness() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - brightness allows > 100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		if (rawValue < 0) {
			return err(`brightness() value must be non-negative, got ${rawValue}%`);
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (non-negative)
	if (value < 0) {
		return err(`brightness() value must be non-negative, got ${value}`);
	}

	return ok({ kind: "brightness", value });
}


=== File: src/parse/filter/contrast.test.ts ===
// b_path:: src/parse/filter/contrast.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/contrast";
import { parse } from "./contrast";

describe("parse()", () => {
	it("parses contrast with number", () => {
		const result = parse("contrast(1.5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "contrast", value: 1.5 },
		});
	});

	it("parses contrast with percentage", () => {
		const result = parse("contrast(150%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "contrast", value: 1.5 },
		});
	});

	it("parses contrast(0)", () => {
		const result = parse("contrast(0)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "contrast", value: 0 },
		});
	});

	it("parses contrast(1)", () => {
		const result = parse("contrast(1)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "contrast", value: 1 },
		});
	});

	it("parses contrast with 100%", () => {
		const result = parse("contrast(100%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "contrast", value: 1 },
		});
	});

	it("parses contrast with 50%", () => {
		const result = parse("contrast(50%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "contrast", value: 0.5 },
		});
	});

	it("parses contrast with large value", () => {
		const result = parse("contrast(5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "contrast", value: 5 },
		});
	});

	it("rejects negative value", () => {
		const result = parse("contrast(-1)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("non-negative");
		}
	});

	it("rejects wrong function name", () => {
		const result = parse("brightness(1.5)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("contrast");
		}
	});

	it("rejects no arguments", () => {
		const result = parse("contrast()");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("1 argument");
		}
	});

	it("rejects multiple arguments", () => {
		const result = parse("contrast(1, 2)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("1 argument");
		}
	});

	it("rejects invalid value type", () => {
		const result = parse("contrast(red)");
		expect(result.ok).toBe(false);
	});
});

describe("toCss()", () => {
	it("generates CSS for contrast", () => {
		const css = toCss({ kind: "contrast", value: 1.5 });
		expect(css).toBe("contrast(1.5)");
	});

	it("generates CSS for contrast(0)", () => {
		const css = toCss({ kind: "contrast", value: 0 });
		expect(css).toBe("contrast(0)");
	});

	it("generates CSS for contrast(1)", () => {
		const css = toCss({ kind: "contrast", value: 1 });
		expect(css).toBe("contrast(1)");
	});

	it("generates CSS for fractional value", () => {
		const css = toCss({ kind: "contrast", value: 0.5 });
		expect(css).toBe("contrast(0.5)");
	});
});

describe("round-trip", () => {
	it("round-trip: parse → generate → parse", () => {
		const input = "contrast(1.5)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});

	it("round-trip: percentage normalizes to number", () => {
		const input = "contrast(150%)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		expect(generated).toBe("contrast(1.5)");

		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});
});


=== File: src/parse/filter/contrast.ts ===
// b_path:: src/parse/filter/contrast.ts
import { err, ok, type Result } from "@/core/result";
import type { ContrastFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS contrast() filter function.
 *
 * Parses contrast filter with number or percentage value.
 * Number values: 1 = 100% contrast (no change)
 * Percentage values: converted to decimal (150% → 1.5)
 * Value range: 0 to infinity (0 = completely black)
 *
 * @param input - CSS string like "contrast(1.5)" or "contrast(150%)"
 * @returns Result with ContrastFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/contrast";
 *
 * const result = parse("contrast(1.5)");
 * // { ok: true, value: { kind: "contrast", value: 1.5 } }
 *
 * const result2 = parse("contrast(150%)");
 * // { ok: true, value: { kind: "contrast", value: 1.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<ContrastFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find contrast() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "contrast");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`contrast() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("contrast() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - contrast allows > 100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		if (rawValue < 0) {
			return err(`contrast() value must be non-negative, got ${rawValue}%`);
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (non-negative)
	if (value < 0) {
		return err(`contrast() value must be non-negative, got ${value}`);
	}

	return ok({ kind: "contrast", value });
}


=== File: src/parse/filter/drop-shadow.test.ts ===
// b_path:: src/parse/filter/drop-shadow.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/drop-shadow";
import { parse } from "./drop-shadow";

describe("parse()", () => {
	// Basic drop-shadow with just offset values
	it("parses drop-shadow with px offsets", () => {
		const result = parse("drop-shadow(2px 2px)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "px" },
				offsetY: { value: 2, unit: "px" },
			},
		});
	});

	it("parses drop-shadow with em offsets", () => {
		const result = parse("drop-shadow(1em 0.5em)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 1, unit: "em" },
				offsetY: { value: 0.5, unit: "em" },
			},
		});
	});

	it("parses drop-shadow with rem offsets", () => {
		const result = parse("drop-shadow(2rem 1rem)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "rem" },
				offsetY: { value: 1, unit: "rem" },
			},
		});
	});

	it("parses drop-shadow with mixed units", () => {
		const result = parse("drop-shadow(10px 1em)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 10, unit: "px" },
				offsetY: { value: 1, unit: "em" },
			},
		});
	});

	// With blur radius
	it("parses drop-shadow with blur radius", () => {
		const result = parse("drop-shadow(2px 2px 4px)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "px" },
				offsetY: { value: 2, unit: "px" },
				blurRadius: { value: 4, unit: "px" },
			},
		});
	});

	it("parses drop-shadow with blur radius and em", () => {
		const result = parse("drop-shadow(1em 0.5em 0.2em)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 1, unit: "em" },
				offsetY: { value: 0.5, unit: "em" },
				blurRadius: { value: 0.2, unit: "em" },
			},
		});
	});

	// With color
	it("parses drop-shadow with named color", () => {
		const result = parse("drop-shadow(2px 2px black)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "px" },
				offsetY: { value: 2, unit: "px" },
				color: { kind: "named", name: "black" },
			},
		});
	});

	it("parses drop-shadow with hex color", () => {
		const result = parse("drop-shadow(2px 2px #000000)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "px" },
				offsetY: { value: 2, unit: "px" },
				color: { kind: "hex", value: "#000000" },
			},
		});
	});

	it("parses drop-shadow with rgb color", () => {
		const result = parse("drop-shadow(2px 2px rgb(0 0 0))");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "px" },
				offsetY: { value: 2, unit: "px" },
				color: { kind: "rgb", r: 0, g: 0, b: 0 },
			},
		});
	});

	it("parses drop-shadow with rgba color", () => {
		const result = parse("drop-shadow(2px 2px rgba(0 0 0 / 0.5))");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "px" },
				offsetY: { value: 2, unit: "px" },
				color: { kind: "rgb", r: 0, g: 0, b: 0, alpha: 0.5 },
			},
		});
	});

	// With both blur radius and color
	it("parses drop-shadow with blur radius and color", () => {
		const result = parse("drop-shadow(2px 2px 4px black)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "px" },
				offsetY: { value: 2, unit: "px" },
				blurRadius: { value: 4, unit: "px" },
				color: { kind: "named", name: "black" },
			},
		});
	});

	it("parses drop-shadow with blur radius and hex color", () => {
		const result = parse("drop-shadow(1em 0.5em 0.2em #ff0000)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 1, unit: "em" },
				offsetY: { value: 0.5, unit: "em" },
				blurRadius: { value: 0.2, unit: "em" },
				color: { kind: "hex", value: "#FF0000" },
			},
		});
	});

	// Edge cases
	it("parses drop-shadow with 0 values", () => {
		const result = parse("drop-shadow(0px 0px)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 0, unit: "px" },
				offsetY: { value: 0, unit: "px" },
			},
		});
	});

	it("parses drop-shadow with currentcolor", () => {
		const result = parse("drop-shadow(2px 2px currentcolor)");
		expect(result).toEqual({
			ok: true,
			value: {
				kind: "drop-shadow",
				offsetX: { value: 2, unit: "px" },
				offsetY: { value: 2, unit: "px" },
				color: { kind: "special", keyword: "currentcolor" },
			},
		});
	});

	// Error cases
	it("rejects drop-shadow with no arguments", () => {
		const result = parse("drop-shadow()");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() expects at least 2 arguments, got 0",
		});
	});

	it("rejects drop-shadow with only one argument", () => {
		const result = parse("drop-shadow(2px)");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() expects at least 2 arguments, got 1",
		});
	});

	it("rejects drop-shadow with too many arguments", () => {
		const result = parse("drop-shadow(2px 2px 4px black extra)");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() invalid argument: extra. Expected length or color.",
		});
	});

	it("rejects drop-shadow with invalid offset-x", () => {
		const result = parse("drop-shadow(invalid 2px)");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() offset-x: Expected length dimension",
		});
	});

	it("rejects drop-shadow with invalid offset-y", () => {
		const result = parse("drop-shadow(2px invalid)");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() offset-y: Expected length dimension",
		});
	});

	it("rejects drop-shadow with invalid blur radius", () => {
		const result = parse("drop-shadow(2px 2px invalid)");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() invalid argument: invalid. Expected length or color.",
		});
	});

	it("rejects drop-shadow with invalid color", () => {
		const result = parse("drop-shadow(2px 2px 4px invalid-color)");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() invalid argument: invalid-color. Expected length or color.",
		});
	});

	it("rejects drop-shadow with duplicate blur radius", () => {
		const result = parse("drop-shadow(2px 2px 4px 2px)");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() can have at most one blur-radius",
		});
	});

	it("rejects drop-shadow with duplicate color", () => {
		const result = parse("drop-shadow(2px 2px 4px black red)");
		expect(result).toEqual({
			ok: false,
			error: "drop-shadow() can have at most one color",
		});
	});

	it("rejects drop-shadow with wrong function name", () => {
		const result = parse("blur(2px 2px)");
		expect(result).toEqual({
			ok: false,
			error: "No function found with name(s): drop-shadow",
		});
	});
});

describe("toCss()", () => {
	// Basic generation
	it("generates CSS for basic drop-shadow", () => {
		const css = toCss({
			kind: "drop-shadow",
			offsetX: { value: 2, unit: "px" },
			offsetY: { value: 2, unit: "px" },
		});
		expect(css).toBe("drop-shadow(2px 2px)");
	});

	it("generates CSS for drop-shadow with blur radius", () => {
		const css = toCss({
			kind: "drop-shadow",
			offsetX: { value: 2, unit: "px" },
			offsetY: { value: 2, unit: "px" },
			blurRadius: { value: 4, unit: "px" },
		});
		expect(css).toBe("drop-shadow(2px 2px 4px)");
	});

	it("generates CSS for drop-shadow with color", () => {
		const css = toCss({
			kind: "drop-shadow",
			offsetX: { value: 2, unit: "px" },
			offsetY: { value: 2, unit: "px" },
			color: { kind: "named", name: "black" },
		});
		expect(css).toBe("drop-shadow(2px 2px black)");
	});

	it("generates CSS for drop-shadow with blur radius and color", () => {
		const css = toCss({
			kind: "drop-shadow",
			offsetX: { value: 2, unit: "px" },
			offsetY: { value: 2, unit: "px" },
			blurRadius: { value: 4, unit: "px" },
			color: { kind: "named", name: "black" },
		});
		expect(css).toBe("drop-shadow(2px 2px 4px black)");
	});

	// Different units
	it("generates CSS with em units", () => {
		const css = toCss({
			kind: "drop-shadow",
			offsetX: { value: 1, unit: "em" },
			offsetY: { value: 0.5, unit: "em" },
			blurRadius: { value: 0.2, unit: "em" },
			color: { kind: "hex", value: "#FF0000" },
		});
		expect(css).toBe("drop-shadow(1em 0.5em 0.2em #FF0000)");
	});

	// Different color formats
	it("generates CSS with hex color", () => {
		const css = toCss({
			kind: "drop-shadow",
			offsetX: { value: 2, unit: "px" },
			offsetY: { value: 2, unit: "px" },
			color: { kind: "hex", value: "#000000" },
		});
		expect(css).toBe("drop-shadow(2px 2px #000000)");
	});

	it("generates CSS with rgb color", () => {
		const css = toCss({
			kind: "drop-shadow",
			offsetX: { value: 2, unit: "px" },
			offsetY: { value: 2, unit: "px" },
			color: { kind: "rgb", r: 0, g: 0, b: 0 },
		});
		expect(css).toBe("drop-shadow(2px 2px rgb(0 0 0))");
	});

	it("generates CSS with rgba color", () => {
		const css = toCss({
			kind: "drop-shadow",
			offsetX: { value: 2, unit: "px" },
			offsetY: { value: 2, unit: "px" },
			color: { kind: "rgb", r: 0, g: 0, b: 0, alpha: 0.5 },
		});
		expect(css).toBe("drop-shadow(2px 2px rgb(0 0 0 / 0.5))");
	});
});

describe("round-trip", () => {
	it("round-trips basic drop-shadow", () => {
		const input = "drop-shadow(2px 2px)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips drop-shadow with blur radius", () => {
		const input = "drop-shadow(2px 2px 4px)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips drop-shadow with color", () => {
		const input = "drop-shadow(2px 2px black)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips drop-shadow with blur radius and color", () => {
		const input = "drop-shadow(2px 2px 4px black)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips drop-shadow with hex color", () => {
		const input = "drop-shadow(1em 0.5em #FF0000)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips drop-shadow with rgba color", () => {
		const input = "drop-shadow(2px 2px 4px rgb(0 0 0 / 0.5))";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips drop-shadow with currentcolor", () => {
		const input = "drop-shadow(2px 2px currentcolor)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});
});


=== File: src/parse/filter/drop-shadow.ts ===
// b_path:: src/parse/filter/drop-shadow.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import type { DropShadowFilter } from "@/core/types/filter";
import type { Length } from "@/core/types/length-percentage";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import { parseColor } from "@/utils/parse/color";

/**
 * Convert an AST node to string representation for error messages.
 *
 * @param node - CSS AST node
 * @returns String representation of the node
 * @internal
 */
function nodeToString(node: csstree.CssNode): string {
	try {
		return csstree.generate(node);
	} catch {
		return node.type;
	}
}

/**
 * Parse CSS drop-shadow() filter function.
 *
 * Applies a drop shadow effect to the element.
 * Syntax: drop-shadow(offset-x offset-y [blur-radius] [color])
 *
 * @param input - CSS string like "drop-shadow(2px 2px)" or "drop-shadow(2px 2px 4px rgba(0,0,0,0.5))"
 * @returns Result with DropShadowFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/drop-shadow";
 *
 * // Basic drop shadow
 * const result = parse("drop-shadow(2px 2px)");
 * // { ok: true, value: { kind: "drop-shadow", offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" } } }
 *
 * // With blur radius
 * const result2 = parse("drop-shadow(2px 2px 4px)");
 * // { ok: true, value: { kind: "drop-shadow", offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" }, blurRadius: { value: 4, unit: "px" } } }
 *
 * // With color
 * const result3 = parse("drop-shadow(2px 2px 4px black)");
 * // { ok: true, value: { kind: "drop-shadow", offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" }, blurRadius: { value: 4, unit: "px" }, color: { kind: "named", name: "black" } } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<DropShadowFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find drop-shadow() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "drop-shadow");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect at least 2 arguments (offset-x and offset-y are required)
	if (children.length < 2) {
		return err(`drop-shadow() expects at least 2 arguments, got ${children.length}`);
	}

	// Parse arguments - need to identify lengths vs color
	return parseDropShadowArguments(children);
}

/**
 * Parse drop-shadow function arguments from AST nodes.
 *
 * Handles the complexity of identifying which arguments are lengths vs color.
 * Color can appear in any position after the first two required length arguments.
 *
 * @param nodes - Array of CSS AST nodes from function arguments
 * @returns Result containing parsed DropShadowFilter or error message
 *
 * @internal
 */
function parseDropShadowArguments(nodes: csstree.CssNode[]): Result<DropShadowFilter, string> {
	// First two arguments are always offset-x and offset-y (required lengths)
	const firstNode = nodes[0];
	const secondNode = nodes[1];

	if (!firstNode) {
		return err("drop-shadow() missing offset-x");
	}
	if (!secondNode) {
		return err("drop-shadow() missing offset-y");
	}

	const offsetXResult = ParseUtils.parseLengthNode(firstNode);
	if (!offsetXResult.ok) {
		return err(`drop-shadow() offset-x: ${offsetXResult.error}`);
	}

	const offsetYResult = ParseUtils.parseLengthNode(secondNode);
	if (!offsetYResult.ok) {
		return err(`drop-shadow() offset-y: ${offsetYResult.error}`);
	}

	const offsetX = offsetXResult.value;
	const offsetY = offsetYResult.value;

	// Default values
	let blurRadius: Length | undefined;
	let color: Color | undefined;

	// Process remaining arguments (2-4 total, so 0-2 more arguments)
	const remainingNodes = nodes.slice(2);

	// If we have remaining arguments, determine their types
	if (remainingNodes.length > 0) {
		const result = parseRemainingArguments(remainingNodes);
		if (!result.ok) {
			return err(result.error);
		}

		({ blurRadius, color } = result.value);
	}

	return ok({
		kind: "drop-shadow",
		offsetX,
		offsetY,
		blurRadius,
		color,
	});
}

/**
 * Parse the remaining arguments after offset-x and offset-y.
 *
 * Handles the complexity where:
 * - blur-radius is optional length
 * - color is optional and can appear in any position
 * - We need to distinguish between length and color arguments
 *
 * @param nodes - Remaining AST nodes to parse
 * @returns Result with parsed blurRadius and color, or error
 *
 * @internal
 */
function parseRemainingArguments(
	nodes: csstree.CssNode[],
): Result<{ blurRadius: Length | undefined; color: Color | undefined }, string> {
	let blurRadius: Length | undefined;
	let color: Color | undefined;

	// Process each remaining node
	for (const node of nodes) {
		// Skip operators (like commas if present)
		if (node.type === "Operator") {
			continue;
		}

		// Try parsing as length first (for blur-radius)
		const lengthResult = ParseUtils.parseLengthNode(node);
		if (lengthResult.ok) {
			if (blurRadius !== undefined) {
				return err("drop-shadow() can have at most one blur-radius");
			}
			blurRadius = lengthResult.value;
			continue;
		}

		// If not a length, try parsing as color
		const colorResult = parseColor(nodeToString(node));
		if (colorResult.ok) {
			if (color !== undefined) {
				return err("drop-shadow() can have at most one color");
			}
			color = colorResult.value;
			continue;
		}

		// If neither length nor color, it's an invalid argument
		return err(`drop-shadow() invalid argument: ${nodeToString(node)}. Expected length or color.`);
	}

	// Check for too many arguments (more than 2 remaining = more than 4 total)
	if (nodes.length > 2) {
		return err(`drop-shadow() expects at most 4 arguments, got ${nodes.length + 2}`);
	}

	return ok({ blurRadius, color });
}


=== File: src/parse/filter/filter.test.ts ===
// b_path:: src/parse/filter/filter.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./filter";

describe("parse() - unified filter dispatcher", () => {
	describe("auto-detection", () => {
		it("detects blur()", () => {
			const result = parse("blur(5px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("blur");
			}
		});

		it("detects brightness()", () => {
			const result = parse("brightness(1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("brightness");
			}
		});

		it("detects contrast()", () => {
			const result = parse("contrast(200%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("contrast");
			}
		});

		it("detects drop-shadow()", () => {
			const result = parse("drop-shadow(2px 2px 4px black)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("drop-shadow");
			}
		});

		it("detects grayscale()", () => {
			const result = parse("grayscale(50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("grayscale");
			}
		});

		it("detects hue-rotate()", () => {
			const result = parse("hue-rotate(90deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hue-rotate");
			}
		});

		it("detects invert()", () => {
			const result = parse("invert(100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("invert");
			}
		});

		it("detects opacity()", () => {
			const result = parse("opacity(0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("opacity");
			}
		});

		it("detects saturate()", () => {
			const result = parse("saturate(150%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("saturate");
			}
		});

		it("detects sepia()", () => {
			const result = parse("sepia(75%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("sepia");
			}
		});

		it("detects url()", () => {
			const result = parse("url(#filter-id)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("url");
			}
		});
	});

	describe("error handling", () => {
		it("rejects unknown filter function", () => {
			const result = parse("unknown(50%)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown filter function");
			}
		});

		it("rejects invalid syntax", () => {
			const result = parse("not-a-filter");
			expect(result.ok).toBe(false);
		});

		it("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});

	describe("case insensitivity", () => {
		it("handles uppercase function names", () => {
			const result = parse("BLUR(5px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("blur");
			}
		});

		it("handles mixed case function names", () => {
			const result = parse("BrIgHtNeSs(1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("brightness");
			}
		});
	});
});


=== File: src/parse/filter/filter.ts ===
// b_path:: src/parse/filter/filter.ts

import type { CssNode } from "css-tree";
import * as cssTree from "css-tree";
import { err, type ParseResult, parseErr, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as Blur from "./blur";
import * as Brightness from "./brightness";
import * as Contrast from "./contrast";
import * as DropShadow from "./drop-shadow";
import * as Grayscale from "./grayscale";
import * as HueRotate from "./hue-rotate";
import * as Invert from "./invert";
import * as Opacity from "./opacity";
import * as Saturate from "./saturate";
import * as Sepia from "./sepia";
import * as Url from "./url";

/**
 * Parse filter value with auto-detection.
 *
 * Automatically detects and parses any CSS filter function:
 * - blur(), brightness(), contrast(), drop-shadow()
 * - grayscale(), hue-rotate(), invert(), opacity()
 * - saturate(), sepia(), url()
 *
 * @param value - CSS filter value string
 * @returns Result with FilterFunction IR or error
 *
 * @example
 * ```typescript
 * parse("blur(5px)");              // Auto-detects blur
 * parse("brightness(1.5)");        // Auto-detects brightness
 * parse("drop-shadow(2px 2px 4px black)"); // Auto-detects drop-shadow
 * parse("url(#filter)");           // Auto-detects url
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Type.FilterFunction> {
	const ast = cssTree.parse(value, { context: "value" }) as cssTree.Value;
	if (!ast.children) return parseErr("invalid-syntax", "Empty value");
	const first = ast.children.first;
	if (!first) return parseErr("invalid-syntax", "Empty value");
	const result = parseNode(first);
	return toParseResult(result);
}

/**
 * Parse filter AST node with auto-detection.
 *
 * @param node - CSS AST node
 * @returns Result with FilterFunction IR or error
 *
 * @internal
 */
function parseNode(node: CssNode): Result<Type.FilterFunction, string> {
	// URL filter (special case - Url node type)
	if (node.type === "Url") {
		const css = cssTree.generate(node);
		return Url.parse(css);
	}

	// Filter functions
	if (node.type === "Function") {
		const css = cssTree.generate(node);
		switch (node.name.toLowerCase()) {
			case "blur":
				return Blur.parse(css);
			case "brightness":
				return Brightness.parse(css);
			case "contrast":
				return Contrast.parse(css);
			case "drop-shadow":
				return DropShadow.parse(css);
			case "grayscale":
				return Grayscale.parse(css);
			case "hue-rotate":
				return HueRotate.parse(css);
			case "invert":
				return Invert.parse(css);
			case "opacity":
				return Opacity.parse(css);
			case "saturate":
				return Saturate.parse(css);
			case "sepia":
				return Sepia.parse(css);
			default:
				return err(`Unknown filter function: ${node.name}`);
		}
	}

	return err("Invalid filter value");
}


=== File: src/parse/filter/grayscale.test.ts ===
// b_path:: src/parse/filter/grayscale.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/grayscale";
import { parse } from "./grayscale";

describe("parse()", () => {
	it("parses grayscale(0)", () => {
		const result = parse("grayscale(0)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "grayscale", value: 0 },
		});
	});

	it("parses grayscale(0.5)", () => {
		const result = parse("grayscale(0.5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "grayscale", value: 0.5 },
		});
	});

	it("parses grayscale(1)", () => {
		const result = parse("grayscale(1)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "grayscale", value: 1 },
		});
	});

	it("parses grayscale with 50%", () => {
		const result = parse("grayscale(50%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "grayscale", value: 0.5 },
		});
	});

	it("parses grayscale with 100%", () => {
		const result = parse("grayscale(100%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "grayscale", value: 1 },
		});
	});

	it("rejects value > 1", () => {
		const result = parse("grayscale(1.5)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("between 0 and 1");
		}
	});

	it("rejects negative value", () => {
		const result = parse("grayscale(-0.1)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("between 0 and 1");
		}
	});
});

describe("toCss()", () => {
	it("generates CSS for grayscale", () => {
		const css = toCss({ kind: "grayscale", value: 0.5 });
		expect(css).toBe("grayscale(0.5)");
	});

	it("generates CSS for grayscale(0)", () => {
		const css = toCss({ kind: "grayscale", value: 0 });
		expect(css).toBe("grayscale(0)");
	});

	it("generates CSS for grayscale(1)", () => {
		const css = toCss({ kind: "grayscale", value: 1 });
		expect(css).toBe("grayscale(1)");
	});
});

describe("round-trip", () => {
	it("round-trip: parse → generate → parse", () => {
		const input = "grayscale(0.5)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});

	it("round-trip: percentage normalizes to number", () => {
		const input = "grayscale(50%)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		expect(generated).toBe("grayscale(0.5)");

		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});
});


=== File: src/parse/filter/grayscale.ts ===
// b_path:: src/parse/filter/grayscale.ts
import { err, ok, type Result } from "@/core/result";
import type { GrayscaleFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS grayscale() filter function.
 *
 * Parses grayscale filter with number or percentage value.
 * Number values: 0 to 1, where 1 = 100% grayscale
 * Percentage values: converted to decimal (50% → 0.5)
 * Value range: 0 to 1 (clamped)
 *
 * @param input - CSS string like "grayscale(0.5)" or "grayscale(50%)"
 * @returns Result with GrayscaleFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/grayscale";
 *
 * const result = parse("grayscale(0.5)");
 * // { ok: true, value: { kind: "grayscale", value: 0.5 } }
 *
 * const result2 = parse("grayscale(50%)");
 * // { ok: true, value: { kind: "grayscale", value: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<GrayscaleFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find grayscale() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "grayscale");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`grayscale() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("grayscale() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - grayscale bounded 0-100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (0 to 1)
	if (value < 0 || value > 1) {
		return err(`grayscale() value must be between 0 and 1, got ${value}`);
	}

	return ok({ kind: "grayscale", value });
}


=== File: src/parse/filter/hue-rotate.test.ts ===
// b_path:: src/parse/filter/hue-rotate.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/hue-rotate";
import { parse } from "./hue-rotate";

describe("parse()", () => {
	it("parses hue-rotate with deg", () => {
		const result = parse("hue-rotate(90deg)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "hue-rotate", angle: { value: 90, unit: "deg" } },
		});
	});

	it("parses hue-rotate with rad", () => {
		const result = parse("hue-rotate(1.57rad)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "hue-rotate", angle: { value: 1.57, unit: "rad" } },
		});
	});

	it("parses hue-rotate with grad", () => {
		const result = parse("hue-rotate(100grad)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "hue-rotate", angle: { value: 100, unit: "grad" } },
		});
	});

	it("parses hue-rotate with turn", () => {
		const result = parse("hue-rotate(0.5turn)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "hue-rotate", angle: { value: 0.5, unit: "turn" } },
		});
	});

	it("parses hue-rotate with 0deg", () => {
		const result = parse("hue-rotate(0deg)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "hue-rotate", angle: { value: 0, unit: "deg" } },
		});
	});

	it("parses hue-rotate with negative angle", () => {
		const result = parse("hue-rotate(-90deg)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "hue-rotate", angle: { value: -90, unit: "deg" } },
		});
	});

	it("parses hue-rotate with large angle", () => {
		const result = parse("hue-rotate(360deg)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "hue-rotate", angle: { value: 360, unit: "deg" } },
		});
	});

	it("rejects hue-rotate without unit", () => {
		const result = parse("hue-rotate(90)");
		expect(result).toEqual({
			ok: false,
			error: "Expected angle dimension",
		});
	});

	it("rejects hue-rotate with wrong unit", () => {
		const result = parse("hue-rotate(90px)");
		expect(result).toEqual({
			ok: false,
			error: "Invalid angle unit: px",
		});
	});

	it("rejects hue-rotate with wrong function name", () => {
		const result = parse("blur(90deg)");
		expect(result).toEqual({
			ok: false,
			error: "No function found with name(s): hue-rotate",
		});
	});

	it("rejects hue-rotate with no arguments", () => {
		const result = parse("hue-rotate()");
		expect(result).toEqual({
			ok: false,
			error: "hue-rotate() expects 1 argument, got 0",
		});
	});

	it("rejects hue-rotate with too many arguments", () => {
		const result = parse("hue-rotate(90deg, 180deg)");
		expect(result).toEqual({
			ok: false,
			error: "hue-rotate() expects 1 argument, got 2",
		});
	});

	it("rejects hue-rotate with percentage", () => {
		const result = parse("hue-rotate(50%)");
		expect(result).toEqual({
			ok: false,
			error: "Expected angle dimension",
		});
	});
});

describe("toCss()", () => {
	it("generates CSS for hue-rotate with deg", () => {
		const css = toCss({ kind: "hue-rotate", angle: { value: 90, unit: "deg" } });
		expect(css).toBe("hue-rotate(90deg)");
	});

	it("generates CSS for hue-rotate with rad", () => {
		const css = toCss({ kind: "hue-rotate", angle: { value: 1.57, unit: "rad" } });
		expect(css).toBe("hue-rotate(1.57rad)");
	});

	it("generates CSS for hue-rotate with turn", () => {
		const css = toCss({ kind: "hue-rotate", angle: { value: 0.5, unit: "turn" } });
		expect(css).toBe("hue-rotate(0.5turn)");
	});

	it("generates CSS for hue-rotate with 0deg", () => {
		const css = toCss({ kind: "hue-rotate", angle: { value: 0, unit: "deg" } });
		expect(css).toBe("hue-rotate(0deg)");
	});

	it("generates CSS for hue-rotate with negative angle", () => {
		const css = toCss({ kind: "hue-rotate", angle: { value: -90, unit: "deg" } });
		expect(css).toBe("hue-rotate(-90deg)");
	});
});

describe("round-trip", () => {
	it("round-trips hue-rotate(90deg)", () => {
		const input = "hue-rotate(90deg)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips hue-rotate(0.5turn)", () => {
		const input = "hue-rotate(0.5turn)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips hue-rotate(-90deg)", () => {
		const input = "hue-rotate(-90deg)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});

	it("round-trips hue-rotate(1.57rad)", () => {
		const input = "hue-rotate(1.57rad)";
		const result = parse(input);
		expect(result.ok).toBe(true);
		if (result.ok) {
			const css = toCss(result.value);
			expect(css).toBe(input);
			const result2 = parse(css);
			expect(result2).toEqual(result);
		}
	});
});


=== File: src/parse/filter/hue-rotate.ts ===
// b_path:: src/parse/filter/hue-rotate.ts
import { err, ok, type Result } from "@/core/result";
import type { HueRotateFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS hue-rotate() filter function.
 *
 * Parses hue-rotate filter with angle value (deg, grad, rad, turn).
 * Value: Angle dimension representing hue rotation.
 * Any angle value is allowed (positive or negative).
 *
 * @param input - CSS string like "hue-rotate(90deg)" or "hue-rotate(0.5turn)"
 * @returns Result with HueRotateFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/hue-rotate";
 *
 * const result = parse("hue-rotate(90deg)");
 * // { ok: true, value: { kind: "hue-rotate", angle: { value: 90, unit: "deg" } } }
 *
 * const result2 = parse("hue-rotate(0.5turn)");
 * // { ok: true, value: { kind: "hue-rotate", angle: { value: 0.5, unit: "turn" } } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<HueRotateFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find hue-rotate() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "hue-rotate");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`hue-rotate() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("hue-rotate() expects 1 argument");
	}

	// Parse angle value
	const angleResult = ParseUtils.parseAngleNode(valueNode);
	if (!angleResult.ok) {
		return err(angleResult.error);
	}

	const angle = angleResult.value;

	return ok({ kind: "hue-rotate", angle });
}


=== File: src/parse/filter/index.ts ===
// b_path:: src/parse/filter/index.ts

/**
 * CSS filter parsers - convert filter strings to structured IR.
 *
 * All filter parsers return Result<T, string> for type-safe error handling.
 *
 * @module Parse.Filter
 * @public
 */

/**
 * Parse blur filter functions.
 *
 * @see {@link Blur.parse}
 */
export * as Blur from "./blur";
/**
 * Parse brightness filter functions.
 *
 * @see {@link Brightness.parse}
 */
export * as Brightness from "./brightness";
/**
 * Parse contrast filter functions.
 *
 * @see {@link Contrast.parse}
 */
export * as Contrast from "./contrast";
/**
 * Parse drop-shadow filter functions.
 *
 * @see {@link DropShadow.parse}
 */
export * as DropShadow from "./drop-shadow";
/**
 * Unified filter dispatcher with auto-detection.
 *
 * @see {@link module:Parse.Filter}
 */
export { parse } from "./filter";
/**
 * Parse grayscale filter functions.
 *
 * @see {@link Grayscale.parse}
 */
export * as Grayscale from "./grayscale";
/**
 * Parse hue-rotate filter functions.
 *
 * @see {@link HueRotate.parse}
 */
export * as HueRotate from "./hue-rotate";
/**
 * Parse invert filter functions.
 *
 * @see {@link Invert.parse}
 */
export * as Invert from "./invert";
/**
 * Parse opacity filter functions.
 *
 * @see {@link Opacity.parse}
 */
export * as Opacity from "./opacity";
/**
 * Parse saturate filter functions.
 *
 * @see {@link Saturate.parse}
 */
export * as Saturate from "./saturate";
/**
 * Parse sepia filter functions.
 *
 * @see {@link Sepia.parse}
 */
export * as Sepia from "./sepia";
/**
 * Parse URL filter functions.
 *
 * @see {@link Url.parse}
 */
export * as Url from "./url";


=== File: src/parse/filter/invert.test.ts ===
// b_path:: src/parse/filter/invert.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/invert";
import { parse } from "./invert";

describe("parse()", () => {
	it("parses invert(0)", () => {
		const result = parse("invert(0)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "invert", value: 0 },
		});
	});

	it("parses invert(0.5)", () => {
		const result = parse("invert(0.5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "invert", value: 0.5 },
		});
	});

	it("parses invert(1)", () => {
		const result = parse("invert(1)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "invert", value: 1 },
		});
	});

	it("parses invert with 50%", () => {
		const result = parse("invert(50%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "invert", value: 0.5 },
		});
	});

	it("parses invert with 100%", () => {
		const result = parse("invert(100%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "invert", value: 1 },
		});
	});

	it("rejects value > 1", () => {
		const result = parse("invert(1.5)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("between 0 and 1");
		}
	});

	it("rejects negative value", () => {
		const result = parse("invert(-0.1)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("between 0 and 1");
		}
	});
});

describe("toCss()", () => {
	it("generates CSS for invert", () => {
		const css = toCss({ kind: "invert", value: 0.5 });
		expect(css).toBe("invert(0.5)");
	});

	it("generates CSS for invert(0)", () => {
		const css = toCss({ kind: "invert", value: 0 });
		expect(css).toBe("invert(0)");
	});

	it("generates CSS for invert(1)", () => {
		const css = toCss({ kind: "invert", value: 1 });
		expect(css).toBe("invert(1)");
	});
});

describe("round-trip", () => {
	it("round-trip: parse → generate → parse", () => {
		const input = "invert(0.5)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});

	it("round-trip: percentage normalizes to number", () => {
		const input = "invert(50%)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		expect(generated).toBe("invert(0.5)");

		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});
});


=== File: src/parse/filter/invert.ts ===
// b_path:: src/parse/filter/invert.ts
import { err, ok, type Result } from "@/core/result";
import type { InvertFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS invert() filter function.
 *
 * Parses invert filter with number or percentage value.
 * Number values: 0 to 1, where 1 = 100% invert
 * Percentage values: converted to decimal (50% → 0.5)
 * Value range: 0 to 1 (clamped)
 *
 * @param input - CSS string like "invert(0.5)" or "invert(50%)"
 * @returns Result with InvertFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/invert";
 *
 * const result = parse("invert(0.5)");
 * // { ok: true, value: { kind: "invert", value: 0.5 } }
 *
 * const result2 = parse("invert(50%)");
 * // { ok: true, value: { kind: "invert", value: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<InvertFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find invert() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "invert");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`invert() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("invert() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - invert bounded 0-100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (0 to 1)
	if (value < 0 || value > 1) {
		return err(`invert() value must be between 0 and 1, got ${value}`);
	}

	return ok({ kind: "invert", value });
}


=== File: src/parse/filter/opacity.test.ts ===
// b_path:: src/parse/filter/opacity.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/opacity";
import { parse } from "./opacity";

describe("parse()", () => {
	it("parses opacity(0)", () => {
		const result = parse("opacity(0)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "opacity", value: 0 },
		});
	});

	it("parses opacity(0.5)", () => {
		const result = parse("opacity(0.5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "opacity", value: 0.5 },
		});
	});

	it("parses opacity(1)", () => {
		const result = parse("opacity(1)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "opacity", value: 1 },
		});
	});

	it("parses opacity with 50%", () => {
		const result = parse("opacity(50%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "opacity", value: 0.5 },
		});
	});

	it("parses opacity with 100%", () => {
		const result = parse("opacity(100%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "opacity", value: 1 },
		});
	});

	it("rejects value > 1", () => {
		const result = parse("opacity(1.5)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("between 0 and 1");
		}
	});

	it("rejects negative value", () => {
		const result = parse("opacity(-0.1)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("between 0 and 1");
		}
	});
});

describe("toCss()", () => {
	it("generates CSS for opacity", () => {
		const css = toCss({ kind: "opacity", value: 0.5 });
		expect(css).toBe("opacity(0.5)");
	});

	it("generates CSS for opacity(0)", () => {
		const css = toCss({ kind: "opacity", value: 0 });
		expect(css).toBe("opacity(0)");
	});

	it("generates CSS for opacity(1)", () => {
		const css = toCss({ kind: "opacity", value: 1 });
		expect(css).toBe("opacity(1)");
	});
});

describe("round-trip", () => {
	it("round-trip: parse → generate → parse", () => {
		const input = "opacity(0.5)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});

	it("round-trip: percentage normalizes to number", () => {
		const input = "opacity(50%)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		expect(generated).toBe("opacity(0.5)");

		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});
});


=== File: src/parse/filter/opacity.ts ===
// b_path:: src/parse/filter/opacity.ts
import { err, ok, type Result } from "@/core/result";
import type { OpacityFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS opacity() filter function.
 *
 * Parses opacity filter with number or percentage value.
 * Number values: 0 to 1, where 1 = 100% opacity
 * Percentage values: converted to decimal (50% → 0.5)
 * Value range: 0 to 1 (clamped)
 *
 * @param input - CSS string like "opacity(0.5)" or "opacity(50%)"
 * @returns Result with OpacityFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/opacity}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/opacity";
 *
 * const result = parse("opacity(0.5)");
 * // { ok: true, value: { kind: "opacity", value: 0.5 } }
 *
 * const result2 = parse("opacity(50%)");
 * // { ok: true, value: { kind: "opacity", value: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<OpacityFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find opacity() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "opacity");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`opacity() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("opacity() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - opacity bounded 0-100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (0 to 1)
	if (value < 0 || value > 1) {
		return err(`opacity() value must be between 0 and 1, got ${value}`);
	}

	return ok({ kind: "opacity", value });
}


=== File: src/parse/filter/saturate.test.ts ===
// b_path:: src/parse/filter/saturate.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/saturate";
import { parse } from "./saturate";

describe("parse()", () => {
	it("parses saturate with number", () => {
		const result = parse("saturate(1.5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "saturate", value: 1.5 },
		});
	});

	it("parses saturate with percentage", () => {
		const result = parse("saturate(150%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "saturate", value: 1.5 },
		});
	});

	it("parses saturate(0)", () => {
		const result = parse("saturate(0)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "saturate", value: 0 },
		});
	});

	it("parses saturate(1)", () => {
		const result = parse("saturate(1)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "saturate", value: 1 },
		});
	});

	it("parses saturate with 100%", () => {
		const result = parse("saturate(100%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "saturate", value: 1 },
		});
	});

	it("parses saturate with 50%", () => {
		const result = parse("saturate(50%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "saturate", value: 0.5 },
		});
	});

	it("parses saturate with large value", () => {
		const result = parse("saturate(5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "saturate", value: 5 },
		});
	});

	it("rejects negative value", () => {
		const result = parse("saturate(-1)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("non-negative");
		}
	});

	it("rejects wrong function name", () => {
		const result = parse("brightness(1.5)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("saturate");
		}
	});

	it("rejects no arguments", () => {
		const result = parse("saturate()");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("1 argument");
		}
	});

	it("rejects multiple arguments", () => {
		const result = parse("saturate(1, 2)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("1 argument");
		}
	});

	it("rejects invalid value type", () => {
		const result = parse("saturate(red)");
		expect(result.ok).toBe(false);
	});
});

describe("toCss()", () => {
	it("generates CSS for saturate", () => {
		const css = toCss({ kind: "saturate", value: 1.5 });
		expect(css).toBe("saturate(1.5)");
	});

	it("generates CSS for saturate(0)", () => {
		const css = toCss({ kind: "saturate", value: 0 });
		expect(css).toBe("saturate(0)");
	});

	it("generates CSS for saturate(1)", () => {
		const css = toCss({ kind: "saturate", value: 1 });
		expect(css).toBe("saturate(1)");
	});

	it("generates CSS for fractional value", () => {
		const css = toCss({ kind: "saturate", value: 0.5 });
		expect(css).toBe("saturate(0.5)");
	});
});

describe("round-trip", () => {
	it("round-trip: parse → generate → parse", () => {
		const input = "saturate(1.5)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});

	it("round-trip: percentage normalizes to number", () => {
		const input = "saturate(150%)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		expect(generated).toBe("saturate(1.5)");

		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});
});


=== File: src/parse/filter/saturate.ts ===
// b_path:: src/parse/filter/saturate.ts
import { err, ok, type Result } from "@/core/result";
import type { SaturateFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS saturate() filter function.
 *
 * Parses saturate filter with number or percentage value.
 * Number values: 1 = 100% saturate (no change)
 * Percentage values: converted to decimal (150% → 1.5)
 * Value range: 0 to infinity (0 = completely black)
 *
 * @param input - CSS string like "saturate(1.5)" or "saturate(150%)"
 * @returns Result with SaturateFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/saturate";
 *
 * const result = parse("saturate(1.5)");
 * // { ok: true, value: { kind: "saturate", value: 1.5 } }
 *
 * const result2 = parse("saturate(150%)");
 * // { ok: true, value: { kind: "saturate", value: 1.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<SaturateFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find saturate() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "saturate");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`saturate() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("saturate() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - saturate allows > 100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		if (rawValue < 0) {
			return err(`saturate() value must be non-negative, got ${rawValue}%`);
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (non-negative)
	if (value < 0) {
		return err(`saturate() value must be non-negative, got ${value}`);
	}

	return ok({ kind: "saturate", value });
}


=== File: src/parse/filter/sepia.test.ts ===
// b_path:: src/parse/filter/sepia.test.ts
import { describe, expect, it } from "vitest";
import { toCss } from "@/generate/filter/sepia";
import { parse } from "./sepia";

describe("parse()", () => {
	it("parses sepia(0)", () => {
		const result = parse("sepia(0)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "sepia", value: 0 },
		});
	});

	it("parses sepia(0.5)", () => {
		const result = parse("sepia(0.5)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "sepia", value: 0.5 },
		});
	});

	it("parses sepia(1)", () => {
		const result = parse("sepia(1)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "sepia", value: 1 },
		});
	});

	it("parses sepia with 50%", () => {
		const result = parse("sepia(50%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "sepia", value: 0.5 },
		});
	});

	it("parses sepia with 100%", () => {
		const result = parse("sepia(100%)");
		expect(result).toEqual({
			ok: true,
			value: { kind: "sepia", value: 1 },
		});
	});

	it("rejects value > 1", () => {
		const result = parse("sepia(1.5)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("between 0 and 1");
		}
	});

	it("rejects negative value", () => {
		const result = parse("sepia(-0.1)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("between 0 and 1");
		}
	});
});

describe("toCss()", () => {
	it("generates CSS for sepia", () => {
		const css = toCss({ kind: "sepia", value: 0.5 });
		expect(css).toBe("sepia(0.5)");
	});

	it("generates CSS for sepia(0)", () => {
		const css = toCss({ kind: "sepia", value: 0 });
		expect(css).toBe("sepia(0)");
	});

	it("generates CSS for sepia(1)", () => {
		const css = toCss({ kind: "sepia", value: 1 });
		expect(css).toBe("sepia(1)");
	});
});

describe("round-trip", () => {
	it("round-trip: parse → generate → parse", () => {
		const input = "sepia(0.5)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});

	it("round-trip: percentage normalizes to number", () => {
		const input = "sepia(50%)";
		const parsed = parse(input);
		expect(parsed.ok).toBe(true);
		if (!parsed.ok) return;

		const generated = toCss(parsed.value);
		expect(generated).toBe("sepia(0.5)");

		const reparsed = parse(generated);
		expect(reparsed).toEqual(parsed);
	});
});


=== File: src/parse/filter/sepia.ts ===
// b_path:: src/parse/filter/sepia.ts
import { err, ok, type Result } from "@/core/result";
import type { SepiaFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS sepia() filter function.
 *
 * Parses sepia filter with number or percentage value.
 * Number values: 0 to 1, where 1 = 100% sepia
 * Percentage values: converted to decimal (50% → 0.5)
 * Value range: 0 to 1 (clamped)
 *
 * @param input - CSS string like "sepia(0.5)" or "sepia(50%)"
 * @returns Result with SepiaFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/sepia";
 *
 * const result = parse("sepia(0.5)");
 * // { ok: true, value: { kind: "sepia", value: 0.5 } }
 *
 * const result2 = parse("sepia(50%)");
 * // { ok: true, value: { kind: "sepia", value: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<SepiaFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find sepia() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "sepia");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`sepia() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("sepia() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - sepia bounded 0-100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (0 to 1)
	if (value < 0 || value > 1) {
		return err(`sepia() value must be between 0 and 1, got ${value}`);
	}

	return ok({ kind: "sepia", value });
}


=== File: src/parse/filter/url-edge-cases.test.ts ===
// b_path:: src/parse/filter/url-edge-cases.test.ts
import { describe, expect, test } from "vitest";
import { toCss } from "@/generate/filter/url";
import { parse } from "./url";

describe("URL filter edge cases", () => {
	describe("Data URIs", () => {
		test("parses SVG data URI", () => {
			const input = "url(\"data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E\")";
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%3E%3C/svg%3E");
		});

		test("parses base64 data URI", () => {
			const input = 'url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA");
		});
	});

	describe("URLs with special characters", () => {
		test("parses absolute URL without quotes", () => {
			const input = "url(https://example.com/image.png)";
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("https://example.com/image.png");
		});

		test("parses URL with spaces (quoted)", () => {
			const input = 'url("https://example.com/image with spaces.png")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("https://example.com/image with spaces.png");
		});

		test("parses URL with encoded quote", () => {
			const input = "url('https://example.com/image-with-quote%22inside.png')";
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("https://example.com/image-with-quote%22inside.png");
		});
	});

	describe("Escaped characters", () => {
		test("parses URL with escaped space", () => {
			const input = 'url("https://example.com/escape\\\\20space.png")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			// css-tree handles escape sequences
			expect(result.value.url).toContain("example.com");
		});

		test("parses URL with unicode escape", () => {
			const input = 'url("https://example.com/unicode\\\\000026.png")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toContain("example.com");
		});

		test("parses URL with emoji", () => {
			const input = 'url("https://example.com/emoji-🌈.svg")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("https://example.com/emoji-🌈.svg");
		});
	});

	describe("Relative paths", () => {
		test("parses relative path with parent navigation", () => {
			const input = "url(../assets/icons/../icons/logo.svg)";
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("../assets/icons/../icons/logo.svg");
		});

		test("parses relative path with current directory", () => {
			const input = "url(./images/./../images/bg.jpg)";
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("./images/./../images/bg.jpg");
		});
	});

	describe("Fragment identifiers", () => {
		test("parses SVG fragment identifier", () => {
			const input = 'url("sprite.svg#icon-home")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("sprite.svg#icon-home");
		});

		test("parses standalone fragment identifier", () => {
			const input = 'url("#gradient1")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("#gradient1");
		});
	});

	describe("Empty and invalid edge cases", () => {
		test("rejects empty url() function", () => {
			const input = "url()";
			const result = parse(input);
			expect(result.ok).toBe(false);
		});

		test("rejects empty string URL", () => {
			const input = 'url("")';
			const result = parse(input);
			expect(result.ok).toBe(false);
		});

		test("accepts whitespace-only URL (css-tree behavior)", () => {
			// Note: css-tree treats whitespace as valid URL content
			const input = "url('   ')";
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("   ");
		});

		test("accepts partial URL (protocol only)", () => {
			const input = 'url("https://")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("https://");
		});
	});

	describe("Mixed quotes and escapes", () => {
		test("parses URL with escaped quote inside", () => {
			const input = 'url("https://example.com/quote\\"inside.png")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toContain("example.com");
		});

		test("parses URL with single quote inside double quotes", () => {
			const input = 'url("https://example.com/quote\'inside.png")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("https://example.com/quote'inside.png");
		});
	});

	describe("Unusual schemes", () => {
		test("parses FTP URL", () => {
			const input = 'url("ftp://example.com/resource.svg")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("ftp://example.com/resource.svg");
		});

		test("parses chrome extension URL", () => {
			const input = 'url("chrome-extension://abc123/icon.png")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("chrome-extension://abc123/icon.png");
		});

		test("parses blob URL", () => {
			const input = 'url("blob:https://example.com/550e8400-e29b-41d4-a716-446655440000")';
			const result = parse(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value.url).toBe("blob:https://example.com/550e8400-e29b-41d4-a716-446655440000");
		});
	});

	describe("Round-trip verification", () => {
		test("data URI round-trips correctly", () => {
			const input = 'url("data:image/svg+xml,%3Csvg%3E%3C/svg%3E")';
			const parsed = parse(input);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = toCss(parsed.value);
			const reparsed = parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value.url).toBe(parsed.value.url);
		});

		test("absolute URL round-trips correctly", () => {
			const input = "url(https://example.com/image.png)";
			const parsed = parse(input);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = toCss(parsed.value);
			const reparsed = parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("relative path round-trips correctly", () => {
			const input = "url(../assets/logo.svg)";
			const parsed = parse(input);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = toCss(parsed.value);
			const reparsed = parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("fragment identifier round-trips correctly", () => {
			const input = 'url("#gradient1")';
			const parsed = parse(input);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = toCss(parsed.value);
			const reparsed = parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("blob URL round-trips correctly", () => {
			const input = 'url("blob:https://example.com/550e8400-e29b-41d4-a716-446655440000")';
			const parsed = parse(input);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = toCss(parsed.value);
			const reparsed = parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value.url).toBe(parsed.value.url);
		});
	});
});


=== File: src/parse/filter/url.test.ts ===
// b_path:: src/parse/filter/url.test.ts
import { describe, expect, test } from "vitest";
import { toCss } from "@/generate/filter/url";
import { parse } from "./url";

describe("parse() - URL filter parser", () => {
	describe("Valid inputs", () => {
		test("parses fragment identifier", () => {
			const result = parse("url(#filter-id)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "url",
				url: "#filter-id",
			});
		});

		test("parses fragment with quoted string", () => {
			const result = parse('url("#filter-id")');
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "url",
				url: "#filter-id",
			});
		});

		test("parses fragment with single quotes", () => {
			const result = parse("url('#filter-id')");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "url",
				url: "#filter-id",
			});
		});

		test("parses file path", () => {
			const result = parse("url(filters.svg)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "url",
				url: "filters.svg",
			});
		});

		test("parses file path with directory", () => {
			const result = parse("url(path/to/filters.svg)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "url",
				url: "path/to/filters.svg",
			});
		});

		test("parses quoted file path", () => {
			const result = parse('url("path/to/filters.svg")');
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "url",
				url: "path/to/filters.svg",
			});
		});

		test("parses absolute URL", () => {
			const result = parse("url(https://example.com/filter.svg)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "url",
				url: "https://example.com/filter.svg",
			});
		});

		test("parses fragment with special characters", () => {
			const result = parse("url(#my-filter-123)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "url",
				url: "#my-filter-123",
			});
		});
	});

	describe("Round-trip: parse → generate → parse", () => {
		test("fragment identifier", () => {
			const input = "url(#filter)";
			const parsed = parse(input);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = toCss(parsed.value);
			const reparsed = parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("file path", () => {
			const input = "url(filters.svg)";
			const parsed = parse(input);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = toCss(parsed.value);
			const reparsed = parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});

		test("path with directory", () => {
			const input = "url(path/to/filter.svg)";
			const parsed = parse(input);
			expect(parsed.ok).toBe(true);
			if (!parsed.ok) return;

			const css = toCss(parsed.value);
			const reparsed = parse(css);
			expect(reparsed.ok).toBe(true);
			if (!reparsed.ok) return;

			expect(reparsed.value).toEqual(parsed.value);
		});
	});

	describe("Error cases", () => {
		test("rejects empty input", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});

		test("rejects non-url function", () => {
			const result = parse("blur(5px)");
			expect(result.ok).toBe(false);
		});

		test("rejects invalid syntax", () => {
			const result = parse("url(");
			expect(result.ok).toBe(false);
		});
	});
});

describe("toCss() - URL filter generator", () => {
	test("generates fragment identifier", () => {
		const css = toCss({ kind: "url", url: "#filter-id" });
		expect(css).toBe("url(#filter-id)");
	});

	test("generates file path", () => {
		const css = toCss({ kind: "url", url: "filters.svg" });
		expect(css).toBe("url(filters.svg)");
	});

	test("generates path with directory", () => {
		const css = toCss({ kind: "url", url: "path/to/filters.svg" });
		expect(css).toBe("url(path/to/filters.svg)");
	});

	test("generates absolute URL", () => {
		const css = toCss({ kind: "url", url: "https://example.com/filter.svg" });
		expect(css).toBe("url(https://example.com/filter.svg)");
	});
});


=== File: src/parse/filter/url.ts ===
// b_path:: src/parse/filter/url.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { UrlFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";

/**
 * Parse CSS url() filter function.
 *
 * Parses url filter for SVG filter references.
 * Accepts fragment identifiers (#id) or file paths.
 * Supports quoted and unquoted URLs.
 *
 * @param input - CSS string like "url(#filter)" or "url('path/to/filter.svg')"
 * @returns Result with UrlFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/url}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/url";
 *
 * const result = parse("url(#filter-id)");
 * // { ok: true, value: { kind: "url", url: "#filter-id" } }
 *
 * const result2 = parse("url('path/to/filter.svg')");
 * // { ok: true, value: { kind: "url", url: "path/to/filter.svg" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<UrlFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find url() in the AST
	// url() is represented as a Url node, not a Function node
	const ast = astResult.value;
	let foundUrl = "";

	// Walk the AST to find Url node
	csstree.walk(ast, {
		visit: "Url",
		enter(node: csstree.Url) {
			foundUrl = node.value;
			return false; // Stop walking once found
		},
	});

	if (foundUrl === "") {
		return err("Expected url() function");
	}

	return ok({ kind: "url", url: foundUrl });
}


=== File: src/parse/gradient/color-stop.test.ts ===
// b_path:: src/parse/gradient/color-stop.test.ts

import { describe, expect, it } from "vitest";
import { fromNodes } from "./color-stop";

describe("Color Stop Parser", () => {
	it("should handle empty nodes array", () => {
		const result = fromNodes([]);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("requires at least a color value");
		}
	});

	it("should parse color-only stop", () => {
		// This would be tested through integration, but we need direct unit tests
		// for coverage of error paths
		const result = fromNodes([]);
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/gradient/color-stop.ts ===
// b_path:: src/parse/gradient/color-stop.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseColor } from "@/utils/parse/color";

/**
 * Parse color stop from CSS AST nodes.
 *
 * A color stop consists of a color value and an optional position.
 * Per CSS spec: <color-stop> = <color> [ <length-percentage> ]?
 *
 * @param nodes - Array of CSS AST nodes (color and optional position)
 * @returns Result containing ColorStop IR or error message
 *
 * @example
 * ```typescript
 * // Color only: red
 * const result1 = fromNodes([colorNode]);
 *
 * // Color with percentage: red 50%
 * const result2 = fromNodes([colorNode, percentageNode]);
 *
 * // Color with length: blue 100px
 * const result3 = fromNodes([colorNode, lengthNode]);
 * ```
 *
 * @internal
 */
export function fromNodes(nodes: csstree.CssNode[]): Result<Type.ColorStop, string> {
	if (nodes.length === 0) {
		return err("Color stop requires at least a color value");
	}

	const firstNode = nodes[0];
	if (!firstNode) {
		return err("Color stop requires at least a color value");
	}

	// Extract and parse color value
	let colorString: string;
	try {
		colorString = csstree.generate(firstNode);
	} catch (error) {
		return err(`Failed to generate color value: ${error instanceof Error ? error.message : String(error)}`);
	}

	// Parse color using master color parser
	const colorResult = parseColor(colorString);
	if (!colorResult.ok) {
		return err(`Invalid color value: ${colorResult.error}`);
	}
	const color = colorResult.value;

	// Check for optional position (second node)
	if (nodes.length >= 2) {
		const posNode = nodes[1];
		if (!posNode) {
			return ok({ color });
		}

		// Parse position as length or percentage
		if (posNode.type === "Percentage") {
			const value = Number.parseFloat(posNode.value);
			return ok({
				color,
				position: { value, unit: "%" },
			});
		}

		if (posNode.type === "Dimension") {
			const value = Number.parseFloat(posNode.value);
			const unit = posNode.unit.toLowerCase();
			// Type assertion needed for unit validation
			return ok({
				color,
				position: { value, unit } as Type.LengthPercentage,
			});
		}

		return err(`Invalid position type: ${posNode.type}`);
	}

	// Color only
	return ok({ color });
}


=== File: src/parse/gradient/conic.parse.test.ts ===
// b_path:: src/parse/gradient/conic.parse.test.ts

import { describe, expect, it } from "vitest";
import * as ConicParser from "./conic";

describe("Conic Gradient Parser", () => {
	it("should parse simple conic gradient", () => {
		const css = "conic-gradient(red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("conic");
			expect(result.value.repeating).toBe(false);
			expect(result.value.colorStops).toHaveLength(2);
			expect(result.value.colorStops[0]?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "blue" });
		}
	});

	it("should parse conic gradient with starting angle", () => {
		const css = "conic-gradient(from 45deg, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 45,
				unit: "deg",
			});
		}
	});

	it("should parse conic gradient with position", () => {
		const css = "conic-gradient(at center, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "center",
				vertical: "center",
			});
		}
	});

	it("should parse conic gradient with position keywords", () => {
		const css = "conic-gradient(at left top, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "left",
				vertical: "top",
			});
		}
	});

	it("should parse conic gradient with percentage position", () => {
		const css = "conic-gradient(at 50% 75%, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: { value: 50, unit: "%" },
				vertical: { value: 75, unit: "%" },
			});
		}
	});

	it("should parse conic gradient with both angle and position", () => {
		const css = "conic-gradient(from 90deg at 50% 50%, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 90,
				unit: "deg",
			});
			expect(result.value.position).toEqual({
				horizontal: { value: 50, unit: "%" },
				vertical: { value: 50, unit: "%" },
			});
		}
	});

	it("should parse conic gradient with turn unit", () => {
		const css = "conic-gradient(from 0.25turn, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 0.25,
				unit: "turn",
			});
		}
	});

	it("should parse conic gradient with rad unit", () => {
		const css = "conic-gradient(from 1.57rad, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 1.57,
				unit: "rad",
			});
		}
	});

	it("should parse conic gradient with color stops having angle positions", () => {
		const css = "conic-gradient(red 0deg, blue 180deg)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 0,
				unit: "deg",
			});
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 180,
				unit: "deg",
			});
		}
	});

	it("should parse conic gradient with color interpolation", () => {
		const css = "conic-gradient(in oklch, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse conic gradient with angle and color interpolation", () => {
		const css = "conic-gradient(from 45deg in oklch, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 45,
				unit: "deg",
			});
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse repeating conic gradient", () => {
		const css = "repeating-conic-gradient(red, blue 45deg)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.repeating).toBe(true);
		}
	});

	it("should parse complex conic gradient", () => {
		const css = "conic-gradient(from 90deg at 30% 30%, red 0deg, yellow 120deg, blue 240deg)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 90,
				unit: "deg",
			});
			expect(result.value.position).toEqual({
				horizontal: { value: 30, unit: "%" },
				vertical: { value: 30, unit: "%" },
			});
			expect(result.value.colorStops).toHaveLength(3);
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "yellow" });
		}
	});

	it("should handle conic gradient with multiple color stops", () => {
		const css = "conic-gradient(red, orange, yellow, green, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(5);
		}
	});

	it("should parse conic gradient with percentage color stop positions", () => {
		const css = "conic-gradient(red 0%, blue 100%)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 0,
				unit: "%",
			});
		}
	});

	it("should return error for invalid function name", () => {
		const css = "linear-gradient(red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("No conic-gradient function found");
		}
	});

	it("should return error for insufficient color stops", () => {
		const css = "conic-gradient(red)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});

	it("should return error for invalid CSS syntax", () => {
		const css = "not valid css";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should return error for empty function", () => {
		const css = "conic-gradient()";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});
});


=== File: src/parse/gradient/conic.ts ===
// b_path:: src/parse/gradient/conic.ts
import * as csstree from "css-tree";
import type * as Keyword from "@/core/keywords";
import { COLOR_INTERPOLATION_KEYWORDS } from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import * as ColorStop from "./color-stop";

/**
 * Parse starting angle from nodes (from keyword followed by angle value).
 *
 * Syntax: from <angle>
 * Example: from 45deg, from 0.5turn, from 1rad
 *
 * @param nodes - Array of CSS nodes starting with "from" keyword
 * @param startIdx - Index to start parsing from
 * @returns Result with Angle and next index, or error
 *
 * @internal
 */
function parseFromAngle(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ angle: Type.Angle; nextIdx: number }, string> {
	let idx = startIdx;

	// Should start with "from" keyword
	const fromNode = nodes[idx];
	if (!fromNode || fromNode.type !== "Identifier" || fromNode.name.toLowerCase() !== "from") {
		return err("Expected 'from' keyword for starting angle");
	}
	idx++;

	// Parse angle value
	const angleNode = nodes[idx];
	if (!angleNode || angleNode.type !== "Dimension") {
		return err("Expected angle value after 'from'");
	}

	if (!["deg", "rad", "grad", "turn"].includes(angleNode.unit)) {
		return err(`Invalid angle unit: ${angleNode.unit}`);
	}

	const angle: Type.Angle = {
		value: Number.parseFloat(angleNode.value),
		unit: angleNode.unit as "deg" | "rad" | "grad" | "turn",
	};

	return ok({ angle, nextIdx: idx + 1 });
}

/**
 * Parse position from nodes (at keyword followed by position values).
 *
 * Syntax: at <position>
 * Example: at center, at left top, at 50% 50%, at 100px 200px
 *
 * @param nodes - Array of CSS nodes starting with "at" keyword
 * @param startIdx - Index to start parsing from
 * @returns Result with Position2D and next index, or error
 *
 * @internal
 */
function parsePosition(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Should start with "at" keyword
	const atNode = nodes[idx];
	if (!atNode || atNode.type !== "Identifier" || atNode.name.toLowerCase() !== "at") {
		return err("Expected 'at' keyword for position");
	}
	idx++;

	// Parse position values (1 or 2 values: horizontal and vertical)
	const positionValues: Type.PositionValue[] = [];

	// Collect position value nodes until we hit comma or end
	while (idx < nodes.length) {
		const node = nodes[idx];
		if (!node) break;

		if (node.type === "Operator" && "value" in node && node.value === ",") {
			break;
		}

		if (node.type === "Identifier") {
			// Try parsing as position keyword using shared utility
			const positionResult = ParseUtils.parsePositionValueNode(node);
			if (positionResult.ok && typeof positionResult.value === "string") {
				positionValues.push(positionResult.value);
				idx++;
			} else {
				break;
			}
		} else {
			// Try parsing as length-percentage using shared utility
			const lengthResult = ParseUtils.parseLengthPercentageNode(node);
			if (lengthResult.ok) {
				positionValues.push(lengthResult.value);
				idx++;
			} else {
				break;
			}
		}
	}

	if (positionValues.length === 0) {
		return err("Expected position values after 'at'");
	}

	// Convert 1-2 values into Position2D
	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Invalid position value");
		}
		// Single value is treated as horizontal, vertical defaults to center
		if (typeof val === "string") {
			// Keyword: if it's top/bottom, it's vertical; otherwise horizontal
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		// Two values: horizontal then vertical
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Invalid position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse conic gradient from CSS function AST.
 *
 * Handles conic-gradient() and repeating-conic-gradient() functions.
 * Supports optional starting angle, position, color interpolation, and color stops.
 *
 * Syntax: conic-gradient([ from <angle> ]? [ at <position> ]? [, in <color-space>]?, <color-stop-list>)
 *
 * @param fn - CSS Function AST node
 * @returns Result containing ConicGradient IR or error message
 *
 * @example
 * ```typescript
 * // Parse: conic-gradient(red, blue)
 * // Parse: conic-gradient(from 45deg, red, blue)
 * // Parse: conic-gradient(at center, red, blue)
 * // Parse: conic-gradient(from 90deg at 50% 50%, red, blue)
 * // Parse: repeating-conic-gradient(red, blue 45deg)
 * ```
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode): Result<Type.ConicGradient, string> {
	const functionName = fn.name.toLowerCase();
	const isRepeating = functionName === "repeating-conic-gradient";

	if (!isRepeating && functionName !== "conic-gradient") {
		return err(`Expected conic-gradient or repeating-conic-gradient, got: ${functionName}`);
	}

	// Get all children nodes
	const children = fn.children.toArray();
	if (children.length === 0) {
		return err("conic-gradient requires at least 2 color stops");
	}

	let fromAngle: Type.Angle | undefined;
	let position: Type.Position2D | undefined;
	let colorSpace: Keyword.ColorInterpolationKeyword | undefined;

	let idx = 0;

	// Parse optional "from <angle>"
	const firstNode = children[idx];
	if (firstNode?.type === "Identifier" && firstNode.name.toLowerCase() === "from") {
		const angleResult = parseFromAngle(children, idx);
		if (angleResult.ok) {
			fromAngle = angleResult.value.angle;
			idx = angleResult.value.nextIdx;
		}
	}

	// Parse optional position: "at <position>"
	const atNode = children[idx];
	if (atNode?.type === "Identifier" && atNode.name.toLowerCase() === "at") {
		const posResult = parsePosition(children, idx);
		if (posResult.ok) {
			position = posResult.value.position;
			idx = posResult.value.nextIdx;
		}
	}

	// Skip comma after from/at if present
	const commaNode = children[idx];
	if (commaNode && commaNode.type === "Operator" && "value" in commaNode && commaNode.value === ",") {
		idx++;
	}

	// Parse optional color interpolation: "in <color-space>"
	if (idx < children.length) {
		const node = children[idx];
		if (node?.type === "Identifier" && node.name.toLowerCase() === "in") {
			idx++;
			const spaceNode = children[idx];
			if (spaceNode?.type === "Identifier") {
				const space = spaceNode.name.toLowerCase();
				// Validate against core color interpolation keywords
				if (COLOR_INTERPOLATION_KEYWORDS.includes(space as Keyword.ColorInterpolationKeyword)) {
					colorSpace = space as Keyword.ColorInterpolationKeyword;
					idx++;
				}
			}

			// Skip comma after color space if present
			const spaceCommaNode = children[idx];
			if (
				spaceCommaNode &&
				spaceCommaNode.type === "Operator" &&
				"value" in spaceCommaNode &&
				spaceCommaNode.value === ","
			) {
				idx++;
			}
		}
	}

	// Split remaining nodes into color stop groups
	const stopGroups = AstUtils.splitNodesByComma(children, { startIndex: idx });

	// Parse each color stop
	const colorStops: Type.ColorStop[] = [];
	for (const stopNodes of stopGroups) {
		const stopResult = ColorStop.fromNodes(stopNodes);
		if (stopResult.ok) {
			colorStops.push(stopResult.value);
		} else {
			return err(`Invalid color stop: ${stopResult.error}`);
		}
	}

	if (colorStops.length < 2) {
		return err("conic-gradient requires at least 2 color stops");
	}

	return ok({
		kind: "conic",
		fromAngle,
		position,
		colorSpace,
		colorStops,
		repeating: isRepeating,
	});
}

/**
 * Parse a CSS conic gradient value into structured intermediate representation (IR).
 *
 * Parses both `conic-gradient()` and `repeating-conic-gradient()` functions,
 * extracting starting angle, position, color interpolation, and color stops into a
 * type-safe IR object.
 *
 * Supports all CSS conic gradient syntax per CSS Images Module Level 4:
 * - Starting angle: `from <angle>` (default: 0deg from top)
 * - Position: `at <position>` syntax with keywords or length values
 * - Color interpolation: `in <color-space>` syntax
 * - Color stops: with optional angle positions
 *
 * @param css - CSS string containing a conic gradient function
 * @returns Result containing ConicGradient IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * Simple gradient (defaults to starting from top at center):
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Conic.parse("conic-gradient(red, blue)");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { kind: "conic", colorStops: [...], repeating: false }
 * }
 * ```
 *
 * @example
 * With starting angle:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "conic-gradient(from 45deg, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.fromAngle);
 *   // { value: 45, unit: "deg" }
 * }
 * ```
 *
 * @example
 * At specific position:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "conic-gradient(at left top, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.position);
 *   // { horizontal: "left", vertical: "top" }
 * }
 * ```
 *
 * @example
 * With both angle and position:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "conic-gradient(from 90deg at 50% 50%, red 0deg, blue 180deg)"
 * );
 * if (result.ok) {
 *   console.log(result.value.fromAngle); // { value: 90, unit: "deg" }
 *   console.log(result.value.position);  // { horizontal: {value: 50, unit: "%"}, ... }
 * }
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "conic-gradient(in oklch, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.colorSpace); // "oklch"
 * }
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "repeating-conic-gradient(red 0deg, blue 45deg)"
 * );
 * if (result.ok) {
 *   console.log(result.value.repeating); // true
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse("invalid syntax");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient | MDN: conic-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-4/#conic-gradients | W3C Spec: Conic Gradients}
 * @see {@link https://github.com/mdn/data/blob/main/css/functions.json | MDN Data: conic-gradient()}
 */
export function parse(css: string): Result<Type.ConicGradient, string> {
	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the function node
		let funcNode: csstree.FunctionNode | null = null;
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (node.name === "conic-gradient" || node.name === "repeating-conic-gradient") {
					funcNode = node;
				}
			},
		});

		if (!funcNode) {
			return err("No conic-gradient function found in CSS string");
		}

		return fromFunction(funcNode);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/gradient/gradient.test.ts ===
// b_path:: src/parse/gradient/gradient.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./gradient";

describe("parse() - unified gradient dispatcher", () => {
	describe("linear gradient", () => {
		it("detects linear-gradient()", () => {
			const result = parse("linear-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
				expect(result.value?.repeating).toBe(false);
			}
		});

		it("detects repeating-linear-gradient()", () => {
			const result = parse("repeating-linear-gradient(red 0%, blue 10%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
				expect(result.value?.repeating).toBe(true);
			}
		});
	});

	describe("radial gradient", () => {
		it("detects radial-gradient()", () => {
			const result = parse("radial-gradient(circle, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("radial");
				expect(result.value?.repeating).toBe(false);
			}
		});

		it("detects repeating-radial-gradient()", () => {
			const result = parse("repeating-radial-gradient(circle, red 0%, blue 10%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("radial");
				expect(result.value?.repeating).toBe(true);
			}
		});
	});

	describe("conic gradient", () => {
		it("detects conic-gradient()", () => {
			const result = parse("conic-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("conic");
				expect(result.value?.repeating).toBe(false);
			}
		});

		it("detects repeating-conic-gradient()", () => {
			const result = parse("repeating-conic-gradient(red 0deg, blue 180deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("conic");
				expect(result.value?.repeating).toBe(true);
			}
		});
	});

	describe("with direction/position/angle", () => {
		it("handles linear gradient with angle", () => {
			const result = parse("linear-gradient(45deg, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
			}
		});

		it("handles linear gradient with to side", () => {
			const result = parse("linear-gradient(to right, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
			}
		});

		it("handles radial gradient with position", () => {
			const result = parse("radial-gradient(at center, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("radial");
			}
		});

		it("handles conic gradient with angle", () => {
			const result = parse("conic-gradient(from 45deg, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("conic");
			}
		});
	});

	describe("error handling", () => {
		it("rejects unknown gradient function", () => {
			const result = parse("unknown-gradient(red, blue)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown gradient function");
			}
		});

		it("rejects invalid syntax", () => {
			const result = parse("not-a-gradient");
			expect(result.ok).toBe(false);
		});

		it("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});

	describe("case insensitivity", () => {
		it("handles lowercase (standard)", () => {
			const result = parse("linear-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
			}
		});

		it("handles radial gradient", () => {
			const result = parse("radial-gradient(circle, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("radial");
			}
		});

		it("handles repeating variants", () => {
			const result = parse("repeating-conic-gradient(red 0deg, blue 180deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("conic");
				expect(result.value?.repeating).toBe(true);
			}
		});
	});
});


=== File: src/parse/gradient/gradient.ts ===
// b_path:: src/parse/gradient/gradient.ts

import type { CssNode } from "css-tree";
import * as cssTree from "css-tree";
import { err, type ParseResult, parseErr, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as Conic from "./conic";
import * as Linear from "./linear";
import * as Radial from "./radial";

/**
 * Parse gradient value with auto-detection.
 *
 * Automatically detects and parses any CSS gradient function:
 * - linear-gradient(), repeating-linear-gradient()
 * - radial-gradient(), repeating-radial-gradient()
 * - conic-gradient(), repeating-conic-gradient()
 *
 * @param value - CSS gradient value string
 * @returns Result with Gradient IR or error
 *
 * @example
 * ```typescript
 * parse("linear-gradient(red, blue)");
 * parse("radial-gradient(circle, red, blue)");
 * parse("conic-gradient(red, blue)");
 * parse("repeating-linear-gradient(red 0%, blue 10%)");
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Type.Gradient> {
	const ast = cssTree.parse(value, { context: "value" }) as cssTree.Value;
	if (!ast.children) return parseErr("invalid-syntax", "Empty value");
	const first = ast.children.first;
	if (!first) return parseErr("invalid-syntax", "Empty value");
	const result = parseNode(first);
	return toParseResult(result);
}

/**
 * Parse gradient AST node with auto-detection.
 *
 * @param node - CSS AST node
 * @returns Result with Gradient IR or error
 *
 * @internal
 */
function parseNode(node: CssNode): Result<Type.Gradient, string> {
	// All gradients are Function nodes
	if (node.type === "Function") {
		const css = cssTree.generate(node);
		switch (node.name.toLowerCase()) {
			case "linear-gradient":
			case "repeating-linear-gradient":
				return Linear.parse(css);
			case "radial-gradient":
			case "repeating-radial-gradient":
				return Radial.parse(css);
			case "conic-gradient":
			case "repeating-conic-gradient":
				return Conic.parse(css);
			default:
				return err(`Unknown gradient function: ${node.name}`);
		}
	}

	return err("Invalid gradient value");
}


=== File: src/parse/gradient/index.ts ===
// b_path:: src/parse/gradient/index.ts

/**
 * CSS gradient parsers - convert gradient strings to structured IR.
 *
 * @module Parse.Gradient
 * @public
 */

/**
 * Parse color stops within gradients.
 *
 * @see {@link ColorStop.parse}
 */
export * as ColorStop from "./color-stop";
/**
 * Parse conic and repeating-conic gradients.
 *
 * @see {@link Conic.parse}
 */
export * as Conic from "./conic";
/**
 * Unified gradient dispatcher with auto-detection.
 *
 * @see {@link module:Parse.Gradient}
 */
export { parse } from "./gradient";

/**
 * Parse linear and repeating-linear gradients.
 *
 * @see {@link Linear.parse}
 */
export * as Linear from "./linear";
/**
 * Parse radial and repeating-radial gradients.
 *
 * @see {@link Radial.parse}
 */
export * as Radial from "./radial";


=== File: src/parse/gradient/linear.parse.test.ts ===
// b_path:: src/parse/gradient/linear.parse.test.ts

import { describe, expect, it } from "vitest";
import * as LinearParser from "./linear";

describe("Linear Gradient Parser", () => {
	it("should parse simple linear gradient", () => {
		const css = "linear-gradient(red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("linear");
			expect(result.value.repeating).toBe(false);
			expect(result.value.colorStops).toHaveLength(2);
			expect(result.value.colorStops[0]?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "blue" });
		}
	});

	it("should parse linear gradient with angle direction", () => {
		const css = "linear-gradient(45deg, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "angle",
				value: { value: 45, unit: "deg" },
			});
		}
	});

	it("should parse linear gradient with to-side direction", () => {
		const css = "linear-gradient(to right, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "to-side",
				value: "right",
			});
		}
	});

	it("should parse linear gradient with to-corner direction", () => {
		const css = "linear-gradient(to top right, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "to-corner",
				value: "top right",
			});
		}
	});

	it("should parse linear gradient with turn unit", () => {
		const css = "linear-gradient(0.25turn, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "angle",
				value: { value: 0.25, unit: "turn" },
			});
		}
	});

	it("should parse linear gradient with rad unit", () => {
		const css = "linear-gradient(1.57rad, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "angle",
				value: { value: 1.57, unit: "rad" },
			});
		}
	});

	it("should parse linear gradient with color stops having positions", () => {
		const css = "linear-gradient(red 0%, blue 100%)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 0,
				unit: "%",
			});
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 100,
				unit: "%",
			});
		}
	});

	it("should parse linear gradient with color interpolation", () => {
		const css = "linear-gradient(in oklch, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse linear gradient with direction and color interpolation", () => {
		const css = "linear-gradient(45deg in oklch, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "angle",
				value: { value: 45, unit: "deg" },
			});
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse repeating linear gradient", () => {
		const css = "repeating-linear-gradient(45deg, red, blue 20px)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.repeating).toBe(true);
		}
	});

	it("should parse complex linear gradient", () => {
		const css = "linear-gradient(to bottom right, red 0%, yellow 50%, blue 100%)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "to-corner",
				value: "bottom right",
			});
			expect(result.value.colorStops).toHaveLength(3);
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "yellow" });
		}
	});

	it("should parse linear gradient with all directions", () => {
		const directions = ["to top", "to right", "to bottom", "to left"];

		for (const dir of directions) {
			const css = `linear-gradient(${dir}, red, blue)`;
			const result = LinearParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.direction?.kind).toBe("to-side");
			}
		}
	});

	it("should parse linear gradient with all corners", () => {
		const corners = ["to top left", "to top right", "to bottom left", "to bottom right"];

		for (const corner of corners) {
			const css = `linear-gradient(${corner}, red, blue)`;
			const result = LinearParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.direction?.kind).toBe("to-corner");
			}
		}
	});

	it("should handle linear gradient with multiple color stops", () => {
		const css = "linear-gradient(red, orange, yellow, green, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(5);
		}
	});

	it("should return error for invalid function name", () => {
		const css = "radial-gradient(red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("No linear-gradient function found");
		}
	});

	it("should return error for insufficient color stops", () => {
		const css = "linear-gradient(red)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});

	it("should return error for invalid CSS syntax", () => {
		const css = "not valid css";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should return error for empty function", () => {
		const css = "linear-gradient()";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});
});


=== File: src/parse/gradient/linear.ts ===
// b_path:: src/parse/gradient/linear.ts
import * as csstree from "css-tree";
import type * as Keyword from "@/core/keywords";
import { COLOR_INTERPOLATION_KEYWORDS } from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import * as ColorStop from "./color-stop";

/**
 * Parse gradient direction from nodes.
 *
 * Handles angle values, "to side" keywords, and "to corner" keywords.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @returns Result with direction and next index, or error
 *
 * @internal
 */
function parseDirection(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ direction: Type.GradientDirection; nextIdx: number }, string> {
	let idx = startIdx;
	const node = nodes[idx];

	if (!node) {
		return err("Expected direction value");
	}

	// Check for angle using shared utility
	const angleResult = ParseUtils.parseAngleNode(node);
	if (angleResult.ok) {
		return ok({
			direction: {
				kind: "angle",
				value: angleResult.value,
			},
			nextIdx: idx + 1,
		});
	}

	// Check for "to" keyword (for side or corner)
	if (node.type === "Identifier" && node.name.toLowerCase() === "to") {
		idx++;
		const firstKeyword = nodes[idx];
		if (!firstKeyword || firstKeyword.type !== "Identifier") {
			return err("Expected side or corner keyword after 'to'");
		}

		const first = firstKeyword.name.toLowerCase();
		idx++;

		// Check if there's a second keyword (for corners)
		const secondKeyword = nodes[idx];
		if (secondKeyword && secondKeyword.type === "Identifier") {
			const second = secondKeyword.name.toLowerCase();
			// Corner: "to top left", "to bottom right", etc.
			const corner = `${first} ${second}`;
			if (["top left", "top right", "bottom left", "bottom right"].includes(corner)) {
				return ok({
					direction: {
						kind: "to-corner",
						value: corner as "top left" | "top right" | "bottom left" | "bottom right",
					},
					nextIdx: idx + 1,
				});
			}
		}

		// Single keyword - side
		if (["top", "right", "bottom", "left"].includes(first)) {
			return ok({
				direction: {
					kind: "to-side",
					value: first as "top" | "right" | "bottom" | "left",
				},
				nextIdx: idx,
			});
		}

		return err(`Invalid direction keyword: ${first}`);
	}

	return err("Invalid direction syntax");
}

/**
 * Parse linear gradient from CSS function AST.
 *
 * Handles linear-gradient() and repeating-linear-gradient() functions.
 * Supports optional direction, color interpolation, and color stops.
 *
 * Syntax: linear-gradient([ <angle> | to <side-or-corner> ]? [, in <color-space>]?, <color-stop-list>)
 *
 * @param fn - CSS Function AST node
 * @returns Result containing LinearGradient IR or error message
 *
 * @example
 * ```typescript
 * // Parse: linear-gradient(red, blue)
 * // Parse: linear-gradient(45deg, red, blue)
 * // Parse: linear-gradient(to right, red, blue)
 * // Parse: linear-gradient(to top left, red, blue)
 * // Parse: repeating-linear-gradient(45deg, red, blue 20px)
 * ```
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode): Result<Type.LinearGradient, string> {
	const functionName = fn.name.toLowerCase();
	const isRepeating = functionName === "repeating-linear-gradient";

	if (!isRepeating && functionName !== "linear-gradient") {
		return err(`Expected linear-gradient or repeating-linear-gradient, got: ${functionName}`);
	}

	// Get all children nodes
	const children = fn.children.toArray();
	if (children.length === 0) {
		return err("linear-gradient requires at least 2 color stops");
	}

	let direction: Type.GradientDirection | undefined;
	let colorSpace: Keyword.ColorInterpolationKeyword | undefined;

	let idx = 0;

	// Parse optional direction
	const firstNode = children[idx];
	if (firstNode) {
		// Check for angle using shared utility
		const angleResult = ParseUtils.parseAngleNode(firstNode);
		if (angleResult.ok) {
			const dirResult = parseDirection(children, idx);
			if (dirResult.ok) {
				direction = dirResult.value.direction;
				idx = dirResult.value.nextIdx;
			}
		}
		// Check for "to" keyword
		else if (firstNode.type === "Identifier" && firstNode.name.toLowerCase() === "to") {
			const dirResult = parseDirection(children, idx);
			if (dirResult.ok) {
				direction = dirResult.value.direction;
				idx = dirResult.value.nextIdx;
			}
		}
	}

	// Skip comma after direction if present
	idx = AstUtils.skipComma(children, idx);

	// Parse optional color interpolation: "in <color-space>"
	if (idx < children.length) {
		const node = children[idx];
		if (node?.type === "Identifier" && node.name.toLowerCase() === "in") {
			idx++;
			const spaceNode = children[idx];
			if (spaceNode?.type === "Identifier") {
				const space = spaceNode.name.toLowerCase();
				// Validate against core color interpolation keywords
				if (COLOR_INTERPOLATION_KEYWORDS.includes(space as Keyword.ColorInterpolationKeyword)) {
					colorSpace = space as Keyword.ColorInterpolationKeyword;
					idx++;
				}
			}

			// Skip comma after color space if present
			idx = AstUtils.skipComma(children, idx);
		}
	}

	// Split remaining nodes into color stop groups
	const stopGroups = AstUtils.splitNodesByComma(children, { startIndex: idx });

	// Parse each color stop
	const colorStops: Type.ColorStop[] = [];
	for (const stopNodes of stopGroups) {
		const stopResult = ColorStop.fromNodes(stopNodes);
		if (stopResult.ok) {
			colorStops.push(stopResult.value);
		} else {
			return err(`Invalid color stop: ${stopResult.error}`);
		}
	}

	if (colorStops.length < 2) {
		return err("linear-gradient requires at least 2 color stops");
	}

	return ok({
		kind: "linear",
		direction,
		colorSpace,
		colorStops,
		repeating: isRepeating,
	});
}

/**
 * Parse a CSS linear gradient value into structured intermediate representation (IR).
 *
 * Parses both `linear-gradient()` and `repeating-linear-gradient()` functions,
 * extracting direction, color interpolation, and color stops into a
 * type-safe IR object.
 *
 * Supports all CSS linear gradient syntax per CSS Images Module Level 3:
 * - Direction angles: `45deg`, `0.5turn`, `1rad`, etc.
 * - Side keywords: `to top`, `to right`, `to bottom`, `to left`
 * - Corner keywords: `to top left`, `to bottom right`, etc.
 * - Color interpolation: `in <color-space>` syntax
 * - Color stops: with optional positions
 *
 * @param css - CSS string containing a linear gradient function
 * @returns Result containing LinearGradient IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * Simple gradient (defaults to top to bottom):
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Linear.parse("linear-gradient(red, blue)");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { kind: "linear", colorStops: [...], repeating: false }
 * }
 * ```
 *
 * @example
 * With angle direction:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "linear-gradient(45deg, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.direction);
 *   // { kind: "angle", value: { value: 45, unit: "deg" } }
 * }
 * ```
 *
 * @example
 * With side direction:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "linear-gradient(to right, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.direction);
 *   // { kind: "to-side", value: "right" }
 * }
 * ```
 *
 * @example
 * With corner direction:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "linear-gradient(to top right, red 0%, blue 100%)"
 * );
 * if (result.ok) {
 *   console.log(result.value.direction);
 *   // { kind: "to-corner", value: "top right" }
 * }
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "linear-gradient(in oklch, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.colorSpace); // "oklch"
 * }
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "repeating-linear-gradient(45deg, red 0px, blue 20px)"
 * );
 * if (result.ok) {
 *   console.log(result.value.repeating); // true
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse("invalid syntax");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient | MDN: linear-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients | W3C Spec: Linear Gradients}
 * @see {@link https://github.com/mdn/data/blob/main/css/functions.json | MDN Data: linear-gradient()}
 */
export function parse(css: string): Result<Type.LinearGradient, string> {
	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the function node
		let funcNode: csstree.FunctionNode | null = null;
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (node.name === "linear-gradient" || node.name === "repeating-linear-gradient") {
					funcNode = node;
				}
			},
		});

		if (!funcNode) {
			return err("No linear-gradient function found in CSS string");
		}

		return fromFunction(funcNode);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/gradient/radial.parse.test.ts ===
// b_path:: src/parse/gradient/radial.parse.test.ts

import { describe, expect, it } from "vitest";
import * as RadialParser from "./radial";

describe("Radial Gradient Parser", () => {
	it("should parse simple radial gradient", () => {
		const css = "radial-gradient(red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("radial");
			expect(result.value.repeating).toBe(false);
			expect(result.value.colorStops).toHaveLength(2);
			expect(result.value.colorStops[0]?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "blue" });
		}
	});

	it("should parse radial gradient with shape", () => {
		const css = "radial-gradient(circle, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("circle");
		}
	});

	it("should parse radial gradient with size keyword", () => {
		const css = "radial-gradient(circle closest-side, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "closest-side",
			});
		}
	});

	it("should parse radial gradient with position", () => {
		const css = "radial-gradient(at center, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "center",
				vertical: "center",
			});
		}
	});

	it("should parse radial gradient with color stops having positions", () => {
		const css = "radial-gradient(red 0%, blue 100%)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 0,
				unit: "%",
			});
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 100,
				unit: "%",
			});
		}
	});

	it("should parse repeating radial gradient", () => {
		const css = "repeating-radial-gradient(red, blue 20px)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.repeating).toBe(true);
		}
	});

	it("should parse complex radial gradient", () => {
		const css = "radial-gradient(ellipse farthest-corner at 30% 30%, red 0%, blue 100%)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("ellipse");
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "farthest-corner",
			});
			expect(result.value.position).toEqual({
				horizontal: { value: 30, unit: "%" },
				vertical: { value: 30, unit: "%" },
			});
		}
	});

	it("should parse radial gradient with multiple color stops", () => {
		const css = "radial-gradient(red, yellow 30%, green 60%, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(4);
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "yellow" });
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 30,
				unit: "%",
			});
		}
	});

	it("should return error for invalid gradient syntax", () => {
		const css = "not-a-gradient";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should return error for gradient with insufficient color stops", () => {
		const css = "radial-gradient(red)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});

	it("should parse radial gradient with explicit circle radius", () => {
		const css = "radial-gradient(100px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "circle-explicit",
				radius: { value: 100, unit: "px" },
			});
		}
	});

	it("should parse radial gradient with explicit ellipse radii", () => {
		const css = "radial-gradient(50% 100px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 50, unit: "%" },
				radiusY: { value: 100, unit: "px" },
			});
		}
	});

	it("should parse radial gradient with color interpolation method", () => {
		const css = "radial-gradient(in srgb, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("srgb");
		}
	});

	it("should parse radial gradient with oklch color space", () => {
		const css = "radial-gradient(in oklch, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse radial gradient with display-p3 color space", () => {
		const css = "radial-gradient(in display-p3, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("display-p3");
		}
	});

	it("should parse radial gradient with shape and color space", () => {
		const css = "radial-gradient(circle in srgb, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("circle");
			expect(result.value.colorSpace).toBe("srgb");
		}
	});

	it("should handle comma after color space", () => {
		const css = "radial-gradient(in srgb, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("srgb");
			expect(result.value.colorStops).toHaveLength(2);
		}
	});

	it("should handle size with single dimension value", () => {
		const css = "radial-gradient(50px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "circle-explicit",
				radius: { value: 50, unit: "px" },
			});
		}
	});

	it("should handle size with percentage value", () => {
		const css = "radial-gradient(75%, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "circle-explicit",
				radius: { value: 75, unit: "%" },
			});
		}
	});

	it("should handle ellipse with two length values", () => {
		const css = "radial-gradient(100px 50px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 100, unit: "px" },
				radiusY: { value: 50, unit: "px" },
			});
		}
	});

	it("should handle position with length values", () => {
		const css = "radial-gradient(at 10px 20px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: { value: 10, unit: "px" },
				vertical: { value: 20, unit: "px" },
			});
		}
	});

	it("should handle position with mixed keyword and length", () => {
		const css = "radial-gradient(at left 20px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position?.horizontal).toBe("left");
		}
	});

	it("should handle position with single value", () => {
		const css = "radial-gradient(at 50%, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toBeDefined();
		}
	});

	// Error path tests
	it("should return error for empty gradient", () => {
		const css = "radial-gradient()";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});

	it("should return error for missing function", () => {
		const css = "not a function";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should return error for wrong function name", () => {
		const css = "linear-gradient(red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should handle shape without size", () => {
		const css = "radial-gradient(ellipse, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("ellipse");
			expect(result.value.size).toBeUndefined();
		}
	});

	it("should handle size closest-side", () => {
		const css = "radial-gradient(closest-side, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "closest-side",
			});
		}
	});

	it("should handle size farthest-side", () => {
		const css = "radial-gradient(farthest-side, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "farthest-side",
			});
		}
	});

	it("should handle size closest-corner", () => {
		const css = "radial-gradient(closest-corner, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "closest-corner",
			});
		}
	});

	it("should handle circle with explicit size", () => {
		const css = "radial-gradient(circle 200px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("circle");
			expect(result.value.size).toEqual({
				kind: "circle-explicit",
				radius: { value: 200, unit: "px" },
			});
		}
	});

	it("should handle ellipse with explicit size", () => {
		const css = "radial-gradient(ellipse 100px 200px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("ellipse");
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 100, unit: "px" },
				radiusY: { value: 200, unit: "px" },
			});
		}
	});

	it("should handle position right bottom", () => {
		const css = "radial-gradient(at right bottom, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "right",
				vertical: "bottom",
			});
		}
	});

	it("should handle position with percentage values", () => {
		const css = "radial-gradient(at 25% 75%, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: { value: 25, unit: "%" },
				vertical: { value: 75, unit: "%" },
			});
		}
	});

	it("should handle position with top keyword", () => {
		const css = "radial-gradient(at top, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "center",
				vertical: "top",
			});
		}
	});

	it("should handle position with bottom keyword", () => {
		const css = "radial-gradient(at bottom, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "center",
				vertical: "bottom",
			});
		}
	});

	it("should handle explicit size with ellipse two dimensions", () => {
		const css = "radial-gradient(120px 80px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 120, unit: "px" },
				radiusY: { value: 80, unit: "px" },
			});
		}
	});

	it("should handle explicit size with percentages for ellipse", () => {
		const css = "radial-gradient(60% 40%, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 60, unit: "%" },
				radiusY: { value: 40, unit: "%" },
			});
		}
	});

	it("should handle color stops with px positions", () => {
		const css = "radial-gradient(red 10px, blue 50px)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 10,
				unit: "px",
			});
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 50,
				unit: "px",
			});
		}
	});

	it("should handle color stops with em positions", () => {
		const css = "radial-gradient(red 1em, blue 2em)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 1,
				unit: "em",
			});
		}
	});

	it("should handle rgb colors", () => {
		const css = "radial-gradient(rgb(255, 0, 0), rgb(0, 0, 255))";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(2);
		}
	});

	it("should handle hex colors", () => {
		const css = "radial-gradient(#ff0000, #0000ff)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.color).toEqual({ kind: "hex", value: "#FF0000" });
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "hex", value: "#0000FF" });
		}
	});

	it("should handle mixed color formats", () => {
		const css = "radial-gradient(red, #00ff00, rgb(0, 0, 255))";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(3);
		}
	});
});


=== File: src/parse/gradient/radial.ts ===
// b_path:: src/parse/gradient/radial.ts
import type * as csstree from "css-tree";
import type * as Keyword from "@/core/keywords";
import { COLOR_INTERPOLATION_KEYWORDS } from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import * as ColorStop from "./color-stop";

/**
 * Parse position from nodes (at keyword followed by position values).
 *
 * Syntax: at <position>
 * Example: at center, at left top, at 50% 50%, at 100px 200px
 *
 * @param nodes - Array of CSS nodes starting with "at" keyword
 * @param startIdx - Index to start parsing from
 * @returns Result with Position2D and next index, or error
 *
 * @internal
 */
function parsePosition(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Should start with "at" keyword
	const atNode = nodes[idx];
	if (!atNode || atNode.type !== "Identifier" || atNode.name.toLowerCase() !== "at") {
		return err("Expected 'at' keyword for position");
	}
	idx++;

	// Parse position values (1 or 2 values: horizontal and vertical)
	const positionValues: Type.PositionValue[] = [];

	// Collect position value nodes until we hit comma or end
	while (idx < nodes.length) {
		const node = nodes[idx];
		if (!node) break;

		if (node.type === "Operator" && "value" in node && node.value === ",") {
			break;
		}

		if (node.type === "Identifier") {
			// Try parsing as position keyword using shared utility
			const positionResult = ParseUtils.parsePositionValueNode(node);
			if (positionResult.ok && typeof positionResult.value === "string") {
				positionValues.push(positionResult.value);
				idx++;
			} else {
				break;
			}
		} else {
			// Try parsing as length-percentage using shared utility
			const lengthResult = ParseUtils.parseLengthPercentageNode(node);
			if (lengthResult.ok) {
				positionValues.push(lengthResult.value);
				idx++;
			} else {
				break;
			}
		}
	}

	if (positionValues.length === 0) {
		return err("Expected position values after 'at'");
	}

	// Convert 1-2 values into Position2D
	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Invalid position value");
		}
		// Single value is treated as horizontal, vertical defaults to center
		if (typeof val === "string") {
			// Keyword: if it's top/bottom, it's vertical; otherwise horizontal
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		// Two values: horizontal then vertical
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Invalid position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse radial gradient size from nodes.
 *
 * Handles keyword sizes (closest-side, etc.) and explicit sizes.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @param _shape - Shape parameter (reserved for future use)
 * @returns Result with size and next index, or error
 *
 * @internal
 */
function parseSize(
	nodes: csstree.CssNode[],
	startIdx: number,
	_shape?: Type.RadialGradientShape,
): Result<{ size: Type.RadialGradientSize; nextIdx: number }, string> {
	let idx = startIdx;
	const node = nodes[idx];

	if (!node) {
		return err("Expected size value");
	}

	// Check for keyword size
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();
		if (["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(keyword)) {
			return ok({
				size: {
					kind: "keyword",
					value: keyword as "closest-side" | "farthest-side" | "closest-corner" | "farthest-corner",
				},
				nextIdx: idx + 1,
			});
		}
	}

	// Check for explicit size (length or percentage)
	if (node.type === "Dimension" || node.type === "Percentage") {
		const firstValue =
			node.type === "Dimension"
				? { value: Number.parseFloat(node.value), unit: node.unit as "px" | "em" | "rem" | "%" }
				: { value: Number.parseFloat(node.value), unit: "%" as const };

		idx++;

		// Check if there's a second value (for ellipse)
		const nextNode = nodes[idx];
		if (nextNode && (nextNode.type === "Dimension" || nextNode.type === "Percentage")) {
			const secondValue =
				nextNode.type === "Dimension"
					? { value: Number.parseFloat(nextNode.value), unit: nextNode.unit as "px" | "em" | "rem" | "%" }
					: { value: Number.parseFloat(nextNode.value), unit: "%" as const };

			return ok({
				size: {
					kind: "ellipse-explicit",
					radiusX: firstValue,
					radiusY: secondValue,
				},
				nextIdx: idx + 1,
			});
		}

		// Single value - circle
		return ok({
			size: {
				kind: "circle-explicit",
				radius: firstValue,
			},
			nextIdx: idx,
		});
	}

	return err("Invalid size value");
}

/**
 * Parse radial gradient from CSS function AST.
 *
 * Handles radial-gradient() and repeating-radial-gradient() functions.
 * Supports optional shape, size, position, color interpolation, and color stops.
 *
 * Syntax: radial-gradient([ <shape> || <size> ]? [ at <position> ]? [, in <color-space>]?, <color-stop-list>)
 *
 * @param fn - CSS Function AST node
 * @returns Result containing RadialGradient IR or error message
 *
 * @example
 * ```typescript
 * // Parse: radial-gradient(red, blue)
 * // Parse: radial-gradient(circle, red, blue)
 * // Parse: radial-gradient(closest-side, red, blue)
 * // Parse: radial-gradient(circle at center, red, blue)
 * // Parse: radial-gradient(100px at left top, red, blue)
 * // Parse: repeating-radial-gradient(circle, red, blue 20px)
 * ```
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode): Result<Type.RadialGradient, string> {
	const functionName = fn.name.toLowerCase();
	const isRepeating = functionName === "repeating-radial-gradient";

	if (!isRepeating && functionName !== "radial-gradient") {
		return err(`Expected radial-gradient or repeating-radial-gradient, got: ${functionName}`);
	}

	// Get all children nodes
	const children = fn.children.toArray();
	if (children.length === 0) {
		return err("radial-gradient requires at least 2 color stops");
	}

	let shape: Type.RadialGradientShape | undefined;
	let size: Type.RadialGradientSize | undefined;
	let position: Type.Position2D | undefined;
	let colorSpace: Keyword.ColorInterpolationKeyword | undefined;

	let idx = 0;

	// Parse optional shape and/or size
	const firstNode = children[idx];
	if (firstNode?.type === "Identifier") {
		const keyword = firstNode.name.toLowerCase();

		// Check for shape keyword
		if (keyword === "circle" || keyword === "ellipse") {
			shape = keyword;
			idx++;

			// Check for size after shape
			const nextNode = children[idx];
			if (nextNode && nextNode.type !== "Identifier") {
				// Could be explicit size
				const sizeResult = parseSize(children, idx, shape);
				if (sizeResult.ok) {
					size = sizeResult.value.size;
					idx = sizeResult.value.nextIdx;
				}
			} else if (
				nextNode?.type === "Identifier" &&
				["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(nextNode.name.toLowerCase())
			) {
				// Keyword size
				const sizeResult = parseSize(children, idx, shape);
				if (sizeResult.ok) {
					size = sizeResult.value.size;
					idx = sizeResult.value.nextIdx;
				}
			}
		}
		// Check for size keyword without shape
		else if (["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(keyword)) {
			const sizeResult = parseSize(children, idx);
			if (sizeResult.ok) {
				size = sizeResult.value.size;
				idx = sizeResult.value.nextIdx;
			}
		}
	}
	// Check for explicit size without shape keyword
	else if (firstNode && (firstNode.type === "Dimension" || firstNode.type === "Percentage")) {
		const sizeResult = parseSize(children, idx);
		if (sizeResult.ok) {
			size = sizeResult.value.size;
			idx = sizeResult.value.nextIdx;
		}
	}

	// Parse optional position: "at <position>"
	const atNode = children[idx];
	if (atNode?.type === "Identifier" && atNode.name.toLowerCase() === "at") {
		const posResult = parsePosition(children, idx);
		if (posResult.ok) {
			position = posResult.value.position;
			idx = posResult.value.nextIdx;
		}
	}

	// Skip comma after shape/size/position if present
	const commaNode = children[idx];
	if (commaNode && commaNode.type === "Operator" && "value" in commaNode && commaNode.value === ",") {
		idx++;
	}

	// Parse optional color interpolation: "in <color-space>"
	if (idx < children.length) {
		const node = children[idx];
		if (node?.type === "Identifier" && node.name.toLowerCase() === "in") {
			idx++;
			const spaceNode = children[idx];
			if (spaceNode?.type === "Identifier") {
				const space = spaceNode.name.toLowerCase();
				// Validate against core color interpolation keywords
				if (COLOR_INTERPOLATION_KEYWORDS.includes(space as Keyword.ColorInterpolationKeyword)) {
					colorSpace = space as Keyword.ColorInterpolationKeyword;
					idx++;
				}
			}

			// Skip comma after color space if present
			const spaceCommaNode = children[idx];
			if (
				spaceCommaNode &&
				spaceCommaNode.type === "Operator" &&
				"value" in spaceCommaNode &&
				spaceCommaNode.value === ","
			) {
				idx++;
			}
		}
	}

	// Split remaining nodes into color stop groups
	const stopGroups = AstUtils.splitNodesByComma(children, { startIndex: idx });

	// Parse each color stop
	const colorStops: Type.ColorStop[] = [];
	for (const stopNodes of stopGroups) {
		const stopResult = ColorStop.fromNodes(stopNodes);
		if (stopResult.ok) {
			colorStops.push(stopResult.value);
		} else {
			return err(`Invalid color stop: ${stopResult.error}`);
		}
	}

	if (colorStops.length < 2) {
		return err("radial-gradient requires at least 2 color stops");
	}

	return ok({
		kind: "radial",
		shape,
		size,
		position,
		colorSpace,
		colorStops,
		repeating: isRepeating,
	});
}

/**
 * Parse a CSS radial gradient value into structured intermediate representation (IR).
 *
 * Parses both `radial-gradient()` and `repeating-radial-gradient()` functions,
 * extracting shape, size, position, color interpolation, and color stops into a
 * type-safe IR object.
 *
 * Supports all CSS radial gradient syntax per CSS Images Module Level 3:
 * - Shape keywords: `circle`, `ellipse` (default: `ellipse`)
 * - Size keywords: `closest-side`, `farthest-side`, `closest-corner`, `farthest-corner`
 * - Explicit sizes: lengths (px, em, etc.)
 * - Position: keywords (`center`, `top`, `left`, etc.) or length values
 * - Color interpolation: `in <color-space>` syntax
 * - Color stops: with optional positions
 *
 * @param css - CSS string containing a radial gradient function
 * @returns Result containing RadialGradient IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * Simple gradient (defaults to ellipse at center):
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Radial.parse("radial-gradient(red, blue)");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { kind: "radial", colorStops: [...], repeating: false }
 * }
 * ```
 *
 * @example
 * Circle with keyword size:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(circle closest-side, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.shape); // "circle"
 *   console.log(result.value.size);  // { kind: "keyword", value: "closest-side" }
 * }
 * ```
 *
 * @example
 * Positioned gradient:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(at center top, red 0%, blue 100%)"
 * );
 * if (result.ok) {
 *   console.log(result.value.position);
 *   // { horizontal: "center", vertical: "top" }
 * }
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(in oklch, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.colorSpace); // "oklch"
 * }
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse(
 *   "repeating-radial-gradient(circle, red 0px, blue 20px)"
 * );
 * if (result.ok) {
 *   console.log(result.value.repeating); // true
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse("invalid syntax");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient | MDN: radial-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients | W3C Spec: Radial Gradients}
 * @see {@link https://github.com/mdn/data/blob/main/css/functions.json | MDN Data: radial-gradient()}
 */
export function parse(css: string): Result<Type.RadialGradient, string> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the function node
		let funcNode: csstree.FunctionNode | null = null;
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (node.name === "radial-gradient" || node.name === "repeating-radial-gradient") {
					funcNode = node;
				}
			},
		});

		if (!funcNode) {
			return err("No radial-gradient function found in CSS string");
		}

		return fromFunction(funcNode);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/index.ts ===
// b_path:: src/parse/index.ts

/**
 * CSS value parsers - convert CSS strings to structured IR.
 *
 * All parsers return Result<T, string> for type-safe error handling.
 * Parse any CSS value into a structured intermediate representation (IR)
 * that can be inspected, transformed, or converted back to CSS.
 *
 * @module Parse
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(circle, red, blue)"
 * );
 *
 * if (result.ok) {
 *   console.log(result.value.shape); // "circle"
 *   console.log(result.value.colorStops); // [...]
 * } else {
 *   console.error(result.error);
 * }
 * ```
 */

/**
 * Animation parsers (delay, duration, iteration-count, direction, fill-mode, play-state, name, timing-function).
 *
 * @see {@link Animation.Delay.parse}
 */
export * as Animation from "./animation";
/**
 * Background parsers (attachment, clip, origin, repeat, size).
 *
 * @see {@link Background.Attachment.parse}
 */
export * as Background from "./background";
/**
 * Border parsers (width, style, color, radius).
 *
 * @see {@link Border.Width.parse}
 */
export * as Border from "./border";
/**
 * Clip-path parsers (url, none).
 *
 * @see {@link ClipPath.Url.parse}
 */
export * as ClipPath from "./clip-path";
/**
 * Color parsers (hex, named, RGB, HSL, HWB, LAB, LCH, OKLab, OKLCH, system, special).
 *
 * @see {@link Color.Hex.parse}
 */
export * as Color from "./color";
/**
 * Filter parsers (blur, brightness, contrast, drop-shadow, grayscale, hue-rotate, invert, opacity, saturate, sepia, url).
 *
 * @see {@link Filter.Blur.parse}
 */
export * as Filter from "./filter";
/**
 * Gradient parsers (radial, linear, conic).
 *
 * @see {@link Gradient.Radial.parse}
 */
export * as Gradient from "./gradient";
/**
 * Layout parsers (display, visibility, opacity).
 *
 * @see {@link Layout.Display.parse}
 */
export * as Layout from "./layout";
/**
 * Outline parsers (width, style, color, offset).
 *
 * @see {@link Outline.Width.parse}
 */
export * as Outline from "./outline";
/**
 * Position parsers (background-position, object-position, transform-origin, etc.).
 *
 * @see {@link Position.parse}
 */
export * as Position from "./position/position";
/**
 * Shadow parsers (box-shadow, text-shadow).
 *
 * @see {@link Shadow.BoxShadow.parse}
 */
export * as Shadow from "./shadow";
/**
 * Text decoration parsers (color, line, style, thickness).
 *
 * @see {@link Text.Color.parse}
 */
export * as Text from "./text";
/**
 * Transform parsers (translate, rotate, scale, skew, matrix, etc.).
 *
 * @see {@link Transform.parse}
 */
export * as Transform from "./transform/transform";
/**
 * Transition parsers (delay, duration, timing-function, property).
 *
 * @see {@link Transition.Delay.parse}
 */
export * as Transition from "./transition";


=== File: src/parse/layout/bottom.test.ts ===
// b_path:: src/parse/layout/bottom.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./bottom";

describe("Parse.Layout.Bottom", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: "auto",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses positive px", () => {
			const result = parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 10, unit: "px" },
				});
			}
		});

		it("parses negative px", () => {
			const result = parse("-10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: -10, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("1.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 1.5, unit: "rem" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("parses positive percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses negative percentage", () => {
			const result = parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: -25, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("10px 20px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/layout/bottom.ts ===
// b_path:: src/parse/layout/bottom.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS bottom property value.
 *
 * Accepts length-percentage values or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS bottom value (e.g., "10px", "50%", "auto")
 * @returns Result with Bottom IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("10px");
 * // { ok: true, value: { kind: "bottom", value: { value: 10, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "bottom", value: { value: 50, unit: "%" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "bottom", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/bottom | MDN: bottom}
 * @see {@link https://www.w3.org/TR/css-position-3/#insets | W3C Spec}
 */
export function parse(css: string): Result<Type.Bottom, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected bottom value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid bottom keyword: ${keyword}`);
			}
			return ok({
				kind: "bottom",
				value: "auto",
			});
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "bottom",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "bottom",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse bottom: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/cursor.ts ===
// b_path:: src/parse/layout/cursor.ts
import * as csstree from "css-tree";
import { CURSOR_KEYWORDS } from "@/core/keywords/cursor-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS cursor property value.
 *
 * Accepts cursor keyword values.
 * Per CSS Basic User Interface Module Level 4 specification.
 *
 * @param css - CSS cursor value (e.g., "pointer", "default", "text", "move")
 * @returns Result with Cursor IR or error message
 *
 * @example
 * Pointer cursor:
 * ```typescript
 * const result = parse("pointer");
 * // { ok: true, value: { kind: "cursor", value: "pointer" } }
 * ```
 *
 * @example
 * Text cursor:
 * ```typescript
 * const result = parse("text");
 * // { ok: true, value: { kind: "cursor", value: "text" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor | MDN: cursor}
 * @see {@link https://www.w3.org/TR/css-ui-4/#cursor | W3C Spec}
 */
export function parse(css: string): Result<Type.Cursor, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!CURSOR_KEYWORDS.includes(keyword as Type.Cursor["value"])) {
			return err(`Invalid cursor keyword: ${keyword}`);
		}

		return ok({
			kind: "cursor",
			value: keyword as Type.Cursor["value"],
		});
	} catch (error) {
		return err(`Failed to parse cursor: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/display.ts ===
// b_path:: src/parse/layout/display.ts
import * as csstree from "css-tree";
import { DISPLAY_KEYWORDS } from "@/core/keywords/display-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS display property value.
 *
 * Accepts display keywords including box, inside, internal, legacy, and outside values.
 * Per CSS Display Module Level 3 specification.
 *
 * @param css - CSS display value (e.g., "flex", "block", "inline-block", "none")
 * @returns Result with Display IR or error message
 *
 * @example
 * Flex layout:
 * ```typescript
 * const result = parse("flex");
 * // { ok: true, value: { kind: "display", value: "flex" } }
 * ```
 *
 * @example
 * Hidden element:
 * ```typescript
 * const result = parse("none");
 * // { ok: true, value: { kind: "display", value: "none" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display | MDN: display}
 * @see {@link https://www.w3.org/TR/css-display-3/ | W3C Spec}
 */
export function parse(css: string): Result<Type.Display, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!DISPLAY_KEYWORDS.includes(keyword as Type.Display["value"])) {
			return err(`Invalid display keyword: ${keyword}`);
		}

		return ok({
			kind: "display",
			value: keyword as Type.Display["value"],
		});
	} catch (error) {
		return err(`Failed to parse display: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/height.test.ts ===
// b_path:: src/parse/layout/height.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./height";

describe("Parse.Layout.Height", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: "auto",
				});
			}
		});
	});

	describe("intrinsic sizing keywords", () => {
		it("parses 'min-content'", () => {
			const result = parse("min-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: "min-content",
				});
			}
		});

		it("parses 'max-content'", () => {
			const result = parse("max-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: "max-content",
				});
			}
		});

		it("parses 'fit-content'", () => {
			const result = parse("fit-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: "fit-content",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses px", () => {
			const result = parse("100px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: { value: 100, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: { value: 5, unit: "em" },
				});
			}
		});

		it("parses vh", () => {
			const result = parse("100vh");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: { value: 100, unit: "vh" },
				});
			}
		});

		it("parses unitless 0", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("percentage values", () => {
		it("parses percentage", () => {
			const result = parse("100%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: { value: 100, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("100px 50px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/layout/height.ts ===
// b_path:: src/parse/layout/height.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS height property value.
 *
 * Accepts length-percentage values, auto keyword, or intrinsic sizing keywords.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @param css - CSS height value (e.g., "100px", "50%", "auto", "max-content")
 * @returns Result with Height IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("100px");
 * // { ok: true, value: { kind: "height", value: { value: 100, unit: "px" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "height", value: "auto" } }
 * ```
 *
 * @example
 * Intrinsic sizing:
 * ```typescript
 * const result = parse("max-content");
 * // { ok: true, value: { kind: "height", value: "max-content" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/height | MDN: height}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#width-height-keywords | W3C Spec}
 */
export function parse(css: string): Result<Type.Height, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected height value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			// Check for auto
			if (keyword === "auto") {
				return ok({
					kind: "height",
					value: "auto",
				});
			}

			// Check for intrinsic sizing keywords
			if (keyword === "min-content" || keyword === "max-content" || keyword === "fit-content") {
				return ok({
					kind: "height",
					value: keyword,
				});
			}

			return err(`Invalid height keyword: ${keyword}`);
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "height",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "height",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse height: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/index.ts ===
// b_path:: src/parse/layout/index.ts

export * as Bottom from "./bottom";
export * as Cursor from "./cursor";
export * as Display from "./display";
export * as Height from "./height";
export * as Left from "./left";
export * as Opacity from "./opacity";
export * as OverflowX from "./overflow-x";
export * as OverflowY from "./overflow-y";
export * as Position from "./position";
export * as Right from "./right";
export * as Top from "./top";
export * as Visibility from "./visibility";
export * as Width from "./width";
export * as ZIndex from "./z-index";


=== File: src/parse/layout/layout.test.ts ===
// b_path:: src/parse/layout/layout.test.ts
import { describe, expect, it } from "vitest";
import * as Cursor from "./cursor";
import * as Display from "./display";
import * as Opacity from "./opacity";
import * as Visibility from "./visibility";

describe("Parse Layout - Cursor", () => {
	it("should parse pointer cursor", () => {
		const result = Cursor.parse("pointer");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "pointer" });
		}
	});

	it("should parse default cursor", () => {
		const result = Cursor.parse("default");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "default" });
		}
	});

	it("should parse text cursor", () => {
		const result = Cursor.parse("text");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "text" });
		}
	});

	it("should parse move cursor", () => {
		const result = Cursor.parse("move");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "move" });
		}
	});

	it("should parse grab cursor", () => {
		const result = Cursor.parse("grab");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "grab" });
		}
	});

	it("should parse grabbing cursor", () => {
		const result = Cursor.parse("grabbing");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "grabbing" });
		}
	});

	it("should parse not-allowed cursor", () => {
		const result = Cursor.parse("not-allowed");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "not-allowed" });
		}
	});

	it("should parse help cursor", () => {
		const result = Cursor.parse("help");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "help" });
		}
	});

	it("should parse wait cursor", () => {
		const result = Cursor.parse("wait");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "wait" });
		}
	});

	it("should parse crosshair cursor", () => {
		const result = Cursor.parse("crosshair");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "crosshair" });
		}
	});

	it("should parse zoom-in cursor", () => {
		const result = Cursor.parse("zoom-in");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "zoom-in" });
		}
	});

	it("should parse zoom-out cursor", () => {
		const result = Cursor.parse("zoom-out");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "zoom-out" });
		}
	});

	it("should reject invalid cursor value", () => {
		const result = Cursor.parse("invalid");
		expect(result.ok).toBe(false);
	});
});

describe("Parse Layout - Display", () => {
	it("should parse flex display", () => {
		const result = Display.parse("flex");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "flex" });
		}
	});

	it("should parse block display", () => {
		const result = Display.parse("block");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "block" });
		}
	});

	it("should parse inline display", () => {
		const result = Display.parse("inline");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "inline" });
		}
	});

	it("should parse inline-block display", () => {
		const result = Display.parse("inline-block");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "inline-block" });
		}
	});

	it("should parse grid display", () => {
		const result = Display.parse("grid");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "grid" });
		}
	});

	it("should parse none display", () => {
		const result = Display.parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "none" });
		}
	});

	it("should parse table display", () => {
		const result = Display.parse("table");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "table" });
		}
	});

	it("should parse inline-flex display", () => {
		const result = Display.parse("inline-flex");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "inline-flex" });
		}
	});

	it("should parse inline-grid display", () => {
		const result = Display.parse("inline-grid");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "inline-grid" });
		}
	});

	it("should parse contents display", () => {
		const result = Display.parse("contents");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "contents" });
		}
	});

	it("should parse flow-root display", () => {
		const result = Display.parse("flow-root");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "flow-root" });
		}
	});

	it("should reject invalid display value", () => {
		const result = Display.parse("invalid");
		expect(result.ok).toBe(false);
	});
});

describe("Parse Layout - Visibility", () => {
	it("should parse visible visibility", () => {
		const result = Visibility.parse("visible");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "visibility", value: "visible" });
		}
	});

	it("should parse hidden visibility", () => {
		const result = Visibility.parse("hidden");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "visibility", value: "hidden" });
		}
	});

	it("should parse collapse visibility", () => {
		const result = Visibility.parse("collapse");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "visibility", value: "collapse" });
		}
	});

	it("should reject invalid visibility value", () => {
		const result = Visibility.parse("invalid");
		expect(result.ok).toBe(false);
	});
});

describe("Parse Layout - Opacity", () => {
	it("should parse opacity 0", () => {
		const result = Opacity.parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0 });
		}
	});

	it("should parse opacity 1", () => {
		const result = Opacity.parse("1");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 1 });
		}
	});

	it("should parse opacity 0.5", () => {
		const result = Opacity.parse("0.5");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0.5 });
		}
	});

	it("should parse opacity percentage 50%", () => {
		const result = Opacity.parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0.5 });
		}
	});

	it("should parse opacity percentage 100%", () => {
		const result = Opacity.parse("100%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 1 });
		}
	});

	it("should parse opacity percentage 0%", () => {
		const result = Opacity.parse("0%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0 });
		}
	});

	it("should clamp opacity above 1", () => {
		const result = Opacity.parse("1.5");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 1 });
		}
	});

	it("should clamp opacity below 0", () => {
		const result = Opacity.parse("-0.5");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0 });
		}
	});

	it("should reject invalid opacity value", () => {
		const result = Opacity.parse("invalid");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/layout/left.test.ts ===
// b_path:: src/parse/layout/left.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./left";

describe("Parse.Layout.Left", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: "auto",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses positive px", () => {
			const result = parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 10, unit: "px" },
				});
			}
		});

		it("parses negative px", () => {
			const result = parse("-10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: -10, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("1.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 1.5, unit: "rem" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("parses positive percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses negative percentage", () => {
			const result = parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: -25, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("10px 20px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/layout/left.ts ===
// b_path:: src/parse/layout/left.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS left property value.
 *
 * Accepts length-percentage values or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS left value (e.g., "10px", "50%", "auto")
 * @returns Result with Left IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("10px");
 * // { ok: true, value: { kind: "left", value: { value: 10, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "left", value: { value: 50, unit: "%" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "left", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/left | MDN: left}
 * @see {@link https://www.w3.org/TR/css-position-3/#insets | W3C Spec}
 */
export function parse(css: string): Result<Type.Left, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected left value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid left keyword: ${keyword}`);
			}
			return ok({
				kind: "left",
				value: "auto",
			});
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "left",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "left",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse left: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/opacity.ts ===
// b_path:: src/parse/layout/opacity.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS opacity property value.
 *
 * Accepts number (0-1) or percentage (0%-100%) values.
 * Values are clamped to the range [0, 1].
 *
 * @param css - CSS opacity value (e.g., "0.5", "50%", "1")
 * @returns Result with Opacity IR or error message
 *
 * @example
 * Number value:
 * ```typescript
 * const result = parse("0.5");
 * // { ok: true, value: { kind: "opacity", value: 0.5 } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "opacity", value: 0.5 } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/opacity | MDN: opacity}
 * @see {@link https://www.w3.org/TR/css-color-4/#transparency | W3C Spec}
 */
export function parse(css: string): Result<Type.Opacity, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected opacity value");
		}

		let value: number;

		if (node.type === "Number") {
			value = Number.parseFloat(node.value);
		} else if (node.type === "Percentage") {
			value = Number.parseFloat(node.value) / 100;
		} else {
			return err(`Expected number or percentage, got: ${node.type}`);
		}

		// Clamp value to [0, 1]
		value = Math.max(0, Math.min(1, value));

		return ok({
			kind: "opacity",
			value,
		});
	} catch (error) {
		return err(`Failed to parse opacity: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/overflow-x.test.ts ===
// b_path:: src/parse/layout/overflow-x.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse";

describe("Parse.Layout.OverflowX", () => {
	describe("valid overflow-x keywords", () => {
		it("should parse 'visible'", () => {
			const result = Parse.Layout.OverflowX.parse("visible");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-x",
					value: "visible",
				});
			}
		});

		it("should parse 'hidden'", () => {
			const result = Parse.Layout.OverflowX.parse("hidden");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-x",
					value: "hidden",
				});
			}
		});

		it("should parse 'clip'", () => {
			const result = Parse.Layout.OverflowX.parse("clip");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-x",
					value: "clip",
				});
			}
		});

		it("should parse 'scroll'", () => {
			const result = Parse.Layout.OverflowX.parse("scroll");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-x",
					value: "scroll",
				});
			}
		});

		it("should parse 'auto'", () => {
			const result = Parse.Layout.OverflowX.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-x",
					value: "auto",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse 'HIDDEN'", () => {
			const result = Parse.Layout.OverflowX.parse("HIDDEN");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("hidden");
			}
		});

		it("should parse 'Scroll'", () => {
			const result = Parse.Layout.OverflowX.parse("Scroll");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("scroll");
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = Parse.Layout.OverflowX.parse("invalid");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid overflow-x keyword");
			}
		});

		it("should reject empty string", () => {
			const result = Parse.Layout.OverflowX.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject numeric value", () => {
			const result = Parse.Layout.OverflowX.parse("123");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = Parse.Layout.OverflowX.parse("hidden scroll");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected single value");
			}
		});
	});
});


=== File: src/parse/layout/overflow-x.ts ===
// b_path:: src/parse/layout/overflow-x.ts
import * as csstree from "css-tree";
import { OVERFLOW_KEYWORDS } from "@/core/keywords/overflow-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS overflow-x property value.
 *
 * Accepts overflow keyword values for horizontal overflow behavior.
 * Per CSS Overflow Module Level 3 specification.
 *
 * @param css - CSS overflow-x value (e.g., "visible", "hidden", "scroll", "auto", "clip")
 * @returns Result with OverflowX IR or error message
 *
 * @example
 * Hidden overflow:
 * ```typescript
 * const result = parse("hidden");
 * // { ok: true, value: { kind: "overflow-x", value: "hidden" } }
 * ```
 *
 * @example
 * Scroll overflow:
 * ```typescript
 * const result = parse("scroll");
 * // { ok: true, value: { kind: "overflow-x", value: "scroll" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x | MDN: overflow-x}
 * @see {@link https://www.w3.org/TR/css-overflow-3/#overflow-properties | W3C Spec}
 */
export function parse(css: string): Result<Type.OverflowX, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!OVERFLOW_KEYWORDS.includes(keyword as Type.OverflowX["value"])) {
			return err(`Invalid overflow-x keyword: ${keyword}`);
		}

		return ok({
			kind: "overflow-x",
			value: keyword as Type.OverflowX["value"],
		});
	} catch (error) {
		return err(`Failed to parse overflow-x: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/overflow-y.test.ts ===
// b_path:: src/parse/layout/overflow-y.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse";

describe("Parse.Layout.OverflowY", () => {
	describe("valid overflow-y keywords", () => {
		it("should parse 'visible'", () => {
			const result = Parse.Layout.OverflowY.parse("visible");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-y",
					value: "visible",
				});
			}
		});

		it("should parse 'hidden'", () => {
			const result = Parse.Layout.OverflowY.parse("hidden");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-y",
					value: "hidden",
				});
			}
		});

		it("should parse 'clip'", () => {
			const result = Parse.Layout.OverflowY.parse("clip");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-y",
					value: "clip",
				});
			}
		});

		it("should parse 'scroll'", () => {
			const result = Parse.Layout.OverflowY.parse("scroll");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-y",
					value: "scroll",
				});
			}
		});

		it("should parse 'auto'", () => {
			const result = Parse.Layout.OverflowY.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-y",
					value: "auto",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse 'VISIBLE'", () => {
			const result = Parse.Layout.OverflowY.parse("VISIBLE");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("visible");
			}
		});

		it("should parse 'Auto'", () => {
			const result = Parse.Layout.OverflowY.parse("Auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("auto");
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = Parse.Layout.OverflowY.parse("overflow");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid overflow-y keyword");
			}
		});

		it("should reject empty string", () => {
			const result = Parse.Layout.OverflowY.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject numeric value", () => {
			const result = Parse.Layout.OverflowY.parse("50");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = Parse.Layout.OverflowY.parse("auto scroll");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected single value");
			}
		});
	});
});


=== File: src/parse/layout/overflow-y.ts ===
// b_path:: src/parse/layout/overflow-y.ts
import * as csstree from "css-tree";
import { OVERFLOW_KEYWORDS } from "@/core/keywords/overflow-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS overflow-y property value.
 *
 * Accepts overflow keyword values for vertical overflow behavior.
 * Per CSS Overflow Module Level 3 specification.
 *
 * @param css - CSS overflow-y value (e.g., "visible", "hidden", "scroll", "auto", "clip")
 * @returns Result with OverflowY IR or error message
 *
 * @example
 * Hidden overflow:
 * ```typescript
 * const result = parse("hidden");
 * // { ok: true, value: { kind: "overflow-y", value: "hidden" } }
 * ```
 *
 * @example
 * Auto overflow:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "overflow-y", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y | MDN: overflow-y}
 * @see {@link https://www.w3.org/TR/css-overflow-3/#overflow-properties | W3C Spec}
 */
export function parse(css: string): Result<Type.OverflowY, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!OVERFLOW_KEYWORDS.includes(keyword as Type.OverflowY["value"])) {
			return err(`Invalid overflow-y keyword: ${keyword}`);
		}

		return ok({
			kind: "overflow-y",
			value: keyword as Type.OverflowY["value"],
		});
	} catch (error) {
		return err(`Failed to parse overflow-y: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/position.test.ts ===
// b_path:: src/parse/layout/position.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse";

describe("Parse.Layout.Position", () => {
	describe("valid position keywords", () => {
		it("should parse 'static'", () => {
			const result = Parse.Layout.Position.parse("static");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "position-property",
					value: "static",
				});
			}
		});

		it("should parse 'relative'", () => {
			const result = Parse.Layout.Position.parse("relative");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "position-property",
					value: "relative",
				});
			}
		});

		it("should parse 'absolute'", () => {
			const result = Parse.Layout.Position.parse("absolute");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "position-property",
					value: "absolute",
				});
			}
		});

		it("should parse 'fixed'", () => {
			const result = Parse.Layout.Position.parse("fixed");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "position-property",
					value: "fixed",
				});
			}
		});

		it("should parse 'sticky'", () => {
			const result = Parse.Layout.Position.parse("sticky");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "position-property",
					value: "sticky",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse 'ABSOLUTE'", () => {
			const result = Parse.Layout.Position.parse("ABSOLUTE");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("absolute");
			}
		});

		it("should parse 'Sticky'", () => {
			const result = Parse.Layout.Position.parse("Sticky");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("sticky");
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = Parse.Layout.Position.parse("positioned");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid position keyword");
			}
		});

		it("should reject empty string", () => {
			const result = Parse.Layout.Position.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject numeric value", () => {
			const result = Parse.Layout.Position.parse("10px");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = Parse.Layout.Position.parse("absolute fixed");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected single value");
			}
		});
	});
});


=== File: src/parse/layout/position.ts ===
// b_path:: src/parse/layout/position.ts
import * as csstree from "css-tree";
import { POSITION_PROPERTY_KEYWORDS } from "@/core/keywords/position-property-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS position property value.
 *
 * Accepts position keyword values that control positioning scheme.
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS position value (e.g., "static", "relative", "absolute", "fixed", "sticky")
 * @returns Result with PositionProperty IR or error message
 *
 * @example
 * Absolute positioning:
 * ```typescript
 * const result = parse("absolute");
 * // { ok: true, value: { kind: "position-property", value: "absolute" } }
 * ```
 *
 * @example
 * Sticky positioning:
 * ```typescript
 * const result = parse("sticky");
 * // { ok: true, value: { kind: "position-property", value: "sticky" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position | MDN: position}
 * @see {@link https://www.w3.org/TR/css-position-3/#position-property | W3C Spec}
 */
export function parse(css: string): Result<Type.PositionProperty, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!POSITION_PROPERTY_KEYWORDS.includes(keyword as Type.PositionProperty["value"])) {
			return err(`Invalid position keyword: ${keyword}`);
		}

		return ok({
			kind: "position-property",
			value: keyword as Type.PositionProperty["value"],
		});
	} catch (error) {
		return err(`Failed to parse position: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/right.test.ts ===
// b_path:: src/parse/layout/right.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./right";

describe("Parse.Layout.Right", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: "auto",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses positive px", () => {
			const result = parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 10, unit: "px" },
				});
			}
		});

		it("parses negative px", () => {
			const result = parse("-10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: -10, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("1.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 1.5, unit: "rem" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("parses positive percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses negative percentage", () => {
			const result = parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: -25, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("10px 20px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/layout/right.ts ===
// b_path:: src/parse/layout/right.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS right property value.
 *
 * Accepts length-percentage values or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS right value (e.g., "10px", "50%", "auto")
 * @returns Result with Right IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("10px");
 * // { ok: true, value: { kind: "right", value: { value: 10, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "right", value: { value: 50, unit: "%" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "right", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/right | MDN: right}
 * @see {@link https://www.w3.org/TR/css-position-3/#insets | W3C Spec}
 */
export function parse(css: string): Result<Type.Right, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected right value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid right keyword: ${keyword}`);
			}
			return ok({
				kind: "right",
				value: "auto",
			});
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "right",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "right",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse right: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/top.test.ts ===
// b_path:: src/parse/layout/top.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./top";

describe("Parse.Layout.Top", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: "auto",
				});
			}
		});

		it("parses 'AUTO' (case insensitive)", () => {
			const result = parse("AUTO");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("auto");
			}
		});
	});

	describe("length values", () => {
		it("parses positive px", () => {
			const result = parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 10, unit: "px" },
				});
			}
		});

		it("parses negative px", () => {
			const result = parse("-10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: -10, unit: "px" },
				});
			}
		});

		it("parses zero", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("1.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 1.5, unit: "rem" },
				});
			}
		});

		it("parses vh", () => {
			const result = parse("50vh");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 50, unit: "vh" },
				});
			}
		});

		it("parses vw", () => {
			const result = parse("100vw");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 100, unit: "vw" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("parses positive percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses negative percentage", () => {
			const result = parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: -25, unit: "%" },
				});
			}
		});

		it("parses zero percentage", () => {
			const result = parse("0%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "%" });
			}
		});

		it("parses decimal percentage", () => {
			const result = parse("33.33%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 33.33, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("10px 20px");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid unit", () => {
			const result = parse("10xyz");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/layout/top.ts ===
// b_path:: src/parse/layout/top.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS top property value.
 *
 * Accepts length-percentage values or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS top value (e.g., "10px", "50%", "auto")
 * @returns Result with Top IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("10px");
 * // { ok: true, value: { kind: "top", value: { value: 10, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "top", value: { value: 50, unit: "%" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "top", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/top | MDN: top}
 * @see {@link https://www.w3.org/TR/css-position-3/#insets | W3C Spec}
 */
export function parse(css: string): Result<Type.Top, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected top value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid top keyword: ${keyword}`);
			}
			return ok({
				kind: "top",
				value: "auto",
			});
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "top",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "top",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse top: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/visibility.ts ===
// b_path:: src/parse/layout/visibility.ts
import * as csstree from "css-tree";
import { VISIBILITY_KEYWORDS } from "@/core/keywords/visibility-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS visibility property value.
 *
 * Accepts visibility keywords: visible, hidden, collapse.
 * Per CSS Display Module Level 3 specification.
 *
 * @param css - CSS visibility value (e.g., "visible", "hidden", "collapse")
 * @returns Result with Visibility IR or error message
 *
 * @example
 * Visible element:
 * ```typescript
 * const result = parse("visible");
 * // { ok: true, value: { kind: "visibility", value: "visible" } }
 * ```
 *
 * @example
 * Hidden element:
 * ```typescript
 * const result = parse("hidden");
 * // { ok: true, value: { kind: "visibility", value: "hidden" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | MDN: visibility}
 * @see {@link https://www.w3.org/TR/css-display-3/#visibility | W3C Spec}
 */
export function parse(css: string): Result<Type.Visibility, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!VISIBILITY_KEYWORDS.includes(keyword as Type.Visibility["value"])) {
			return err(`Invalid visibility keyword: ${keyword}`);
		}

		return ok({
			kind: "visibility",
			value: keyword as Type.Visibility["value"],
		});
	} catch (error) {
		return err(`Failed to parse visibility: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/width.test.ts ===
// b_path:: src/parse/layout/width.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./width";

describe("Parse.Layout.Width", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: "auto",
				});
			}
		});
	});

	describe("intrinsic sizing keywords", () => {
		it("parses 'min-content'", () => {
			const result = parse("min-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: "min-content",
				});
			}
		});

		it("parses 'max-content'", () => {
			const result = parse("max-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: "max-content",
				});
			}
		});

		it("parses 'fit-content'", () => {
			const result = parse("fit-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: "fit-content",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses px", () => {
			const result = parse("200px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 200, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("10em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 10, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("2.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 2.5, unit: "rem" },
				});
			}
		});

		it("parses vw", () => {
			const result = parse("100vw");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 100, unit: "vw" },
				});
			}
		});

		it("parses unitless 0", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("percentage values", () => {
		it("parses percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses decimal percentage", () => {
			const result = parse("33.33%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 33.33, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("100px 200px");
			expect(result.ok).toBe(false);
		});

		it("rejects negative values", () => {
			const result = parse("-100px");
			expect(result.ok).toBe(true); // CSS allows negative widths (they're clamped to 0)
		});
	});
});


=== File: src/parse/layout/width.ts ===
// b_path:: src/parse/layout/width.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS width property value.
 *
 * Accepts length-percentage values, auto keyword, or intrinsic sizing keywords.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @param css - CSS width value (e.g., "200px", "50%", "auto", "min-content")
 * @returns Result with Width IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("200px");
 * // { ok: true, value: { kind: "width", value: { value: 200, unit: "px" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "width", value: "auto" } }
 * ```
 *
 * @example
 * Intrinsic sizing:
 * ```typescript
 * const result = parse("min-content");
 * // { ok: true, value: { kind: "width", value: "min-content" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width | MDN: width}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#width-height-keywords | W3C Spec}
 */
export function parse(css: string): Result<Type.Width, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected width value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			// Check for auto
			if (keyword === "auto") {
				return ok({
					kind: "width",
					value: "auto",
				});
			}

			// Check for intrinsic sizing keywords
			if (keyword === "min-content" || keyword === "max-content" || keyword === "fit-content") {
				return ok({
					kind: "width",
					value: keyword,
				});
			}

			return err(`Invalid width keyword: ${keyword}`);
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "width",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "width",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse width: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/z-index.test.ts ===
// b_path:: src/parse/layout/z-index.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse";

describe("Parse.Layout.ZIndex", () => {
	describe("valid integer values", () => {
		it("should parse positive integer", () => {
			const result = Parse.Layout.ZIndex.parse("10");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: 10,
				});
			}
		});

		it("should parse negative integer", () => {
			const result = Parse.Layout.ZIndex.parse("-5");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: -5,
				});
			}
		});

		it("should parse zero", () => {
			const result = Parse.Layout.ZIndex.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: 0,
				});
			}
		});

		it("should parse large positive integer", () => {
			const result = Parse.Layout.ZIndex.parse("999");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: 999,
				});
			}
		});

		it("should parse large negative integer", () => {
			const result = Parse.Layout.ZIndex.parse("-999");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: -999,
				});
			}
		});
	});

	describe("auto keyword", () => {
		it("should parse 'auto'", () => {
			const result = Parse.Layout.ZIndex.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: "auto",
				});
			}
		});

		it("should parse 'AUTO' (case insensitive)", () => {
			const result = Parse.Layout.ZIndex.parse("AUTO");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("auto");
			}
		});
	});

	describe("invalid values", () => {
		it("should reject decimal/float values", () => {
			const result = Parse.Layout.ZIndex.parse("1.5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("must be an integer");
			}
		});

		it("should reject percentage", () => {
			const result = Parse.Layout.ZIndex.parse("50%");
			expect(result.ok).toBe(false);
		});

		it("should reject length units", () => {
			const result = Parse.Layout.ZIndex.parse("10px");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid keyword", () => {
			const result = Parse.Layout.ZIndex.parse("inherit");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid z-index keyword");
			}
		});

		it("should reject empty string", () => {
			const result = Parse.Layout.ZIndex.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = Parse.Layout.ZIndex.parse("10 20");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected single value");
			}
		});
	});
});


=== File: src/parse/layout/z-index.ts ===
// b_path:: src/parse/layout/z-index.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS z-index property value.
 *
 * Accepts integer values (positive, negative, or zero) or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS z-index value (e.g., "10", "-5", "0", "auto")
 * @returns Result with ZIndex IR or error message
 *
 * @example
 * Positive integer:
 * ```typescript
 * const result = parse("10");
 * // { ok: true, value: { kind: "z-index", value: 10 } }
 * ```
 *
 * @example
 * Negative integer:
 * ```typescript
 * const result = parse("-5");
 * // { ok: true, value: { kind: "z-index", value: -5 } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "z-index", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/z-index | MDN: z-index}
 * @see {@link https://www.w3.org/TR/css-position-3/#z-index | W3C Spec}
 */
export function parse(css: string): Result<Type.ZIndex, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected z-index value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid z-index keyword: ${keyword}`);
			}
			return ok({
				kind: "z-index",
				value: "auto",
			});
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);

			// Check if it's an integer
			if (!Number.isInteger(value)) {
				return err(`z-index must be an integer, got: ${value}`);
			}

			return ok({
				kind: "z-index",
				value,
			});
		}

		return err(`Expected integer or 'auto', got: ${node.type}`);
	} catch (error) {
		return err(`Failed to parse z-index: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/outline/color.test.ts ===
// b_path:: src/parse/outline/color.test.ts
import { describe, expect, it } from "vitest";
import * as OutlineColor from "./color";

describe("Parse.Border.Color", () => {
	describe("valid keywords", () => {
		it("should parse 'invert'", () => {
			const result = OutlineColor.parse("invert");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "invert",
				});
			}
		});

		it("should parse 'transparent'", () => {
			const result = OutlineColor.parse("transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "transparent",
				});
			}
		});

		it("should parse 'currentcolor'", () => {
			const result = OutlineColor.parse("currentcolor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "currentcolor",
				});
			}
		});

		it("should parse 'red'", () => {
			const result = OutlineColor.parse("red");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "red",
				});
			}
		});

		it("should parse 'blue'", () => {
			const result = OutlineColor.parse("blue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "blue",
				});
			}
		});

		it("should parse 'green'", () => {
			const result = OutlineColor.parse("green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "green",
				});
			}
		});

		it("should parse 'black'", () => {
			const result = OutlineColor.parse("black");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "black",
				});
			}
		});

		it("should parse 'white'", () => {
			const result = OutlineColor.parse("white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "white",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = OutlineColor.parse("notacolor");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("color keyword");
			}
		});

		it("should reject length values", () => {
			const result = OutlineColor.parse("1px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OutlineColor.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OutlineColor.parse("red blue");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/color.ts ===
// b_path:: src/parse/outline/color.ts
import * as csstree from "css-tree";
import { ALL_NAMED_COLOR_KEYWORDS } from "@/core/keywords/color-value-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS outline-color property value.
 *
 * Accepts color keywords (currentcolor, transparent, named colors, invert).
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * Note: This parser currently handles color keywords only.
 * For full color support (rgb, hsl, hex, etc.), use the color parsers.
 *
 * @param css - CSS outline-color value (e.g., "red", "transparent", "invert")
 * @returns Result with OutlineColor IR or error message
 *
 * @example
 * Named color:
 * ```typescript
 * const result = parse("red");
 * // { ok: true, value: { kind: "outline-color", color: "red" } }
 * ```
 *
 * @example
 * Invert (outline-specific):
 * ```typescript
 * const result = parse("invert");
 * // { ok: true, value: { kind: "outline-color", color: "invert" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color | MDN: outline-color}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-color | W3C Spec}
 */
export function parse(css: string): Result<Type.OutlineColorValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single outline-color value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty outline-color value");
		}

		if (node.type !== "Identifier") {
			return err(`Expected color keyword for outline-color, got: ${node.type}`);
		}

		const keyword = node.name.toLowerCase();

		// Check for 'invert' which is outline-specific
		if (keyword === "invert") {
			return ok({
				kind: "outline-color",
				color: "invert",
			});
		}

		// Check standard color keywords
		if (!ALL_NAMED_COLOR_KEYWORDS.includes(keyword as (typeof ALL_NAMED_COLOR_KEYWORDS)[number])) {
			return err(`Invalid color keyword: ${keyword}`);
		}

		return ok({
			kind: "outline-color",
			color: keyword as (typeof ALL_NAMED_COLOR_KEYWORDS)[number] | "invert",
		});
	} catch (e) {
		return err(`Failed to parse outline-color: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/outline/index.ts ===
// b_path:: src/parse/outline/index.ts

export * as Color from "./color";
export * as Offset from "./offset";
export { parse } from "./outline";
export * as Style from "./style";
export * as Width from "./width";


=== File: src/parse/outline/offset.test.ts ===
// b_path:: src/parse/outline/offset.test.ts
import { describe, expect, it } from "vitest";
import * as OutlineOffset from "./offset";

describe("Parse.Outline.Offset", () => {
	describe("valid lengths", () => {
		it("should parse '0' (unitless zero)", () => {
			const result = OutlineOffset.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '5px'", () => {
			const result = OutlineOffset.parse("5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 5, unit: "px" },
				});
			}
		});

		it("should parse '2.5em'", () => {
			const result = OutlineOffset.parse("2.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 2.5, unit: "em" },
				});
			}
		});

		it("should parse '0.5rem'", () => {
			const result = OutlineOffset.parse("0.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 0.5, unit: "rem" },
				});
			}
		});

		it("should parse '10pt'", () => {
			const result = OutlineOffset.parse("10pt");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 10, unit: "pt" },
				});
			}
		});
	});

	describe("negative values", () => {
		it("should parse '-1px'", () => {
			const result = OutlineOffset.parse("-1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: -1, unit: "px" },
				});
			}
		});

		it("should parse '-2.5em'", () => {
			const result = OutlineOffset.parse("-2.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: -2.5, unit: "em" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keywords", () => {
			const result = OutlineOffset.parse("auto");
			expect(result.ok).toBe(false);
		});

		it("should reject unitless non-zero", () => {
			const result = OutlineOffset.parse("5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless");
			}
		});

		it("should reject percentage values", () => {
			const result = OutlineOffset.parse("50%");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OutlineOffset.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OutlineOffset.parse("1px 2px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/offset.ts ===
// b_path:: src/parse/outline/offset.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { ABSOLUTE_LENGTH_UNITS, FONT_LENGTH_UNITS, VIEWPORT_LENGTH_UNITS } from "@/core/units";

/**
 * Parse CSS outline-offset property value.
 *
 * Accepts length values (can be negative unlike border/outline-width).
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param css - CSS outline-offset value (e.g., "5px", "-2px", "0.5em")
 * @returns Result with OutlineOffset IR or error message
 *
 * @example
 * Positive offset:
 * ```typescript
 * const result = parse("5px");
 * // { ok: true, value: { kind: "outline-offset", offset: { value: 5, unit: "px" } } }
 * ```
 *
 * @example
 * Negative offset:
 * ```typescript
 * const result = parse("-2px");
 * // { ok: true, value: { kind: "outline-offset", offset: { value: -2, unit: "px" } } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset | MDN: outline-offset}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-offset | W3C Spec}
 */
export function parse(css: string): Result<Type.OutlineOffsetValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single outline-offset value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty outline-offset value");
		}

		// Handle zero without unit
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value !== 0) {
				return err("Unitless values must be zero");
			}
			return ok({
				kind: "outline-offset",
				offset: {
					value: 0,
					unit: "px",
				},
			});
		}

		// Handle length (including negative values)
		if (node.type === "Dimension") {
			const value = Number.parseFloat(node.value);
			const unit = node.unit.toLowerCase();

			const allLengthUnits = [...ABSOLUTE_LENGTH_UNITS, ...FONT_LENGTH_UNITS, ...VIEWPORT_LENGTH_UNITS];
			if (!allLengthUnits.includes(unit as (typeof allLengthUnits)[number])) {
				return err(`Invalid length unit for outline-offset: ${unit}`);
			}

			return ok({
				kind: "outline-offset",
				offset: {
					value,
					unit: unit as (typeof allLengthUnits)[number],
				},
			});
		}

		return err(`Unexpected node type: ${node.type}`);
	} catch (e) {
		return err(`Failed to parse outline-offset: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/outline/outline.ts ===
// b_path:: src/parse/outline/outline.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";

import * as Color from "./color";
import * as Offset from "./offset";
import * as Style from "./style";
import * as Width from "./width";

export function parse(value: string): ParseResult<unknown> {
	const widthResult = Width.parse(value);
	if (widthResult.ok) return toParseResult(widthResult);

	const styleResult = Style.parse(value);
	if (styleResult.ok) return toParseResult(styleResult);

	const colorResult = Color.parse(value);
	if (colorResult.ok) return toParseResult(colorResult);

	const offsetResult = Offset.parse(value);
	if (offsetResult.ok) return toParseResult(offsetResult);

	return parseErr("invalid-value", "Invalid outline property value", {
		suggestion: "Expected width, style, color, or offset",
	});
}


=== File: src/parse/outline/style.test.ts ===
// b_path:: src/parse/outline/style.test.ts
import { describe, expect, it } from "vitest";
import * as OutlineStyle from "./style";

describe("Parse.Border.Style", () => {
	describe("valid keywords", () => {
		it("should parse 'auto'", () => {
			const result = OutlineStyle.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "auto",
				});
			}
		});

		it("should parse 'none'", () => {
			const result = OutlineStyle.parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "none",
				});
			}
		});

		it("should parse 'hidden'", () => {
			const result = OutlineStyle.parse("hidden");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "hidden",
				});
			}
		});

		it("should parse 'dotted'", () => {
			const result = OutlineStyle.parse("dotted");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "dotted",
				});
			}
		});

		it("should parse 'dashed'", () => {
			const result = OutlineStyle.parse("dashed");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "dashed",
				});
			}
		});

		it("should parse 'solid'", () => {
			const result = OutlineStyle.parse("solid");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "solid",
				});
			}
		});

		it("should parse 'double'", () => {
			const result = OutlineStyle.parse("double");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "double",
				});
			}
		});

		it("should parse 'groove'", () => {
			const result = OutlineStyle.parse("groove");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "groove",
				});
			}
		});

		it("should parse 'ridge'", () => {
			const result = OutlineStyle.parse("ridge");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "ridge",
				});
			}
		});

		it("should parse 'inset'", () => {
			const result = OutlineStyle.parse("inset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "inset",
				});
			}
		});

		it("should parse 'outset'", () => {
			const result = OutlineStyle.parse("outset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "outset",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = OutlineStyle.parse("wavy");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("keyword");
			}
		});

		it("should reject length values", () => {
			const result = OutlineStyle.parse("1px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OutlineStyle.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OutlineStyle.parse("solid dashed");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/style.ts ===
// b_path:: src/parse/outline/style.ts
import * as csstree from "css-tree";
import { OUTLINE_STYLE_KEYWORDS } from "@/core/keywords/outline-style-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS outline-style property value.
 *
 * Accepts predefined style keywords including 'auto' (outline-specific).
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param css - CSS outline-style value (e.g., "solid", "dashed", "auto")
 * @returns Result with OutlineStyle IR or error message
 *
 * @example
 * Solid outline:
 * ```typescript
 * const result = parse("solid");
 * // { ok: true, value: { kind: "outline-style", style: "solid" } }
 * ```
 *
 * @example
 * Auto outline (browser-determined):
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "outline-style", style: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style | MDN: outline-style}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-style | W3C Spec}
 */
export function parse(css: string): Result<Type.OutlineStyleValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single outline-style value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty outline-style value");
		}

		if (node.type !== "Identifier") {
			return err(`Expected keyword for outline-style, got: ${node.type}`);
		}

		const keyword = node.name.toLowerCase();
		if (!OUTLINE_STYLE_KEYWORDS.includes(keyword as Type.OutlineStyle)) {
			return err(`Invalid outline-style keyword: ${keyword}`);
		}

		return ok({
			kind: "outline-style",
			style: keyword as Type.OutlineStyle,
		});
	} catch (e) {
		return err(`Failed to parse outline-style: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/outline/width.test.ts ===
// b_path:: src/parse/outline/width.test.ts
import { describe, expect, it } from "vitest";
import * as OutlineWidth from "./width";

describe("Parse.Outline.Width", () => {
	describe("valid keywords", () => {
		it("should parse 'thin'", () => {
			const result = OutlineWidth.parse("thin");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: "thin",
				});
			}
		});

		it("should parse 'medium'", () => {
			const result = OutlineWidth.parse("medium");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: "medium",
				});
			}
		});

		it("should parse 'thick'", () => {
			const result = OutlineWidth.parse("thick");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: "thick",
				});
			}
		});
	});

	describe("valid lengths", () => {
		it("should parse '0' (unitless zero)", () => {
			const result = OutlineWidth.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '1px'", () => {
			const result = OutlineWidth.parse("1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 1, unit: "px" },
				});
			}
		});

		it("should parse '2.5em'", () => {
			const result = OutlineWidth.parse("2.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 2.5, unit: "em" },
				});
			}
		});

		it("should parse '0.5rem'", () => {
			const result = OutlineWidth.parse("0.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 0.5, unit: "rem" },
				});
			}
		});

		it("should parse '10pt'", () => {
			const result = OutlineWidth.parse("10pt");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 10, unit: "pt" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject negative values", () => {
			const result = OutlineWidth.parse("-1px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject invalid keywords", () => {
			const result = OutlineWidth.parse("large");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("keyword");
			}
		});

		it("should reject unitless non-zero", () => {
			const result = OutlineWidth.parse("5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless");
			}
		});

		it("should reject percentage values", () => {
			const result = OutlineWidth.parse("50%");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OutlineWidth.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OutlineWidth.parse("1px 2px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/width.ts ===
// b_path:: src/parse/outline/width.ts
import * as csstree from "css-tree";
import { BORDER_WIDTH_KEYWORDS } from "@/core/keywords/border-width-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { ABSOLUTE_LENGTH_UNITS, FONT_LENGTH_UNITS, VIEWPORT_LENGTH_UNITS } from "@/core/units";

/**
 * Parse CSS outline-width property value.
 *
 * Accepts length values or predefined keywords (thin, medium, thick).
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param css - CSS outline-width value (e.g., "1px", "medium", "0.5em")
 * @returns Result with OutlineWidth IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("1px");
 * // { ok: true, value: { kind: "outline-width", width: { value: 1, unit: "px" } } }
 * ```
 *
 * @example
 * Keyword value:
 * ```typescript
 * const result = parse("medium");
 * // { ok: true, value: { kind: "outline-width", width: "medium" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-width | MDN: outline-width}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-width | W3C Spec}
 */
export function parse(css: string): Result<Type.OutlineWidthValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single outline-width value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty outline-width value");
		}

		// Handle keywords
		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			const keywordValue = keyword as "thin" | "medium" | "thick";
			if (BORDER_WIDTH_KEYWORDS.includes(keywordValue)) {
				return ok({
					kind: "outline-width",
					width: keywordValue,
				});
			}
			return err(`Invalid outline-width keyword: ${keyword}`);
		}

		// Handle length
		if (node.type === "Dimension") {
			const value = Number.parseFloat(node.value);
			const unit = node.unit.toLowerCase();

			const allLengthUnits = [...ABSOLUTE_LENGTH_UNITS, ...FONT_LENGTH_UNITS, ...VIEWPORT_LENGTH_UNITS];
			if (!allLengthUnits.includes(unit as (typeof allLengthUnits)[number])) {
				return err(`Invalid length unit for outline-width: ${unit}`);
			}

			if (value < 0) {
				return err(`outline-width must be non-negative, got: ${value}`);
			}

			return ok({
				kind: "outline-width",
				width: {
					value,
					unit: unit as (typeof allLengthUnits)[number],
				},
			});
		}

		// Handle zero without unit
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value !== 0) {
				return err("Unitless values must be zero");
			}
			return ok({
				kind: "outline-width",
				width: {
					value: 0,
					unit: "px",
				},
			});
		}

		return err(`Unexpected node type: ${node.type}`);
	} catch (e) {
		return err(`Failed to parse outline-width: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/position/index.ts ===
// b_path:: src/parse/position/index.ts

export * as Position from "./position";
export { parse, parse3D, parseList } from "./position";


=== File: src/parse/position/position.parse.test.ts ===
// b_path:: src/parse/position/position.parse.test.ts
import { describe, expect, it } from "vitest";
import * as PositionParser from "./position";

describe("Position Parser", () => {
	describe("2D Position parsing", () => {
		it("should parse single keyword position", () => {
			const css = "center";
			const result = PositionParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "center",
				});
			}
		});

		it("should parse two keyword positions", () => {
			const css = "left top";
			const result = PositionParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: "top",
				});
			}
		});

		it("should parse all keyword combinations", () => {
			const positions = [
				{ css: "center", expected: { horizontal: "center", vertical: "center" } },
				{ css: "left", expected: { horizontal: "left", vertical: "center" } },
				{ css: "right", expected: { horizontal: "right", vertical: "center" } },
				{ css: "top", expected: { horizontal: "center", vertical: "top" } },
				{ css: "bottom", expected: { horizontal: "center", vertical: "bottom" } },
				{ css: "left top", expected: { horizontal: "left", vertical: "top" } },
				{ css: "right bottom", expected: { horizontal: "right", vertical: "bottom" } },
				{ css: "center top", expected: { horizontal: "center", vertical: "top" } },
			];

			for (const { css, expected } of positions) {
				const result = PositionParser.parse(css);
				expect(result.ok).toBe(true);
				if (result.ok) {
					expect(result.value).toEqual(expected);
				}
			}
		});

		it("should parse length values", () => {
			const css = "100px 50px";
			const result = PositionParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 100, unit: "px" },
					vertical: { value: 50, unit: "px" },
				});
			}
		});

		it("should parse percentage values", () => {
			const css = "50% 25%";
			const result = PositionParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 50, unit: "%" },
					vertical: { value: 25, unit: "%" },
				});
			}
		});

		it("should parse mixed keyword and length", () => {
			const css = "left 50px";
			const result = PositionParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: { value: 50, unit: "px" },
				});
			}
		});

		it("should parse mixed keyword and percentage", () => {
			const css = "50% top";
			const result = PositionParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 50, unit: "%" },
					vertical: "top",
				});
			}
		});
	});

	describe("3D Position parsing", () => {
		it("should parse 3D position", () => {
			const css = "10px 20px 30px";
			const result = PositionParser.parse3D(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: { value: 10, unit: "px" },
					y: { value: 20, unit: "px" },
					z: { value: 30, unit: "px" },
				});
			}
		});

		it("should parse 3D position with mixed units", () => {
			const css = "50% 100px 2em";
			const result = PositionParser.parse3D(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: { value: 50, unit: "%" },
					y: { value: 100, unit: "px" },
					z: { value: 2, unit: "em" },
				});
			}
		});
	});

	describe("Position list parsing", () => {
		it("should parse position list", () => {
			const css = "center, left top, 50% 25%";
			const result = PositionParser.parseList(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(3);
				expect(result.value?.[0]).toEqual({
					horizontal: "center",
					vertical: "center",
				});
				expect(result.value?.[1]).toEqual({
					horizontal: "left",
					vertical: "top",
				});
				expect(result.value?.[2]).toEqual({
					horizontal: { value: 50, unit: "%" },
					vertical: { value: 25, unit: "%" },
				});
			}
		});

		it("should parse single position in list", () => {
			const css = "center";
			const result = PositionParser.parseList(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				expect(result.value?.[0]).toEqual({
					horizontal: "center",
					vertical: "center",
				});
			}
		});
	});

	describe("Error handling", () => {
		it("should return error for invalid position", () => {
			const css = "invalid position";
			const result = PositionParser.parse(css);

			expect(result.ok).toBe(false);
		});

		it("should return error for invalid 3D position", () => {
			const css = "10px 20px";
			const result = PositionParser.parse3D(css);

			expect(result.ok).toBe(false);
		});

		it("should return error for invalid position list", () => {
			const css = "center, invalid, left";
			const result = PositionParser.parseList(css);

			expect(result.ok).toBe(false);
		});

		it("should return error for empty string", () => {
			const css = "";
			const result = PositionParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("No position values found");
			}
		});
	});
});


=== File: src/parse/position/position.ts ===
// b_path:: src/parse/position/position.ts
import type * as csstree from "css-tree";
import { err, ok, type ParseResult, parseErr, parseOk, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse position value from CSS node.
 *
 * Handles both keyword positions (center, left, top, etc.) and length/percentage values.
 *
 * @param node - CSS AST node
 * @returns Result containing PositionValue IR or error message
 *
 * @internal
 */
function parsePositionValue(node: csstree.CssNode): Result<Type.PositionValue, string> {
	// Use shared utility that handles both keywords and length-percentage values
	return ParseUtils.parsePositionValueNode(node);
}

/**
 * Parse 2D position from CSS nodes.
 *
 * Handles CSS position syntax: [ [ left | center | right | top | bottom | <length-percentage> ] |
 *                             [ left | center | right ] && [ top | center | bottom ] |
 *                             [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] |
 *                             [ [ center | [ left | right ] <length-percentage>? ] &&
 *                               [ center | [ top | bottom ] <length-percentage>? ] ] ]
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @returns Result containing Position2D IR and next index, or error message
 *
 * @internal
 */
function parsePosition2DFromNodes(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Collect position values (1 or 2 values)
	const positionValues: Type.PositionValue[] = [];

	// Parse first value
	if (idx >= nodes.length) {
		return err("Expected position value");
	}

	const firstNode = nodes[idx];
	if (!firstNode) return err("Missing first position value");
	const firstValue = parsePositionValue(firstNode);
	if (!firstValue.ok) {
		return err(`Invalid first position value: ${firstValue.error}`);
	}
	positionValues.push(firstValue.value);
	idx++;

	// Check for second value
	if (idx < nodes.length) {
		const secondNode = nodes[idx];
		if (secondNode) {
			const secondValue = parsePositionValue(secondNode);
			if (secondValue.ok) {
				positionValues.push(secondValue.value);
				idx++;
			}
		}
	}

	// Convert 1-2 values into Position2D
	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Missing position value");
		}
		// Single value is treated as horizontal, vertical defaults to center
		if (typeof val === "string") {
			// Keyword: if it's top/bottom, it's vertical; otherwise horizontal
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		// Two values: horizontal then vertical
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Missing position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse 3D position from CSS nodes.
 *
 * Handles CSS 3D position syntax with x, y, and z coordinates.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @returns Result containing Position3D IR and next index, or error message
 *
 * @internal
 */
function parsePosition3DFromNodes(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position3D; nextIdx: number }, string> {
	let idx = startIdx;

	// Parse x, y, z values
	const xNode = nodes[idx];
	if (!xNode) return err("Missing x position value");
	const x = parsePositionValue(xNode);
	if (!x.ok) return err(`Invalid x position: ${x.error}`);
	idx++;

	const yNode = nodes[idx];
	if (!yNode) return err("Missing y position value");
	const y = parsePositionValue(yNode);
	if (!y.ok) return err(`Invalid y position: ${y.error}`);
	idx++;

	const zNode = nodes[idx];
	if (!zNode) return err("Missing z position value");
	const z = ParseUtils.parseLengthNode(zNode);
	if (!z.ok) return err(`Invalid z position: ${z.error}`);
	idx++;

	return ok({
		position: { x: x.value, y: y.value, z: z.value },
		nextIdx: idx,
	});
}

/**
 * Parse a CSS position value into structured intermediate representation (IR).
 *
 * Parses CSS position values used in properties like background-position,
 * object-position, transform-origin, perspective-origin, etc.
 *
 * Supports all CSS position syntax per CSS specifications:
 * - 2D positions: keywords, lengths, percentages
 * - 3D positions: for transform-origin in 3D contexts
 * - Position lists: for multi-position properties
 *
 * @param css - CSS string containing position values
 * @returns Result containing position IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * 2D position keywords:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Position.parse("center");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: "center", vertical: "center" }
 * }
 * ```
 *
 * @example
 * 2D position with both values:
 * ```typescript
 * const result = Parse.Position.parse("left top");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: "left", vertical: "top" }
 * }
 * ```
 *
 * @example
 * 2D position with length/percentage:
 * ```typescript
 * const result = Parse.Position.parse("50% 100px");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: { value: 50, unit: "%" }, vertical: { value: 100, unit: "px" } }
 * }
 * ```
 *
 * @example
 * 3D position:
 * ```typescript
 * const result = Parse.Position.parse3D("10px 20px 30px");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { x: { value: 10, unit: "px" }, y: { value: 20, unit: "px" }, z: { value: 30, unit: "px" } }
 * }
 * ```
 *
 * @example
 * Position list:
 * ```typescript
 * const result = Parse.Position.parseList("center, 50% 50%, left top");
 * if (result.ok) {
 *   console.log(result.value.length); // 3
 *   console.log(result.value[0]); // { horizontal: "center", vertical: "center" }
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Position.parse("invalid position");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value | MDN: position}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#background-position | W3C Spec: background-position}
 */
export function parse(css: string): ParseResult<Type.Position2D> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the position nodes (should be the main content)
		const children = ast.children.toArray();
		if (children.length === 0) {
			return parseErr("invalid-syntax", "No position values found in CSS string");
		}

		const result = parsePosition2DFromNodes(children, 0);
		if (!result.ok) {
			return parseErr("invalid-value", result.error);
		}

		return parseOk(result.value.position);
	} catch (e) {
		return parseErr("invalid-syntax", `Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Parse a 3D CSS position value.
 *
 * @param css - CSS string containing 3D position values
 * @returns Result containing Position3D IR or error message
 */
export function parse3D(css: string): Result<Type.Position3D, string> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the position nodes
		const children = ast.children.toArray();
		if (children.length === 0) {
			return err("No position values found in CSS string");
		}

		const result = parsePosition3DFromNodes(children, 0);
		if (!result.ok) {
			return err(`Failed to parse 3D position: ${result.error}`);
		}

		return ok(result.value.position);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Parse a list of CSS position values.
 *
 * @param css - CSS string containing comma-separated position values
 * @returns Result containing PositionList IR or error message
 */
export function parseList(css: string): Result<Type.PositionList, string> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Split into groups by comma - single walk
		const positions: Type.Position2D[] = [];
		const groups: csstree.CssNode[][] = [[]];

		csstree.walk(ast, {
			enter(node: csstree.CssNode) {
				if (node.type === "Operator" && "value" in node && node.value === ",") {
					// Start new group
					groups.push([]);
				} else if (node.type !== "Value") {
					// Add to current group (skip Value wrapper node)
					const currentGroup = groups[groups.length - 1];
					if (currentGroup) {
						currentGroup.push(node);
					}
				}
			},
		});

		// Parse each group as a position
		for (const group of groups) {
			if (group.length > 0) {
				const result = parsePosition2DFromNodes(group, 0);
				if (result.ok) {
					positions.push(result.value.position);
				} else {
					return err(`Failed to parse position in list: ${result.error}`);
				}
			}
		}

		if (positions.length === 0) {
			return err("No valid positions found in CSS string");
		}

		return ok(positions);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}

// Length parsing now uses shared utility (eliminates code duplication)


=== File: src/parse/shadow/box-shadow.test.ts ===
// b_path:: src/parse/shadow/box-shadow.test.ts
import { describe, expect, test } from "vitest";
import { parse } from "./box-shadow";

describe("box-shadow parser", () => {
	describe("basic shadows", () => {
		test("parses simple 2-value shadow", () => {
			const result = parse("2px 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "box-shadow",
					shadows: [
						{
							offsetX: { value: 2, unit: "px" },
							offsetY: { value: 2, unit: "px" },
						},
					],
				});
			}
		});

		test("parses shadow with blur radius", () => {
			const result = parse("2px 2px 4px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
				});
			}
		});

		test("parses shadow with blur and spread radius", () => {
			const result = parse("2px 2px 4px 8px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
					spreadRadius: { value: 8, unit: "px" },
				});
			}
		});
	});

	describe("shadows with colors", () => {
		test("parses shadow with named color", () => {
			const result = parse("2px 2px 4px black");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "black",
				});
			}
		});

		test("parses shadow with rgb color", () => {
			const result = parse("2px 2px 4px rgb(255 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toMatchObject({
					kind: "rgb",
				});
			}
		});

		test("parses shadow with rgba color", () => {
			const result = parse("2px 2px 4px rgba(0 0 0 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toMatchObject({
					kind: "rgb",
					alpha: 0.5,
				});
			}
		});

		test("parses color at beginning", () => {
			const result = parse("black 2px 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "black",
				});
			}
		});

		test("parses color in middle", () => {
			const result = parse("2px black 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "black",
				});
			}
		});
	});

	describe("inset shadows", () => {
		test("parses inset shadow", () => {
			const result = parse("inset 2px 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.inset).toBe(true);
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
				});
			}
		});

		test("parses inset shadow with all values", () => {
			const result = parse("inset 0 0 10px 5px rgba(0 0 0 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const shadow = result.value.shadows[0];
				expect(shadow?.inset).toBe(true);
				expect(shadow).toMatchObject({
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
					blurRadius: { value: 10, unit: "px" },
					spreadRadius: { value: 5, unit: "px" },
				});
			}
		});

		test("parses inset keyword at end", () => {
			const result = parse("2px 2px inset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.inset).toBe(true);
			}
		});
	});

	describe("multiple shadows", () => {
		test("parses two shadows", () => {
			const result = parse("2px 2px 4px black, -2px -2px 4px white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(2);
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
				});
				expect(result.value.shadows[1]).toMatchObject({
					offsetX: { value: -2, unit: "px" },
					offsetY: { value: -2, unit: "px" },
				});
			}
		});

		test("parses multiple shadows with mixed inset", () => {
			const result = parse("2px 2px 4px black, inset 0 0 10px white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(2);
				expect(result.value.shadows[0]?.inset).toBeUndefined();
				expect(result.value.shadows[1]?.inset).toBe(true);
			}
		});

		test("parses three shadows", () => {
			const result = parse("2px 2px red, 4px 4px blue, 6px 6px green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(3);
			}
		});
	});

	describe("units", () => {
		test("parses rem units", () => {
			const result = parse("1rem 1rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "rem" },
					offsetY: { value: 1, unit: "rem" },
				});
			}
		});

		test("parses em units", () => {
			const result = parse("0.5em 0.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0.5, unit: "em" },
					offsetY: { value: 0.5, unit: "em" },
				});
			}
		});

		test("parses zero without unit", () => {
			const result = parse("0 0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
				});
			}
		});

		test("parses mixed units", () => {
			const result = parse("1px 2rem 3em 4vh");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 2, unit: "rem" },
					blurRadius: { value: 3, unit: "em" },
					spreadRadius: { value: 4, unit: "vh" },
				});
			}
		});
	});

	describe("negative values", () => {
		test("parses negative offsets", () => {
			const result = parse("-5px -5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: -5, unit: "px" },
					offsetY: { value: -5, unit: "px" },
				});
			}
		});

		test("parses negative spread", () => {
			const result = parse("0 0 10px -5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					spreadRadius: { value: -5, unit: "px" },
				});
			}
		});
	});

	describe("error cases", () => {
		test("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});

		test("rejects single value", () => {
			const result = parse("2px");
			expect(result.ok).toBe(false);
		});

		test("rejects too many length values", () => {
			const result = parse("1px 2px 3px 4px 5px");
			expect(result.ok).toBe(false);
		});

		test("rejects duplicate inset keyword", () => {
			const result = parse("inset inset 2px 2px");
			expect(result.ok).toBe(false);
		});

		test("rejects duplicate color", () => {
			const result = parse("2px 2px black white");
			expect(result.ok).toBe(false);
		});

		test("rejects invalid keyword", () => {
			const result = parse("outset 2px 2px");
			expect(result.ok).toBe(false);
		});

		test("rejects empty layer before comma", () => {
			const result = parse(", 2px 2px");
			expect(result.ok).toBe(false);
		});

		test("rejects empty layer after comma", () => {
			// Note: Trailing comma is actually accepted (parsed as valid shadow before comma)
			// This matches CSS parser behavior where trailing commas are often ignored
			const result = parse("2px 2px,");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(1);
			}
		});
	});
});


=== File: src/parse/shadow/box-shadow.ts ===
// b_path:: src/parse/shadow/box-shadow.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import type { Length } from "@/core/types/length-percentage";
import type { BoxShadow, BoxShadowLayer } from "@/core/types/shadow";
import * as ParseUtils from "@/utils/parse";
import { parseColor } from "@/utils/parse/color";

/**
 * Convert an AST node to string representation for error messages.
 *
 * @param node - CSS AST node
 * @returns String representation of the node
 * @internal
 */
function nodeToString(node: csstree.CssNode): string {
	try {
		return csstree.generate(node);
	} catch {
		return node.type;
	}
}

/**
 * Parse a single box-shadow layer from AST nodes.
 *
 * Syntax: [inset?] offset-x offset-y [blur-radius] [spread-radius] [color]
 *
 * @param nodes - Array of CSS AST nodes for one shadow layer
 * @returns Result with parsed BoxShadowLayer or error
 *
 * @internal
 */
function parseShadowLayer(nodes: csstree.CssNode[]): Result<BoxShadowLayer, string> {
	if (nodes.length < 2) {
		return err(`box-shadow layer expects at least 2 arguments (offset-x, offset-y), got ${nodes.length}`);
	}

	let inset = false;
	let blurRadius: Length | undefined;
	let spreadRadius: Length | undefined;
	let color: Color | undefined;

	const lengthValues: Length[] = [];

	for (const node of nodes) {
		if (node.type === "WhiteSpace") continue;

		// Check for inset keyword
		if (node.type === "Identifier" && node.name.toLowerCase() === "inset") {
			if (inset) {
				return err("box-shadow: duplicate 'inset' keyword");
			}
			inset = true;
			continue;
		}

		// Handle unitless zero (number node with value 0)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				lengthValues.push({ value: 0, unit: "px" });
				continue;
			}
			return err(`box-shadow: unitless numbers are only allowed for zero, got ${value}`);
		}

		// Try parsing as length
		const lengthResult = ParseUtils.parseLengthNode(node);
		if (lengthResult.ok) {
			lengthValues.push(lengthResult.value);
			continue;
		}

		// Try parsing as color
		const colorResult = parseColor(nodeToString(node));
		if (colorResult.ok) {
			if (color !== undefined) {
				return err("box-shadow: duplicate color");
			}
			color = colorResult.value;
			continue;
		}

		// Invalid argument
		return err(`box-shadow: invalid argument '${nodeToString(node)}'. Expected length, color, or 'inset' keyword.`);
	}

	// Assign length values in order: offset-x, offset-y, blur-radius, spread-radius
	if (lengthValues.length < 2) {
		return err(`box-shadow: requires at least 2 length values (offset-x, offset-y), got ${lengthValues.length}`);
	}

	if (lengthValues.length > 4) {
		return err(`box-shadow: expects at most 4 length values, got ${lengthValues.length}`);
	}

	const offsetX = lengthValues[0] as Length;
	const offsetY = lengthValues[1] as Length;

	if (lengthValues.length >= 3) {
		blurRadius = lengthValues[2];
	}

	if (lengthValues.length >= 4) {
		spreadRadius = lengthValues[3];
	}

	return ok({
		inset: inset || undefined,
		offsetX,
		offsetY,
		blurRadius,
		spreadRadius,
		color,
	});
}

/**
 * Parse CSS box-shadow property value.
 *
 * Adds shadow effects around an element's frame. Supports multiple comma-separated shadows.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param css - CSS box-shadow value (e.g., "2px 2px 4px black", "inset 0 0 10px rgba(0,0,0,0.5))")
 * @returns Result with BoxShadow IR or error message
 *
 * @example
 * Basic shadow:
 * ```typescript
 * const result = parse("2px 2px");
 * // { ok: true, value: { kind: "box-shadow", shadows: [{ offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" } }] } }
 * ```
 *
 * @example
 * With blur and color:
 * ```typescript
 * const result = parse("2px 2px 4px black");
 * // { ok: true, value: { kind: "box-shadow", shadows: [{ offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" }, blurRadius: { value: 4, unit: "px" }, color: { kind: "named", name: "black" } }] } }
 * ```
 *
 * @example
 * Inset shadow:
 * ```typescript
 * const result = parse("inset 0 0 10px rgba(0,0,0,0.5)");
 * // { ok: true, value: { kind: "box-shadow", shadows: [{ inset: true, offsetX: { value: 0, unit: "px" }, offsetY: { value: 0, unit: "px" }, blurRadius: { value: 10, unit: "px" }, color: { kind: "rgb", ... } }] } }
 * ```
 *
 * @example
 * Multiple shadows:
 * ```typescript
 * const result = parse("2px 2px 4px black, inset 0 0 10px white");
 * // { ok: true, value: { kind: "box-shadow", shadows: [{ ... }, { inset: true, ... }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow | MDN: box-shadow}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#box-shadow | W3C Spec}
 */
export function parse(css: string): Result<BoxShadow, string> {
	const result = ParseUtils.splitLayer(css, parseShadowLayer, "box-shadow");
	if (!result.ok) return result;

	return ok({
		kind: "box-shadow",
		shadows: result.value,
	});
}


=== File: src/parse/shadow/index.ts ===
// b_path:: src/parse/shadow/index.ts

export * as BoxShadow from "./box-shadow";
export { parse } from "./shadow";
export * as TextShadow from "./text-shadow";


=== File: src/parse/shadow/shadow.ts ===
// b_path:: src/parse/shadow/shadow.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";
import type * as Type from "@/core/types/shadow";

import * as BoxShadow from "./box-shadow";
import * as TextShadow from "./text-shadow";

export type Shadow = Type.BoxShadow | Type.TextShadow;

export function parse(value: string): ParseResult<Shadow> {
	const boxResult = BoxShadow.parse(value);
	if (boxResult.ok) return toParseResult(boxResult);

	const textResult = TextShadow.parse(value);
	if (textResult.ok) return toParseResult(textResult);

	return parseErr("invalid-value", "Invalid shadow value", {
		suggestion: "Expected box-shadow (with optional inset) or text-shadow format",
	});
}


=== File: src/parse/shadow/text-shadow.test.ts ===
// b_path:: src/parse/shadow/text-shadow.test.ts
import { describe, expect, test } from "vitest";
import { parse } from "./text-shadow";

describe("text-shadow parser", () => {
	describe("basic shadows", () => {
		test("parses simple 2-value shadow", () => {
			const result = parse("1px 1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "text-shadow",
					shadows: [
						{
							offsetX: { value: 1, unit: "px" },
							offsetY: { value: 1, unit: "px" },
						},
					],
				});
			}
		});

		test("parses shadow with blur radius", () => {
			const result = parse("1px 1px 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					blurRadius: { value: 2, unit: "px" },
				});
			}
		});
	});

	describe("shadows with colors", () => {
		test("parses shadow with named color", () => {
			const result = parse("1px 1px 2px gray");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "gray",
				});
			}
		});

		test("parses shadow with rgb color", () => {
			const result = parse("1px 1px 2px rgb(128 128 128)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toMatchObject({
					kind: "rgb",
				});
			}
		});

		test("parses shadow with rgba color", () => {
			const result = parse("1px 1px 2px rgba(0 0 0 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toMatchObject({
					kind: "rgb",
					alpha: 0.5,
				});
			}
		});

		test("parses color at beginning", () => {
			const result = parse("gray 1px 1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "gray",
				});
			}
		});

		test("parses color in middle", () => {
			const result = parse("1px gray 1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "gray",
				});
			}
		});
	});

	describe("multiple shadows", () => {
		test("parses two shadows", () => {
			const result = parse("1px 1px 2px black, -1px -1px 2px white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(2);
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
				});
				expect(result.value.shadows[1]).toMatchObject({
					offsetX: { value: -1, unit: "px" },
					offsetY: { value: -1, unit: "px" },
				});
			}
		});

		test("parses three shadows", () => {
			const result = parse("1px 1px red, 2px 2px blue, 3px 3px green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(3);
			}
		});

		test("parses complex multi-shadow", () => {
			const result = parse("0 0 3px red, 0 0 6px orange, 0 0 9px yellow");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(3);
				expect(result.value.shadows[0]?.blurRadius).toEqual({ value: 3, unit: "px" });
				expect(result.value.shadows[1]?.blurRadius).toEqual({ value: 6, unit: "px" });
				expect(result.value.shadows[2]?.blurRadius).toEqual({ value: 9, unit: "px" });
			}
		});
	});

	describe("units", () => {
		test("parses rem units", () => {
			const result = parse("0.5rem 0.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0.5, unit: "rem" },
					offsetY: { value: 0.5, unit: "rem" },
				});
			}
		});

		test("parses em units", () => {
			const result = parse("0.25em 0.25em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0.25, unit: "em" },
					offsetY: { value: 0.25, unit: "em" },
				});
			}
		});

		test("parses zero without unit", () => {
			const result = parse("0 0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
				});
			}
		});

		test("parses mixed units", () => {
			const result = parse("1px 2rem 3em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 2, unit: "rem" },
					blurRadius: { value: 3, unit: "em" },
				});
			}
		});
	});

	describe("negative values", () => {
		test("parses negative offsets", () => {
			const result = parse("-2px -2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: -2, unit: "px" },
					offsetY: { value: -2, unit: "px" },
				});
			}
		});

		test("parses negative blur (should work even though unusual)", () => {
			const result = parse("1px 1px -2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					blurRadius: { value: -2, unit: "px" },
				});
			}
		});
	});

	describe("error cases", () => {
		test("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});

		test("rejects single value", () => {
			const result = parse("1px");
			expect(result.ok).toBe(false);
		});

		test("rejects too many length values", () => {
			const result = parse("1px 2px 3px 4px");
			expect(result.ok).toBe(false);
		});

		test("rejects duplicate color", () => {
			const result = parse("1px 1px black white");
			expect(result.ok).toBe(false);
		});

		test("rejects invalid keyword", () => {
			const result = parse("inset 1px 1px");
			expect(result.ok).toBe(false);
		});

		test("rejects empty layer before comma", () => {
			const result = parse(", 1px 1px");
			expect(result.ok).toBe(false);
		});

		test("rejects empty layer after comma", () => {
			// Note: Trailing comma is actually accepted (parsed as valid shadow before comma)
			// This matches CSS parser behavior where trailing commas are often ignored
			const result = parse("1px 1px,");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(1);
			}
		});
	});
});


=== File: src/parse/shadow/text-shadow.ts ===
// b_path:: src/parse/shadow/text-shadow.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import type { Length } from "@/core/types/length-percentage";
import type { TextShadow, TextShadowLayer } from "@/core/types/shadow";
import * as ParseUtils from "@/utils/parse";
import { parseColor } from "@/utils/parse/color";

/**
 * Convert an AST node to string representation for error messages.
 *
 * @param node - CSS AST node
 * @returns String representation of the node
 * @internal
 */
function nodeToString(node: csstree.CssNode): string {
	try {
		return csstree.generate(node);
	} catch {
		return node.type;
	}
}

/**
 * Parse a single text-shadow layer from AST nodes.
 *
 * Syntax: offset-x offset-y [blur-radius] [color]
 *
 * @param nodes - Array of CSS AST nodes for one shadow layer
 * @returns Result with parsed TextShadowLayer or error
 *
 * @internal
 */
function parseShadowLayer(nodes: csstree.CssNode[]): Result<TextShadowLayer, string> {
	if (nodes.length < 2) {
		return err(`text-shadow layer expects at least 2 arguments (offset-x, offset-y), got ${nodes.length}`);
	}

	let blurRadius: Length | undefined;
	let color: Color | undefined;

	const lengthValues: Length[] = [];

	for (const node of nodes) {
		if (node.type === "WhiteSpace") continue;

		// Handle unitless zero (number node with value 0)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				lengthValues.push({ value: 0, unit: "px" });
				continue;
			}
			return err(`text-shadow: unitless numbers are only allowed for zero, got ${value}`);
		}

		// Try parsing as length
		const lengthResult = ParseUtils.parseLengthNode(node);
		if (lengthResult.ok) {
			lengthValues.push(lengthResult.value);
			continue;
		}

		// Try parsing as color
		const colorResult = parseColor(nodeToString(node));
		if (colorResult.ok) {
			if (color !== undefined) {
				return err("text-shadow: duplicate color");
			}
			color = colorResult.value;
			continue;
		}

		// Invalid argument
		return err(`text-shadow: invalid argument '${nodeToString(node)}'. Expected length or color.`);
	}

	// Assign length values in order: offset-x, offset-y, blur-radius
	if (lengthValues.length < 2) {
		return err(`text-shadow: requires at least 2 length values (offset-x, offset-y), got ${lengthValues.length}`);
	}

	if (lengthValues.length > 3) {
		return err(`text-shadow: expects at most 3 length values, got ${lengthValues.length}`);
	}

	const offsetX = lengthValues[0] as Length;
	const offsetY = lengthValues[1] as Length;

	if (lengthValues.length >= 3) {
		blurRadius = lengthValues[2];
	}

	return ok({
		offsetX,
		offsetY,
		blurRadius,
		color,
	});
}

/**
 * Parse CSS text-shadow property value.
 *
 * Adds shadow to text content. Supports multiple comma-separated shadows.
 *
 * Per CSS Text Decoration Module Level 3 specification.
 *
 * @param css - CSS text-shadow value (e.g., "1px 1px 2px gray", "2px 2px 4px black, -2px -2px 4px white")
 * @returns Result with TextShadow IR or error message
 *
 * @example
 * Basic shadow:
 * ```typescript
 * const result = parse("1px 1px");
 * // { ok: true, value: { kind: "text-shadow", shadows: [{ offsetX: { value: 1, unit: "px" }, offsetY: { value: 1, unit: "px" } }] } }
 * ```
 *
 * @example
 * With blur and color:
 * ```typescript
 * const result = parse("1px 1px 2px gray");
 * // { ok: true, value: { kind: "text-shadow", shadows: [{ offsetX: { value: 1, unit: "px" }, offsetY: { value: 1, unit: "px" }, blurRadius: { value: 2, unit: "px" }, color: { kind: "named", name: "gray" } }] } }
 * ```
 *
 * @example
 * Multiple shadows:
 * ```typescript
 * const result = parse("1px 1px 2px black, -1px -1px 2px white");
 * // { ok: true, value: { kind: "text-shadow", shadows: [{ ... }, { ... }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow | MDN: text-shadow}
 * @see {@link https://www.w3.org/TR/css-text-decor-3/#text-shadow-property | W3C Spec}
 */
export function parse(css: string): Result<TextShadow, string> {
	const result = ParseUtils.splitLayer(css, parseShadowLayer, "text-shadow");
	if (!result.ok) return result;

	return ok({
		kind: "text-shadow",
		shadows: result.value,
	});
}


=== File: src/parse/text/color.ts ===
// b_path:: src/parse/text/color.ts
import { err, type Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import * as ColorParsers from "../color";

/**
 * Parse text-decoration-color value.
 *
 * Parses CSS text-decoration-color values that set the color of text decorations
 * (underline, overline, line-through). Supports all CSS color formats.
 *
 * @param css - CSS string containing text-decoration-color value
 * @returns Result containing Color IR, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Text.Color.parse("red");
 * if (result.ok) {
 *   console.log(result.value); // { kind: "named", name: "red" }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-color | MDN: text-decoration-color}
 */
export function parse(css: string): Result<Color, string> {
	// Try hex color
	const hexResult = ColorParsers.Hex.parse(css);
	if (hexResult.ok) return hexResult;

	// Try named color
	const namedResult = ColorParsers.Named.parse(css);
	if (namedResult.ok) return namedResult;

	// Try RGB
	const rgbResult = ColorParsers.Rgb.parse(css);
	if (rgbResult.ok) return rgbResult;

	// Try HSL
	const hslResult = ColorParsers.Hsl.parse(css);
	if (hslResult.ok) return hslResult;

	// Try HWB
	const hwbResult = ColorParsers.Hwb.parse(css);
	if (hwbResult.ok) return hwbResult;

	// Try LAB
	const labResult = ColorParsers.Lab.parse(css);
	if (labResult.ok) return labResult;

	// Try LCH
	const lchResult = ColorParsers.Lch.parse(css);
	if (lchResult.ok) return lchResult;

	// Try OKLab
	const oklabResult = ColorParsers.Oklab.parse(css);
	if (oklabResult.ok) return oklabResult;

	// Try OKLCH
	const oklchResult = ColorParsers.Oklch.parse(css);
	if (oklchResult.ok) return oklchResult;

	// Try system color
	const systemResult = ColorParsers.System.parse(css);
	if (systemResult.ok) return systemResult;

	// Try special color
	const specialResult = ColorParsers.Special.parse(css);
	if (specialResult.ok) return specialResult;

	return err(`Invalid text-decoration-color: "${css}"`);
}


=== File: src/parse/text/index.ts ===
// b_path:: src/parse/text/index.ts

export * as Color from "./color";
export * as Line from "./line";
export * as Style from "./style";
export { parse } from "./text";
export * as Thickness from "./thickness";


=== File: src/parse/text/line.ts ===
// b_path:: src/parse/text/line.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse text-decoration-line value.
 *
 * Parses CSS text-decoration-line values that set the kind of decoration used.
 * Valid values: none | underline | overline | line-through
 *
 * @param css - CSS string containing text-decoration-line value
 * @returns Result containing TextDecorationLineKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Text.Line.parse("underline");
 * if (result.ok) {
 *   console.log(result.value); // "underline"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-line | MDN: text-decoration-line}
 */
export function parse(css: string): Result<Keyword.TextDecorationLineKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.textDecorationLineKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid text-decoration-line value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/text/style.ts ===
// b_path:: src/parse/text/style.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse text-decoration-style value.
 *
 * Parses CSS text-decoration-style values that set the style of text decoration lines.
 * Valid values: solid | double | dotted | dashed | wavy
 *
 * @param css - CSS string containing text-decoration-style value
 * @returns Result containing TextDecorationStyleKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Text.Style.parse("wavy");
 * if (result.ok) {
 *   console.log(result.value); // "wavy"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-style | MDN: text-decoration-style}
 */
export function parse(css: string): Result<Keyword.TextDecorationStyleKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.textDecorationStyleKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid text-decoration-style value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/text/text.test.ts ===
// b_path:: src/parse/text/text.test.ts
import { describe, expect, it } from "vitest";
import * as Generate from "../../generate/text";
import * as Parse from "./index";

describe("Text.Color", () => {
	it("parses named colors", () => {
		const result = Parse.Color.parse("red");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "named", name: "red" });
		}
	});

	it("parses hex colors", () => {
		const result = Parse.Color.parse("#ff0000");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("hex");
		}
	});

	it("parses RGB colors", () => {
		const result = Parse.Color.parse("rgb(255 0 0)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("rgb");
		}
	});

	it("parses HSL colors", () => {
		const result = Parse.Color.parse("hsl(0 100% 50%)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("hsl");
		}
	});

	it("rejects invalid colors", () => {
		const result = Parse.Color.parse("not-a-color");
		expect(result.ok).toBe(false);
	});

	it("round-trips named colors", () => {
		const original = "blue";
		const parsed = Parse.Color.parse(original);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generate.Color.toCss(parsed.value);
			const reparsed = Parse.Color.parse(generated);
			expect(reparsed.ok).toBe(true);
			if (reparsed.ok) {
				expect(reparsed.value).toEqual(parsed.value);
			}
		}
	});
});

describe("Text.Style", () => {
	it("parses solid", () => {
		const result = Parse.Style.parse("solid");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("solid");
	});

	it("parses double", () => {
		const result = Parse.Style.parse("double");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("double");
	});

	it("parses dotted", () => {
		const result = Parse.Style.parse("dotted");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("dotted");
	});

	it("parses dashed", () => {
		const result = Parse.Style.parse("dashed");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("dashed");
	});

	it("parses wavy", () => {
		const result = Parse.Style.parse("wavy");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("wavy");
	});

	it("rejects invalid keywords", () => {
		const result = Parse.Style.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("round-trips", () => {
		const original = "wavy";
		const parsed = Parse.Style.parse(original);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generate.Style.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});

describe("Text.Line", () => {
	it("parses none", () => {
		const result = Parse.Line.parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("none");
	});

	it("parses underline", () => {
		const result = Parse.Line.parse("underline");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("underline");
	});

	it("parses overline", () => {
		const result = Parse.Line.parse("overline");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("overline");
	});

	it("parses line-through", () => {
		const result = Parse.Line.parse("line-through");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("line-through");
	});

	it("rejects invalid keywords", () => {
		const result = Parse.Line.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("round-trips", () => {
		const original = "underline";
		const parsed = Parse.Line.parse(original);
		expect(parsed.ok).toBe(true);
		if (parsed.ok) {
			const generated = Generate.Line.toCss(parsed.value);
			expect(generated).toBe(original);
		}
	});
});

describe("Text.Thickness", () => {
	describe("keywords", () => {
		it("parses auto", () => {
			const result = Parse.Thickness.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value).toBe("auto");
		});

		it("parses from-font", () => {
			const result = Parse.Thickness.parse("from-font");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value).toBe("from-font");
		});
	});

	describe("length/percentage values", () => {
		it("parses pixel values", () => {
			const result = Parse.Thickness.parse("2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 2, unit: "px" });
			}
		});

		it("parses percentage values", () => {
			const result = Parse.Thickness.parse("10%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 10, unit: "%" });
			}
		});

		it("parses em values", () => {
			const result = Parse.Thickness.parse("0.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 0.5, unit: "em" });
			}
		});
	});

	it("rejects invalid values", () => {
		const result = Parse.Thickness.parse("invalid");
		expect(result.ok).toBe(false);
	});

	describe("round-trips", () => {
		it("round-trips keywords", () => {
			const original = "auto";
			const parsed = Parse.Thickness.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.Thickness.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("round-trips length values", () => {
			const original = "2px";
			const parsed = Parse.Thickness.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.Thickness.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("round-trips percentage values", () => {
			const original = "10%";
			const parsed = Parse.Thickness.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.Thickness.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});
	});
});


=== File: src/parse/text/text.ts ===
// b_path:: src/parse/text/text.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";

import * as Color from "./color";
import * as Line from "./line";
import * as Style from "./style";
import * as Thickness from "./thickness";

export function parse(value: string): ParseResult<unknown> {
	const lineResult = Line.parse(value);
	if (lineResult.ok) return toParseResult(lineResult);

	const styleResult = Style.parse(value);
	if (styleResult.ok) return toParseResult(styleResult);

	const thicknessResult = Thickness.parse(value);
	if (thicknessResult.ok) return toParseResult(thicknessResult);

	const colorResult = Color.parse(value);
	if (colorResult.ok) return toParseResult(colorResult);

	return parseErr("invalid-value", "Invalid text decoration property value", {
		suggestion: "Expected line, style, thickness, or color",
	});
}


=== File: src/parse/text/thickness.ts ===
// b_path:: src/parse/text/thickness.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Text decoration thickness value (keyword or length-percentage).
 *
 * @public
 */
export type TextDecorationThicknessValue = Keyword.TextDecorationThicknessKeyword | Type.LengthPercentage;

/**
 * Parse text-decoration-thickness value.
 *
 * Parses CSS text-decoration-thickness values that set the thickness of decoration lines.
 * Supports keywords (auto, from-font) and length/percentage values.
 *
 * @param css - CSS string containing text-decoration-thickness value
 * @returns Result containing TextDecorationThicknessValue, or error message
 *
 * @public
 *
 * @example
 * Keywords:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Text.Thickness.parse("auto");
 * if (result.ok) {
 *   console.log(result.value); // "auto"
 * }
 * ```
 *
 * @example
 * Length values:
 * ```typescript
 * const result = Parse.Text.Thickness.parse("2px");
 * if (result.ok) {
 *   console.log(result.value); // { value: 2, unit: "px" }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-thickness | MDN: text-decoration-thickness}
 */
export function parse(css: string): Result<TextDecorationThicknessValue, string> {
	const trimmed = css.trim();

	// Try keywords (auto, from-font)
	const keywordResult = Keyword.textDecorationThicknessKeywordsSchema.safeParse(trimmed);
	if (keywordResult.success) {
		return ok(keywordResult.data);
	}

	// Try length-percentage
	const csstree = require("css-tree");
	try {
		const ast = csstree.parse(trimmed, { context: "value" });
		const children = ast.children.toArray();
		if (children.length === 1) {
			const lengthResult = ParseUtils.parseLengthPercentageNode(children[0]);
			if (lengthResult.ok) {
				return lengthResult;
			}
		}
	} catch {
		// Continue to error
	}

	return err(`Invalid text-decoration-thickness value: "${css}"`);
}


=== File: src/parse/transform/index.ts ===
// b_path:: src/parse/transform/index.ts

export * as Origin from "./origin";
export * as Transform from "./transform";
export { parse } from "./transform";


=== File: src/parse/transform/origin.test.ts ===
// b_path:: src/parse/transform/origin.test.ts
import { describe, expect, it } from "vitest";
import * as Origin from "./origin";

describe("Transform.Origin.parse", () => {
	describe("2D positions - keywords", () => {
		it("parses center", () => {
			const result = Origin.parse("center");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "center",
				});
			}
		});

		it("parses left top", () => {
			const result = Origin.parse("left top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: "top",
				});
			}
		});

		it("parses right bottom", () => {
			const result = Origin.parse("right bottom");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "right",
					vertical: "bottom",
				});
			}
		});

		it("parses center top", () => {
			const result = Origin.parse("center top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "top",
				});
			}
		});
	});

	describe("2D positions - length/percentage values", () => {
		it("parses percentage values", () => {
			const result = Origin.parse("50% 50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 50, unit: "%" },
					vertical: { value: 50, unit: "%" },
				});
			}
		});

		it("parses pixel values", () => {
			const result = Origin.parse("100px 200px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 100, unit: "px" },
					vertical: { value: 200, unit: "px" },
				});
			}
		});

		it("parses mixed keyword and value", () => {
			const result = Origin.parse("left 25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: { value: 25, unit: "%" },
				});
			}
		});

		it("parses zero values", () => {
			const result = Origin.parse("0px 0px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 0, unit: "px" },
					vertical: { value: 0, unit: "px" },
				});
			}
		});
	});

	describe("3D positions", () => {
		it("parses 3D with pixel values", () => {
			const result = Origin.parse("50px 100px 10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: { value: 50, unit: "px" },
					y: { value: 100, unit: "px" },
					z: { value: 10, unit: "px" },
				});
			}
		});

		it("parses 3D with keywords and z-value", () => {
			const result = Origin.parse("left top 20px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: "left",
					y: "top",
					z: { value: 20, unit: "px" },
				});
			}
		});

		it("parses 3D with center and z-value", () => {
			const result = Origin.parse("center center 5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: "center",
					y: "center",
					z: { value: 5, unit: "px" },
				});
			}
		});

		it("parses 3D with percentages and z-value", () => {
			const result = Origin.parse("50% 50% 0px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: { value: 50, unit: "%" },
					y: { value: 50, unit: "%" },
					z: { value: 0, unit: "px" },
				});
			}
		});
	});

	describe("single value behavior", () => {
		it("parses single keyword (horizontal)", () => {
			const result = Origin.parse("left");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: "center",
				});
			}
		});

		it("parses single value (horizontal)", () => {
			const result = Origin.parse("25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 25, unit: "%" },
					vertical: "center",
				});
			}
		});

		it("parses single top keyword (vertical)", () => {
			const result = Origin.parse("top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "top",
				});
			}
		});
	});

	describe("error handling", () => {
		it("rejects empty string", () => {
			const result = Origin.parse("");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid keywords", () => {
			const result = Origin.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid values", () => {
			const result = Origin.parse("abc def");
			expect(result.ok).toBe(false);
		});
	});
});

describe("Transform.PerspectiveOrigin.parsePerspectiveOrigin", () => {
	describe("2D positions - keywords", () => {
		it("parses center", () => {
			const result = Origin.parsePerspectiveOrigin("center");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "center",
				});
			}
		});

		it("parses left top", () => {
			const result = Origin.parsePerspectiveOrigin("left top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: "top",
				});
			}
		});

		it("parses right bottom", () => {
			const result = Origin.parsePerspectiveOrigin("right bottom");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "right",
					vertical: "bottom",
				});
			}
		});
	});

	describe("2D positions - values", () => {
		it("parses percentage values", () => {
			const result = Origin.parsePerspectiveOrigin("50% 50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 50, unit: "%" },
					vertical: { value: 50, unit: "%" },
				});
			}
		});

		it("parses pixel values", () => {
			const result = Origin.parsePerspectiveOrigin("100px 200px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 100, unit: "px" },
					vertical: { value: 200, unit: "px" },
				});
			}
		});

		it("parses mixed values", () => {
			const result = Origin.parsePerspectiveOrigin("left 75%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: { value: 75, unit: "%" },
				});
			}
		});
	});

	describe("error handling", () => {
		it("rejects empty string", () => {
			const result = Origin.parsePerspectiveOrigin("");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid values", () => {
			const result = Origin.parsePerspectiveOrigin("invalid");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/transform/origin.ts ===
// b_path:: src/parse/transform/origin.ts
import { err, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as Position from "../position/position";

/**
 * Parse transform-origin value (2D or 3D).
 *
 * Parses CSS transform-origin values that define the point around which
 * a transformation is applied. Supports 2D positions (x y) and 3D positions (x y z).
 *
 * Syntax:
 * - 2D: [ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?
 * - 3D: [ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]? <length>
 *
 * @param css - CSS string containing transform-origin value
 * @returns Result containing Position2D or Position3D IR, or error message
 *
 * @public
 *
 * @example
 * 2D origin with keywords:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Transform.Origin.parse("center top");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: "center", vertical: "top" }
 * }
 * ```
 *
 * @example
 * 2D origin with values:
 * ```typescript
 * const result = Parse.Transform.Origin.parse("50% 100px");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: { value: 50, unit: "%" }, vertical: { value: 100, unit: "px" } }
 * }
 * ```
 *
 * @example
 * 3D origin:
 * ```typescript
 * const result = Parse.Transform.Origin.parse("left top 10px");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { x: "left", y: "top", z: { value: 10, unit: "px" } }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin | MDN: transform-origin}
 * @see {@link https://www.w3.org/TR/css-transforms-1/#transform-origin-property | W3C Spec: transform-origin}
 */
export function parse(css: string): Result<Type.Position2D | Type.Position3D, string> {
	// Try 3D first (if it has 3 values)
	const parts = css.trim().split(/\s+/);

	if (parts.length === 3) {
		// Try 3D parsing
		const result3D = Position.parse3D(css);
		if (result3D.ok) {
			return result3D;
		}
	}

	// Fall back to 2D parsing
	const result2D = Position.parse(css);
	if (!result2D.ok) {
		const errorMsg = result2D.issues[0]?.message || "Invalid transform-origin";
		return err(errorMsg);
	}

	// Convert ParseResult to Result
	return result2D.value ? { ok: true, value: result2D.value, error: undefined } : err("Missing position value");
}

/**
 * Parse perspective-origin value (2D only).
 *
 * Parses CSS perspective-origin values that define the position at which
 * the viewer is looking. Only supports 2D positions.
 *
 * Syntax: [ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?
 *
 * @param css - CSS string containing perspective-origin value
 * @returns Result containing Position2D IR, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Transform.PerspectiveOrigin.parse("50% 50%");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/perspective-origin | MDN: perspective-origin}
 * @see {@link https://www.w3.org/TR/css-transforms-1/#perspective-origin-property | W3C Spec: perspective-origin}
 */
export function parsePerspectiveOrigin(css: string): Result<Type.Position2D, string> {
	const result = Position.parse(css);
	if (!result.ok) {
		const errorMsg = result.issues[0]?.message || "Invalid perspective-origin";
		return err(errorMsg);
	}
	// Convert ParseResult to Result
	return result.value ? { ok: true, value: result.value, error: undefined } : err("Missing position value");
}


=== File: src/parse/transform/transform.parse.test.ts ===
// b_path:: src/parse/transform/transform.parse.test.ts
import { describe, expect, it } from "vitest";
import * as TransformParser from "./transform";

describe("Transform Parser", () => {
	describe("Translation transforms", () => {
		it("should parse translate with two values", () => {
			const css = "translate(100px, 50px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				expect(result.value?.[0]).toEqual({
					kind: "translate",
					x: { value: 100, unit: "px" },
					y: { value: 50, unit: "px" },
				});
			}
		});

		it("should parse translate with one value", () => {
			const css = "translate(100px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				expect(result.value?.[0]).toEqual({
					kind: "translate",
					x: { value: 100, unit: "px" },
					y: undefined,
				});
			}
		});

		it("should parse translate with percentage values", () => {
			const css = "translate(50%, 25%)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translate",
					x: { value: 50, unit: "%" },
					y: { value: 25, unit: "%" },
				});
			}
		});

		it("should parse translateX", () => {
			const css = "translateX(100px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translateX",
					x: { value: 100, unit: "px" },
				});
			}
		});

		it("should parse translateY", () => {
			const css = "translateY(50%)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translateY",
					y: { value: 50, unit: "%" },
				});
			}
		});

		it("should parse translateZ", () => {
			const css = "translateZ(30px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translateZ",
					z: { value: 30, unit: "px" },
				});
			}
		});

		it("should parse translate3d", () => {
			const css = "translate3d(10px, 20px, 30px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translate3d",
					x: { value: 10, unit: "px" },
					y: { value: 20, unit: "px" },
					z: { value: 30, unit: "px" },
				});
			}
		});
	});

	describe("Rotation transforms", () => {
		it("should parse rotate", () => {
			const css = "rotate(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotate",
					angle: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse rotate with radians", () => {
			const css = "rotate(1.57rad)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotate",
					angle: { value: 1.57, unit: "rad" },
				});
			}
		});

		it("should parse rotate with turns", () => {
			const css = "rotate(0.25turn)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotate",
					angle: { value: 0.25, unit: "turn" },
				});
			}
		});

		it("should parse rotateX", () => {
			const css = "rotateX(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotateX",
					angle: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse rotateY", () => {
			const css = "rotateY(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotateY",
					angle: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse rotateZ", () => {
			const css = "rotateZ(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotateZ",
					angle: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse rotate3d", () => {
			const css = "rotate3d(1, 1, 0, 45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotate3d",
					x: 1,
					y: 1,
					z: 0,
					angle: { value: 45, unit: "deg" },
				});
			}
		});
	});

	describe("Scale transforms", () => {
		it("should parse scale with two values", () => {
			const css = "scale(1.5, 2)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scale",
					x: 1.5,
					y: 2,
				});
			}
		});

		it("should parse scale with one value", () => {
			const css = "scale(1.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scale",
					x: 1.5,
					y: 1.5,
				});
			}
		});

		it("should parse scaleX", () => {
			const css = "scaleX(1.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scaleX",
					x: 1.5,
				});
			}
		});

		it("should parse scaleY", () => {
			const css = "scaleY(2)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scaleY",
					y: 2,
				});
			}
		});

		it("should parse scaleZ", () => {
			const css = "scaleZ(0.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scaleZ",
					z: 0.5,
				});
			}
		});

		it("should parse scale3d", () => {
			const css = "scale3d(1.5, 2, 0.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scale3d",
					x: 1.5,
					y: 2,
					z: 0.5,
				});
			}
		});
	});

	describe("Skew transforms", () => {
		it("should parse skew with two values", () => {
			const css = "skew(45deg, 10deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "skew",
					x: { value: 45, unit: "deg" },
					y: { value: 10, unit: "deg" },
				});
			}
		});

		it("should parse skew with one value", () => {
			const css = "skew(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "skew",
					x: { value: 45, unit: "deg" },
					y: { value: 0, unit: "deg" },
				});
			}
		});

		it("should parse skewX", () => {
			const css = "skewX(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "skewX",
					x: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse skewY", () => {
			const css = "skewY(10deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "skewY",
					y: { value: 10, unit: "deg" },
				});
			}
		});
	});

	describe("Matrix transforms", () => {
		it("should parse matrix", () => {
			const css = "matrix(1, 0.5, -0.5, 1, 10, 20)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "matrix",
					a: 1,
					b: 0.5,
					c: -0.5,
					d: 1,
					e: { value: 10, unit: "px" },
					f: { value: 20, unit: "px" },
				});
			}
		});

		it("should parse matrix3d", () => {
			const css = "matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "matrix3d",
					values: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
				});
			}
		});
	});

	describe("Perspective transform", () => {
		it("should parse perspective", () => {
			const css = "perspective(1000px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "perspective",
					depth: { value: 1000, unit: "px" },
				});
			}
		});
	});

	describe("Multiple transforms", () => {
		it("should parse multiple transforms", () => {
			const css = "translateX(100px) rotate(45deg) scale(1.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(3);
				expect(result.value?.[0]?.kind).toBe("translateX");
				expect(result.value?.[1]?.kind).toBe("rotate");
				expect(result.value?.[2]?.kind).toBe("scale");
			}
		});

		it("should parse complex transform chain", () => {
			const css = "translate3d(10px, 20px, 30px) rotateY(45deg) scale3d(1.5, 2, 0.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(3);
				expect(result.value?.[0]?.kind).toBe("translate3d");
				expect(result.value?.[1]?.kind).toBe("rotateY");
				expect(result.value?.[2]?.kind).toBe("scale3d");
			}
		});
	});

	describe("Error handling", () => {
		it("should return error for invalid function name", () => {
			const css = "invalid-transform(red, blue)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("No valid transform functions found");
			}
		});

		it("should return error for invalid CSS syntax", () => {
			const css = "not valid css";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
		});

		it("should return error for translate with wrong number of arguments", () => {
			const css = "translate(100px, 50px, 30px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("expects 1 or 2 arguments");
			}
		});

		it("should return error for rotate3d with wrong number of arguments", () => {
			const css = "rotate3d(1, 1, 0)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("expects 4 arguments");
			}
		});

		it("should return error for matrix with wrong number of arguments", () => {
			const css = "matrix(1, 0.5, -0.5, 1, 10)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("expects 6 arguments");
			}
		});

		it("should return error for matrix3d with wrong number of arguments", () => {
			const css = "matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("expects 16 arguments");
			}
		});
	});
});


=== File: src/parse/transform/transform.ts ===
// b_path:: src/parse/transform/transform.ts
import type * as csstree from "css-tree";
import { TRANSFORM_FUNCTION_NAMES } from "@/core/keywords";
import { err, ok, type ParseResult, parseErr, parseOk, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse transform function from CSS function AST node.
 *
 * Handles all CSS transform functions including translate, rotate, scale, skew, matrix, etc.
 *
 * @param fn - CSS Function AST node
 * @returns Result containing TransformFunction IR or error message
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode, canonicalName?: string): Result<Type.TransformFunction, string> {
	const functionName = canonicalName || fn.name.toLowerCase();

	// Get all children nodes, filtering out operators (commas)
	const children = fn.children.toArray().filter((node) => node.type !== "Operator");
	if (children.length === 0) {
		return err("Transform function requires arguments");
	}

	try {
		switch (functionName) {
			case "translate": {
				if (children.length < 1 || children.length > 2) {
					return err("translate() expects 1 or 2 arguments");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x value");
				const x = ParseUtils.parseLengthPercentageNode(xNode);
				if (!x.ok) return err(`Invalid x value: ${x.error}`);

				const y = children[1] ? ParseUtils.parseLengthPercentageNode(children[1]) : ok(undefined);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);

				return ok({
					kind: "translate",
					x: x.value,
					y: y.value,
				});
			}

			case "translatex": {
				if (children.length !== 1) {
					return err("translateX() expects 1 argument");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x value");
				const x = ParseUtils.parseLengthPercentageNode(xNode);
				if (!x.ok) return err(`Invalid x value: ${x.error}`);

				return ok({
					kind: "translateX",
					x: x.value,
				});
			}

			case "translatey": {
				if (children.length !== 1) {
					return err("translateY() expects 1 argument");
				}

				const yNode = children[0];
				if (!yNode) return err("Missing y value");
				const y = ParseUtils.parseLengthPercentageNode(yNode);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);

				return ok({
					kind: "translateY",
					y: y.value,
				});
			}

			case "translatez": {
				if (children.length !== 1) {
					return err("translateZ() expects 1 argument");
				}

				const zNode = children[0];
				if (!zNode) return err("Missing z value");
				const z = ParseUtils.parseLengthNode(zNode);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);

				return ok({
					kind: "translateZ",
					z: z.value,
				});
			}

			case "translate3d": {
				if (children.length !== 3) {
					return err("translate3d() expects 3 arguments");
				}

				const xNode = children[0];
				const yNode = children[1];
				const zNode = children[2];

				if (!xNode) return err("Missing x value");
				if (!yNode) return err("Missing y value");
				if (!zNode) return err("Missing z value");

				const x = ParseUtils.parseLengthPercentageNode(xNode);
				const y = ParseUtils.parseLengthPercentageNode(yNode);
				const z = ParseUtils.parseLengthNode(zNode);

				if (!x.ok) return err(`Invalid x value: ${x.error}`);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);

				return ok({
					kind: "translate3d",
					x: x.value,
					y: y.value,
					z: z.value,
				});
			}

			case "rotate": {
				if (children.length !== 1) {
					return err("rotate() expects 1 argument");
				}

				const angleNode = children[0];
				if (!angleNode) return err("Missing angle value");
				const angle = ParseUtils.parseAngleNode(angleNode);
				if (!angle.ok) return err(`Invalid angle: ${angle.error}`);

				return ok({
					kind: "rotate",
					angle: angle.value,
				});
			}

			case "rotatex":
			case "rotatey":
			case "rotatez": {
				if (children.length !== 1) {
					return err(`${functionName}() expects 1 argument`);
				}

				const angleNode = children[0];
				if (!angleNode) return err("Missing angle value");
				const angle = ParseUtils.parseAngleNode(angleNode);
				if (!angle.ok) return err(`Invalid angle: ${angle.error}`);

				// Map lowercase to camelCase
				const kindMap = {
					rotatex: "rotateX",
					rotatey: "rotateY",
					rotatez: "rotateZ",
				} as const;

				return ok({
					kind: kindMap[functionName as keyof typeof kindMap],
					angle: angle.value,
				});
			}

			case "rotate3d": {
				if (children.length !== 4) {
					return err("rotate3d() expects 4 arguments");
				}

				const xNode = children[0];
				const yNode = children[1];
				const zNode = children[2];
				const angleNode = children[3];

				if (!xNode) return err("Missing x value");
				if (!yNode) return err("Missing y value");
				if (!zNode) return err("Missing z value");
				if (!angleNode) return err("Missing angle value");

				const x = ParseUtils.parseNumberNode(xNode);
				const y = ParseUtils.parseNumberNode(yNode);
				const z = ParseUtils.parseNumberNode(zNode);
				const angle = ParseUtils.parseAngleNode(angleNode);

				if (!x.ok) return err(`Invalid x value: ${x.error}`);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);
				if (!angle.ok) return err(`Invalid angle: ${angle.error}`);

				return ok({
					kind: "rotate3d",
					x: x.value,
					y: y.value,
					z: z.value,
					angle: angle.value,
				});
			}

			case "scale": {
				if (children.length < 1 || children.length > 2) {
					return err("scale() expects 1 or 2 arguments");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x value");
				const x = ParseUtils.parseNumberNode(xNode);
				if (!x.ok) return err(`Invalid x value: ${x.error}`);

				const y = children[1] ? ParseUtils.parseNumberNode(children[1]) : ok(x.value);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);

				return ok({
					kind: "scale",
					x: x.value,
					y: y.value,
				});
			}

			case "scalex": {
				if (children.length !== 1) {
					return err("scaleX() expects 1 argument");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x value");
				const x = ParseUtils.parseNumberNode(xNode);
				if (!x.ok) return err(`Invalid x value: ${x.error}`);

				return ok({
					kind: "scaleX",
					x: x.value,
				});
			}

			case "scaley": {
				if (children.length !== 1) {
					return err("scaleY() expects 1 argument");
				}

				const yNode = children[0];
				if (!yNode) return err("Missing y value");
				const y = ParseUtils.parseNumberNode(yNode);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);

				return ok({
					kind: "scaleY",
					y: y.value,
				});
			}

			case "scalez": {
				if (children.length !== 1) {
					return err("scaleZ() expects 1 argument");
				}

				const zNode = children[0];
				if (!zNode) return err("Missing z value");
				const z = ParseUtils.parseNumberNode(zNode);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);

				return ok({
					kind: "scaleZ",
					z: z.value,
				});
			}

			case "scale3d": {
				if (children.length !== 3) {
					return err("scale3d() expects 3 arguments");
				}

				const xNode = children[0];
				const yNode = children[1];
				const zNode = children[2];

				if (!xNode) return err("Missing x value");
				if (!yNode) return err("Missing y value");
				if (!zNode) return err("Missing z value");

				const x = ParseUtils.parseNumberNode(xNode);
				const y = ParseUtils.parseNumberNode(yNode);
				const z = ParseUtils.parseNumberNode(zNode);

				if (!x.ok) return err(`Invalid x value: ${x.error}`);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);

				return ok({
					kind: "scale3d",
					x: x.value,
					y: y.value,
					z: z.value,
				});
			}

			case "skew": {
				if (children.length < 1 || children.length > 2) {
					return err("skew() expects 1 or 2 arguments");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x angle");
				const x = ParseUtils.parseAngleNode(xNode);
				if (!x.ok) return err(`Invalid x angle: ${x.error}`);

				const yNode = children[1];
				const y = yNode ? ParseUtils.parseAngleNode(yNode) : ok({ value: 0, unit: "deg" as const });
				if (!y.ok) return err(`Invalid y angle: ${y.error}`);

				return ok({
					kind: "skew",
					x: x.value,
					y: y.value,
				});
			}

			case "skewx": {
				if (children.length !== 1) {
					return err("skewX() expects 1 argument");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x angle");
				const x = ParseUtils.parseAngleNode(xNode);
				if (!x.ok) return err(`Invalid x angle: ${x.error}`);

				return ok({
					kind: "skewX",
					x: x.value,
				});
			}

			case "skewy": {
				if (children.length !== 1) {
					return err("skewY() expects 1 argument");
				}

				const yNode = children[0];
				if (!yNode) return err("Missing y angle");
				const y = ParseUtils.parseAngleNode(yNode);
				if (!y.ok) return err(`Invalid y angle: ${y.error}`);

				return ok({
					kind: "skewY",
					y: y.value,
				});
			}

			case "matrix": {
				if (children.length !== 6) {
					return err("matrix() expects 6 arguments");
				}

				const values: number[] = [];
				for (let i = 0; i < 6; i++) {
					const node = children[i];
					if (!node) return err(`Missing matrix value at position ${i + 1}`);
					const num = ParseUtils.parseNumberNode(node);
					if (!num.ok) return err(`Invalid matrix value at position ${i + 1}: ${num.error}`);
					values.push(num.value);
				}

				// Validate we have exactly 6 values
				if (values.length !== 6) {
					return err("matrix() requires exactly 6 values");
				}

				// Destructure to satisfy TypeScript - we know length is 6
				const [a, b, c, d, e, f] = values;

				return ok({
					kind: "matrix",
					a: a as number,
					b: b as number,
					c: c as number,
					d: d as number,
					e: { value: e as number, unit: "px" },
					f: { value: f as number, unit: "px" },
				});
			}

			case "matrix3d": {
				if (children.length !== 16) {
					return err("matrix3d() expects 16 arguments");
				}

				const values: number[] = [];
				for (let i = 0; i < 16; i++) {
					const node = children[i];
					if (!node) return err(`Missing matrix3d value at position ${i + 1}`);
					const num = ParseUtils.parseNumberNode(node);
					if (!num.ok) return err(`Invalid matrix3d value at position ${i + 1}: ${num.error}`);
					values.push(num.value);
				}

				// Validate we have exactly 16 values
				if (values.length !== 16) {
					return err("matrix3d() requires exactly 16 values");
				}

				return ok({
					kind: "matrix3d",
					values,
				});
			}

			case "perspective": {
				if (children.length !== 1) {
					return err("perspective() expects 1 argument");
				}

				const depthNode = children[0];
				if (!depthNode) return err("Missing depth value");
				const depth = ParseUtils.parseLengthNode(depthNode);
				if (!depth.ok) return err(`Invalid depth value: ${depth.error}`);

				return ok({
					kind: "perspective",
					depth: depth.value,
				});
			}

			default:
				return err(`Unknown transform function: ${functionName}`);
		}
	} catch (e) {
		return err(`Failed to parse transform function: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Parse a CSS transform value into structured intermediate representation (IR).
 *
 * Parses CSS transform property values containing transform functions like
 * translate(), rotate(), scale(), etc. into type-safe IR objects.
 *
 * Supports all CSS transform functions per CSS Transforms Module Level 1 & 2:
 * - Translation: translate(), translateX(), translateY(), translateZ(), translate3d()
 * - Rotation: rotate(), rotateX(), rotateY(), rotateZ(), rotate3d()
 * - Scaling: scale(), scaleX(), scaleY(), scaleZ(), scale3d()
 * - Skewing: skew(), skewX(), skewY()
 * - Matrix: matrix(), matrix3d()
 * - Perspective: perspective()
 *
 * @param css - CSS string containing transform functions
 * @returns Result containing Transform IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * Simple translation:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Transform.parse("translate(100px, 50px)");
 * if (result.ok) {
 *   console.log(result.value);
 *   // [{ kind: "translate", x: { value: 100, unit: "px" }, y: { value: 50, unit: "px" } }]
 * }
 * ```
 *
 * @example
 * Multiple transforms:
 * ```typescript
 * const result = Parse.Transform.parse("translateX(100px) rotate(45deg) scale(1.5)");
 * if (result.ok) {
 *   console.log(result.value.length); // 3
 *   console.log(result.value[0].kind); // "translateX"
 *   console.log(result.value[1].kind); // "rotate"
 *   console.log(result.value[2].kind); // "scale"
 * }
 * ```
 *
 * @example
 * 3D transforms:
 * ```typescript
 * const result = Parse.Transform.parse("translate3d(10px, 20px, 30px) rotateY(45deg)");
 * if (result.ok) {
 *   console.log(result.value[0].kind); // "translate3d"
 *   console.log(result.value[1].kind); // "rotateY"
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Transform.parse("invalid syntax");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform | MDN: transform}
 * @see {@link https://www.w3.org/TR/css-transforms-1/ | W3C Spec: CSS Transforms Level 1}
 * @see {@link https://www.w3.org/TR/css-transforms-2/ | W3C Spec: CSS Transforms Level 2}
 */
export function parse(css: string): ParseResult<Type.Transform> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find all function nodes
		const transformFunctions: Type.TransformFunction[] = [];
		const errors: string[] = [];

		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				// Check if it's a transform function
				const functionName = node.name.toLowerCase();

				if (TRANSFORM_FUNCTION_NAMES.includes(functionName as (typeof TRANSFORM_FUNCTION_NAMES)[number])) {
					// Use the canonical function name for parsing
					const canonicalName = TRANSFORM_FUNCTION_NAMES.find((name) => name === functionName) || functionName;
					const funcResult = fromFunction(node, canonicalName);
					if (funcResult.ok) {
						transformFunctions.push(funcResult.value);
					} else {
						errors.push(`${functionName}(): ${funcResult.error}`);
					}
				}
			},
		});

		if (transformFunctions.length === 0) {
			if (errors.length > 0) {
				return parseErr("invalid-value", errors.join("; "));
			}
			return parseErr("invalid-syntax", "No valid transform functions found in CSS string", {
				suggestion:
					"Expected transform functions like translate(), rotate(), scale(), skew(), matrix(), or perspective()",
			});
		}

		return parseOk(transformFunctions);
	} catch (e) {
		return parseErr("invalid-syntax", `Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/transition/delay.test.ts ===
// b_path:: src/parse/transition/delay.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./delay";

describe("Transition Delay Parser", () => {
	it("should parse single time value in seconds", () => {
		const result = Parser.parse("1s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("transition-delay");
			expect(result.value.delays).toHaveLength(1);
			expect(result.value.delays[0]).toEqual({ value: 1, unit: "s" });
		}
	});

	it("should parse single time value in milliseconds", () => {
		const result = Parser.parse("500ms");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays).toHaveLength(1);
			expect(result.value.delays[0]).toEqual({ value: 500, unit: "ms" });
		}
	});

	it("should parse negative delay", () => {
		const result = Parser.parse("-2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays[0]).toEqual({ value: -2, unit: "s" });
		}
	});

	it("should parse zero delay", () => {
		const result = Parser.parse("0s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays[0]).toEqual({ value: 0, unit: "s" });
		}
	});

	it("should parse decimal values", () => {
		const result = Parser.parse("0.5s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays[0]).toEqual({ value: 0.5, unit: "s" });
		}
	});

	it("should parse multiple delays", () => {
		const result = Parser.parse("1s, 500ms, 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays).toHaveLength(3);
			expect(result.value.delays[0]).toEqual({ value: 1, unit: "s" });
			expect(result.value.delays[1]).toEqual({ value: 500, unit: "ms" });
			expect(result.value.delays[2]).toEqual({ value: 2, unit: "s" });
		}
	});

	it("should parse delays with whitespace", () => {
		const result = Parser.parse("1s , 500ms , 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays).toHaveLength(3);
		}
	});

	it("should parse mixed positive and negative delays", () => {
		const result = Parser.parse("1s, -500ms, 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.delays).toHaveLength(3);
			expect(result.value.delays[1]).toEqual({ value: -500, unit: "ms" });
		}
	});

	it("should reject invalid time unit", () => {
		const result = Parser.parse("1px");

		expect(result.ok).toBe(false);
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");

		expect(result.ok).toBe(false);
	});

	it("should reject value without unit", () => {
		const result = Parser.parse("1");

		expect(result.ok).toBe(false);
	});

	it("should reject trailing comma", () => {
		const result = Parser.parse("1s,");

		expect(result.ok).toBe(false);
	});

	it("should reject leading comma", () => {
		const result = Parser.parse(",1s");

		expect(result.ok).toBe(false);
	});

	it("should reject multiple commas", () => {
		const result = Parser.parse("1s,,2s");

		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/transition/delay.ts ===
// b_path:: src/parse/transition/delay.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse time value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with Time object or error
 *
 * @internal
 */
function parseTime(node: csstree.CssNode): Result<Type.Time, string> {
	if (node.type !== "Dimension") {
		return err(`Expected time dimension, got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);
	const unit = node.unit.toLowerCase();

	if (unit !== "s" && unit !== "ms") {
		return err(`Invalid time unit: ${unit}. Expected 's' or 'ms'`);
	}

	return ok({
		value,
		unit: unit as "s" | "ms",
	});
}

/**
 * Parse CSS transition-delay property value.
 *
 * Parses comma-separated list of time values.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param css - CSS transition-delay value (e.g., "1s, 500ms, 2s")
 * @returns Result with TransitionDelay IR or error message
 *
 * @example
 * Simple delay:
 * ```typescript
 * const result = parse("1s");
 * // { ok: true, value: { kind: "transition-delay", delays: [{ value: 1, unit: "s" }] } }
 * ```
 *
 * @example
 * Multiple delays:
 * ```typescript
 * const result = parse("1s, 500ms, 2s");
 * // { ok: true, value: { kind: "transition-delay", delays: [...] } }
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay | MDN: transition-delay}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-delay-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TransitionDelay, string> {
	const delaysResult = parseCommaSeparatedSingle(css, parseTime, "transition-delay");

	if (!delaysResult.ok) {
		return err(delaysResult.error);
	}

	return ok({
		kind: "transition-delay",
		delays: delaysResult.value,
	});
}


=== File: src/parse/transition/duration.test.ts ===
// b_path:: src/parse/transition/duration.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./duration";

describe("Transition Duration Parser", () => {
	it("should parse single time value in seconds", () => {
		const result = Parser.parse("1s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("transition-duration");
			expect(result.value.durations).toHaveLength(1);
			expect(result.value.durations[0]).toEqual({ value: 1, unit: "s" });
		}
	});

	it("should parse single time value in milliseconds", () => {
		const result = Parser.parse("500ms");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations).toHaveLength(1);
			expect(result.value.durations[0]).toEqual({ value: 500, unit: "ms" });
		}
	});

	it("should parse zero duration", () => {
		const result = Parser.parse("0s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations[0]).toEqual({ value: 0, unit: "s" });
		}
	});

	it("should parse decimal values", () => {
		const result = Parser.parse("0.5s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations[0]).toEqual({ value: 0.5, unit: "s" });
		}
	});

	it("should parse multiple durations", () => {
		const result = Parser.parse("1s, 500ms, 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations).toHaveLength(3);
			expect(result.value.durations[0]).toEqual({ value: 1, unit: "s" });
			expect(result.value.durations[1]).toEqual({ value: 500, unit: "ms" });
			expect(result.value.durations[2]).toEqual({ value: 2, unit: "s" });
		}
	});

	it("should parse durations with whitespace", () => {
		const result = Parser.parse("1s , 500ms , 2s");

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.durations).toHaveLength(3);
		}
	});

	it("should reject negative duration", () => {
		const result = Parser.parse("-1s");

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("non-negative");
		}
	});

	it("should reject auto keyword", () => {
		const result = Parser.parse("auto");

		expect(result.ok).toBe(false);
	});

	it("should reject invalid time unit", () => {
		const result = Parser.parse("1px");

		expect(result.ok).toBe(false);
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");

		expect(result.ok).toBe(false);
	});

	it("should reject value without unit", () => {
		const result = Parser.parse("1");

		expect(result.ok).toBe(false);
	});

	it("should reject trailing comma", () => {
		const result = Parser.parse("1s,");

		expect(result.ok).toBe(false);
	});

	it("should reject leading comma", () => {
		const result = Parser.parse(",1s");

		expect(result.ok).toBe(false);
	});

	it("should reject multiple commas", () => {
		const result = Parser.parse("1s,,2s");

		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/transition/duration.ts ===
// b_path:: src/parse/transition/duration.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse duration value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with Time object or error
 *
 * @internal
 */
function parseDuration(node: csstree.CssNode): Result<Type.Time, string> {
	if (node.type !== "Dimension") {
		return err(`Expected time dimension, got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);
	const unit = node.unit.toLowerCase();

	if (unit !== "s" && unit !== "ms") {
		return err(`Invalid time unit: ${unit}. Expected 's' or 'ms'`);
	}

	if (value < 0) {
		return err(`transition-duration must be non-negative, got: ${value}`);
	}

	return ok({
		value,
		unit: unit as "s" | "ms",
	});
}

/**
 * Parse CSS transition-duration property value.
 *
 * Parses comma-separated list of time values.
 * Time values must be non-negative.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param css - CSS transition-duration value (e.g., "1s, 500ms")
 * @returns Result with TransitionDuration IR or error message
 *
 * @example
 * Simple duration:
 * ```typescript
 * const result = parse("1s");
 * // { ok: true, value: { kind: "transition-duration", durations: [{ value: 1, unit: "s" }] } }
 * ```
 *
 * @example
 * Multiple durations:
 * ```typescript
 * const result = parse("1s, 500ms");
 * // { ok: true, value: { kind: "transition-duration", durations: [...] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration | MDN: transition-duration}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-duration-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TransitionDuration, string> {
	const durationsResult = parseCommaSeparatedSingle(css, parseDuration, "transition-duration");

	if (!durationsResult.ok) {
		return err(durationsResult.error);
	}

	return ok({
		kind: "transition-duration",
		durations: durationsResult.value,
	});
}


=== File: src/parse/transition/index.ts ===
// b_path:: src/parse/transition/index.ts

export * as Delay from "./delay";
export * as Duration from "./duration";
export * as Property from "./property";
export * as TimingFunction from "./timing-function";
export { parse } from "./transition";


=== File: src/parse/transition/property.test.ts ===
// b_path:: src/parse/transition/property.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./property";

describe("Transition Property Parser", () => {
	// Keywords
	it("should parse none keyword", () => {
		const result = Parser.parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("transition-property");
			expect(result.value.properties).toEqual([{ type: "none" }]);
		}
	});

	it("should parse all keyword", () => {
		const result = Parser.parse("all");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "all" }]);
		}
	});

	it("should parse NONE with uppercase", () => {
		const result = Parser.parse("NONE");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "none" }]);
		}
	});

	it("should parse ALL with uppercase", () => {
		const result = Parser.parse("ALL");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "all" }]);
		}
	});

	// Single property names
	it("should parse single property name", () => {
		const result = Parser.parse("opacity");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "identifier", value: "opacity" }]);
		}
	});

	it("should parse hyphenated property name", () => {
		const result = Parser.parse("background-color");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "identifier", value: "background-color" }]);
		}
	});

	it("should parse transform property", () => {
		const result = Parser.parse("transform");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "identifier", value: "transform" }]);
		}
	});

	it("should preserve case of property name", () => {
		const result = Parser.parse("WebkitTransform");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "identifier", value: "WebkitTransform" }]);
		}
	});

	// Custom properties
	it("should parse custom property", () => {
		const result = Parser.parse("--custom-prop");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "identifier", value: "--custom-prop" }]);
		}
	});

	it("should parse custom property with numbers", () => {
		const result = Parser.parse("--color-1");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toEqual([{ type: "identifier", value: "--color-1" }]);
		}
	});

	// Multiple properties
	it("should parse multiple properties", () => {
		const result = Parser.parse("opacity, transform");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toHaveLength(2);
			expect(result.value.properties[0]).toEqual({ type: "identifier", value: "opacity" });
			expect(result.value.properties[1]).toEqual({ type: "identifier", value: "transform" });
		}
	});

	it("should parse three properties", () => {
		const result = Parser.parse("opacity, transform, background-color");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toHaveLength(3);
			expect(result.value.properties[0]).toEqual({ type: "identifier", value: "opacity" });
			expect(result.value.properties[1]).toEqual({ type: "identifier", value: "transform" });
			expect(result.value.properties[2]).toEqual({ type: "identifier", value: "background-color" });
		}
	});

	it("should parse properties with whitespace", () => {
		const result = Parser.parse("opacity , transform , background-color");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toHaveLength(3);
		}
	});

	it("should parse mixed properties and custom properties", () => {
		const result = Parser.parse("opacity, --custom-color, transform");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.properties).toHaveLength(3);
			expect(result.value.properties[1]).toEqual({ type: "identifier", value: "--custom-color" });
		}
	});

	// Error cases
	it("should reject empty value", () => {
		const result = Parser.parse("");
		expect(result.ok).toBe(false);
	});

	it("should reject trailing comma", () => {
		const result = Parser.parse("opacity,");
		expect(result.ok).toBe(false);
	});

	it("should reject leading comma", () => {
		const result = Parser.parse(",opacity");
		expect(result.ok).toBe(false);
	});

	it("should reject multiple commas", () => {
		const result = Parser.parse("opacity,,transform");
		expect(result.ok).toBe(false);
	});

	it("should reject number value", () => {
		const result = Parser.parse("123");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/transition/property.ts ===
// b_path:: src/parse/transition/property.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse property name from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with property object or error
 *
 * @internal
 */
function parseProperty(node: csstree.CssNode): Result<Type.TransitionProperty["properties"][number], string> {
	if (node.type !== "Identifier") {
		return err(`Expected identifier for property name, got: ${node.type}`);
	}

	const value = node.name.toLowerCase();

	if (value === "none") {
		return ok({ type: "none" });
	}

	if (value === "all") {
		return ok({ type: "all" });
	}

	return ok({ type: "identifier", value: node.name });
}

/**
 * Parse CSS transition-property property value.
 *
 * Parses comma-separated list of property names, 'none', or 'all'.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param css - CSS transition-property value (e.g., "opacity, transform", "all", "none")
 * @returns Result with TransitionProperty IR or error message
 *
 * @example
 * Single property:
 * ```typescript
 * const result = parse("opacity");
 * // { ok: true, value: { kind: "transition-property", properties: [{ type: "identifier", value: "opacity" }] } }
 * ```
 *
 * @example
 * Multiple properties:
 * ```typescript
 * const result = parse("opacity, transform");
 * // { ok: true, value: { kind: "transition-property", properties: [...] } }
 * ```
 *
 * @example
 * Keywords:
 * ```typescript
 * const result = parse("all");
 * // { ok: true, value: { kind: "transition-property", properties: [{ type: "all" }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property | MDN: transition-property}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-property-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TransitionProperty, string> {
	const propertiesResult = parseCommaSeparatedSingle(css, parseProperty, "transition-property");

	if (!propertiesResult.ok) {
		return err(propertiesResult.error);
	}

	return ok({
		kind: "transition-property",
		properties: propertiesResult.value,
	});
}


=== File: src/parse/transition/timing-function.test.ts ===
// b_path:: src/parse/transition/timing-function.test.ts
import { describe, expect, it } from "vitest";
import * as Parser from "./timing-function";

describe("Transition Timing Function Parser", () => {
	// Keywords
	it("should parse ease keyword", () => {
		const result = Parser.parse("ease");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("transition-timing-function");
			expect(result.value.functions).toEqual(["ease"]);
		}
	});

	it("should parse ease-in keyword", () => {
		const result = Parser.parse("ease-in");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["ease-in"]);
		}
	});

	it("should parse ease-out keyword", () => {
		const result = Parser.parse("ease-out");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["ease-out"]);
		}
	});

	it("should parse ease-in-out keyword", () => {
		const result = Parser.parse("ease-in-out");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["ease-in-out"]);
		}
	});

	it("should parse linear keyword", () => {
		const result = Parser.parse("linear");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["linear"]);
		}
	});

	it("should parse step-start keyword", () => {
		const result = Parser.parse("step-start");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["step-start"]);
		}
	});

	it("should parse step-end keyword", () => {
		const result = Parser.parse("step-end");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["step-end"]);
		}
	});

	// cubic-bezier()
	it("should parse cubic-bezier with 4 values", () => {
		const result = Parser.parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "cubic-bezier",
				x1: 0.1,
				y1: 0.7,
				x2: 1.0,
				y2: 0.1,
			});
		}
	});

	it("should parse cubic-bezier without spaces", () => {
		const result = Parser.parse("cubic-bezier(0,0,1,1)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: 1,
				y2: 1,
			});
		}
	});

	it("should parse cubic-bezier with negative values", () => {
		const result = Parser.parse("cubic-bezier(0.5, -0.5, 0.5, 1.5)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "cubic-bezier",
				x1: 0.5,
				y1: -0.5,
				x2: 0.5,
				y2: 1.5,
			});
		}
	});

	it("should reject cubic-bezier with wrong number of args", () => {
		const result = Parser.parse("cubic-bezier(0.1, 0.7)");
		expect(result.ok).toBe(false);
	});

	// steps()
	it("should parse steps with count only", () => {
		const result = Parser.parse("steps(4)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "steps",
				steps: 4,
				position: undefined,
			});
		}
	});

	it("should parse steps with start position", () => {
		const result = Parser.parse("steps(4, start)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "steps",
				steps: 4,
				position: "start",
			});
		}
	});

	it("should parse steps with end position", () => {
		const result = Parser.parse("steps(4, end)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "steps",
				steps: 4,
				position: "end",
			});
		}
	});

	it("should reject steps with non-positive integer", () => {
		const result = Parser.parse("steps(0)");
		expect(result.ok).toBe(false);
	});

	it("should reject steps with decimal", () => {
		const result = Parser.parse("steps(4.5)");
		expect(result.ok).toBe(false);
	});

	// linear()
	it("should parse linear with single stop", () => {
		const result = Parser.parse("linear(0)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "linear",
				stops: [{ output: 0 }],
			});
		}
	});

	it("should parse linear with multiple stops", () => {
		const result = Parser.parse("linear(0, 0.5, 1)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "linear",
				stops: [{ output: 0 }, { output: 0.5 }, { output: 1 }],
			});
		}
	});

	it("should parse linear with input percentages", () => {
		const result = Parser.parse("linear(0 0%, 0.5 50%, 1 100%)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions[0]).toEqual({
				type: "linear",
				stops: [
					{ output: 0, input: 0 },
					{ output: 0.5, input: 0.5 },
					{ output: 1, input: 1 },
				],
			});
		}
	});

	// Multiple functions
	it("should parse multiple timing functions", () => {
		const result = Parser.parse("ease, ease-in, linear");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toEqual(["ease", "ease-in", "linear"]);
		}
	});

	it("should parse mixed function types", () => {
		const result = Parser.parse("ease-in, cubic-bezier(0.1, 0.7, 1.0, 0.1), steps(4)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.functions).toHaveLength(3);
			expect(result.value.functions[0]).toBe("ease-in");
			expect(result.value.functions[1]).toEqual({
				type: "cubic-bezier",
				x1: 0.1,
				y1: 0.7,
				x2: 1.0,
				y2: 0.1,
			});
			expect(result.value.functions[2]).toEqual({
				type: "steps",
				steps: 4,
				position: undefined,
			});
		}
	});

	// Error cases
	it("should reject invalid keyword", () => {
		const result = Parser.parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("should reject empty value", () => {
		const result = Parser.parse("");
		expect(result.ok).toBe(false);
	});

	it("should reject trailing comma", () => {
		const result = Parser.parse("ease,");
		expect(result.ok).toBe(false);
	});

	it("should reject leading comma", () => {
		const result = Parser.parse(",ease");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/transition/timing-function.ts ===
// b_path:: src/parse/transition/timing-function.ts
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";
import { EasingFunction } from "@/utils/parse/easing";

/**
 * Parse CSS transition-timing-function property value.
 *
 * Parses comma-separated list of easing functions.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param css - CSS transition-timing-function value (e.g., "ease-in, cubic-bezier(0.1, 0.7, 1.0, 0.1)")
 * @returns Result with TransitionTimingFunction IR or error message
 *
 * @example
 * Keyword:
 * ```typescript
 * const result = parse("ease-in");
 * // { ok: true, value: { kind: "transition-timing-function", functions: ["ease-in"] } }
 * ```
 *
 * @example
 * Cubic bezier:
 * ```typescript
 * const result = parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)");
 * // { ok: true, value: { kind: "transition-timing-function", functions: [{ type: "cubic-bezier", x1: 0.1, ... }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function | MDN: transition-timing-function}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TransitionTimingFunction, string> {
	const functionsResult = parseCommaSeparatedSingle(
		css,
		EasingFunction.parseEasingFunction,
		"transition-timing-function",
	);

	if (!functionsResult.ok) {
		return err(functionsResult.error);
	}

	return ok({
		kind: "transition-timing-function",
		functions: functionsResult.value,
	});
}


=== File: src/parse/transition/transition.ts ===
// b_path:: src/parse/transition/transition.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";
import type * as Type from "@/core/types/transition";

import * as Delay from "./delay";
import * as Duration from "./duration";
import * as Property from "./property";
import * as TimingFunction from "./timing-function";

export type Transition =
	| Type.TransitionDelay
	| Type.TransitionDuration
	| Type.TransitionProperty
	| Type.TransitionTimingFunction;

export function parse(value: string): ParseResult<Transition> {
	const durationResult = Duration.parse(value);
	if (durationResult.ok) return toParseResult(durationResult);

	const delayResult = Delay.parse(value);
	if (delayResult.ok) return toParseResult(delayResult);

	const timingResult = TimingFunction.parse(value);
	if (timingResult.ok) return toParseResult(timingResult);

	const propertyResult = Property.parse(value);
	if (propertyResult.ok) return toParseResult(propertyResult);

	return parseErr("invalid-value", "Invalid transition property value", {
		suggestion: "Expected duration (1s, 500ms), delay, timing-function, or property name",
	});
}


=== File: src/universal-batch.test.ts ===
// b_path:: src/universal-batch.test.ts

/**
 * Tests for parseAll() and generateAll() batch API
 */

import { describe, expect, it } from "vitest";
import { generateAll, parseAll } from "./universal";

describe("parseAll()", () => {
	describe("basic functionality", () => {
		it("should parse single valid property", () => {
			const result = parseAll("color: red");

			expect(result.ok).toBe(true);
			expect(result.value).toEqual({
				color: { kind: "named", name: "red" },
			});
			expect(result.issues).toEqual([]);
		});

		it("should parse multiple valid properties", () => {
			const result = parseAll("color: red; width: 10px");

			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value?.width).toBeDefined();
			expect(result.issues).toEqual([]);
		});

		it("should handle empty input", () => {
			const result = parseAll("");

			expect(result.ok).toBe(true);
			expect(result.value).toEqual({});
			expect(result.issues).toEqual([]);
		});

		it("should ignore empty declarations", () => {
			const result = parseAll("color: red;  ;  ; width: 10px");

			expect(result.ok).toBe(true);
			expect(result.value?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value?.width).toBeDefined();
			expect(result.issues).toEqual([]);
		});
	});

	describe("edge case: duplicates", () => {
		it("should use last value for duplicate properties (CSS standard)", () => {
			const result = parseAll("color: red; color: blue; width: 10px");

			expect(result.ok).toBe(true);
			expect(result.value?.color).toEqual({ kind: "named", name: "blue" }); // Last wins
			expect(result.value?.width).toBeDefined();
		});

		it("should emit warning for duplicate properties", () => {
			const result = parseAll("color: red; color: blue");

			expect(result.ok).toBe(true); // Still ok despite warning
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("warning");
			expect(result.issues[0]?.code).toBe("duplicate-property");
			expect(result.issues[0]?.property).toBe("color");
		});

		it("should count all duplicates in warning", () => {
			const result = parseAll("color: red; color: blue; color: green");

			expect(result.ok).toBe(true);
			expect(result.value?.color).toEqual({ kind: "named", name: "green" }); // Last wins
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.message).toContain("3 times");
		});
	});

	describe("edge case: invalid values", () => {
		it("should return unparsed string for invalid value", () => {
			const result = parseAll("color: not-a-color; width: 10px");

			expect(result.ok).toBe(false); // Error present
			expect(result.value?.color).toBe("not-a-color"); // Unparsed string
			expect(result.value?.width).toBeDefined();
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.code).toBe("invalid-value");
		});

		it("should continue parsing after invalid value", () => {
			const result = parseAll("color: invalid; width: 10px; height: 20px");

			expect(result.ok).toBe(false);
			expect(result.value?.color).toBe("invalid");
			expect(result.value?.width).toBeDefined();
			expect(result.value?.height).toBeDefined();
		});
	});

	describe("edge case: shorthand properties", () => {
		it("should return unparsed string for shorthand property", () => {
			const result = parseAll("color: red; border: 1px solid black");

			expect(result.ok).toBe(false); // Error present
			expect(result.value?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value?.border).toBe("1px solid black"); // Unparsed
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.code).toBe("shorthand-not-supported");
		});

		it("should include b_short promotion message", () => {
			const result = parseAll("border: 1px solid black");

			expect(result.issues[0]?.action).toContain("b_short");
		});
	});

	describe("edge case: unknown properties", () => {
		it("should return unparsed string for unknown property", () => {
			const result = parseAll("color: red; made-up-property: value");

			expect(result.ok).toBe(false);
			expect(result.value?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value?.["made-up-property"]).toBe("value");
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.code).toBe("unknown-property");
		});
	});

	describe("complex scenarios", () => {
		it("should handle mix of valid, invalid, shorthand, and unknown", () => {
			const result = parseAll("color: red; made-up: x; border: 1px solid; width: invalid; height: 10px");

			expect(result.ok).toBe(false);
			expect(result.value?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value?.["made-up"]).toBe("x");
			expect(result.value?.border).toBe("1px solid");
			expect(result.value?.width).toBe("invalid");
			expect(result.value?.height).toBeDefined();
			expect(result.issues.length).toBeGreaterThan(0);
		});
	});
});

describe("generateAll()", () => {
	describe("basic functionality", () => {
		it("should generate CSS from single IR value", () => {
			const css = generateAll({
				color: { kind: "named", name: "red" },
			});

			expect(css).toBe("color: red");
		});

		it("should generate CSS from multiple IR values", () => {
			const css = generateAll({
				color: { kind: "named", name: "red" },
				width: { kind: "width", value: { value: 10, unit: "px" } },
			});

			expect(css).toBe("color: red; width: 10px");
		});

		it("should handle empty input", () => {
			const css = generateAll({});

			expect(css).toBe("");
		});

		it("should handle null values object", () => {
			const css = generateAll(null as unknown as Record<string, string>);

			expect(css).toBe("");
		});
	});

	describe("string passthrough", () => {
		it("should pass through string values as-is", () => {
			const css = generateAll({
				color: "red",
				border: "1px solid blue",
			});

			expect(css).toBe("color: red; border: 1px solid blue");
		});

		it("should handle mix of IR and string values", () => {
			const css = generateAll({
				color: { kind: "hex", value: "#FF0000" },
				border: "1px solid blue",
			});

			expect(css).toBe("color: #FF0000; border: 1px solid blue");
		});
	});

	describe("minify option", () => {
		it("should minify output when minify: true", () => {
			const css = generateAll(
				{
					color: { kind: "named", name: "red" },
					width: { kind: "width", value: { value: 10, unit: "px" } },
				},
				{ minify: true },
			);

			expect(css).toBe("color:red;width:10px");
		});

		it("should not minify by default", () => {
			const css = generateAll({
				color: { kind: "named", name: "red" },
			});

			expect(css).toBe("color: red");
		});

		it("should minify string values too", () => {
			const css = generateAll(
				{
					color: "red",
					border: "1px solid blue",
				},
				{ minify: true },
			);

			expect(css).toBe("color:red;border:1px solid blue");
		});
	});

	describe("edge cases", () => {
		it("should skip undefined values", () => {
			const css = generateAll({
				color: { kind: "named", name: "red" },
				width: undefined as unknown as string,
			});

			expect(css).toBe("color: red");
		});

		it("should skip null values", () => {
			const css = generateAll({
				color: { kind: "named", name: "red" },
				width: null as unknown as string,
			});

			expect(css).toBe("color: red");
		});

		it("should skip properties with invalid generation", () => {
			// If IR is invalid or generation fails, property should be silently skipped
			const css = generateAll({
				color: { kind: "named", name: "red" },
				// Unknown property generator will skip
				"made-up-property": "some-value",
			});

			// Should only have color
			expect(css).toBe("color: red; made-up-property: some-value");
		});
	});

	describe("round-trip", () => {
		it("should round-trip simple values", () => {
			const input = "color: red; width: 10px";
			const parsed = parseAll(input);

			expect(parsed.ok).toBe(true);
			if (!parsed.ok || !parsed.value) return;

			const css = generateAll(parsed.value);

			expect(css).toBe("color: red; width: 10px");
		});

		it("should round-trip after modification", () => {
			const input = "color: red; width: 10px";
			const parsed = parseAll(input);

			expect(parsed.ok).toBe(true);
			if (!parsed.ok || !parsed.value) return;

			// Modify color
			parsed.value.color = { kind: "hex", value: "#00FF00" };

			const css = generateAll(parsed.value);

			expect(css).toBe("color: #00FF00; width: 10px");
		});

		it("should preserve string values in round-trip", () => {
			const input = "color: red; border: 1px solid blue";
			const parsed = parseAll(input);

			// border will be unparsed string (shorthand)
			if (!parsed.value) return;
			const css = generateAll(parsed.value);

			expect(css).toContain("color: red");
			expect(css).toContain("border: 1px solid blue");
		});

		it("should round-trip complex properties", () => {
			const input = "transform: rotate(45deg) scale(2); filter: blur(5px)";
			const parsed = parseAll(input);

			expect(parsed.ok).toBe(true);
			if (!parsed.ok || !parsed.value) return;

			const css = generateAll(parsed.value);

			expect(css).toContain("transform:");
			expect(css).toContain("rotate(45deg)");
			expect(css).toContain("scale("); // scale() may add implicit second param
			expect(css).toContain("filter:");
			expect(css).toContain("blur(5px)");
		});
	});

	describe("property ordering", () => {
		it("should preserve property order from object iteration", () => {
			const css = generateAll({
				color: { kind: "named", name: "red" },
				width: { kind: "width", value: { value: 10, unit: "px" } },
				height: { kind: "height", value: { value: 20, unit: "px" } },
			});

			// Note: Object iteration order is insertion order in modern JS
			expect(css).toBe("color: red; width: 10px; height: 20px");
		});
	});
});


=== File: src/universal.test.ts ===
// b_path:: src/universal.test.ts

import { describe, expect, it } from "vitest";
import { generate, parse } from "./universal";

describe("parse() - Universal CSS longhand property parser", () => {
	describe("Color properties", () => {
		it("should parse color property", () => {
			const result = parse("color: red");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("color");
			if (result.ok) {
				expect(result.value).toEqual({ kind: "named", name: "red" });
			}
		});

		it("should parse background-color property", () => {
			const result = parse("background-color: #ff0000");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("background-color");
		});

		it("should parse text-decoration-color property", () => {
			const result = parse("text-decoration-color: rgb(255, 0, 0)");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("text-decoration-color");
		});
	});

	describe("Layout properties", () => {
		it("should parse top property", () => {
			const result = parse("top: 10px");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("top");
		});

		it("should parse width property", () => {
			const result = parse("width: 100%");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("width");
		});

		it("should parse display property", () => {
			const result = parse("display: flex");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("display");
		});

		it("should parse position property", () => {
			const result = parse("position: absolute");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("position");
		});
	});

	describe("Text decoration properties", () => {
		it("should parse text-decoration-line property", () => {
			const result = parse("text-decoration-line: underline");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("text-decoration-line");
		});

		it("should parse text-decoration-style property", () => {
			const result = parse("text-decoration-style: wavy");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("text-decoration-style");
		});

		it("should parse text-decoration-thickness property", () => {
			const result = parse("text-decoration-thickness: 2px");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("text-decoration-thickness");
		});
	});

	describe("Background properties", () => {
		it("should parse background-size property", () => {
			const result = parse("background-size: cover");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("background-size");
		});

		it("should parse background-repeat property", () => {
			const result = parse("background-repeat: repeat-x");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("background-repeat");
		});

		it("should parse background-position property", () => {
			const result = parse("background-position: center top");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("background-position");
		});
	});

	describe("Border properties", () => {
		it("should parse border-top-width property", () => {
			const result = parse("border-top-width: 1px");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("border-top-width");
		});

		it("should parse border-top-style property", () => {
			const result = parse("border-top-style: solid");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("border-top-style");
		});

		it("should parse border-top-color property", () => {
			const result = parse("border-top-color: red");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("border-top-color");
		});

		it("should parse border-radius property", () => {
			const result = parse("border-radius: 5px");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("border-radius");
		});
	});

	describe("Complex properties", () => {
		it("should parse transform property", () => {
			const result = parse("transform: rotate(45deg)");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("transform");
		});

		it("should parse filter property", () => {
			const result = parse("filter: blur(5px)");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("filter");
		});

		it("should parse clip-path property", () => {
			const result = parse("clip-path: circle(50%)");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("clip-path");
		});
	});

	describe("Declaration syntax", () => {
		it("should handle trailing semicolon", () => {
			const result = parse("color: red;");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("color");
		});

		it("should handle extra whitespace", () => {
			const result = parse("  color  :  red  ");
			expect(result.ok).toBe(true);
			expect(result.property).toBe("color");
		});

		it("should reject invalid syntax", () => {
			const result = parse("not a declaration");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Invalid CSS declaration syntax");
			}
		});

		it("should reject empty string", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});

	describe("Shorthand rejection", () => {
		it("should reject background shorthand", () => {
			const result = parse("background: red url(image.png) repeat-x");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
				expect(result.issues[0]?.action).toContain("b_short");
				expect(result.property).toBe("background");
			}
		});

		it("should reject border shorthand", () => {
			const result = parse("border: 1px solid red");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
				expect(result.property).toBe("border");
			}
		});

		it("should reject border-color shorthand", () => {
			const result = parse("border-color: red blue");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
			}
		});

		it("should reject border-style shorthand", () => {
			const result = parse("border-style: solid dashed");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
			}
		});

		it("should reject border-width shorthand", () => {
			const result = parse("border-width: 1px 2px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
			}
		});

		it("should reject text-decoration shorthand", () => {
			const result = parse("text-decoration: underline wavy red");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
				expect(result.property).toBe("text-decoration");
			}
		});

		it("should reject margin shorthand", () => {
			const result = parse("margin: 10px 20px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
			}
		});

		it("should reject padding shorthand", () => {
			const result = parse("padding: 10px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
			}
		});

		it("should reject animation shorthand", () => {
			const result = parse("animation: spin 1s linear infinite");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
			}
		});

		it("should reject transition shorthand", () => {
			const result = parse("transition: all 0.3s ease");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
			}
		});
	});

	describe("Unknown properties", () => {
		it("should reject unknown property", () => {
			const result = parse("not-a-real-property: value");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown or unsupported");
				expect(result.property).toBe("not-a-real-property");
			}
		});

		it("should reject typo in property name", () => {
			const result = parse("colr: red");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown or unsupported");
			}
		});
	});
});

describe("generate() - Universal CSS value generator", () => {
	describe("Color properties", () => {
		it("should generate color property", () => {
			const result = generate({
				property: "color",
				value: { kind: "hex", value: "#ff0000" },
			});
			expect(result.ok).toBe(true);
			expect(result.property).toBe("color");
			if (result.ok) {
				expect(result.value).toBe("#ff0000");
			}
		});

		it("should generate background-color property", () => {
			const result = generate({
				property: "background-color",
				value: { kind: "named", name: "red" },
			});
			expect(result.ok).toBe(true);
			expect(result.property).toBe("background-color");
		});
	});

	describe("Transform property", () => {
		it("should generate transform property", () => {
			const result = generate({
				property: "transform",
				value: [{ kind: "rotate", angle: { value: 45, unit: "deg" } }],
			});
			expect(result.ok).toBe(true);
			expect(result.property).toBe("transform");
			if (result.ok) {
				expect(result.value).toBe("rotate(45deg)");
			}
		});
	});

	describe("Shorthand rejection", () => {
		it("should reject background shorthand", () => {
			const result = generate({
				property: "background",
				value: {},
			});
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
				expect(result.property).toBe("background");
			}
		});

		it("should reject border shorthand", () => {
			const result = generate({
				property: "border",
				value: {},
			});
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("shorthand");
			}
		});
	});

	describe("Unknown properties", () => {
		it("should reject unknown property", () => {
			const result = generate({
				property: "not-a-real-property",
				value: {},
			});
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown or unsupported");
			}
		});
	});
});


=== File: src/universal.ts ===
// b_path:: src/universal.ts

/**
 * Universal API for parsing and generating ANY CSS longhand property.
 *
 * This is the main public API for b_value. Users parse declarations like
 * "color: red" and generate CSS from IR with property names.
 *
 * @module
 */

import {
	type CSSPropertyName,
	type GenerateResult,
	generateErr,
	Issues,
	type ParseResult,
	parseErr,
	parseOk,
	toParseResult,
} from "./core/result";
// Import module generators
import * as AnimationGenerate from "./generate/animation/animation";
import * as BorderGenerate from "./generate/border/border";
import * as ClipPathGenerate from "./generate/clip-path/clip-path";
import * as ColorGenerate from "./generate/color/color";
import * as FilterGenerate from "./generate/filter/filter";
import * as GradientGenerate from "./generate/gradient/gradient";
import * as LayoutGenerate from "./generate/layout";
import * as OutlineGenerate from "./generate/outline/outline";
import * as PositionGenerate from "./generate/position/position";
import * as ShadowGenerate from "./generate/shadow/shadow";
import * as TransformGenerate from "./generate/transform/transform";
import * as TransitionGenerate from "./generate/transition/transition";
// Import module parsers
import * as AnimationParse from "./parse/animation/animation";
// Import individual property parsers
import * as BackgroundAttachment from "./parse/background/attachment";
import * as BackgroundClip from "./parse/background/clip";
import * as BackgroundOrigin from "./parse/background/origin";
import * as BackgroundRepeat from "./parse/background/repeat";
import * as BackgroundSize from "./parse/background/size";
import * as BorderRadius from "./parse/border/radius";
import * as BorderStyle from "./parse/border/style";
import * as BorderWidth from "./parse/border/width";
import * as ClipPathParse from "./parse/clip-path/clip-path";
import * as ColorParse from "./parse/color/color";
import * as FilterParse from "./parse/filter/filter";
import * as GradientParse from "./parse/gradient/gradient";
import * as LayoutBottom from "./parse/layout/bottom";
import * as LayoutCursor from "./parse/layout/cursor";
import * as LayoutDisplay from "./parse/layout/display";
import * as LayoutHeight from "./parse/layout/height";
import * as LayoutLeft from "./parse/layout/left";
import * as LayoutOpacity from "./parse/layout/opacity";
import * as LayoutOverflowX from "./parse/layout/overflow-x";
import * as LayoutOverflowY from "./parse/layout/overflow-y";
import * as LayoutPosition from "./parse/layout/position";
import * as LayoutRight from "./parse/layout/right";
import * as LayoutTop from "./parse/layout/top";
import * as LayoutVisibility from "./parse/layout/visibility";
import * as LayoutWidth from "./parse/layout/width";
import * as LayoutZIndex from "./parse/layout/z-index";
import * as OutlineOffset from "./parse/outline/offset";
import * as OutlineStyle from "./parse/outline/style";
import * as OutlineWidth from "./parse/outline/width";
import * as PositionParse from "./parse/position/position";
import * as ShadowParse from "./parse/shadow/shadow";
import * as TextColor from "./parse/text/color";
import * as TextLine from "./parse/text/line";
import * as TextStyle from "./parse/text/style";
import * as TextThickness from "./parse/text/thickness";
import * as TransformParse from "./parse/transform/transform";
import * as TransitionParse from "./parse/transition/transition";

// ============================================================================
// Property Registry
// ============================================================================

type PropertyParser = (value: string) => ParseResult;
// biome-ignore lint/suspicious/noExplicitAny: Generators accept different IR types
type PropertyGenerator = (value: any) => GenerateResult;

/**
 * Wrap old Result<T, string> parsers to return ParseResult<T>.
 * @internal
 */
// biome-ignore lint/suspicious/noExplicitAny: Wrapper handles multiple parser return types
function wrapParser(parser: (value: string) => any): PropertyParser {
	return (value: string) => {
		const result = parser(value);
		// Already ParseResult
		if ("issues" in result) {
			return result;
		}
		// Old Result<T, string> - convert
		// biome-ignore lint/suspicious/noExplicitAny: Type conversion between Result formats
		return toParseResult(result as any);
	};
}

/**
 * Wrap old toCss generators to return GenerateResult.
 * @internal
 */
// biome-ignore lint/suspicious/noExplicitAny: Wrapper handles different IR types
function wrapGenerator(generator: (value: any) => string): PropertyGenerator {
	// biome-ignore lint/suspicious/noExplicitAny: Generator accepts any IR type
	return (value: any) => {
		try {
			const css = generator(value);
			return { ok: true, value: css, issues: [] };
		} catch (error) {
			return generateErr("invalid-ir", error instanceof Error ? error.message : "Generation failed");
		}
	};
}

/**
 * Registry mapping CSS property names to their parsers.
 * @internal
 */
const PROPERTY_PARSERS: Record<string, PropertyParser> = {
	// Color properties
	color: ColorParse.parse,
	"background-color": ColorParse.parse,
	"border-top-color": ColorParse.parse,
	"border-right-color": ColorParse.parse,
	"border-bottom-color": ColorParse.parse,
	"border-left-color": ColorParse.parse,
	"outline-color": ColorParse.parse,
	"text-decoration-color": wrapParser(TextColor.parse),

	// Background properties
	"background-attachment": wrapParser(BackgroundAttachment.parse),
	"background-clip": wrapParser(BackgroundClip.parse),
	"background-origin": wrapParser(BackgroundOrigin.parse),
	"background-repeat": wrapParser(BackgroundRepeat.parse),
	"background-size": wrapParser(BackgroundSize.parse),
	"background-position": PositionParse.parse,
	"background-image": GradientParse.parse, // gradient or image URL

	// Border properties (individual sides only - full sides are shorthands)
	"border-top-style": wrapParser(BorderStyle.parse),
	"border-right-style": wrapParser(BorderStyle.parse),
	"border-bottom-style": wrapParser(BorderStyle.parse),
	"border-left-style": wrapParser(BorderStyle.parse),
	"border-top-width": wrapParser(BorderWidth.parse),
	"border-right-width": wrapParser(BorderWidth.parse),
	"border-bottom-width": wrapParser(BorderWidth.parse),
	"border-left-width": wrapParser(BorderWidth.parse),
	"border-radius": wrapParser(BorderRadius.parse),
	"border-top-left-radius": wrapParser(BorderRadius.parse),
	"border-top-right-radius": wrapParser(BorderRadius.parse),
	"border-bottom-right-radius": wrapParser(BorderRadius.parse),
	"border-bottom-left-radius": wrapParser(BorderRadius.parse),

	// Layout properties
	top: wrapParser(LayoutTop.parse),
	right: wrapParser(LayoutRight.parse),
	bottom: wrapParser(LayoutBottom.parse),
	left: wrapParser(LayoutLeft.parse),
	width: wrapParser(LayoutWidth.parse),
	height: wrapParser(LayoutHeight.parse),
	position: wrapParser(LayoutPosition.parse),
	display: wrapParser(LayoutDisplay.parse),
	opacity: wrapParser(LayoutOpacity.parse),
	visibility: wrapParser(LayoutVisibility.parse),
	"z-index": wrapParser(LayoutZIndex.parse),
	cursor: wrapParser(LayoutCursor.parse),
	"overflow-x": wrapParser(LayoutOverflowX.parse),
	"overflow-y": wrapParser(LayoutOverflowY.parse),

	// Outline properties
	"outline-style": wrapParser(OutlineStyle.parse),
	"outline-width": wrapParser(OutlineWidth.parse),
	"outline-offset": wrapParser(OutlineOffset.parse),

	// Text decoration properties
	"text-decoration-line": wrapParser(TextLine.parse),
	"text-decoration-style": wrapParser(TextStyle.parse),
	"text-decoration-thickness": wrapParser(TextThickness.parse),

	// Complex properties
	"clip-path": ClipPathParse.parse,
	filter: FilterParse.parse,
	transform: TransformParse.parse,
	"box-shadow": ShadowParse.parse,
	"text-shadow": ShadowParse.parse,

	// Animation/Transition properties (module level)
	"animation-name": AnimationParse.parse,
	"animation-duration": AnimationParse.parse,
	"animation-timing-function": AnimationParse.parse,
	"animation-delay": AnimationParse.parse,
	"animation-iteration-count": AnimationParse.parse,
	"animation-direction": AnimationParse.parse,
	"animation-fill-mode": AnimationParse.parse,
	"animation-play-state": AnimationParse.parse,

	"transition-property": TransitionParse.parse,
	"transition-duration": TransitionParse.parse,
	"transition-timing-function": TransitionParse.parse,
	"transition-delay": TransitionParse.parse,
};

/**
 * Registry mapping CSS property names to their generators.
 * @internal
 */
const PROPERTY_GENERATORS: Record<string, PropertyGenerator> = {
	// Color properties
	color: ColorGenerate.generate,
	"background-color": ColorGenerate.generate,
	"border-color": BorderGenerate.generate,
	"border-top-color": BorderGenerate.generate,
	"border-right-color": BorderGenerate.generate,
	"border-bottom-color": BorderGenerate.generate,
	"border-left-color": BorderGenerate.generate,
	"outline-color": OutlineGenerate.generate,

	// Background properties
	"background-position": PositionGenerate.generate,
	"background-image": GradientGenerate.generate,

	// Border properties
	"border-radius": BorderGenerate.generate,

	// Layout properties
	top: wrapGenerator(LayoutGenerate.Top.toCss),
	right: wrapGenerator(LayoutGenerate.Right.toCss),
	bottom: wrapGenerator(LayoutGenerate.Bottom.toCss),
	left: wrapGenerator(LayoutGenerate.Left.toCss),
	width: wrapGenerator(LayoutGenerate.Width.toCss),
	height: wrapGenerator(LayoutGenerate.Height.toCss),
	position: wrapGenerator(LayoutGenerate.Position.toCss),
	display: wrapGenerator(LayoutGenerate.Display.toCss),
	opacity: wrapGenerator(LayoutGenerate.Opacity.toCss),
	visibility: wrapGenerator(LayoutGenerate.Visibility.toCss),
	"z-index": wrapGenerator(LayoutGenerate.ZIndex.toCss),
	cursor: wrapGenerator(LayoutGenerate.Cursor.toCss),
	"overflow-x": wrapGenerator(LayoutGenerate.OverflowX.toCss),
	"overflow-y": wrapGenerator(LayoutGenerate.OverflowY.toCss),

	// Outline properties
	"outline-style": OutlineGenerate.generate,
	"outline-width": OutlineGenerate.generate,

	// Complex properties
	"clip-path": ClipPathGenerate.generate,
	filter: FilterGenerate.generate,
	transform: TransformGenerate.generate,
	"box-shadow": ShadowGenerate.generate,
	"text-shadow": ShadowGenerate.generate,

	// Animation/Transition
	"animation-name": AnimationGenerate.generate,
	"transition-property": TransitionGenerate.generate,
};

/**
 * List of CSS shorthand properties that b_value rejects.
 * Use b_short library to expand shorthands first.
 *
 * @internal
 */
const SHORTHAND_PROPERTIES = [
	"animation",
	"background",
	"border",
	"border-color", // Can specify 1-4 colors
	"border-style", // Can specify 1-4 styles
	"border-width", // Can specify 1-4 widths
	"border-top",
	"border-right",
	"border-bottom",
	"border-left",
	"border-block",
	"border-block-start",
	"border-block-end",
	"border-inline",
	"border-inline-start",
	"border-inline-end",
	"border-color",
	"border-style",
	"border-width",
	"border-image",
	"column-rule",
	"columns",
	"flex",
	"flex-flow",
	"font",
	"gap",
	"grid",
	"grid-area",
	"grid-column",
	"grid-row",
	"grid-template",
	"list-style",
	"margin",
	"mask",
	"offset",
	"outline",
	"overflow",
	"padding",
	"place-content",
	"place-items",
	"place-self",
	"scroll-margin",
	"scroll-padding",
	"text-decoration",
	"text-emphasis",
	"transition",
];

/**
 * Check if a property is a shorthand.
 * @internal
 */
function isShorthand(property: string): boolean {
	return SHORTHAND_PROPERTIES.includes(property);
}

/**
 * Parse CSS declaration syntax "property: value".
 * @internal
 */
function parseDeclaration(declaration: string): { property: string; value: string } | null {
	// Handle "property: value" with optional semicolon
	const match = declaration.match(/^\s*([a-z-]+)\s*:\s*(.+?)\s*;?\s*$/i);
	if (!match) return null;

	return {
		// biome-ignore lint/style/noNonNullAssertion: Already checked match exists
		property: match[1]!.toLowerCase().trim(),
		// biome-ignore lint/style/noNonNullAssertion: Already checked match exists
		value: match[2]!.trim(),
	};
}

// ============================================================================
// Universal API
// ============================================================================

/**
 * Parse ANY CSS longhand property declaration.
 *
 * Takes a CSS declaration like "color: red" and returns ParseResult with
 * the property name and parsed IR value.
 *
 * @param declaration - CSS property declaration ("property: value")
 * @returns ParseResult with property name and IR value
 *
 * @example
 * ```typescript
 * const result = parse("color: red");
 * if (result.ok) {
 *   console.log(result.property); // "color"
 *   console.log(result.value);    // { kind: "named", name: "red" }
 * }
 * ```
 *
 * @example
 * Shorthand rejection:
 * ```typescript
 * const result = parse("border: 1px solid red");
 * if (!result.ok) {
 *   console.log(result.issues[0].message);
 *   // "border is a shorthand property"
 *   console.log(result.issues[0].action);
 *   // "Use b_short to expand shorthands first"
 * }
 * ```
 *
 * @public
 */
export function parse(declaration: string): ParseResult {
	// Step 1: Parse declaration syntax
	const parsed = parseDeclaration(declaration);
	if (!parsed) {
		return parseErr("invalid-syntax", "Invalid CSS declaration syntax", {
			suggestion: "Expected format: 'property: value' or 'property: value;'",
		});
	}

	const { property, value } = parsed;

	// Step 2: Check if shorthand
	if (isShorthand(property)) {
		return parseErr("shorthand-not-supported", `"${property}" is a shorthand property`, {
			suggestion: `Use individual longhand properties instead`,
			action: "Use b_short library to expand shorthands first",
			property: property as CSSPropertyName,
		});
	}

	// Step 3: Find parser
	const parser = PROPERTY_PARSERS[property];
	if (!parser) {
		return parseErr("unknown-property", `Unknown or unsupported property: "${property}"`, {
			suggestion: "Check property name spelling or check if b_value supports this property yet",
			property: property as CSSPropertyName,
		});
	}

	// Step 4: Parse value
	const result = parser(value);

	// Step 5: Add property name to result
	return {
		...result,
		property,
	};
}

/**
 * Generate CSS value from IR for ANY longhand property.
 *
 * Takes a property name and IR value, generates the CSS string.
 *
 * @param options - Property name and IR value
 * @returns GenerateResult with CSS string
 *
 * @example
 * ```typescript
 * const result = generate({
 *   property: "color",
 *   value: { kind: "hex", r: 255, g: 0, b: 0 }
 * });
 * if (result.ok) {
 *   console.log(result.value); // "#ff0000"
 * }
 * ```
 *
 * @example
 * Shorthand rejection:
 * ```typescript
 * const result = generate({
 *   property: "border",
 *   value: { /* ... *\/ }
 * });
 * if (!result.ok) {
 *   console.log(result.issues[0].message);
 *   // "border is a shorthand property"
 * }
 * ```
 *
 * @public
 */
export function generate(options: { property: string; value: unknown }): GenerateResult {
	const { property, value } = options;

	// Step 1: Check if shorthand
	if (isShorthand(property)) {
		return generateErr("shorthand-not-supported", `"${property}" is a shorthand property`, {
			action: "Use b_short library for shorthand generation",
			property: property as CSSPropertyName,
		});
	}

	// Step 2: Find generator
	const generator = PROPERTY_GENERATORS[property];
	if (!generator) {
		return generateErr("unknown-property", `Unknown or unsupported property: "${property}"`, {
			suggestion: "Check property name spelling or check if b_value supports this property yet",
			property: property as CSSPropertyName,
		});
	}

	// Step 3: Generate value
	const result = generator(value);

	// Step 4: Add property name to result
	return {
		...result,
		property,
	};
}

//
// ===== BATCH API: parseAll() and generateAll() =====
//

import type { CSSValue } from "./core/types/css-value";

/**
 * Parse multiple CSS declarations from a style block.
 *
 * Returns a single ParseResult with all properties as a flat object.
 * Perfect for CSS editors - one ok flag, one issues array, easy property access.
 *
 * **Edge Cases**:
 * - Duplicate properties: Last value wins (CSS standard), warning emitted
 * - Invalid values: Returned as unparsed string, error emitted
 * - Shorthand properties: Returned as unparsed string, error emitted (use b_short)
 * - Unknown properties: Returned as unparsed string, error emitted
 * - Empty declarations: Silently ignored
 *
 * @param css - CSS declarations (e.g., "color: red; width: 10px")
 * @returns ParseResult with flat object of parsed values
 *
 * @example
 * ```typescript
 * const result = parseAll("color: red; width: 10px");
 * if (result.ok) {
 *   console.log(result.value.color);  // { kind: "named", name: "red" }
 *   console.log(result.value.width);  // { kind: "length", value: 10, unit: "px" }
 * }
 * ```
 *
 * @example
 * Handle invalid values:
 * ```typescript
 * const result = parseAll("color: invalid; width: 10px");
 * // result.ok === false
 * // result.value.color === "invalid" (unparsed string)
 * // result.issues contains error details
 * ```
 *
 * @public
 */
export function parseAll(css: string): ParseResult<Record<string, CSSValue | string>> {
	// Handle empty input
	if (!css || css.trim().length === 0) {
		return parseOk({});
	}

	// Step 1: Split declarations by semicolon
	const declarations = splitDeclarations(css);

	// Step 2: Detect duplicates
	const duplicates = detectDuplicates(declarations);

	// Step 3: Parse each declaration
	const results: Array<{
		property: string;
		value: string;
		result: ParseResult<unknown>;
	}> = [];

	for (const decl of declarations) {
		const parseResult = parse(`${decl.property}: ${decl.value}`);
		results.push({
			property: decl.property,
			value: decl.value,
			result: parseResult,
		});
	}

	// Step 4: Merge results into single ParseResult
	return mergeResults(results, duplicates);
}

/**
 * Split CSS string into individual declarations.
 * Handles empty declarations gracefully.
 *
 * @internal
 */
function splitDeclarations(css: string): Array<{ property: string; value: string }> {
	return css
		.split(";")
		.map((decl) => decl.trim())
		.filter((decl) => decl.length > 0 && decl.includes(":")) // Skip empty and invalid
		.map((decl) => {
			const colonIdx = decl.indexOf(":");
			return {
				property: decl.slice(0, colonIdx).trim(),
				value: decl.slice(colonIdx + 1).trim(),
			};
		})
		.filter((decl) => decl.property.length > 0 && decl.value.length > 0);
}

/**
 * Detect duplicate property declarations.
 *
 * @internal
 */
function detectDuplicates(declarations: Array<{ property: string; value: string }>): Map<string, number> {
	const counts = new Map<string, number>();
	for (const decl of declarations) {
		counts.set(decl.property, (counts.get(decl.property) || 0) + 1);
	}
	return counts;
}

/**
 * Merge individual parse results into single ParseResult.
 *
 * @internal
 */
function mergeResults(
	results: Array<{
		property: string;
		value: string;
		result: ParseResult<unknown>;
	}>,
	duplicates: Map<string, number>,
): ParseResult<Record<string, CSSValue | string>> {
	const value: Record<string, CSSValue | string> = {};
	const issues: Array<import("./core/result").Issue> = [];
	let allOk = true;

	// Track which properties we've seen to handle duplicates
	const seen = new Map<string, number>();

	for (const { property, value: inputValue, result } of results) {
		// Track this property
		const count = (seen.get(property) || 0) + 1;
		seen.set(property, count);

		// Add duplicate warning on last occurrence
		const duplicateCount = duplicates.get(property);
		if (duplicateCount && duplicateCount > 1 && count === duplicateCount) {
			issues.push(Issues.duplicateProperty(property as import("./core/result").CSSLonghandProperty, duplicateCount));
		}

		// Handle parse result
		if (result.ok) {
			// Successfully parsed - use IR value
			value[property] = result.value as CSSValue;
		} else {
			// Failed to parse - use unparsed string
			value[property] = inputValue;
			allOk = false;
		}

		// Collect issues
		issues.push(...result.issues);
	}

	return {
		ok: allOk,
		value,
		issues,
	};
}

/**
 * Generate CSS declarations from a flat object of properties.
 *
 * Takes the same shape returned by parseAll() - a flat object with property names
 * as keys and IR values or unparsed strings as values. Returns formatted CSS string.
 *
 * **Features**:
 * - IR values: Automatically calls generate() for each property
 * - String values: Pass through as-is (already valid CSS)
 * - Minify option: Control spacing and formatting
 * - Perfect round-trip: parseAll() → modify → generateAll()
 *
 * @param values - Flat object of property names to values (IR or strings)
 * @param options - Optional generation options
 * @returns CSS declaration string (e.g., "color: red; width: 10px")
 *
 * @example
 * Basic usage:
 * ```typescript
 * const css = generateAll({
 *   color: { kind: "hex", r: 255, g: 0, b: 0 },
 *   width: { kind: "length", value: 10, unit: "px" }
 * });
 * // Returns: "color: #ff0000; width: 10px"
 * ```
 *
 * @example
 * Mix IR and string values:
 * ```typescript
 * const css = generateAll({
 *   color: { kind: "hex", r: 255, g: 0, b: 0 },
 *   border: "1px solid blue"  // String passthrough
 * });
 * // Returns: "color: #ff0000; border: 1px solid blue"
 * ```
 *
 * @example
 * Minified output:
 * ```typescript
 * const css = generateAll(
 *   { color: { kind: "named", name: "red" } },
 *   { minify: true }
 * );
 * // Returns: "color:red"
 * ```
 *
 * @example
 * Round-trip:
 * ```typescript
 * const parsed = parseAll("color: red; width: 10px");
 * if (parsed.ok) {
 *   // Modify values
 *   parsed.value.color = { kind: "hex", r: 0, g: 255, b: 0 };
 *
 *   // Generate back to CSS
 *   const css = generateAll(parsed.value);
 *   // Returns: "color: #00ff00; width: 10px"
 * }
 * ```
 *
 * @public
 */
export function generateAll(values: Record<string, CSSValue | string>, options?: { minify?: boolean }): string {
	// Handle empty input
	if (!values || Object.keys(values).length === 0) {
		return "";
	}

	const declarations: string[] = [];

	// Process each property
	for (const [property, value] of Object.entries(values)) {
		// Skip undefined/null values
		if (value === undefined || value === null) {
			continue;
		}

		// String passthrough - already valid CSS
		if (typeof value === "string") {
			const formatted = options?.minify ? `${property}:${value}` : `${property}: ${value}`;
			declarations.push(formatted);
			continue;
		}

		// IR value - generate CSS
		const result = generate({ property, value });
		if (result.ok) {
			const formatted = options?.minify ? `${property}:${result.value}` : `${property}: ${result.value}`;
			declarations.push(formatted);
		}
		// Silently skip failed generation (shouldn't happen with valid IR)
	}

	// Join declarations
	const separator = options?.minify ? ";" : "; ";
	return declarations.join(separator);
}


=== File: src/utils/ast/functions.ts ===
// b_path:: src/utils/ast/functions.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";

/**
 * Find a function node by name in a CSS AST.
 *
 * Walks the AST to find the first function node with the specified name.
 * Function name matching is case-insensitive to match CSS spec behavior.
 * Commonly used pattern across all parsers.
 *
 * @param ast - CSS AST to search
 * @param functionNames - Function name(s) to search for (case-insensitive)
 * @returns Result containing FunctionNode or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { findFunctionNode } from "@/utils/ast/functions";
 *
 * const result = findFunctionNode(ast, ["linear-gradient", "repeating-linear-gradient"]);
 * if (result.ok) {
 *   console.log(result.value.name); // "linear-gradient"
 * }
 * ```
 */
export function findFunctionNode(
	ast: csstree.CssNode,
	functionNames: string | string[],
): Result<csstree.FunctionNode, string> {
	const names = Array.isArray(functionNames) ? functionNames : [functionNames];
	const lowerNames = names.map((name) => name.toLowerCase());
	let foundNode: csstree.FunctionNode | null = null;

	try {
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (lowerNames.includes(node.name.toLowerCase())) {
					foundNode = node;
					// Stop traversal once found
					return false;
				}
			},
		});

		if (!foundNode) {
			return err(`No function found with name(s): ${names.join(", ")}`);
		}

		return ok(foundNode);
	} catch (e) {
		return err(`Failed to search AST: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Parse comma-separated values from a CSS AST.
 *
 * Handles the common pattern of parsing comma-separated arguments
 * in CSS functions like gradients, transforms, etc.
 *
 * @param ast - CSS AST to parse
 * @returns Array of CSS node arrays, split by commas
 *
 * @public
 *
 * @example
 * ```typescript
 * import { parseCommaSeparatedValues } from "@/utils/ast/functions";
 *
 * const groups = parseCommaSeparatedValues(ast);
 * console.log(groups.length); // Number of comma-separated groups
 * console.log(groups[0]); // First group of nodes
 * ```
 */
export function parseCommaSeparatedValues(ast: csstree.CssNode): csstree.CssNode[][] {
	const groups: csstree.CssNode[][] = [[]];

	csstree.walk(ast, {
		enter(node: csstree.CssNode) {
			if (node.type === "Operator" && "value" in node && node.value === ",") {
				// Start new group
				groups.push([]);
			} else if (node.type !== "Value") {
				// Add to current group (skip Value wrapper node)
				const currentGroup = groups[groups.length - 1];
				if (currentGroup) {
					currentGroup.push(node);
				}
			}
		},
	});

	return groups;
}

/**
 * Parse function arguments from a function node.
 *
 * Extracts the arguments from a CSS function, filtering out operators.
 * Commonly used pattern in all function parsers.
 *
 * @param fn - CSS Function AST node
 * @returns Array of CSS nodes representing function arguments
 *
 * @public
 *
 * @example
 * ```typescript
 * import { parseFunctionArguments } from "@/utils/ast/functions";
 *
 * const args = parseFunctionArguments(functionNode);
 * console.log(args.length); // Number of arguments
 * console.log(args[0].type); // Type of first argument
 * ```
 */
export function parseFunctionArguments(fn: csstree.FunctionNode): csstree.CssNode[] {
	return fn.children.toArray().filter((node) => node.type !== "Operator");
}

/**
 * Parse CSS string into AST with error handling.
 *
 * Common pattern for parsing CSS strings with proper error handling.
 *
 * @param css - CSS string to parse
 * @param context - CSS parsing context ("value", "declaration", etc.)
 * @returns Result containing CSS AST or error message
 *
 * @public
 */
export function parseCssString(
	css: string,
	context: "value" | "declaration" = "value",
): Result<csstree.CssNode, string> {
	try {
		const ast = csstree.parse(css, { context });
		return ok(ast);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/utils/ast/index.ts ===
// b_path:: src/utils/ast/index.ts

export * from "./functions";
export * from "./split-by-comma";


=== File: src/utils/ast/split-by-comma.test.ts ===
// b_path:: src/utils/ast/split-by-comma.test.ts
import * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { isCommaAt, skipComma, splitNodesByComma } from "./split-by-comma";

describe("splitNodesByComma", () => {
	it("splits simple comma-separated values", () => {
		const ast = csstree.parse("red, blue, green", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(1);
		expect(groups[2]).toHaveLength(1);
	});

	it("handles multi-node groups", () => {
		const ast = csstree.parse("red, blue 50%, green", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(2);
		expect(groups[2]).toHaveLength(1);
	});

	it("handles single value (no commas)", () => {
		const ast = csstree.parse("red", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(1);
		expect(groups[0]).toHaveLength(1);
	});

	it("handles empty input", () => {
		const groups = splitNodesByComma([]);

		expect(groups).toHaveLength(0);
	});

	it("handles startIndex option", () => {
		const ast = csstree.parse("45deg, red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		// Find the comma after 45deg
		const firstCommaIdx = nodes.findIndex((n) => n.type === "Operator" && "value" in n && n.value === ",");

		// Start after first comma
		const groups = splitNodesByComma(nodes, {
			startIndex: firstCommaIdx + 1,
		});

		expect(groups).toHaveLength(2);
	});

	it("rejects empty groups by default", () => {
		const ast = csstree.parse("red,, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(2);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(1);
	});

	it("allows empty groups when requested", () => {
		const ast = csstree.parse("red,, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes, { allowEmpty: true });

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(0);
		expect(groups[2]).toHaveLength(1);
	});

	it("handles trailing comma (creates empty group if allowEmpty)", () => {
		const ast = csstree.parse("red, blue,", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const withoutEmpty = splitNodesByComma(nodes);
		expect(withoutEmpty).toHaveLength(2);

		const withEmpty = splitNodesByComma(nodes, { allowEmpty: true });
		expect(withEmpty).toHaveLength(3);
		expect(withEmpty[2]).toHaveLength(0);
	});

	it("handles whitespace nodes by default", () => {
		const ast = csstree.parse("red  ,  blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(2);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(1);
	});

	it("handles complex multi-value groups", () => {
		const ast = csstree.parse("1px 2px 3px, 4px 5px, 6px", {
			context: "value",
		});
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(3);
		expect(groups[1]).toHaveLength(2);
		expect(groups[2]).toHaveLength(1);
	});

	it("handles percentage and length mixed", () => {
		const ast = csstree.parse("50% 0%, 100% 50%, 0% 100%", {
			context: "value",
		});
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(2);
		expect(groups[1]).toHaveLength(2);
		expect(groups[2]).toHaveLength(2);
	});
});

describe("isCommaAt", () => {
	it("returns true for comma at index", () => {
		const ast = csstree.parse("red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const commaIndex = nodes.findIndex((n) => n.type === "Operator" && "value" in n && n.value === ",");

		expect(isCommaAt(nodes, commaIndex)).toBe(true);
	});

	it("returns false for non-comma node", () => {
		const ast = csstree.parse("red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(isCommaAt(nodes, 0)).toBe(false);
	});

	it("returns false for out of bounds index", () => {
		const ast = csstree.parse("red", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(isCommaAt(nodes, 999)).toBe(false);
	});

	it("returns false for negative index", () => {
		const ast = csstree.parse("red", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(isCommaAt(nodes, -1)).toBe(false);
	});

	it("returns false for empty array", () => {
		expect(isCommaAt([], 0)).toBe(false);
	});
});

describe("skipComma", () => {
	it("skips comma and returns next index", () => {
		const ast = csstree.parse("red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const commaIndex = nodes.findIndex((n) => n.type === "Operator" && "value" in n && n.value === ",");

		expect(skipComma(nodes, commaIndex)).toBe(commaIndex + 1);
	});

	it("returns same index if not comma", () => {
		const ast = csstree.parse("red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(skipComma(nodes, 0)).toBe(0);
	});

	it("handles out of bounds index", () => {
		const ast = csstree.parse("red", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(skipComma(nodes, 999)).toBe(999);
	});

	it("handles empty array", () => {
		expect(skipComma([], 0)).toBe(0);
	});

	it("can chain multiple skipComma calls", () => {
		const ast = csstree.parse("red, blue, green", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		let idx = 0;
		// Skip to first value
		idx = nodes.findIndex((n) => n.type === "Identifier");
		expect(idx).toBeGreaterThanOrEqual(0);

		// Find first comma
		idx = nodes.findIndex((n, i) => i > idx && n.type === "Operator" && "value" in n && n.value === ",");
		// Skip it
		idx = skipComma(nodes, idx);

		// Should be at blue now (or whitespace before it)
		const nextIdentifier = nodes[idx];
		expect(nextIdentifier?.type === "Identifier" || nextIdentifier?.type === "WhiteSpace").toBe(true);
	});
});


=== File: src/utils/ast/split-by-comma.ts ===
// b_path:: src/utils/ast/split-by-comma.ts
import type * as csstree from "css-tree";

export interface SplitByCommaOptions {
	/** Start index in nodes array (default: 0) */
	startIndex?: number;

	/** Allow empty groups between commas (default: false) */
	allowEmpty?: boolean;

	/** Skip whitespace nodes (default: true) */
	trimWhitespace?: boolean;
}

/**
 * Split array of AST nodes by comma operators.
 *
 * Used for parsing comma-separated function arguments.
 * Returns array of node groups, where each group is the nodes between commas.
 *
 * @param nodes - Array of AST nodes to split
 * @param options - Parsing options
 * @returns Array of node groups (each group is nodes between commas)
 *
 * @example
 * ```typescript
 * // For polygon(50% 0%, 100% 50%, 0% 100%)
 * const functionNode = findFunctionNode(ast, "polygon");
 * const children = functionNode.children.toArray();
 * const groups = splitNodesByComma(children);
 * // Returns: [[50%, 0%], [100%, 50%], [0%, 100%]]
 * ```
 *
 * @example
 * ```typescript
 * // For linear-gradient(45deg, red, blue 50%, green)
 * // After parsing direction, start from index 2
 * const groups = splitNodesByComma(children, { startIndex: 2 });
 * // Returns: [[red], [blue, 50%], [green]]
 * ```
 *
 * @internal
 */
export function splitNodesByComma(nodes: csstree.CssNode[], options: SplitByCommaOptions = {}): csstree.CssNode[][] {
	const { startIndex = 0, allowEmpty = false, trimWhitespace = true } = options;

	const groups: csstree.CssNode[][] = [];
	let currentGroup: csstree.CssNode[] = [];

	for (let i = startIndex; i < nodes.length; i++) {
		const node = nodes[i];
		if (!node) continue;

		// Skip whitespace nodes if requested
		if (trimWhitespace && node.type === "WhiteSpace") {
			continue;
		}

		// Check for comma operator
		if (node.type === "Operator" && "value" in node && node.value === ",") {
			// End current group
			if (currentGroup.length > 0 || allowEmpty) {
				groups.push(currentGroup);
				currentGroup = [];
			}
		} else {
			currentGroup.push(node);
		}
	}

	// Push final group
	if (currentGroup.length > 0 || allowEmpty) {
		groups.push(currentGroup);
	}

	return groups;
}

/**
 * Check if a comma exists at the given index.
 *
 * Helper for optional comma checking in function parsers.
 *
 * @param nodes - Array of AST nodes
 * @param index - Index to check
 * @returns True if node at index is a comma operator
 *
 * @internal
 */
export function isCommaAt(nodes: csstree.CssNode[], index: number): boolean {
	const node = nodes[index];
	return Boolean(node && node.type === "Operator" && "value" in node && node.value === ",");
}

/**
 * Skip comma at index if present, return next index.
 *
 * Helper for optional comma handling in function parsers.
 *
 * @param nodes - Array of AST nodes
 * @param index - Current index
 * @returns Index after comma if present, otherwise same index
 *
 * @example
 * ```typescript
 * let idx = 5;
 * idx = skipComma(children, idx); // Skips comma if at index 5
 * ```
 *
 * @internal
 */
export function skipComma(nodes: csstree.CssNode[], index: number): number {
	return isCommaAt(nodes, index) ? index + 1 : index;
}


=== File: src/utils/generate/color.ts ===
// b_path:: src/utils/generate/color.ts
import type { Color } from "@/core/types/color";
import * as ColorGenerate from "@/generate/color";

/**
 * Generate CSS from any Color IR format.
 *
 * Convenience helper that dispatches to appropriate color generator
 * based on the color's kind field.
 *
 * @param color - Color IR to convert
 * @returns CSS color string
 *
 * @internal
 */
export function generateColor(color: Color): string {
	switch (color.kind) {
		case "hex":
			return ColorGenerate.Hex.toCss(color);
		case "named":
			return ColorGenerate.Named.toCss(color);
		case "rgb":
			return ColorGenerate.Rgb.toCss(color);
		case "hsl":
			return ColorGenerate.Hsl.toCss(color);
		case "hwb":
			return ColorGenerate.Hwb.toCss(color);
		case "lab":
			return ColorGenerate.Lab.toCss(color);
		case "lch":
			return ColorGenerate.Lch.toCss(color);
		case "oklab":
			return ColorGenerate.Oklab.toCss(color);
		case "oklch":
			return ColorGenerate.Oklch.toCss(color);
		case "system":
			return ColorGenerate.System.toCss(color);
		case "special":
			return ColorGenerate.Special.toCss(color);
		case "color":
			return ColorGenerate.ColorFunction.toCss(color);
	}
}


=== File: src/utils/generate/index.ts ===
// b_path:: src/utils/generate/index.ts

export * from "./values";


=== File: src/utils/generate/url.ts ===
// b_path:: src/utils/generate/url.ts

import type { Url } from "@/core/types/url";

/**
 * Generate CSS url() function.
 *
 * Shared utility for generating URL references across different CSS properties.
 *
 * @param value - Url IR value
 * @returns CSS string like "url(#id)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/url_function}
 *
 * @example
 * ```typescript
 * import { urlToCss } from "@/utils/generate/url";
 *
 * const css = urlToCss({ kind: "url", value: "#clip-shape" });
 * // "url(#clip-shape)"
 * ```
 *
 * @public
 */
export function urlToCss(value: Url): string {
	return `url(${value.value})`;
}


=== File: src/utils/generate/values.ts ===
// b_path:: src/utils/generate/values.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS value string from PositionValue IR.
 *
 * Handles both keyword and length/percentage position values.
 * Common pattern used across position and transform generation.
 *
 * @param value - PositionValue IR object
 * @returns CSS value string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { positionValueToCss } from "@/utils/generate/values";
 *
 * console.log(positionValueToCss("center")); // "center"
 * console.log(positionValueToCss({ value: 50, unit: "%" })); // "50%"
 * console.log(positionValueToCss({ value: 100, unit: "px" })); // "100px"
 * ```
 */
export function positionValueToCss(value: Type.PositionValue): string {
	if (typeof value === "string") {
		return value;
	}
	return `${value.value}${value.unit}`;
}

/**
 * Generate CSS value string from Length IR.
 *
 * @param length - Length IR object
 * @returns CSS length string
 *
 * @public
 */
export function lengthToCss(length: Type.Length): string {
	return `${length.value}${length.unit}`;
}

/**
 * Generate CSS value string from LengthPercentage IR.
 *
 * @param lengthPercentage - LengthPercentage IR object
 * @returns CSS length-percentage string
 *
 * @public
 */
export function lengthPercentageToCss(lengthPercentage: Type.LengthPercentage): string {
	return `${lengthPercentage.value}${lengthPercentage.unit}`;
}

/**
 * Generate CSS value string from Angle IR.
 *
 * @param angle - Angle IR object
 * @returns CSS angle string
 *
 * @public
 */
export function angleToCss(angle: Type.Angle): string {
	return `${angle.value}${angle.unit}`;
}

/**
 * Generate CSS value string from number.
 *
 * @param number - Number value
 * @returns CSS number string
 *
 * @public
 */
export function numberToCss(number: number): string {
	return String(number);
}

/**
 * Join an array of CSS value strings with commas and spaces.
 *
 * Common pattern for generating comma-separated CSS values.
 *
 * @param values - Array of CSS value strings
 * @returns Joined CSS string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { joinCssValues } from "@/utils/generate/values";
 *
 * const values = ["red", "blue", "green"];
 * console.log(joinCssValues(values)); // "red, blue, green"
 * ```
 */
export function joinCssValues(values: string[]): string {
	return values.join(", ");
}

/**
 * Join an array of CSS value strings with spaces.
 *
 * Common pattern for generating space-separated CSS values.
 *
 * @param values - Array of CSS value strings
 * @returns Joined CSS string
 *
 * @public
 */
export function joinCssValuesWithSpaces(values: string[]): string {
	return values.join(" ");
}

/**
 * Generate border-radius CSS in shortest form.
 *
 * Converts 4-corner border-radius values to shortest CSS representation:
 * - All equal → 1 value
 * - Diagonals same → 2 values
 * - Top-right/bottom-left same → 3 values
 * - All different → 4 values
 *
 * Used by clip-path shapes (inset, rect, xywh) for 'round' clause.
 *
 * @param radius - Border radius with 4 corner values
 * @returns CSS border-radius string in shortest form
 *
 * @public
 *
 * @example
 * All corners equal:
 * ```typescript
 * const radius = {
 *   topLeft: { value: 5, unit: "px" },
 *   topRight: { value: 5, unit: "px" },
 *   bottomRight: { value: 5, unit: "px" },
 *   bottomLeft: { value: 5, unit: "px" }
 * };
 * borderRadiusToCss(radius); // "5px"
 * ```
 *
 * @example
 * Diagonals same:
 * ```typescript
 * const radius = {
 *   topLeft: { value: 5, unit: "px" },
 *   topRight: { value: 10, unit: "px" },
 *   bottomRight: { value: 5, unit: "px" },
 *   bottomLeft: { value: 10, unit: "px" }
 * };
 * borderRadiusToCss(radius); // "5px 10px"
 * ```
 */
export function borderRadiusToCss(radius: {
	topLeft: Type.LengthPercentage;
	topRight: Type.LengthPercentage;
	bottomRight: Type.LengthPercentage;
	bottomLeft: Type.LengthPercentage;
}): string {
	const tl = lengthPercentageToCss(radius.topLeft);
	const tr = lengthPercentageToCss(radius.topRight);
	const br = lengthPercentageToCss(radius.bottomRight);
	const bl = lengthPercentageToCss(radius.bottomLeft);

	// Check for optimization opportunities
	if (tl === tr && tr === br && br === bl) {
		// All equal: 1 value
		return tl;
	}

	if (tl === br && tr === bl) {
		// Diagonals same: 2 values
		return `${tl} ${tr}`;
	}

	if (tr === bl) {
		// Top-right/bottom-left same: 3 values
		return `${tl} ${tr} ${br}`;
	}

	// All different: 4 values
	return `${tl} ${tr} ${br} ${bl}`;
}


=== File: src/utils/index.ts ===
// b_path:: src/utils/index.ts

export * as Ast from "./ast";
export * as Generate from "./generate";
export * as Parse from "./parse";


=== File: src/utils/parse/color-components.test.ts ===
// b_path:: src/utils/parse/color-components.test.ts

import * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { parseAlpha, parseHue, parseLightness, parsePercentage } from "./color-components";

describe("parseAlpha", () => {
	it("parses number in valid range (0-1)", () => {
		const ast = csstree.parse("0.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(0.5);
	});

	it("parses percentage (0%-100%)", () => {
		const ast = csstree.parse("50%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(0.5);
	});

	it("rejects number out of range without clamp", () => {
		const ast = csstree.parse("1.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node);
		expect(result.ok).toBe(false);
	});

	it("clamps number out of range with clamp option", () => {
		const ast = csstree.parse("1.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node, { clamp: true });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(1);
	});

	it("clamps percentage with clamp option", () => {
		const ast = csstree.parse("150%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node, { clamp: true });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(1);
	});
});

describe("parseHue", () => {
	it("parses unitless number as degrees", () => {
		const ast = csstree.parse("120", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(120);
	});

	it("parses angle in degrees", () => {
		const ast = csstree.parse("180deg", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(180);
	});

	it("parses angle in radians", () => {
		const ast = csstree.parse("3.14159rad", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBeCloseTo(180, 0);
	});

	it("parses angle in turns", () => {
		const ast = csstree.parse("0.5turn", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(180);
	});

	it("normalizes hue with wrapping (negative)", () => {
		const ast = csstree.parse("-30", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(330);
	});

	it("normalizes hue with wrapping (>360)", () => {
		const ast = csstree.parse("400", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(40);
	});
});

describe("parseLightness", () => {
	it("parses number in 0-100 range", () => {
		const ast = csstree.parse("50", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-100");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(50);
	});

	it("parses number in 0-1 range", () => {
		const ast = csstree.parse("0.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-1");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(0.5);
	});

	it("parses percentage and converts to 0-100 range", () => {
		const ast = csstree.parse("50%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-100");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(50);
	});

	it("parses percentage and converts to 0-1 range", () => {
		const ast = csstree.parse("50%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-1");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(0.5);
	});

	it("clamps value to 0-100 range", () => {
		const ast = csstree.parse("150", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-100");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(100);
	});

	it("clamps value to 0-1 range", () => {
		const ast = csstree.parse("1.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-1");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(1);
	});
});

describe("parsePercentage", () => {
	it("parses valid percentage", () => {
		const ast = csstree.parse("75%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parsePercentage(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(75);
	});

	it("rejects out of range percentage without clamp", () => {
		const ast = csstree.parse("150%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parsePercentage(node);
		expect(result.ok).toBe(false);
	});

	it("clamps percentage with clamp option", () => {
		const ast = csstree.parse("150%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parsePercentage(node, { clamp: true });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(100);
	});

	it("rejects non-percentage node", () => {
		const ast = csstree.parse("50", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parsePercentage(node);
		expect(result.ok).toBe(false);
	});
});


=== File: src/utils/parse/color-components.ts ===
// b_path:: src/utils/parse/color-components.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import * as ParseUtils from "@/utils/parse";

/**
 * Options for parsing alpha values.
 */
export interface ParseAlphaOptions {
	/**
	 * If true, clamp values to 0-1 range instead of returning errors.
	 * Default: false (return errors for out-of-range values)
	 */
	clamp?: boolean;
}

/**
 * Parse an alpha (transparency) value from a CSS AST node.
 *
 * Accepts:
 * - Number: 0-1 range
 * - Percentage: 0%-100% (converted to 0-1)
 *
 * @param node - CSS AST node to parse
 * @param options - Parsing options (clamping behavior)
 * @returns Result containing alpha value (0-1) or error message
 *
 * @example
 * ```typescript
 * import { parseAlpha } from "@/utils/parse/color-components";
 *
 * // Number (0-1)
 * const alpha1 = parseAlpha(numberNode);
 * // => { ok: true, value: 0.5 }
 *
 * // Percentage (0%-100%)
 * const alpha2 = parseAlpha(percentageNode);
 * // => { ok: true, value: 0.5 }
 *
 * // With clamping
 * const alpha3 = parseAlpha(invalidNode, { clamp: true });
 * // => { ok: true, value: 1 } // clamped from 1.5
 * ```
 *
 * @public
 */
export function parseAlpha(node: csstree.CssNode, options?: ParseAlphaOptions): Result<number, string> {
	const clamp = options?.clamp ?? false;

	// Try parsing as number (0-1)
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;

		if (clamp) {
			return ok(Math.max(0, Math.min(1, value)));
		}

		if (value < 0 || value > 1) {
			return err(`Alpha value must be between 0 and 1, got ${value}`);
		}
		return ok(value);
	}

	// Try parsing as percentage (0%-100%)
	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value for alpha");
		}

		// Convert percentage to 0-1 range
		const alphaValue = value / 100;

		if (clamp) {
			return ok(Math.max(0, Math.min(1, alphaValue)));
		}

		if (value < 0 || value > 100) {
			return err(`Alpha percentage must be between 0% and 100%, got ${value}%`);
		}
		return ok(alphaValue);
	}

	return err(`Expected number or percentage for alpha, got ${node.type}`);
}

/**
 * Parse a hue value from a CSS AST node.
 *
 * Accepts:
 * - Number: Unitless degrees
 * - Dimension: Angle with unit (deg, rad, grad, turn)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 *
 * @param node - CSS AST node to parse
 * @returns Result containing hue value (0-360 degrees) or error message
 *
 * @example
 * ```typescript
 * import { parseHue } from "@/utils/parse/color-components";
 *
 * // Unitless number (defaults to degrees)
 * const hue1 = parseHue(numberNode);
 * // => { ok: true, value: 120 }
 *
 * // Angle with unit
 * const hue2 = parseHue(angleNode);
 * // => { ok: true, value: 180 } // converted from 0.5turn
 *
 * // Wrapping (negative values)
 * const hue3 = parseHue(negativeNode);
 * // => { ok: true, value: 330 } // -30 wraps to 330
 * ```
 *
 * @public
 */
export function parseHue(node: csstree.CssNode): Result<number, string> {
	// Unitless number (defaults to degrees)
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		return ok(normalizeHue(numResult.value));
	}

	// Angle with unit
	if (node.type === "Dimension") {
		const angleResult = ParseUtils.parseAngleNode(node);
		if (!angleResult.ok) {
			return err(angleResult.error);
		}

		const angle = angleResult.value;
		// Convert to degrees
		let degrees: number;
		switch (angle.unit) {
			case "deg":
				degrees = angle.value;
				break;
			case "rad":
				degrees = (angle.value * 180) / Math.PI;
				break;
			case "grad":
				degrees = (angle.value * 360) / 400;
				break;
			case "turn":
				degrees = angle.value * 360;
				break;
			default:
				return err(`Unsupported angle unit: ${angle.unit}`);
		}

		return ok(normalizeHue(degrees));
	}

	return err(`Expected number or angle for hue, got ${node.type}`);
}

/**
 * Normalize hue to 0-360 degrees range with wrapping.
 *
 * @param hue - Hue value in degrees
 * @returns Normalized hue (0-360)
 *
 * @internal
 */
function normalizeHue(hue: number): number {
	// Wrap to 0-360 range
	const normalized = hue % 360;
	// Handle negative values
	const positive = normalized < 0 ? normalized + 360 : normalized;
	// Ensure positive zero (avoid -0)
	return positive === 0 ? 0 : positive;
}

/**
 * Range specification for lightness values.
 */
export type LightnessRange = "0-1" | "0-100";

/**
 * Parse a lightness value from a CSS AST node.
 *
 * Accepts:
 * - Number: Unitless value in specified range
 * - Percentage: 0%-100% (converted to specified range)
 *
 * Values are clamped to the specified range.
 *
 * @param node - CSS AST node to parse
 * @param range - Expected range for lightness ("0-1" or "0-100")
 * @returns Result containing lightness value (clamped) or error message
 *
 * @example
 * ```typescript
 * import { parseLightness } from "@/utils/parse/color-components";
 *
 * // Number in 0-100 range (for LAB/LCH)
 * const lightness1 = parseLightness(numberNode, "0-100");
 * // => { ok: true, value: 50 }
 *
 * // Number in 0-1 range (for OKLab/OKLCH)
 * const lightness2 = parseLightness(numberNode, "0-1");
 * // => { ok: true, value: 0.5 }
 *
 * // Percentage (converts to range)
 * const lightness3 = parseLightness(percentageNode, "0-100");
 * // => { ok: true, value: 50 } // from 50%
 * ```
 *
 * @public
 */
export function parseLightness(node: csstree.CssNode, range: LightnessRange): Result<number, string> {
	const maxValue = range === "0-1" ? 1 : 100;

	// Try percentage first
	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value for lightness");
		}
		// Convert percentage to range and clamp
		const lightness = (value / 100) * maxValue;
		return ok(Math.max(0, Math.min(maxValue, lightness)));
	}

	// Try number
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		// Clamp to range
		return ok(Math.max(0, Math.min(maxValue, numResult.value)));
	}

	return err(`Expected number or percentage for lightness, got ${node.type}`);
}

/**
 * Options for parsing percentage values.
 */
export interface ParsePercentageOptions {
	/**
	 * If true, clamp values to 0-100 range instead of returning errors.
	 * Default: false (return errors for out-of-range values)
	 */
	clamp?: boolean;
}

/**
 * Parse a percentage value from a CSS AST node.
 *
 * Accepts:
 * - Percentage: 0%-100%
 *
 * @param node - CSS AST node to parse
 * @param options - Parsing options (clamping behavior)
 * @returns Result containing percentage value (0-100) or error message
 *
 * @example
 * ```typescript
 * import { parsePercentage } from "@/utils/parse/color-components";
 *
 * // Valid percentage
 * const pct1 = parsePercentage(percentageNode);
 * // => { ok: true, value: 50 }
 *
 * // With clamping
 * const pct2 = parsePercentage(invalidNode, { clamp: true });
 * // => { ok: true, value: 100 } // clamped from 150
 * ```
 *
 * @public
 */
export function parsePercentage(node: csstree.CssNode, options?: ParsePercentageOptions): Result<number, string> {
	const clamp = options?.clamp ?? false;

	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value");
		}

		if (clamp) {
			return ok(Math.max(0, Math.min(100, value)));
		}

		if (value < 0 || value > 100) {
			return err(`Percentage must be between 0% and 100%, got ${value}%`);
		}
		return ok(value);
	}

	return err(`Expected percentage, got ${node.type}`);
}


=== File: src/utils/parse/color.ts ===
// b_path:: src/utils/parse/color.ts
import type { Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import * as ColorParse from "@/parse/color";

/**
 * Parse a CSS color value with auto-detection of format.
 *
 * Convenience helper that dispatches to appropriate color parser
 * based on input format detection.
 *
 * @param input - CSS color string
 * @returns Result containing parsed Color IR or error message
 *
 * @internal
 */
export function parseColor(input: string): Result<Color, string> {
	const trimmed = input.trim();

	// Try hex - starts with #
	if (trimmed.startsWith("#")) {
		return ColorParse.Hex.parse(trimmed);
	}

	// Try function syntax - contains (
	if (trimmed.includes("(")) {
		const lower = trimmed.toLowerCase();

		// Check function name prefix
		if (lower.startsWith("rgb(") || lower.startsWith("rgba(")) {
			return ColorParse.Rgb.parse(trimmed);
		}
		if (lower.startsWith("hsl(") || lower.startsWith("hsla(")) {
			return ColorParse.Hsl.parse(trimmed);
		}
		if (lower.startsWith("hwb(")) {
			return ColorParse.Hwb.parse(trimmed);
		}
		if (lower.startsWith("lab(")) {
			return ColorParse.Lab.parse(trimmed);
		}
		if (lower.startsWith("lch(")) {
			return ColorParse.Lch.parse(trimmed);
		}
		if (lower.startsWith("oklab(")) {
			return ColorParse.Oklab.parse(trimmed);
		}
		if (lower.startsWith("oklch(")) {
			return ColorParse.Oklch.parse(trimmed);
		}
	}

	// Try special keywords - transparent, currentcolor
	const lower = trimmed.toLowerCase();
	if (lower === "transparent" || lower === "currentcolor") {
		return ColorParse.Special.parse(trimmed);
	}

	// Try system color keywords
	const systemResult = ColorParse.System.parse(trimmed);
	if (systemResult.ok) {
		return systemResult;
	}

	// Try named colors - fallback
	return ColorParse.Named.parse(trimmed);
}


=== File: src/utils/parse/comma-separated.test.ts ===
// b_path:: src/utils/parse/comma-separated.test.ts

import type * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { err, ok, type Result } from "@/core/result";
import { parseCommaSeparatedSingle } from "./comma-separated";

function mockIdentifierParser(node: csstree.CssNode): Result<string, string> {
	if (node.type !== "Identifier") {
		return err(`Expected Identifier, got ${node.type}`);
	}
	return ok(node.name);
}

function mockNumberParser(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		return ok(Number.parseFloat(node.value));
	}
	if (node.type === "Dimension" && node.unit === "px") {
		return ok(Number.parseFloat(node.value));
	}
	return err(`Expected number or dimension, got ${node.type}`);
}

describe("parseCommaSeparatedSingle", () => {
	describe("Basic Functionality", () => {
		it("parses single value", () => {
			const result = parseCommaSeparatedSingle("value", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["value"],
			});
		});

		it("parses two comma-separated values", () => {
			const result = parseCommaSeparatedSingle("first, second", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["first", "second"],
			});
		});

		it("parses three comma-separated values", () => {
			const result = parseCommaSeparatedSingle("one, two, three", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["one", "two", "three"],
			});
		});

		it("parses many comma-separated values", () => {
			const result = parseCommaSeparatedSingle("a, b, c, d, e, f, g", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(7);
				expect(result.value).toEqual(["a", "b", "c", "d", "e", "f", "g"]);
			}
		});
	});

	describe("Whitespace Handling", () => {
		it("handles values with no spaces around commas", () => {
			const result = parseCommaSeparatedSingle("first,second,third", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["first", "second", "third"],
			});
		});

		it("handles values with multiple spaces around commas", () => {
			const result = parseCommaSeparatedSingle("first  ,  second  ,  third", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["first", "second", "third"],
			});
		});

		it("handles values with tabs and newlines", () => {
			const result = parseCommaSeparatedSingle("first\t,\nsecond\t,\nthird", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["first", "second", "third"],
			});
		});
	});

	describe("Different Value Types", () => {
		it("parses numeric values", () => {
			const result = parseCommaSeparatedSingle("1, 2, 3", mockNumberParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: [1, 2, 3],
			});
		});

		it("parses dimension values", () => {
			const result = parseCommaSeparatedSingle("10px, 20px, 30px", mockNumberParser, "test-property");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual([10, 20, 30]);
			}
		});

		it("parses mixed identifiers", () => {
			const result = parseCommaSeparatedSingle("ease, linear, ease-in-out", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["ease", "linear", "ease-in-out"],
			});
		});
	});

	describe("Error Cases", () => {
		it("rejects empty string", () => {
			const result = parseCommaSeparatedSingle("", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("test-property");
			}
		});

		it("rejects empty value before comma", () => {
			const result = parseCommaSeparatedSingle(", second", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Empty value");
			}
		});

		it("rejects empty value after comma", () => {
			const result = parseCommaSeparatedSingle("first, ", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Empty value");
			}
		});

		it("rejects empty value between commas", () => {
			const result = parseCommaSeparatedSingle("first, , third", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Empty value");
			}
		});

		it("propagates parser errors", () => {
			const result = parseCommaSeparatedSingle("123, 456", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected Identifier");
			}
		});

		it("includes property name in error messages", () => {
			const result = parseCommaSeparatedSingle(", invalid", mockIdentifierParser, "my-custom-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("my-custom-property");
			}
		});
	});

	describe("Edge Cases", () => {
		it("handles single comma (two empty values)", () => {
			const result = parseCommaSeparatedSingle(",", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
		});

		it("handles multiple consecutive commas", () => {
			const result = parseCommaSeparatedSingle("first,,third", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
		});

		it("handles only whitespace", () => {
			const result = parseCommaSeparatedSingle("   ", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/utils/parse/comma-separated.ts ===
// b_path:: src/utils/parse/comma-separated.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse comma-separated list where each item is a single AST node.
 *
 * This helper handles the common pattern of splitting comma-separated values
 * where each item between commas is exactly one value (not a complex expression).
 *
 * Examples:
 * - animation-name: fade, slide, bounce
 * - transition-property: opacity, transform
 * - animation-delay: 1s, 500ms, 2s
 * - background-image: linear-gradient(...), url(img.png)
 *
 * @param css - CSS value string to parse
 * @param itemParser - Function to parse each individual item node
 * @param propertyName - Property name for error messages
 * @returns Result with array of parsed items or error
 *
 * @example
 * ```typescript
 * const result = parseCommaSeparatedSingle(
 *   "fade, slide, bounce",
 *   (node) => parseAnimationName(node),
 *   "animation-name"
 * );
 * // result.value = [{ type: "identifier", value: "fade" }, ...]
 * ```
 *
 * @internal
 */
export function parseCommaSeparatedSingle<T>(
	css: string,
	itemParser: (node: csstree.CssNode) => Result<T, string>,
	propertyName: string,
): Result<T[], string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err(`${propertyName}: Expected Value node`);
		}

		const children = ast.children.toArray();

		const results: T[] = [];
		let currentNodes: csstree.CssNode[] = [];

		for (const node of children) {
			if (node.type === "Operator" && "value" in node && node.value === ",") {
				if (currentNodes.length === 1 && currentNodes[0]) {
					const itemResult = itemParser(currentNodes[0]);
					if (!itemResult.ok) {
						return err(`${propertyName}: ${itemResult.error}`);
					}
					results.push(itemResult.value);
					currentNodes = [];
				} else if (currentNodes.length === 0) {
					return err(`${propertyName}: Empty value before comma`);
				} else {
					return err(`${propertyName}: Expected single value between commas, got ${currentNodes.length} values`);
				}
			} else {
				currentNodes.push(node);
			}
		}

		if (currentNodes.length === 1 && currentNodes[0]) {
			const itemResult = itemParser(currentNodes[0]);
			if (!itemResult.ok) {
				return err(`${propertyName}: ${itemResult.error}`);
			}
			results.push(itemResult.value);
		} else if (currentNodes.length === 0) {
			return err(`${propertyName}: Empty value`);
		} else {
			return err(`${propertyName}: Expected single value, got ${currentNodes.length} values`);
		}

		if (results.length === 0) {
			return err(`${propertyName}: Requires at least one value`);
		}

		return ok(results);
	} catch (e) {
		return err(`Failed to parse ${propertyName}: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/utils/parse/comma.test.ts ===
// b_path:: src/utils/parse/comma.test.ts

import * as csstree from "css-tree";
import { describe, expect, test } from "vitest";
import { err, ok } from "@/core/result";
import { splitLayer, splitValue } from "./comma";

describe("splitValue", () => {
	test("parses single value", () => {
		const result = splitValue("fade", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(1);
			expect(result.value[0]?.name).toBe("fade");
		}
	});

	test("parses multiple values", () => {
		const result = splitValue("fade, slide, bounce", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(3);
			expect(result.value[0]?.name).toBe("fade");
			expect(result.value[1]?.name).toBe("slide");
			expect(result.value[2]?.name).toBe("bounce");
		}
	});

	test("parses function values", () => {
		const result = splitValue("url(a.png), url(b.png)", (node) => ok({ value: csstree.generate(node) }), "test");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.value).toBe("url(a.png)");
			expect(result.value[1]?.value).toBe("url(b.png)");
		}
	});

	test("CRITICAL: handles nested commas in function values", () => {
		const result = splitValue(
			"linear-gradient(red, blue), url(a.png)",
			(node) => ok({ value: csstree.generate(node) }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Should be 2 values, NOT 3!
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.value).toContain("linear-gradient");
			expect(result.value[0]?.value).toContain("red");
			expect(result.value[0]?.value).toContain("blue");
			expect(result.value[1]?.value).toBe("url(a.png)");
		}
	});

	test("handles values with whitespace", () => {
		const result = splitValue("  fade  ,  slide  ", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
		}
	});

	test("errors on empty value", () => {
		const result = splitValue("fade, , slide", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Empty value");
		}
	});

	test("errors on multiple nodes between commas", () => {
		const result = splitValue("fade slide, bounce", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Expected single value");
		}
	});

	test("errors on trailing comma", () => {
		const result = splitValue("fade, slide,", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Empty value");
		}
	});

	test("errors on leading comma", () => {
		const result = splitValue(", fade, slide", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Empty value");
		}
	});

	test("propagates parser errors", () => {
		const result = splitValue("fade, slide", () => err("custom error"), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("custom error");
		}
	});
});

describe("splitLayer", () => {
	test("parses single layer with multiple tokens", () => {
		const result = splitLayer(
			"2px 2px red",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(1);
			expect(result.value[0]?.count).toBe(3);
		}
	});

	test("parses multiple layers", () => {
		const result = splitLayer(
			"2px 2px red, 3px 3px blue",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.count).toBe(3);
			expect(result.value[1]?.count).toBe(3);
		}
	});

	test("CRITICAL: handles nested function commas in layer", () => {
		const result = splitLayer(
			"drop-shadow(1px 2px red), 3px 3px blue",
			(nodes) => ok({ nodeCount: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Should be 2 layers, NOT 3!
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.nodeCount).toBe(1); // drop-shadow function
			expect(result.value[1]?.nodeCount).toBe(3); // 3px 3px blue
		}
	});

	test("handles layers with different token counts", () => {
		const result = splitLayer(
			"2px, 3px 3px 5px red",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.count).toBe(1); // First layer: 1 token
			expect(result.value[1]?.count).toBe(4); // Second layer: 4 tokens
		}
	});

	test("handles layers with whitespace", () => {
		const result = splitLayer(
			"  2px 2px  ,  3px 3px  ",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
		}
	});

	test("errors on empty layer", () => {
		const result = splitLayer("2px 2px, , 3px 3px", (nodes) => ok({ count: nodes.length }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Empty layer");
		}
	});

	test("allows trailing comma (matches CSS parser behavior)", () => {
		const result = splitLayer(
			"2px 2px,",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(1);
		}
	});

	test("propagates parser errors", () => {
		const result = splitLayer("2px 2px, 3px 3px", () => err("layer error"), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("layer error");
		}
	});
});


=== File: src/utils/parse/comma.ts ===
// b_path:: src/utils/parse/comma.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";

/**
 * Split comma-separated VALUES where each value is a complete independent item.
 *
 * A "value" can be:
 * - A keyword: fade, slide, bounce
 * - A function: url(...), linear-gradient(...)
 * - A complex expression: calc(100% - 20px)
 *
 * Use for properties where commas separate independent complete values.
 * These represent parallel behaviors, fallbacks, or multiple targets.
 *
 * Examples:
 * - animation-name: fade, slide, bounce
 * - background-image: url(a.png), linear-gradient(red, blue)
 * - transition-property: opacity, transform
 * - font-family: Arial, "Times New Roman", sans-serif
 *
 * @param css - CSS value string
 * @param valueParser - Parser for each complete value (receives single node)
 * @param propertyName - Property name for error messages
 * @returns Result with array of parsed values or error
 *
 * @example
 * ```typescript
 * const result = splitValue(
 *   "fade, slide, bounce",
 *   (node) => parseAnimationName(node),
 *   "animation-name"
 * );
 * // result.value = [{ type: "identifier", value: "fade" }, ...]
 * ```
 *
 * @public
 */
export function splitValue<T>(
	css: string,
	valueParser: (node: csstree.CssNode) => Result<T, string>,
	propertyName: string,
): Result<T[], string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err(`${propertyName}: Expected Value node`);
		}

		const children = ast.children.toArray();
		const results: T[] = [];
		let currentNodes: csstree.CssNode[] = [];

		for (const node of children) {
			if (node.type === "Operator" && "value" in node && node.value === ",") {
				// Found value separator
				if (currentNodes.length === 1 && currentNodes[0]) {
					const valueResult = valueParser(currentNodes[0]);
					if (!valueResult.ok) {
						return err(`${propertyName}: ${valueResult.error}`);
					}
					results.push(valueResult.value);
					currentNodes = [];
				} else if (currentNodes.length === 0) {
					return err(`${propertyName}: Empty value before comma`);
				} else {
					return err(`${propertyName}: Expected single value between commas, got ${currentNodes.length} nodes`);
				}
			} else {
				currentNodes.push(node);
			}
		}

		// Process last value
		if (currentNodes.length === 1 && currentNodes[0]) {
			const valueResult = valueParser(currentNodes[0]);
			if (!valueResult.ok) {
				return err(`${propertyName}: ${valueResult.error}`);
			}
			results.push(valueResult.value);
		} else if (currentNodes.length === 0) {
			return err(`${propertyName}: Empty value`);
		} else {
			return err(`${propertyName}: Expected single value, got ${currentNodes.length} nodes`);
		}

		if (results.length === 0) {
			return err(`${propertyName}: Requires at least one value`);
		}

		return ok(results);
	} catch (e) {
		return err(`Failed to parse ${propertyName}: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Split comma-separated LAYERS where each layer has multiple components.
 *
 * A "layer" is a comma-separated group of tokens that together form one
 * visual layer/effect. Each layer is parsed as a unit with multiple components.
 *
 * Use for properties where commas separate layers in actual rendering order.
 * These represent layered visual effects that stack on top of each other.
 *
 * Examples:
 * - box-shadow: 2px 2px 5px red, 3px 3px blue
 * - text-shadow: 1px 1px red, 2px 2px blue
 * - background: url(a.png) center / cover, linear-gradient(red, blue)
 * - filter: drop-shadow(1px 1px red), blur(5px)
 *
 * @param css - CSS value string
 * @param layerParser - Parser for each layer (receives array of nodes for one layer)
 * @param propertyName - Property name for error messages
 * @returns Result with array of parsed layers or error
 *
 * @example
 * ```typescript
 * const result = splitLayer(
 *   "2px 2px 5px red, 3px 3px blue",
 *   (nodes) => parseShadowLayer(nodes),
 *   "box-shadow"
 * );
 * // result.value = [{ offsetX: ..., offsetY: ..., ... }, { ... }]
 * ```
 *
 * @public
 */
export function splitLayer<T>(
	css: string,
	layerParser: (nodes: csstree.CssNode[]) => Result<T, string>,
	propertyName: string,
): Result<T[], string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err(`${propertyName}: Expected Value node`);
		}

		const children = ast.children.toArray();
		const results: T[] = [];
		let currentNodes: csstree.CssNode[] = [];

		for (const node of children) {
			if (node.type === "Operator" && "value" in node && node.value === ",") {
				// Found layer separator
				if (currentNodes.length > 0) {
					const layerResult = layerParser(currentNodes);
					if (!layerResult.ok) {
						return err(`${propertyName}: ${layerResult.error}`);
					}
					results.push(layerResult.value);
					currentNodes = [];
				} else {
					return err(`${propertyName}: Empty layer before comma`);
				}
			} else {
				currentNodes.push(node);
			}
		}

		// Process last layer (allow trailing comma - it's valid CSS)
		if (currentNodes.length > 0) {
			const layerResult = layerParser(currentNodes);
			if (!layerResult.ok) {
				return err(`${propertyName}: ${layerResult.error}`);
			}
			results.push(layerResult.value);
		}

		if (results.length === 0) {
			return err(`${propertyName}: Requires at least one layer`);
		}

		return ok(results);
	} catch (e) {
		return err(`Failed to parse ${propertyName}: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/utils/parse/easing/easing-function.test.ts ===
// b_path:: src/utils/parse/easing/easing-function.test.ts
import * as csstree from "css-tree";
import { describe, expect, test } from "vitest";
import { parseEasingFunction } from "./easing-function";

describe("parseEasingFunction", () => {
	describe("keywords", () => {
		test("parses ease", () => {
			const ast = csstree.parse("ease", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({ ok: true, value: "ease" });
		});

		test("parses ease-in", () => {
			const ast = csstree.parse("ease-in", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({ ok: true, value: "ease-in" });
		});

		test("parses linear", () => {
			const ast = csstree.parse("linear", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({ ok: true, value: "linear" });
		});

		test("rejects invalid keyword", () => {
			const ast = csstree.parse("invalid", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("cubic-bezier", () => {
		test("parses cubic-bezier with 4 numbers", () => {
			const ast = csstree.parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "cubic-bezier",
					x1: 0.1,
					y1: 0.7,
					x2: 1.0,
					y2: 0.1,
				},
			});
		});

		test("rejects cubic-bezier with wrong number of args", () => {
			const ast = csstree.parse("cubic-bezier(0.1, 0.7)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("steps", () => {
		test("parses steps with count only", () => {
			const ast = csstree.parse("steps(4)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "steps",
					steps: 4,
					position: undefined,
				},
			});
		});

		test("parses steps with count and position", () => {
			const ast = csstree.parse("steps(4, jump-start)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "steps",
					steps: 4,
					position: "jump-start",
				},
			});
		});

		test("rejects steps with non-integer", () => {
			const ast = csstree.parse("steps(4.5)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});

		test("rejects steps with zero", () => {
			const ast = csstree.parse("steps(0)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("linear function", () => {
		test("parses linear with single stop", () => {
			const ast = csstree.parse("linear(0)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "linear",
					stops: [{ output: 0 }],
				},
			});
		});

		test("parses linear with stop and input", () => {
			const ast = csstree.parse("linear(0 0%, 1 100%)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "linear",
					stops: [
						{ output: 0, input: 0 },
						{ output: 1, input: 1 },
					],
				},
			});
		});

		test("parses linear with multiple stops", () => {
			const ast = csstree.parse("linear(0, 0.5, 1)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "linear",
					stops: [{ output: 0 }, { output: 0.5 }, { output: 1 }],
				},
			});
		});

		test("rejects linear with no stops", () => {
			const ast = csstree.parse("linear()", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("unknown function", () => {
		test("rejects unknown function", () => {
			const ast = csstree.parse("unknown(1, 2, 3)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unknown easing function");
			}
		});
	});

	describe("invalid node type", () => {
		test("rejects number node", () => {
			const ast = csstree.parse("42", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected easing function or keyword");
			}
		});
	});
});


=== File: src/utils/parse/easing/easing-function.ts ===
// b_path:: src/utils/parse/easing/easing-function.ts
import type * as csstree from "css-tree";
import { EASING_KEYWORD_KEYWORDS, STEP_POSITION_KEYWORDS } from "@/core/keywords/animation";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse cubic-bezier() function from AST node.
 *
 * @param node - CSS tree Function node
 * @returns Result with CubicBezier object or error
 *
 * @internal
 */
function parseCubicBezier(node: csstree.FunctionNode): Result<Type.CubicBezier, string> {
	const children = node.children.toArray();
	const numbers: number[] = [];

	for (const child of children) {
		if (child.type === "Number") {
			numbers.push(Number.parseFloat(child.value));
		} else if (child.type === "Operator" && "value" in child && child.value === ",") {
		} else {
			return err(`Invalid node in cubic-bezier: ${child.type}`);
		}
	}

	if (numbers.length !== 4) {
		return err(`cubic-bezier requires exactly 4 numbers, got ${numbers.length}`);
	}

	const [x1, y1, x2, y2] = numbers;

	return ok({
		type: "cubic-bezier",
		x1: x1 as number,
		y1: y1 as number,
		x2: x2 as number,
		y2: y2 as number,
	});
}

/**
 * Parse steps() function from AST node.
 *
 * @param node - CSS tree Function node
 * @returns Result with Steps object or error
 *
 * @internal
 */
function parseSteps(node: csstree.FunctionNode): Result<Type.Steps, string> {
	const children = node.children.toArray();
	let steps: number | undefined;
	let position: Type.Steps["position"] | undefined;

	for (const child of children) {
		if (child.type === "Number") {
			const value = Number.parseFloat(child.value);
			if (value <= 0 || !Number.isInteger(value)) {
				return err(`steps() requires a positive integer, got ${value}`);
			}
			steps = value;
		} else if (child.type === "Identifier") {
			const keyword = child.name.toLowerCase();
			if (STEP_POSITION_KEYWORDS.includes(keyword as (typeof STEP_POSITION_KEYWORDS)[number])) {
				position = keyword as Type.Steps["position"];
			} else {
				return err(`Invalid step position keyword: ${keyword}`);
			}
		} else if (child.type === "Operator" && "value" in child && child.value === ",") {
		} else {
			return err(`Invalid node in steps(): ${child.type}`);
		}
	}

	if (steps === undefined) {
		return err("steps() requires a step count");
	}

	return ok({
		type: "steps",
		steps,
		position,
	});
}

/**
 * Parse linear() function from AST node.
 *
 * @param node - CSS tree Function node
 * @returns Result with LinearEasing object or error
 *
 * @internal
 */
function parseLinear(node: csstree.FunctionNode): Result<Type.LinearEasing, string> {
	const children = node.children.toArray();
	const stops: Type.LinearStop[] = [];
	let currentOutput: number | undefined;
	let currentInput: number | undefined;

	for (let i = 0; i < children.length; i++) {
		const child = children[i];

		if (child?.type === "Number") {
			const value = Number.parseFloat(child.value);

			// Check if next node is a percentage (input value)
			const nextNode = children[i + 1];
			if (nextNode?.type === "Percentage") {
				currentOutput = value;
				currentInput = Number.parseFloat(nextNode.value) / 100;
				i++; // Skip the percentage node in next iteration

				stops.push({
					output: currentOutput,
					input: currentInput,
				});
				currentOutput = undefined;
				currentInput = undefined;
			} else {
				// Just an output value without input
				stops.push({
					output: value,
				});
			}
		} else if (child?.type === "Operator" && "value" in child && child.value === ",") {
		} else if (child?.type !== "WhiteSpace") {
			return err(`Invalid node in linear(): ${child?.type}`);
		}
	}

	if (stops.length === 0) {
		return err("linear() requires at least one stop");
	}

	return ok({
		type: "linear",
		stops,
	});
}

/**
 * Parse easing function from AST node.
 *
 * Supports keywords (ease, ease-in, etc.) and functions (cubic-bezier, steps, linear).
 *
 * @param node - CSS tree node to parse
 * @returns Result with EasingFunction or error
 *
 * @public
 */
export function parseEasingFunction(node: csstree.CssNode): Result<Type.EasingFunction, string> {
	// Keyword
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();
		if (EASING_KEYWORD_KEYWORDS.includes(keyword as (typeof EASING_KEYWORD_KEYWORDS)[number])) {
			return ok(keyword as (typeof EASING_KEYWORD_KEYWORDS)[number]);
		}
		return err(`Invalid easing keyword: ${keyword}`);
	}

	// Function
	if (node.type === "Function") {
		const name = node.name.toLowerCase();

		if (name === "cubic-bezier") {
			return parseCubicBezier(node);
		}

		if (name === "steps") {
			return parseSteps(node);
		}

		if (name === "linear") {
			return parseLinear(node);
		}

		return err(`Unknown easing function: ${name}`);
	}

	return err(`Expected easing function or keyword, got: ${node.type}`);
}


=== File: src/utils/parse/easing/index.ts ===
// b_path:: src/utils/parse/easing/index.ts
export * as EasingFunction from "./easing-function";


=== File: src/utils/parse/index.ts ===
// b_path:: src/utils/parse/index.ts

/**
 * Parsing utilities for CSS values and AST nodes.
 *
 * Re-exports utilities from:
 * - **nodes**: AST node parsing (length, angle, position, etc.)
 * - **color-components**: Color value parsing helpers
 * - **comma**: Comma-separated value splitting
 * - **easing**: Timing function parsing
 * - **url**: URL value parsing
 *
 * @module utils/parse
 */

export * from "./color-components";
export * from "./comma";
export * from "./easing";
export * from "./nodes";
export * from "./nodes/angle";
export * from "./nodes/border-radius";
export * from "./nodes/length";
export * from "./nodes/number";
export * from "./nodes/position";
export * from "./nodes/radial";
export * from "./url";


=== File: src/utils/parse/nodes.test.ts ===
// b_path:: src/utils/parse/nodes.test.ts

import * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { parseCornerValues, parseTRBLLengthPercentage } from "./nodes";

/**
 * Helper to create CSS nodes from a string
 */
function parseNodes(css: string): csstree.CssNode[] {
	const ast = csstree.parse(css, { context: "value" });
	const nodes: csstree.CssNode[] = [];
	csstree.walk(ast, (node) => {
		if (node.type === "Dimension" || node.type === "Percentage" || node.type === "Number") {
			nodes.push(node);
		}
	});
	return nodes;
}

describe("parseTRBLLengthPercentage", () => {
	describe("valid inputs", () => {
		it("should parse single value (all sides)", () => {
			const nodes = parseNodes("10px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse two values (vertical | horizontal)", () => {
			const nodes = parseNodes("10px 20px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse three values (top | horizontal | bottom)", () => {
			const nodes = parseNodes("10px 20px 30px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse four values (TRBL)", () => {
			const nodes = parseNodes("10px 20px 30px 40px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 40, unit: "px" });
			}
		});

		it("should handle mixed units", () => {
			const nodes = parseNodes("10px 50% 2em 0");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 50, unit: "%" });
				expect(result.value.bottom).toEqual({ value: 2, unit: "em" });
				expect(result.value.left).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should handle unitless zero", () => {
			const nodes = parseNodes("0 10px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
			}
		});
	});

	describe("invalid inputs", () => {
		it("should reject empty array", () => {
			const result = parseTRBLLengthPercentage([]);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 1-4");
			}
		});

		it("should reject more than 4 values", () => {
			const nodes = parseNodes("1px 2px 3px 4px 5px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 1-4");
			}
		});

		it("should reject unitless non-zero", () => {
			const ast = csstree.parse("10 20px", { context: "value" });
			const nodes: csstree.CssNode[] = [];
			csstree.walk(ast, (node) => {
				if (node.type === "Number" || node.type === "Dimension") {
					nodes.push(node);
				}
			});

			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless values must be zero");
			}
		});
	});
});

describe("parseCornerValues", () => {
	describe("valid inputs", () => {
		it("should parse single value (all corners)", () => {
			const nodes = parseNodes("5px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse two values (diagonal corners)", () => {
			const nodes = parseNodes("5px 10px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse three values", () => {
			const nodes = parseNodes("5px 10px 15px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 15, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse four values (all corners)", () => {
			const nodes = parseNodes("5px 10px 15px 20px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 15, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should handle unitless zero", () => {
			const nodes = parseNodes("0");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("invalid inputs", () => {
		it("should reject negative values", () => {
			const nodes = parseNodes("-5px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject empty array", () => {
			const result = parseCornerValues([]);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 1-4");
			}
		});

		it("should reject more than 4 values", () => {
			const nodes = parseNodes("1px 2px 3px 4px 5px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 1-4");
			}
		});
	});
});


=== File: src/utils/parse/nodes.ts ===
// b_path:: src/utils/parse/nodes.ts

// Re-export from subdirectory modules
export {
	parseCornerValues,
	parseRoundBorderRadius,
	parseTRBLLengthPercentage,
} from "./nodes/border-radius";
export { parseIdentifierNode } from "./nodes/number";
export { parseAtPosition, parsePosition2D, parsePositionValueNode } from "./nodes/position";
export { parseRadialSize } from "./nodes/radial";


=== File: src/utils/parse/nodes/angle.ts ===
// b_path:: src/utils/parse/nodes/angle.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as Unit from "@/core/units";

/**
 * Angle value parsing utilities.
 *
 * This module handles:
 * - CSS angle values (deg, rad, grad, turn)
 * - Unit validation and conversion
 *
 * @module utils/parse/nodes/angle
 */

/**
 * Parse a CSS dimension node into an Angle IR.
 *
 * Handles all CSS angle units using core unit definitions.
 *
 * @param node - CSS AST dimension node
 * @returns Result containing Angle IR or error message
 *
 * @public
 */
export function parseAngleNode(node: csstree.CssNode): Result<Type.Angle, string> {
	if (node.type === "Dimension") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid angle value");
		}

		// Use core unit validation
		if (!Unit.ANGLE_UNITS.includes(node.unit as (typeof Unit.ANGLE_UNITS)[number])) {
			return err(`Invalid angle unit: ${node.unit}`);
		}

		return ok({ value, unit: node.unit as (typeof Unit.ANGLE_UNITS)[number] });
	}
	return err("Expected angle dimension");
}


=== File: src/utils/parse/nodes/border-radius.ts ===
// b_path:: src/utils/parse/nodes/border-radius.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseLengthPercentageNode } from "./length";

/**
 * Parse CSS 4-value syntax (top, right, bottom, left).
 *
 * Accepts 1-4 length-percentage values following CSS 4-value expansion:
 * - 1 value: all sides
 * - 2 values: vertical | horizontal
 * - 3 values: top | horizontal | bottom
 * - 4 values: top | right | bottom | left (clockwise)
 *
 * Commonly used by margin, padding, inset(), scroll-margin, etc.
 *
 * @param nodes - Array of 1-4 CSS nodes
 * @returns Result with TRBL values or error
 *
 * @example
 * ```typescript
 * // Parse "10px 20px"
 * const result = parseTRBLLengthPercentage([node1, node2]);
 * // { top: 10px, right: 20px, bottom: 10px, left: 20px }
 * ```
 */
export function parseTRBLLengthPercentage(nodes: csstree.CssNode[]): Result<
	{
		top: Type.LengthPercentage;
		right: Type.LengthPercentage;
		bottom: Type.LengthPercentage;
		left: Type.LengthPercentage;
	},
	string
> {
	// Validate count
	if (nodes.length < 1 || nodes.length > 4) {
		return err(`Expected 1-4 length-percentage values, got ${nodes.length}`);
	}

	// Parse all values
	const values: Type.LengthPercentage[] = [];
	for (const node of nodes) {
		// Handle unitless zero
		if (node.type === "Number") {
			const val = Number.parseFloat(node.value);
			if (val !== 0) {
				return err("Unitless values must be zero");
			}
			values.push({ value: 0, unit: "px" });
			continue;
		}

		// Parse length-percentage
		const result = parseLengthPercentageNode(node);
		if (!result.ok) {
			return err(result.error);
		}
		values.push(result.value);
	}

	// Expand per CSS 4-value syntax
	switch (values.length) {
		case 1:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				top: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				right: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottom: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				left: values[0]!,
			});
		case 2:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				top: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				right: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottom: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				left: values[1]!,
			});
		case 3:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				top: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				right: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottom: values[2]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				left: values[1]!,
			});
		case 4:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				top: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				right: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottom: values[2]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				left: values[3]!,
			});
		default:
			return err("Invalid number of values");
	}
}

/**
 * Parse CSS corner values using TRBL expansion rules.
 *
 * This function parses 1-4 length-percentage values and expands them to
 * all 4 corners using the same expansion logic as CSS box model properties.
 * It is used by clip-path shapes (inset, rect, xywh) for border-radius values
 * after the 'round' keyword.
 *
 * **IMPORTANT**: This is NOT a CSS property parser. It parses multi-value
 * syntax used WITHIN other values. The actual border-radius property parser
 * is in `src/parse/border/radius.ts` and only accepts single values (longhand).
 *
 * Expansion rules (same as margin/padding):
 * - 1 value: all corners
 * - 2 values: (top-left/bottom-right) (top-right/bottom-left)
 * - 3 values: top-left (top-right/bottom-left) bottom-right
 * - 4 values: top-left top-right bottom-right bottom-left (clockwise from top-left)
 *
 * @param nodes - Array of 1-4 CSS nodes (length-percentage values, non-negative)
 * @returns Result with 4 corner values or error
 *
 * @example
 * Used in clip-path shapes:
 * ```typescript
 * // inset(10px round 5px 10px)
 * //                  ^^^^^^^^ these nodes
 * const result = parseCornerValues(radiusNodes);
 * // { topLeft: 5px, topRight: 10px, bottomRight: 5px, bottomLeft: 10px }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/inset | MDN: inset()}
 */
export function parseCornerValues(nodes: csstree.CssNode[]): Result<
	{
		topLeft: Type.LengthPercentage;
		topRight: Type.LengthPercentage;
		bottomRight: Type.LengthPercentage;
		bottomLeft: Type.LengthPercentage;
	},
	string
> {
	// Validate count
	if (nodes.length < 1 || nodes.length > 4) {
		return err(`Expected 1-4 border-radius values, got ${nodes.length}`);
	}

	// Parse all values
	const values: Type.LengthPercentage[] = [];
	for (const node of nodes) {
		// Handle unitless zero
		if (node.type === "Number") {
			const val = Number.parseFloat(node.value);
			if (val !== 0) {
				return err("Unitless values must be zero");
			}
			values.push({ value: 0, unit: "px" });
			continue;
		}

		// Parse length-percentage
		const result = parseLengthPercentageNode(node);
		if (!result.ok) {
			return err(result.error);
		}

		// Validate non-negative
		if (result.value.value < 0) {
			return err("border-radius values must be non-negative");
		}

		values.push(result.value);
	}

	// Expand per CSS 4-value syntax (clockwise from top-left)
	switch (values.length) {
		case 1:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topLeft: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topRight: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomRight: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomLeft: values[0]!,
			});
		case 2:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topLeft: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topRight: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomRight: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomLeft: values[1]!,
			});
		case 3:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topLeft: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topRight: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomRight: values[2]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomLeft: values[1]!,
			});
		case 4:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topLeft: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topRight: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomRight: values[2]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomLeft: values[3]!,
			});
		default:
			return err("Invalid number of values");
	}
}

/**
 * Parse optional 'round <border-radius>' clause from function arguments.
 *
 * Finds 'round' keyword and parses subsequent border-radius values.
 * Used by inset(), rect(), and xywh() shape functions.
 *
 * @param args - Function arguments (may contain 'round' keyword)
 * @returns Result with roundIndex and optional borderRadius
 *
 * @example
 * Basic usage:
 * ```typescript
 * // args = [10px, 20px, 'round', 5px, 10px]
 * const result = parseRoundBorderRadius(args);
 * // { roundIndex: 2, borderRadius: { topLeft: {...}, ... } }
 * ```
 *
 * @example
 * No 'round' keyword:
 * ```typescript
 * // args = [10px, 20px, 30px, 40px]
 * const result = parseRoundBorderRadius(args);
 * // { roundIndex: -1, borderRadius: undefined }
 * ```
 *
 * @example
 * Error case:
 * ```typescript
 * // args = [10px, 'round'] // no radius values!
 * const result = parseRoundBorderRadius(args);
 * // err("Expected border-radius values after 'round' keyword")
 * ```
 *
 * @public
 */
export function parseRoundBorderRadius(args: csstree.CssNode[]): Result<
	{
		roundIndex: number;
		borderRadius?: {
			topLeft: Type.LengthPercentage;
			topRight: Type.LengthPercentage;
			bottomRight: Type.LengthPercentage;
			bottomLeft: Type.LengthPercentage;
		};
	},
	string
> {
	// Find 'round' keyword position
	const roundIndex = args.findIndex((node) => node.type === "Identifier" && node.name.toLowerCase() === "round");

	// No 'round' keyword found - valid case
	if (roundIndex === -1) {
		return ok({ roundIndex: -1 });
	}

	// Get border-radius values (everything after 'round')
	const radiusNodes = args.slice(roundIndex + 1);

	// Must have at least one radius value
	if (radiusNodes.length === 0) {
		return err("Expected border-radius values after 'round' keyword");
	}

	// Parse border-radius using existing utility
	const radiusResult = parseCornerValues(radiusNodes);
	if (!radiusResult.ok) {
		return err(`Invalid border-radius: ${radiusResult.error}`);
	}

	return ok({
		roundIndex,
		borderRadius: radiusResult.value,
	});
}


=== File: src/utils/parse/nodes/index.ts ===
// b_path:: src/utils/parse/nodes/index.ts

/**
 * Node parsing utilities organized by domain.
 *
 * This module exports parsing utilities for CSS AST nodes,
 * organized into focused sub-modules by value type:
 *
 * - **angle**: Angle value parsing (deg, rad, grad, turn)
 * - **border-radius**: TRBL, corner values, and round keyword parsing
 * - **length**: Length, percentage, and length-percentage parsing
 * - **number**: Number and identifier keyword parsing
 * - **position**: 2D position value parsing (x/y coordinates)
 * - **radial**: Radial size parsing for circle/ellipse shapes
 *
 * Each module provides focused utilities for its domain, keeping
 * files small (<320 lines) and maintainable.
 *
 * @module utils/parse/nodes
 */

export * from "./angle";
export * from "./border-radius";
export * from "./length";
export * from "./number";
export * from "./position";
export * from "./radial";


=== File: src/utils/parse/nodes/length.ts ===
// b_path:: src/utils/parse/nodes/length.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as Unit from "@/core/units";

/**
 * Length and percentage value parsing utilities.
 *
 * This module handles:
 * - CSS length values (px, em, rem, vh, vw, etc.)
 * - Percentage values
 * - Unitless zero
 * - LengthPercentage union types
 * - Numeric values
 *
 * @module utils/parse/nodes/length
 */

/**
 * Parse a CSS dimension node into a Length IR.
 *
 * Handles all CSS length units using core unit definitions.
 * Replaces hardcoded unit arrays with centralized core units.
 *
 * @param node - CSS AST dimension node
 * @returns Result containing Length IR or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { parseLengthNode } from "@/utils/parse/nodes/length";
 *
 * const result = parseLengthNode(dimensionNode);
 * if (result.ok) {
 *   console.log(result.value); // { value: 100, unit: "px" }
 * }
 * ```
 */
export function parseLengthNode(node: csstree.CssNode): Result<Type.Length, string> {
	if (node.type === "Dimension") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid length value");
		}

		// Use core unit validation
		const allLengthUnits = [...Unit.ABSOLUTE_LENGTH_UNITS, ...Unit.FONT_LENGTH_UNITS, ...Unit.VIEWPORT_LENGTH_UNITS];

		if (!allLengthUnits.includes(node.unit as (typeof allLengthUnits)[number])) {
			return err(`Invalid length unit: ${node.unit}`);
		}

		return ok({
			value,
			unit: node.unit as (typeof allLengthUnits)[number],
		});
	}
	return err("Expected length dimension");
}

/**
 * Parse a CSS dimension or percentage node into a LengthPercentage IR.
 *
 * Handles both length units and percentage values using core definitions.
 *
 * @param node - CSS AST node (dimension or percentage)
 * @returns Result containing LengthPercentage IR or error message
 *
 * @public
 */
export function parseLengthPercentageNode(node: csstree.CssNode): Result<Type.LengthPercentage, string> {
	// Handle unitless zero
	if (node.type === "Number") {
		const val = Number.parseFloat(node.value);
		if (val !== 0) {
			return err("Unitless values must be zero");
		}
		return ok({ value: 0, unit: "px" });
	}

	if (node.type === "Dimension") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid length value");
		}

		// Use core unit validation for length units
		const allLengthUnits = [...Unit.ABSOLUTE_LENGTH_UNITS, ...Unit.FONT_LENGTH_UNITS, ...Unit.VIEWPORT_LENGTH_UNITS];

		if (!allLengthUnits.includes(node.unit as (typeof allLengthUnits)[number])) {
			return err(`Invalid length unit: ${node.unit}`);
		}

		return ok({
			value,
			unit: node.unit as (typeof allLengthUnits)[number],
		});
	}

	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value");
		}
		return ok({ value, unit: Unit.PERCENTAGE_UNIT });
	}

	return err("Expected length or percentage");
}

/**
 * Parse a CSS number node into a number.
 *
 * @param node - CSS AST number node
 * @returns Result containing number or error message
 *
 * @public
 */
export function parseNumberNode(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid number value");
		}
		return ok(value);
	}
	return err("Expected number");
}


=== File: src/utils/parse/nodes/number.ts ===
// b_path:: src/utils/parse/nodes/number.ts
/**
 * Number and identifier parsing utilities.
 *
 * This module handles:
 * - CSS identifier nodes
 * - Keyword extraction
 * - String values
 *
 * @module utils/parse/nodes/number
 */

// b_path:: src/utils/parse/nodes/number.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse a CSS identifier node into a string.
 *
 * @param node - CSS AST identifier node
 * @returns Result containing string or error message
 *
 * @public
 */
export function parseIdentifierNode(node: csstree.CssNode): Result<string, string> {
	if (node.type === "Identifier") {
		return ok(node.name.toLowerCase());
	}
	return err("Expected identifier");
}


=== File: src/utils/parse/nodes/position.ts ===
// b_path:: src/utils/parse/nodes/position.ts
/**
 * Position value parsing utilities.
 *
 * This module handles:
 * - CSS position values (background-position, object-position, etc.)
 * - 2D position parsing (x, y coordinates)
 * - Position keywords (top, bottom, left, right, center)
 * - "at" keyword position parsing (for clip-path, gradients)
 *
 * @module utils/parse/nodes/position
 */

// b_path:: src/utils/parse/nodes/position.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseLengthPercentageNode } from "./length";

/**
 * Parse a CSS value node into a PositionValue IR.
 *
 * Handles keywords, lengths, and percentages for position values.
 *
 * @param node - CSS AST node
 * @returns Result containing PositionValue IR or error message
 *
 * @public
 */
export function parsePositionValueNode(node: csstree.CssNode): Result<Type.PositionValue, string> {
	// Check for keyword first
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();
		// Position keywords
		if (["center", "left", "right", "top", "bottom"].includes(keyword)) {
			return ok(keyword as Type.PositionValue);
		}
		return err(`Invalid position keyword: ${keyword}`);
	}

	// Try parsing as length-percentage
	const lengthResult = parseLengthPercentageNode(node);
	if (lengthResult.ok) {
		return lengthResult;
	}

	return err("Expected position keyword, length, or percentage");
}

/**
 * Parse 2D position from CSS nodes.
 *
 * Handles CSS position syntax with 1-2 values.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @returns Result containing Position2D IR and next index, or error message
 *
 * @example
 * ```typescript
 * // Parse "center top"
 * const result = parsePosition2D([centerNode, topNode], 0);
 * // { position: { horizontal: "center", vertical: "top" }, nextIdx: 2 }
 * ```
 *
 * @public
 */
export function parsePosition2D(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	const positionValues: Type.PositionValue[] = [];

	if (idx >= nodes.length) {
		return err("Expected position value");
	}

	const firstNode = nodes[idx];
	if (!firstNode) return err("Missing first position value");
	const firstValue = parsePositionValueNode(firstNode);
	if (!firstValue.ok) {
		return err(`Invalid first position value: ${firstValue.error}`);
	}
	positionValues.push(firstValue.value);
	idx++;

	if (idx < nodes.length) {
		const secondNode = nodes[idx];
		if (secondNode) {
			const secondValue = parsePositionValueNode(secondNode);
			if (secondValue.ok) {
				positionValues.push(secondValue.value);
				idx++;
			}
		}
	}

	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Missing position value");
		}
		if (typeof val === "string") {
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Missing position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse optional position prefixed by 'at' keyword.
 *
 * Used by circle(), ellipse(), radial-gradient(), etc.
 *
 * Handles:
 * - No 'at' keyword: Returns { nextIdx } (no position parsed)
 * - 'at' keyword present: Parses following position, returns { position, nextIdx }
 * - 'at' without position: Error
 *
 * @param children - Array of CSS nodes
 * @param startIdx - Index to start parsing (should point at potential 'at' keyword)
 * @returns Result with optional position and nextIdx, or error
 *
 * @example
 * No 'at' keyword:
 * ```typescript
 * // children = [50px, 100px] // no 'at' keyword
 * const result = parseAtPosition(children, 0);
 * // ok({ nextIdx: 0 }) - no position parsed
 * ```
 *
 * @example
 * With 'at' and position:
 * ```typescript
 * // children = ['at', 'center', 'top']
 * const result = parseAtPosition(children, 0);
 * // ok({ position: { horizontal: "center", vertical: "top" }, nextIdx: 3 })
 * ```
 *
 * @example
 * Error case:
 * ```typescript
 * // children = [50px, 'at'] // no position values!
 * const result = parseAtPosition(children, 1);
 * // err("Expected position after 'at'")
 * ```
 *
 * @public
 */
export function parseAtPosition(
	children: csstree.CssNode[],
	startIdx: number,
): Result<{ position?: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Check if we have an 'at' keyword at current position
	if (idx >= children.length) {
		return ok({ nextIdx: idx });
	}

	const atNode = children[idx];
	if (atNode?.type !== "Identifier" || atNode.name.toLowerCase() !== "at") {
		// No 'at' keyword - valid case (position is optional)
		return ok({ nextIdx: idx });
	}

	// Found 'at' keyword - advance past it
	idx++;

	// Must have position values after 'at'
	const positionNodes = children.slice(idx);
	if (positionNodes.length === 0) {
		return err("Expected position after 'at'");
	}

	// Parse position using existing utility
	const posResult = parsePosition2D(positionNodes, 0);
	if (!posResult.ok) return posResult;

	return ok({
		position: posResult.value.position,
		nextIdx: idx + posResult.value.nextIdx,
	});
}


=== File: src/utils/parse/nodes/radial.ts ===
// b_path:: src/utils/parse/nodes/radial.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseLengthPercentageNode } from "./length";

/**
 * Parse radial size value (keyword or length-percentage).
 *
 * Handles both radial extent keywords (closest-side, farthest-side)
 * and numeric length-percentage values. Validates non-negative values.
 *
 * Used by circle() and ellipse() shape functions for radius values.
 *
 * @param node - AST node to parse (may be undefined)
 * @param propertyName - Name for error messages (e.g., "radius", "radiusX")
 * @param allowAtKeyword - If true, 'at' keyword returns undefined (not error)
 * @returns Result with parsed size value or undefined if node is undefined or 'at'
 *
 * @example
 * With keyword:
 * ```typescript
 * // node = Identifier { name: "closest-side" }
 * const result = parseRadialSize(node, "radius");
 * // ok("closest-side")
 * ```
 *
 * @example
 * With length-percentage:
 * ```typescript
 * // node = Dimension { value: 50, unit: "px" }
 * const result = parseRadialSize(node, "radiusX");
 * // ok({ value: 50, unit: "px" })
 * ```
 *
 * @example
 * No node (undefined):
 * ```typescript
 * const result = parseRadialSize(undefined, "radius");
 * // ok(undefined)
 * ```
 *
 * @example
 * 'at' keyword with allowAtKeyword=true:
 * ```typescript
 * // node = Identifier { name: "at" }
 * const result = parseRadialSize(node, "radiusX", true);
 * // ok(undefined) - signals to stop radius parsing
 * ```
 *
 * @example
 * Error - negative value:
 * ```typescript
 * // node = Dimension { value: -10, unit: "px" }
 * const result = parseRadialSize(node, "radius");
 * // err("radius must be non-negative")
 * ```
 *
 * @example
 * Error - invalid keyword:
 * ```typescript
 * // node = Identifier { name: "invalid" }
 * const result = parseRadialSize(node, "radius");
 * // err("Invalid keyword for radius: invalid")
 * ```
 *
 * @public
 */
export function parseRadialSize(
	node: csstree.CssNode | undefined,
	propertyName: string,
	allowAtKeyword = false,
): Result<"closest-side" | "farthest-side" | Type.LengthPercentage | undefined, string> {
	// No node provided - valid case
	if (!node) {
		return ok(undefined);
	}

	// Check for radial extent keywords
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();

		// Valid radial extent keywords
		if (keyword === "closest-side" || keyword === "farthest-side") {
			return ok(keyword);
		}

		// 'at' keyword handling (for ellipse - signals end of radius parsing)
		if (keyword === "at" && allowAtKeyword) {
			return ok(undefined);
		}

		// Invalid keyword
		return err(`Invalid keyword for ${propertyName}: ${keyword}`);
	}

	// Try parsing as length-percentage
	const lpResult = parseLengthPercentageNode(node);
	if (!lpResult.ok) {
		return lpResult;
	}

	// Validate non-negative
	if (lpResult.value.value < 0) {
		return err(`${propertyName} must be non-negative`);
	}

	return ok(lpResult.value);
}


=== File: src/utils/parse/url.ts ===
// b_path:: src/utils/parse/url.ts

import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { Url } from "@/core/types/url";
import * as ASTUtils from "@/utils/ast";

/**
 * Parse CSS url() function.
 *
 * Shared utility for parsing URL references across different CSS properties.
 * Handles quoted and unquoted URLs, fragment identifiers, file paths, etc.
 *
 * @param input - CSS string like "url(#id)" or "url('path.svg')"
 * @returns Result with Url IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/url_function}
 *
 * @example
 * ```typescript
 * import { parseUrl } from "@/utils/parse/url";
 *
 * const result = parseUrl("url(#clip-shape)");
 * // { ok: true, value: { kind: "url", value: "#clip-shape" } }
 *
 * const result2 = parseUrl("url('shapes.svg#clip')");
 * // { ok: true, value: { kind: "url", value: "shapes.svg#clip" } }
 * ```
 *
 * @public
 */
export function parseUrl(input: string): Result<Url, string> {
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	const ast = astResult.value;
	let foundUrl = "";

	csstree.walk(ast, {
		visit: "Url",
		enter(node: csstree.Url) {
			foundUrl = node.value;
			return false;
		},
	});

	if (foundUrl === "") {
		return err("Expected url() function");
	}

	return ok({ kind: "url", value: foundUrl });
}


