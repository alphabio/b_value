Excluding patterns: 
Documentation for LLMs
Excluding patterns: 
Excluding patterns: -not -path */__pycache__/* -not -path */.venv/* -not -path */.next/* -not -path */venv/* -not -path */node_modules/* -not -path */build/* -not -path */dist/* -not -path */.git/* -not -path */.idea/* -not -path */.vscode/*
=== File: src/core/index.ts ===
// b_path:: src/core/index.ts

export * as Keyword from "./keywords";
export * from "./result";
export * as Type from "./types";
export * as Unit from "./units";


=== File: src/core/keywords/align-content-keywords.test.ts ===
// b_path:: src/core/keywords/align-content-keywords.test.ts
import { describe, expect, it } from "vitest";
import { ALIGN_CONTENT_KEYWORDS, type AlignContentKeyword, alignContentKeywordsSchema } from "./align-content-keywords";

describe("alignContentKeywordsSchema", () => {
	it("accepts all valid align-content keywords", () => {
		const keywords: AlignContentKeyword[] = [
			"flex-start",
			"flex-end",
			"center",
			"space-between",
			"space-around",
			"space-evenly",
			"stretch",
			"start",
			"end",
		];

		for (const keyword of keywords) {
			expect(alignContentKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid align-content keywords", () => {
		expect(alignContentKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(alignContentKeywordsSchema.safeParse("").success).toBe(false);
		expect(alignContentKeywordsSchema.safeParse(123).success).toBe(false);
		expect(alignContentKeywordsSchema.safeParse("baseline").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(ALIGN_CONTENT_KEYWORDS).toHaveLength(9);
		expect(ALIGN_CONTENT_KEYWORDS).toContain("flex-start");
		expect(ALIGN_CONTENT_KEYWORDS).toContain("space-evenly");
	});
});


=== File: src/core/keywords/align-content-keywords.ts ===
// b_path:: src/core/keywords/align-content-keywords.ts
import { z } from "zod";

/**
 * CSS `align-content` property keyword values.
 *
 * The align-content property sets the distribution of space between and around
 * content items along a flexbox's cross-axis or a grid's block axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-content}
 *
 * @example
 * ```typescript
 * import { alignContentKeywordsSchema } from "@/core/keywords/align-content-keywords";
 *
 * const keyword = alignContentKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const alignContentKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items packed at start of cross axis"),
		z.literal("flex-end").describe("items packed at end of cross axis"),
		z.literal("center").describe("items centered along cross axis"),
		z.literal("space-between").describe("items evenly distributed, first/last at edges"),
		z.literal("space-around").describe("items evenly distributed with equal space around"),
		z.literal("space-evenly").describe("items evenly distributed with equal space between"),
		z.literal("stretch").describe("items stretched to fill container"),
		z.literal("start").describe("items packed at start of writing mode direction"),
		z.literal("end").describe("items packed at end of writing mode direction"),
	])
	.describe("CSS align-content property keyword values");

/**
 * Array of all align-content keyword values.
 *
 * @public
 */
export const ALIGN_CONTENT_KEYWORDS = alignContentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-content keywords.
 *
 * @public
 */
export type AlignContentKeyword = z.infer<typeof alignContentKeywordsSchema>;

/**
 * Metadata for align-content keyword options.
 *
 * @public
 */
export const alignContentKeywordOptions = alignContentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-content keyword options metadata.
 *
 * @public
 */
export type AlignContentKeywordOptions = typeof alignContentKeywordOptions;


=== File: src/core/keywords/align-items-keywords.test.ts ===
// b_path:: src/core/keywords/align-items-keywords.test.ts
import { describe, expect, it } from "vitest";
import { ALIGN_ITEMS_KEYWORDS, type AlignItemsKeyword, alignItemsKeywordsSchema } from "./align-items-keywords";

describe("alignItemsKeywordsSchema", () => {
	it("accepts all valid align-items keywords", () => {
		const keywords: AlignItemsKeyword[] = [
			"flex-start",
			"flex-end",
			"center",
			"baseline",
			"stretch",
			"start",
			"end",
			"self-start",
			"self-end",
		];

		for (const keyword of keywords) {
			expect(alignItemsKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid align-items keywords", () => {
		expect(alignItemsKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(alignItemsKeywordsSchema.safeParse("").success).toBe(false);
		expect(alignItemsKeywordsSchema.safeParse(123).success).toBe(false);
		expect(alignItemsKeywordsSchema.safeParse("space-between").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(ALIGN_ITEMS_KEYWORDS).toHaveLength(9);
		expect(ALIGN_ITEMS_KEYWORDS).toContain("flex-start");
		expect(ALIGN_ITEMS_KEYWORDS).toContain("self-end");
	});
});


=== File: src/core/keywords/align-items-keywords.ts ===
// b_path:: src/core/keywords/align-items-keywords.ts
import { z } from "zod";

/**
 * CSS `align-items` property keyword values.
 *
 * The align-items property sets the align-self value on all direct children as a group.
 * In flexbox, it controls the alignment of items on the cross axis. In grid layout,
 * it controls the alignment of items on the block axis within their grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-items}
 *
 * @example
 * ```typescript
 * import { alignItemsKeywordsSchema } from "@/core/keywords/align-items-keywords";
 *
 * const keyword = alignItemsKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const alignItemsKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items aligned at start of cross axis"),
		z.literal("flex-end").describe("items aligned at end of cross axis"),
		z.literal("center").describe("items centered along cross axis"),
		z.literal("baseline").describe("items aligned along their baselines"),
		z.literal("stretch").describe("items stretched to fill container"),
		z.literal("start").describe("items aligned at start of writing mode direction"),
		z.literal("end").describe("items aligned at end of writing mode direction"),
		z.literal("self-start").describe("items aligned at start of their own writing mode"),
		z.literal("self-end").describe("items aligned at end of their own writing mode"),
	])
	.describe("CSS align-items property keyword values");

/**
 * Array of all align-items keyword values.
 *
 * @public
 */
export const ALIGN_ITEMS_KEYWORDS = alignItemsKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-items keywords.
 *
 * @public
 */
export type AlignItemsKeyword = z.infer<typeof alignItemsKeywordsSchema>;

/**
 * Metadata for align-items keyword options.
 *
 * @public
 */
export const alignItemsKeywordOptions = alignItemsKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-items keyword options metadata.
 *
 * @public
 */
export type AlignItemsKeywordOptions = typeof alignItemsKeywordOptions;


=== File: src/core/keywords/align-self-keywords.test.ts ===
// b_path:: src/core/keywords/align-self-keywords.test.ts
import { describe, expect, it } from "vitest";
import { ALIGN_SELF_KEYWORDS, type AlignSelfKeyword, alignSelfKeywordsSchema } from "./align-self-keywords";

describe("alignSelfKeywordsSchema", () => {
	it("accepts all valid align-self keywords", () => {
		const keywords: AlignSelfKeyword[] = [
			"auto",
			"start",
			"end",
			"center",
			"stretch",
			"baseline",
			"flex-start",
			"flex-end",
			"self-start",
			"self-end",
		];

		for (const keyword of keywords) {
			expect(alignSelfKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid align-self keywords", () => {
		expect(alignSelfKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(alignSelfKeywordsSchema.safeParse("").success).toBe(false);
		expect(alignSelfKeywordsSchema.safeParse(123).success).toBe(false);
		expect(alignSelfKeywordsSchema.safeParse("space-between").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(ALIGN_SELF_KEYWORDS).toHaveLength(10);
		expect(ALIGN_SELF_KEYWORDS).toContain("auto");
		expect(ALIGN_SELF_KEYWORDS).toContain("self-end");
	});
});


=== File: src/core/keywords/align-self-keywords.ts ===
// b_path:: src/core/keywords/align-self-keywords.ts
import { z } from "zod";

/**
 * CSS `align-self` property keyword values.
 *
 * The align-self property overrides a grid or flex item's align-items value.
 * In grid layout, it aligns the item inside the grid area on the block axis (vertical).
 * In flexbox, it aligns the item on the cross axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-self}
 *
 * @example
 * ```typescript
 * import { alignSelfKeywordsSchema } from "@/core/keywords/align-self-keywords";
 *
 * const keyword = alignSelfKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const alignSelfKeywordsSchema = z
	.union([
		z.literal("auto").describe("uses parent's align-items value"),
		z.literal("start").describe("item aligned at start of writing mode direction"),
		z.literal("end").describe("item aligned at end of writing mode direction"),
		z.literal("center").describe("item centered along block axis"),
		z.literal("stretch").describe("item stretched to fill container"),
		z.literal("baseline").describe("item aligned along its baseline"),
		z.literal("flex-start").describe("item aligned at start of flex direction"),
		z.literal("flex-end").describe("item aligned at end of flex direction"),
		z.literal("self-start").describe("item aligned at start of its own writing mode"),
		z.literal("self-end").describe("item aligned at end of its own writing mode"),
	])
	.describe("CSS align-self property keyword values");

/**
 * Array of all align-self keyword values.
 *
 * @public
 */
export const ALIGN_SELF_KEYWORDS = alignSelfKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-self keywords.
 *
 * @public
 */
export type AlignSelfKeyword = z.infer<typeof alignSelfKeywordsSchema>;

/**
 * Metadata for align-self keyword options.
 *
 * @public
 */
export const alignSelfKeywordOptions = alignSelfKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-self keyword options metadata.
 *
 * @public
 */
export type AlignSelfKeywordOptions = typeof alignSelfKeywordOptions;


=== File: src/core/keywords/animation.ts ===
// b_path:: src/core/keywords/animation.ts

/**
 * CSS Animation Direction Keywords
 *
 * Keywords for the animation-direction property.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-direction}
 *
 * @public
 */
export const ANIMATION_DIRECTION_KEYWORDS = ["normal", "reverse", "alternate", "alternate-reverse"] as const;

/**
 * CSS Animation Direction Keyword Type
 *
 * @public
 */
export type AnimationDirectionKeyword = (typeof ANIMATION_DIRECTION_KEYWORDS)[number];

/**
 * CSS Animation Fill Mode Keywords
 *
 * Keywords for the animation-fill-mode property.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-fill-mode}
 *
 * @public
 */
export const ANIMATION_FILL_MODE_KEYWORDS = ["none", "forwards", "backwards", "both"] as const;

/**
 * CSS Animation Fill Mode Keyword Type
 *
 * @public
 */
export type AnimationFillModeKeyword = (typeof ANIMATION_FILL_MODE_KEYWORDS)[number];

/**
 * CSS Animation Play State Keywords
 *
 * Keywords for the animation-play-state property.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-play-state}
 *
 * @public
 */
export const ANIMATION_PLAY_STATE_KEYWORDS = ["running", "paused"] as const;

/**
 * CSS Animation Play State Keyword Type
 *
 * @public
 */
export type AnimationPlayStateKeyword = (typeof ANIMATION_PLAY_STATE_KEYWORDS)[number];

/**
 * CSS Easing Function Keywords
 *
 * Keyword values for easing functions (animation-timing-function, transition-timing-function).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function}
 * @see {@link https://www.w3.org/TR/css-easing-1/#easing-functions}
 *
 * @public
 */
export const EASING_KEYWORD_KEYWORDS = [
	"ease",
	"ease-in",
	"ease-out",
	"ease-in-out",
	"linear",
	"step-start",
	"step-end",
] as const;

/**
 * CSS Easing Function Keyword Type
 *
 * @public
 */
export type EasingKeywordKeyword = (typeof EASING_KEYWORD_KEYWORDS)[number];

/**
 * CSS Step Position Keywords
 *
 * Keywords for the step position parameter in steps() easing function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#steps}
 * @see {@link https://www.w3.org/TR/css-easing-1/#step-easing-functions}
 *
 * @public
 */
export const STEP_POSITION_KEYWORDS = ["jump-start", "jump-end", "jump-none", "jump-both", "start", "end"] as const;

/**
 * CSS Step Position Keyword Type
 *
 * @public
 */
export type StepPositionKeyword = (typeof STEP_POSITION_KEYWORDS)[number];


=== File: src/core/keywords/auto-keyword.test.ts ===
// b_path:: src/core/keywords/auto-keyword.test.ts
import { describe, expect, it } from "vitest";
import { AUTO_KEYWORD, type AutoKeyword, autoKeywordSchema } from "./auto-keyword";

describe("autoKeywordSchema", () => {
	it("accepts auto keyword", () => {
		const result = autoKeywordSchema.safeParse("auto");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("auto");
		}
	});

	it("rejects invalid keywords", () => {
		expect(autoKeywordSchema.safeParse("invalid").success).toBe(false);
		expect(autoKeywordSchema.safeParse("").success).toBe(false);
		expect(autoKeywordSchema.safeParse(123).success).toBe(false);
		expect(autoKeywordSchema.safeParse("none").success).toBe(false);
	});

	it("exports AUTO_KEYWORD constant", () => {
		expect(AUTO_KEYWORD).toBe("auto");
		const keyword: AutoKeyword = AUTO_KEYWORD;
		expect(keyword).toBe("auto");
	});
});


=== File: src/core/keywords/auto-keyword.ts ===
// b_path:: src/core/keywords/auto-keyword.ts
import { z } from "zod";

/**
 * CSS `auto` keyword.
 *
 * The `auto` keyword is used across many CSS properties to indicate
 * automatic calculation or default behavior. Context determines exact meaning.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/auto}
 *
 * @example
 * ```typescript
 * import { autoKeywordSchema } from "@/core/keywords/auto-keyword";
 *
 * // Parse and validate
 * const keyword = autoKeywordSchema.parse("auto"); // "auto"
 *
 * // Use in property values
 * const width = "auto";
 * ```
 *
 * @public
 */
export const autoKeywordSchema = z.literal("auto").describe("automatic calculation or default behavior");

/**
 * TypeScript type for the `auto` keyword.
 *
 * @public
 */
export type AutoKeyword = z.infer<typeof autoKeywordSchema>;

/**
 * Constant for the `auto` keyword value.
 *
 * @example
 * ```typescript
 * import { AUTO_KEYWORD } from "@/core/keywords/auto-keyword";
 *
 * if (value === AUTO_KEYWORD) {
 *   // Handle auto value
 * }
 * ```
 *
 * @public
 */
export const AUTO_KEYWORD = "auto" as const;

/**
 * Metadata for the `auto` keyword.
 *
 * Provides description for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { autoKeywordMetadata } from "@/core/keywords/auto-keyword";
 *
 * // Display in UI
 * <Option value="auto" description={autoKeywordMetadata.description} />
 * ```
 *
 * @public
 */
export const autoKeywordMetadata = {
	value: "auto",
	description: "automatic calculation or default behavior",
} as const;

/**
 * Type for auto keyword metadata.
 *
 * @public
 */
export type AutoKeywordMetadata = typeof autoKeywordMetadata;


=== File: src/core/keywords/background-attachment-keywords.test.ts ===
// b_path:: src/core/keywords/background-attachment-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	BACKGROUND_ATTACHMENT_KEYWORDS,
	type BackgroundAttachmentKeyword,
	type BackgroundAttachmentKeywordOptions,
	backgroundAttachmentKeywordOptions,
	backgroundAttachmentKeywordsSchema,
} from "./background-attachment-keywords";

describe("backgroundAttachmentKeywordsSchema", () => {
	it("accepts all valid keywords", () => {
		const keywords: BackgroundAttachmentKeyword[] = ["scroll", "fixed", "local"];
		for (const keyword of keywords) {
			expect(backgroundAttachmentKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keywords", () => {
		const invalid = ["invalid", "sticky", "absolute", ""];
		for (const keyword of invalid) {
			expect(backgroundAttachmentKeywordsSchema.safeParse(keyword).success).toBe(false);
		}
	});
});

describe("BACKGROUND_ATTACHMENT_KEYWORDS", () => {
	it("exports all keyword values", () => {
		expect(BACKGROUND_ATTACHMENT_KEYWORDS).toEqual(["scroll", "fixed", "local"]);
	});

	it("has correct length", () => {
		expect(BACKGROUND_ATTACHMENT_KEYWORDS).toHaveLength(3);
	});
});

describe("backgroundAttachmentKeywordOptions", () => {
	it("provides metadata for all keywords", () => {
		expect(backgroundAttachmentKeywordOptions).toHaveLength(3);
		for (const option of backgroundAttachmentKeywordOptions) {
			expect(option).toHaveProperty("value");
			expect(option).toHaveProperty("description");
			expect(typeof option.value).toBe("string");
			expect(typeof option.description).toBe("string");
		}
	});

	it("matches BACKGROUND_ATTACHMENT_KEYWORDS values", () => {
		const optionValues = backgroundAttachmentKeywordOptions.map((opt) => opt.value);
		expect(optionValues).toEqual(BACKGROUND_ATTACHMENT_KEYWORDS);
	});
});

describe("Type exports", () => {
	it("exports BackgroundAttachmentKeyword type", () => {
		const keyword: BackgroundAttachmentKeyword = "fixed";
		expect(keyword).toBeDefined();
	});

	it("exports BackgroundAttachmentKeywordOptions type", () => {
		const options: BackgroundAttachmentKeywordOptions = backgroundAttachmentKeywordOptions;
		expect(options).toBeDefined();
	});
});


=== File: src/core/keywords/background-attachment-keywords.ts ===
// b_path:: src/core/keywords/background-attachment-keywords.ts
import { z } from "zod";

/**
 * CSS background-attachment keywords.
 *
 * The background-attachment property sets whether a background image's position
 * is fixed within the viewport, or scrolls with its containing block.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment}
 *
 * @example
 * ```typescript
 * import { backgroundAttachmentKeywordsSchema } from "@/core/keywords/background-attachment-keywords";
 *
 * const keyword = backgroundAttachmentKeywordsSchema.parse("fixed"); // "fixed"
 * ```
 *
 * @public
 */
export const backgroundAttachmentKeywordsSchema = z
	.union([
		z
			.literal("scroll")
			.describe("background is fixed relative to the element itself and does not scroll with its contents"),
		z.literal("fixed").describe("background is fixed relative to the viewport"),
		z.literal("local").describe("background is fixed relative to the element's contents and scrolls with them"),
	])
	.describe(
		"Background attachment keywords control whether a background image scrolls with the page or is fixed. " +
			"Used in the background-attachment property.",
	);

/**
 * Array of all background-attachment keyword values.
 *
 * @example
 * ```typescript
 * import { BACKGROUND_ATTACHMENT_KEYWORDS } from "@/core/keywords/background-attachment-keywords";
 *
 * console.log(BACKGROUND_ATTACHMENT_KEYWORDS); // ["scroll", "fixed", "local"]
 * ```
 *
 * @public
 */
export const BACKGROUND_ATTACHMENT_KEYWORDS = backgroundAttachmentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for background-attachment keywords.
 *
 * @public
 */
export type BackgroundAttachmentKeyword = z.infer<typeof backgroundAttachmentKeywordsSchema>;

/**
 * Metadata for background-attachment keyword options.
 *
 * Provides value and description for each background-attachment keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { backgroundAttachmentKeywordOptions } from "@/core/keywords/background-attachment-keywords";
 *
 * backgroundAttachmentKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const backgroundAttachmentKeywordOptions = backgroundAttachmentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for background-attachment keyword options metadata.
 *
 * @public
 */
export type BackgroundAttachmentKeywordOptions = typeof backgroundAttachmentKeywordOptions;


=== File: src/core/keywords/basic-color-keywords.test.ts ===
// b_path:: src/core/keywords/basic-color-keywords.test.ts
import { describe, expect, it } from "vitest";
import { BASIC_NAMED_COLOR_KEYWORDS, basicNamedColorKeywordsSchema } from "./basic-color-keywords";

describe("basicNamedColorKeywordsSchema", () => {
	it("accepts all valid basic color keywords", () => {
		for (const keyword of BASIC_NAMED_COLOR_KEYWORDS) {
			expect(basicNamedColorKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keyword", () => {
		expect(basicNamedColorKeywordsSchema.safeParse("invalidcolor").success).toBe(false);
	});

	it("rejects empty string", () => {
		expect(basicNamedColorKeywordsSchema.safeParse("").success).toBe(false);
	});

	it("rejects null", () => {
		expect(basicNamedColorKeywordsSchema.safeParse(null).success).toBe(false);
	});

	it("rejects undefined", () => {
		expect(basicNamedColorKeywordsSchema.safeParse(undefined).success).toBe(false);
	});

	it("rejects number", () => {
		expect(basicNamedColorKeywordsSchema.safeParse(123).success).toBe(false);
	});
});

describe("BASIC_NAMED_COLOR_KEYWORDS array", () => {
	it("contains expected number of keywords", () => {
		expect(BASIC_NAMED_COLOR_KEYWORDS.length).toBe(22);
	});

	it("contains primary colors", () => {
		expect(BASIC_NAMED_COLOR_KEYWORDS).toContain("black");
		expect(BASIC_NAMED_COLOR_KEYWORDS).toContain("white");
		expect(BASIC_NAMED_COLOR_KEYWORDS).toContain("red");
		expect(BASIC_NAMED_COLOR_KEYWORDS).toContain("green");
		expect(BASIC_NAMED_COLOR_KEYWORDS).toContain("blue");
	});

	it("contains both gray spellings", () => {
		expect(BASIC_NAMED_COLOR_KEYWORDS).toContain("gray");
		expect(BASIC_NAMED_COLOR_KEYWORDS).toContain("grey");
	});
});


=== File: src/core/keywords/basic-color-keywords.ts ===
// b_path:: src/core/keywords/basic-color-keywords.ts
import { z } from "zod";

/**
 * CSS basic named colors (22 colors).
 *
 * Common subset of named colors for basic use cases.
 * These are the most commonly used color names in CSS.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const basicNamedColorKeywordsSchema = z
	.union([
		z.literal("black").describe("Pure black color (#000000)"),
		z.literal("white").describe("Pure white color (#FFFFFF)"),
		z.literal("red").describe("Pure red color (#FF0000)"),
		z.literal("green").describe("Pure green color (#008000)"),
		z.literal("blue").describe("Pure blue color (#0000FF)"),
		z.literal("yellow").describe("Pure yellow color (#FFFF00)"),
		z.literal("orange").describe("Orange color (#FFA500)"),
		z.literal("purple").describe("Purple color (#800080)"),
		z.literal("pink").describe("Pink color (#FFC0CB)"),
		z.literal("brown").describe("Brown color (#A52A2A)"),
		z.literal("gray").describe("Gray color (#808080)"),
		z.literal("grey").describe("Alternative spelling of gray"),
		z.literal("silver").describe("Silver color (#C0C0C0)"),
		z.literal("gold").describe("Gold color (#FFD700)"),
		z.literal("navy").describe("Navy blue color (#000080)"),
		z.literal("teal").describe("Teal color (#008080)"),
		z.literal("lime").describe("Lime color (#00FF00)"),
		z.literal("aqua").describe("Aqua color (#00FFFF)"),
		z.literal("fuchsia").describe("Fuchsia color (#FF00FF)"),
		z.literal("maroon").describe("Maroon color (#800000)"),
		z.literal("olive").describe("Olive color (#808000)"),
		z.literal("cyan").describe("Cyan color (#00FFFF)"),
	])
	.describe("CSS basic named colors");

/**
 * Array of all basic named color keyword values.
 *
 * @example
 * ```typescript
 * import { BASIC_NAMED_COLOR_KEYWORDS } from "@/core/keywords/basic-color-keywords";
 *
 * console.log(BASIC_NAMED_COLOR_KEYWORDS); // ["black", "white", "red", ...]
 * ```
 *
 * @public
 */
export const BASIC_NAMED_COLOR_KEYWORDS = basicNamedColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for basic named color keywords.
 *
 * @public
 */
export type BasicNamedColorKeyword = z.infer<typeof basicNamedColorKeywordsSchema>;

/**
 * Metadata for basic named color keyword options.
 *
 * Provides value and description for each basic named color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { basicNamedColorKeywordOptions } from "@/core/keywords/basic-color-keywords";
 *
 * basicNamedColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const basicNamedColorKeywordOptions = basicNamedColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for basic named color keyword options metadata.
 *
 * @public
 */
export type BasicNamedColorKeywordOptions = typeof basicNamedColorKeywordOptions;


=== File: src/core/keywords/blend-mode-keywords.test.ts ===
// b_path:: src/core/keywords/blend-mode-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	BLEND_MODE_KEYWORDS,
	type BlendModeKeyword,
	blendModeKeywordOptions,
	blendModeKeywordsSchema,
} from "./blend-mode-keywords";

describe("blendModeKeywordsSchema", () => {
	it("accepts all valid blend mode keywords", () => {
		const keywords: BlendModeKeyword[] = [
			"normal",
			"multiply",
			"screen",
			"overlay",
			"darken",
			"lighten",
			"color-dodge",
			"color-burn",
			"hard-light",
			"soft-light",
			"difference",
			"exclusion",
			"hue",
			"saturation",
			"color",
			"luminosity",
		];
		for (const keyword of keywords) {
			expect(blendModeKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keywords", () => {
		const invalid = ["invalid", "add", "subtract", "divide", "blend", "", 123, null, undefined];
		for (const value of invalid) {
			expect(blendModeKeywordsSchema.safeParse(value).success).toBe(false);
		}
	});

	it("exports correct BLEND_MODE_KEYWORDS array", () => {
		expect(BLEND_MODE_KEYWORDS).toHaveLength(16);
		expect(BLEND_MODE_KEYWORDS).toContain("normal");
		expect(BLEND_MODE_KEYWORDS).toContain("multiply");
		expect(BLEND_MODE_KEYWORDS).toContain("screen");
		expect(BLEND_MODE_KEYWORDS).toContain("overlay");
	});

	it("exports keyword options with descriptions", () => {
		expect(blendModeKeywordOptions).toHaveLength(16);
		for (const option of blendModeKeywordOptions) {
			expect(option).toHaveProperty("value");
			expect(option).toHaveProperty("description");
			expect(typeof option.value).toBe("string");
			expect(typeof option.description).toBe("string");
		}
	});

	it("has descriptions for color modes", () => {
		const hueOption = blendModeKeywordOptions.find((opt) => opt.value === "hue");
		expect(hueOption?.description).toContain("hue");

		const saturationOption = blendModeKeywordOptions.find((opt) => opt.value === "saturation");
		expect(saturationOption?.description).toContain("saturation");

		const colorOption = blendModeKeywordOptions.find((opt) => opt.value === "color");
		expect(colorOption?.description).toContain("hue");

		const luminosityOption = blendModeKeywordOptions.find((opt) => opt.value === "luminosity");
		expect(luminosityOption?.description).toContain("luminosity");
	});

	it("has descriptions for mathematical modes", () => {
		const multiplyOption = blendModeKeywordOptions.find((opt) => opt.value === "multiply");
		expect(multiplyOption?.description).toContain("multiply");

		const screenOption = blendModeKeywordOptions.find((opt) => opt.value === "screen");
		expect(screenOption?.description).toContain("invert");
	});

	it("includes all dodge and burn modes", () => {
		expect(BLEND_MODE_KEYWORDS).toContain("color-dodge");
		expect(BLEND_MODE_KEYWORDS).toContain("color-burn");
	});

	it("includes all light modes", () => {
		expect(BLEND_MODE_KEYWORDS).toContain("hard-light");
		expect(BLEND_MODE_KEYWORDS).toContain("soft-light");
	});

	it("includes difference modes", () => {
		expect(BLEND_MODE_KEYWORDS).toContain("difference");
		expect(BLEND_MODE_KEYWORDS).toContain("exclusion");
	});

	it("includes darken and lighten modes", () => {
		expect(BLEND_MODE_KEYWORDS).toContain("darken");
		expect(BLEND_MODE_KEYWORDS).toContain("lighten");
	});
});


=== File: src/core/keywords/blend-mode-keywords.ts ===
// b_path:: src/core/keywords/blend-mode-keywords.ts
import { z } from "zod";

/**
 * CSS blend mode keywords.
 *
 * Blend modes describe how colors should appear when elements overlap.
 * Each mode defines a different way to combine the top and bottom colors.
 *
 * Used in:
 * - `background-blend-mode` - Blending between background layers
 * - `mix-blend-mode` - Blending an element with its backdrop
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/blend-mode}
 *
 * @example
 * ```typescript
 * import { blendModeKeywordsSchema } from "@/core/keywords/blend-mode-keywords";
 *
 * const keyword = blendModeKeywordsSchema.parse("multiply"); // "multiply"
 * ```
 *
 * @public
 */
export const blendModeKeywordsSchema = z.enum(
	[
		"normal",
		"multiply",
		"screen",
		"overlay",
		"darken",
		"lighten",
		"color-dodge",
		"color-burn",
		"hard-light",
		"soft-light",
		"difference",
		"exclusion",
		"hue",
		"saturation",
		"color",
		"luminosity",
	],
	{
		error: () => ({
			message:
				"Expected normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
		}),
	},
);

/**
 * Array of all blend mode keyword values.
 *
 * @example
 * ```typescript
 * import { BLEND_MODE_KEYWORDS } from "@/core/keywords/blend-mode-keywords";
 *
 * console.log(BLEND_MODE_KEYWORDS);
 * // ["normal", "multiply", "screen", "overlay", "darken", "lighten", ...]
 * ```
 *
 * @public
 */
export const BLEND_MODE_KEYWORDS = blendModeKeywordsSchema.options;

/**
 * TypeScript type for blend mode keywords.
 *
 * @public
 */
export type BlendModeKeyword = z.infer<typeof blendModeKeywordsSchema>;

/**
 * Descriptions for blend mode keywords.
 *
 * @internal
 */
const BLEND_MODE_DESCRIPTIONS: Record<BlendModeKeyword, string> = {
	normal: "top color, regardless of bottom color",
	multiply: "result of multiplying top and bottom colors",
	screen: "result of inverting colors, multiplying, and inverting",
	overlay: "multiply if bottom darker, screen if bottom lighter",
	darken: "darkest values of each color channel",
	lighten: "lightest values of each color channel",
	"color-dodge": "dividing bottom color by inverse of top color",
	"color-burn": "inverting bottom, dividing by top, inverting result",
	"hard-light": "multiply if top darker, screen if top lighter",
	"soft-light": "similar to hard-light but softer",
	difference: "subtracting darker color from lighter",
	exclusion: "similar to difference but with less contrast",
	hue: "hue of top color, saturation and luminosity of bottom",
	saturation: "saturation of top color, hue and luminosity of bottom",
	color: "hue and saturation of top, luminosity of bottom",
	luminosity: "luminosity of top, hue and saturation of bottom",
};

/**
 * Metadata for blend mode keyword options.
 *
 * Provides value and description for each blend mode keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { blendModeKeywordOptions } from "@/core/keywords/blend-mode-keywords";
 *
 * blendModeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const blendModeKeywordOptions = BLEND_MODE_KEYWORDS.map((value) => ({
	value,
	description: BLEND_MODE_DESCRIPTIONS[value],
}));

/**
 * Type for blend mode keyword options metadata.
 *
 * @public
 */
export type BlendModeKeywordOptions = typeof blendModeKeywordOptions;


=== File: src/core/keywords/border-style-keywords.test.ts ===
// b_path:: src/core/keywords/border-style-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	BORDER_STYLE_KEYWORDS,
	type BorderStyleKeyword,
	borderStyleKeywordOptions,
	borderStyleKeywordsSchema,
} from "./border-style-keywords";

describe("borderStyleKeywordsSchema", () => {
	it("accepts all valid border-style keywords", () => {
		const keywords: BorderStyleKeyword[] = [
			"none",
			"hidden",
			"dotted",
			"dashed",
			"solid",
			"double",
			"groove",
			"ridge",
			"inset",
			"outset",
		];
		for (const keyword of keywords) {
			expect(borderStyleKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keywords", () => {
		const invalid = ["invalid", "auto", "wavy", "", 123, null, undefined];
		for (const value of invalid) {
			expect(borderStyleKeywordsSchema.safeParse(value).success).toBe(false);
		}
	});

	it("exports correct BORDER_STYLE_KEYWORDS array", () => {
		expect(BORDER_STYLE_KEYWORDS).toHaveLength(10);
		expect(BORDER_STYLE_KEYWORDS).toContain("solid");
		expect(BORDER_STYLE_KEYWORDS).toContain("none");
		expect(BORDER_STYLE_KEYWORDS).toContain("hidden");
		expect(BORDER_STYLE_KEYWORDS).toContain("dotted");
		expect(BORDER_STYLE_KEYWORDS).toContain("dashed");
		expect(BORDER_STYLE_KEYWORDS).toContain("double");
		expect(BORDER_STYLE_KEYWORDS).toContain("groove");
		expect(BORDER_STYLE_KEYWORDS).toContain("ridge");
		expect(BORDER_STYLE_KEYWORDS).toContain("inset");
		expect(BORDER_STYLE_KEYWORDS).toContain("outset");
	});

	it("exports keyword options with descriptions", () => {
		expect(borderStyleKeywordOptions).toHaveLength(10);
		for (const option of borderStyleKeywordOptions) {
			expect(option).toHaveProperty("value");
			expect(option).toHaveProperty("description");
			expect(typeof option.value).toBe("string");
			expect(typeof option.description).toBe("string");
		}
	});

	it("has description for each keyword", () => {
		const solidOption = borderStyleKeywordOptions.find((opt) => opt.value === "solid");
		expect(solidOption?.description).toContain("solid line");

		const noneOption = borderStyleKeywordOptions.find((opt) => opt.value === "none");
		expect(noneOption?.description).toContain("No border");
	});
});


=== File: src/core/keywords/border-style-keywords.ts ===
// b_path:: src/core/keywords/border-style-keywords.ts
import { z } from "zod";

/**
 * CSS border-style keywords.
 *
 * Defines the style of the border line for all four sides of an element's border.
 * These keywords control how the border appears visually.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style}
 *
 * @example
 * ```typescript
 * import { borderStyleKeywordsSchema } from "@/core/keywords/border-style-keywords";
 *
 * const keyword = borderStyleKeywordsSchema.parse("solid"); // "solid"
 * ```
 *
 * @public
 */
export const borderStyleKeywordsSchema = z
	.union([
		z.literal("none").describe("No border"),
		z.literal("hidden").describe("Same as none, but with different behavior in table elements"),
		z.literal("dotted").describe("Series of round dots"),
		z.literal("dashed").describe("Series of short square-ended dashes"),
		z.literal("solid").describe("Single, straight, solid line"),
		z.literal("double").describe("Two straight lines that add up to the pixel size defined by border-width"),
		z.literal("groove").describe("Carved effect - opposite of ridge"),
		z.literal("ridge").describe("Extruded effect - opposite of groove"),
		z.literal("inset").describe("Border makes element appear embedded"),
		z.literal("outset").describe("Border makes element appear raised"),
	])
	.describe("CSS border style keywords");

/**
 * Array of all border-style keyword values.
 *
 * @example
 * ```typescript
 * import { BORDER_STYLE_KEYWORDS } from "@/core/keywords/border-style-keywords";
 *
 * console.log(BORDER_STYLE_KEYWORDS); // ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
 * ```
 *
 * @public
 */
export const BORDER_STYLE_KEYWORDS = borderStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for border-style keywords.
 *
 * @public
 */
export type BorderStyleKeyword = z.infer<typeof borderStyleKeywordsSchema>;

/**
 * Metadata for border-style keyword options.
 *
 * Provides value and description for each border-style keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { borderStyleKeywordOptions } from "@/core/keywords/border-style-keywords";
 *
 * borderStyleKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const borderStyleKeywordOptions = borderStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for border-style keyword options metadata.
 *
 * @public
 */
export type BorderStyleKeywordOptions = typeof borderStyleKeywordOptions;


=== File: src/core/keywords/border-width-keywords.test.ts ===
// b_path:: src/core/keywords/border-width-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	BORDER_WIDTH_KEYWORDS,
	type BorderWidthKeyword,
	type BorderWidthKeywordOptions,
	type BorderWidthValue,
	borderWidthKeywordOptions,
	borderWidthKeywordsSchema,
} from "./border-width-keywords";

describe("borderWidthKeywordsSchema", () => {
	it("accepts all valid keywords", () => {
		const keywords: BorderWidthKeyword[] = ["thin", "medium", "thick"];
		for (const keyword of keywords) {
			expect(borderWidthKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keywords", () => {
		const invalid = ["invalid", "large", "small", ""];
		for (const keyword of invalid) {
			expect(borderWidthKeywordsSchema.safeParse(keyword).success).toBe(false);
		}
	});
});

describe("BORDER_WIDTH_KEYWORDS", () => {
	it("exports all keyword values", () => {
		expect(BORDER_WIDTH_KEYWORDS).toEqual(["thin", "medium", "thick"]);
	});

	it("has correct length", () => {
		expect(BORDER_WIDTH_KEYWORDS).toHaveLength(3);
	});
});

describe("borderWidthKeywordOptions", () => {
	it("provides metadata for all keywords", () => {
		expect(borderWidthKeywordOptions).toHaveLength(3);
		for (const option of borderWidthKeywordOptions) {
			expect(option).toHaveProperty("value");
			expect(option).toHaveProperty("description");
			expect(typeof option.value).toBe("string");
			expect(typeof option.description).toBe("string");
		}
	});

	it("matches BORDER_WIDTH_KEYWORDS values", () => {
		const optionValues = borderWidthKeywordOptions.map((opt) => opt.value);
		expect(optionValues).toEqual(BORDER_WIDTH_KEYWORDS);
	});
});

describe("Type exports", () => {
	it("exports BorderWidthKeyword type", () => {
		const keyword: BorderWidthKeyword = "medium";
		expect(keyword).toBeDefined();
	});

	it("exports BorderWidthValue type", () => {
		const value1: BorderWidthValue = "thin";
		const value2: BorderWidthValue = { value: 2, unit: "px" };
		expect(value1).toBeDefined();
		expect(value2).toBeDefined();
	});

	it("exports BorderWidthKeywordOptions type", () => {
		const options: BorderWidthKeywordOptions = borderWidthKeywordOptions;
		expect(options).toBeDefined();
	});
});


=== File: src/core/keywords/border-width-keywords.ts ===
// b_path:: src/core/keywords/border-width-keywords.ts
import { z } from "zod";
import type * as Type from "../types";

/**
 * CSS border-width keywords.
 *
 * Predefined border width values that correspond to specific thickness levels.
 * These keywords provide a convenient way to specify common border widths without
 * needing to specify exact measurements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width}
 *
 * @example
 * ```typescript
 * import { borderWidthKeywordsSchema } from "@/core/keywords/border-width-keywords";
 *
 * const keyword = borderWidthKeywordsSchema.parse("medium"); // "medium"
 * ```
 *
 * @public
 */
export const borderWidthKeywordsSchema = z
	.union([
		z.literal("thin").describe("A thin border (typically 1px)"),
		z.literal("medium").describe("A medium border (typically 3px)"),
		z.literal("thick").describe("A thick border (typically 5px)"),
	])
	.describe("Predefined border width keywords");

/**
 * Array of all border-width keyword values.
 *
 * @example
 * ```typescript
 * import { BORDER_WIDTH_KEYWORDS } from "@/core/keywords/border-width-keywords";
 *
 * console.log(BORDER_WIDTH_KEYWORDS); // ["thin", "medium", "thick"]
 * ```
 *
 * @public
 */
export const BORDER_WIDTH_KEYWORDS = borderWidthKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for border-width keywords.
 *
 * @public
 */
export type BorderWidthKeyword = z.infer<typeof borderWidthKeywordsSchema>;

/**
 * TypeScript type for border-width values (keywords or length).
 *
 * @public
 */
export type BorderWidthValue = z.infer<typeof borderWidthKeywordsSchema> | Type.Length;

/**
 * Metadata for border-width keyword options.
 *
 * Provides value and description for each border-width keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { borderWidthKeywordOptions } from "@/core/keywords/border-width-keywords";
 *
 * borderWidthKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const borderWidthKeywordOptions = borderWidthKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for border-width keyword options metadata.
 *
 * @public
 */
export type BorderWidthKeywordOptions = typeof borderWidthKeywordOptions;


=== File: src/core/keywords/box-edge-keywords.test.ts ===
// b_path:: src/core/keywords/box-edge-keywords.test.ts
import { describe, expect, it } from "vitest";
import { BOX_EDGE_KEYWORDS, boxEdgeKeywordsSchema } from "./box-edge-keywords";

describe("boxEdgeKeywordsSchema", () => {
	it("accepts all valid box edge keywords", () => {
		for (const keyword of BOX_EDGE_KEYWORDS) {
			expect(boxEdgeKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("accepts content-box", () => {
		expect(boxEdgeKeywordsSchema.safeParse("content-box").success).toBe(true);
	});

	it("accepts padding-box", () => {
		expect(boxEdgeKeywordsSchema.safeParse("padding-box").success).toBe(true);
	});

	it("accepts border-box", () => {
		expect(boxEdgeKeywordsSchema.safeParse("border-box").success).toBe(true);
	});

	it("accepts margin-box", () => {
		expect(boxEdgeKeywordsSchema.safeParse("margin-box").success).toBe(true);
	});

	it("accepts fill-box", () => {
		expect(boxEdgeKeywordsSchema.safeParse("fill-box").success).toBe(true);
	});

	it("accepts stroke-box", () => {
		expect(boxEdgeKeywordsSchema.safeParse("stroke-box").success).toBe(true);
	});

	it("accepts view-box", () => {
		expect(boxEdgeKeywordsSchema.safeParse("view-box").success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		expect(boxEdgeKeywordsSchema.safeParse("invalid-box").success).toBe(false);
	});

	it("rejects empty string", () => {
		expect(boxEdgeKeywordsSchema.safeParse("").success).toBe(false);
	});
});

describe("BOX_EDGE_KEYWORDS array", () => {
	it("contains expected number of keywords", () => {
		expect(BOX_EDGE_KEYWORDS.length).toBe(7);
	});

	it("contains visual box keywords", () => {
		expect(BOX_EDGE_KEYWORDS).toContain("content-box");
		expect(BOX_EDGE_KEYWORDS).toContain("padding-box");
		expect(BOX_EDGE_KEYWORDS).toContain("border-box");
	});

	it("contains SVG box keywords", () => {
		expect(BOX_EDGE_KEYWORDS).toContain("fill-box");
		expect(BOX_EDGE_KEYWORDS).toContain("stroke-box");
	});
});


=== File: src/core/keywords/box-edge-keywords.ts ===
// b_path:: src/core/keywords/box-edge-keywords.ts
import { z } from "zod";
import { visualBoxKeywords } from "./geometry-box";

/**
 * CSS box edge keywords.
 *
 * Box edge keywords define reference boxes for positioning, clipping, and layout.
 * Used in properties like clip-path, shape-outside, background-clip, and background-origin.
 *
 * Note: For spec-compliant visual-box, shape-box, and geometry-box hierarchies,
 * see geometry-box.ts which follows the CSS specification exactly.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-edge}
 *
 * @example
 * ```typescript
 * import { boxEdgeKeywordsSchema } from "@/core/keywords/box-edge-keywords";
 *
 * const keyword = boxEdgeKeywordsSchema.parse("border-box"); // "border-box"
 * ```
 *
 * @public
 */
export const boxEdgeKeywordsSchema = z
	.union([
		// Visual box (content, padding, border)
		z
			.literal("content-box")
			.describe("outer edge of the box's content area"),
		z.literal("padding-box").describe("outer edge of the padding of the box"),
		z.literal("border-box").describe("outer edge of the border of the box"),

		// Layout box (includes margin)
		z
			.literal("margin-box")
			.describe("outer edge of the margin of the box"),

		// SVG-specific boxes
		z
			.literal("fill-box")
			.describe("object bounding box in SVG"),
		z.literal("stroke-box").describe("stroke bounding box in SVG"),
		z.literal("view-box").describe("nearest SVG viewport element's origin box"),
	])
	.describe(
		"Box edge keywords define reference boxes for positioning, clipping, and layout. " +
			"Used in properties like clip-path, shape-outside, background-clip, and background-origin.",
	);

/**
 * Array of all box edge keyword values.
 *
 * @example
 * ```typescript
 * import { BOX_EDGE_KEYWORDS } from "@/core/keywords/box-edge-keywords";
 *
 * console.log(BOX_EDGE_KEYWORDS);
 * // ["content-box", "padding-box", "border-box", "margin-box", "fill-box", "stroke-box", "view-box"]
 * ```
 *
 * @public
 */
export const BOX_EDGE_KEYWORDS = boxEdgeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for box edge keywords.
 *
 * @public
 */
export type BoxEdgeKeyword = z.infer<typeof boxEdgeKeywordsSchema>;

/**
 * Metadata for box edge keyword options.
 *
 * Provides value and description for each box edge keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { boxEdgeKeywordOptions } from "@/core/keywords/box-edge-keywords";
 *
 * boxEdgeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const boxEdgeKeywordOptions = boxEdgeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for box edge keyword options metadata.
 *
 * @public
 */
export type BoxEdgeKeywordOptions = typeof boxEdgeKeywordOptions;

/**
 * CSS background-clip keywords.
 *
 * Extends visual box keywords with the 'text' keyword which is specific to background-clip.
 * The 'text' keyword clips the background to the foreground text (WebKit prefixed in practice).
 *
 * Uses visual box keywords from geometry-box.ts for spec compliance.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip}
 *
 * @example
 * ```typescript
 * import { backgroundClipKeywordsSchema } from "@/core/keywords/box-edge-keywords";
 *
 * const keyword = backgroundClipKeywordsSchema.parse("text"); // "text"
 * ```
 *
 * @public
 */
export const backgroundClipKeywordsSchema = z
	.enum([...visualBoxKeywords, "text"] as const)
	.describe("Background-clip keywords: visual box keywords plus 'text' for clipping to foreground text.");

/**
 * Array of background-clip keyword values.
 *
 * @public
 */
export const BACKGROUND_CLIP_KEYWORDS = ["content-box", "padding-box", "border-box", "text"] as const;

/**
 * TypeScript type for background-clip keywords.
 *
 * @public
 */
export type BackgroundClipKeyword = z.infer<typeof backgroundClipKeywordsSchema>;


=== File: src/core/keywords/color-interpolation-keywords.ts ===
// b_path:: src/core/keywords/color-interpolation-keywords.ts
import { z } from "zod";

/**
 * Rectangular color space keywords for color interpolation.
 *
 * Rectangular (Cartesian) color spaces use perpendicular axes
 * for each color channel. Used for color interpolation in gradients,
 * animations, and color-mix() function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 * @public
 */
export const rectangularColorSpaceKeywordsSchema = z
	.union([
		z.literal("srgb").describe("sRGB color space"),
		z.literal("srgb-linear").describe("linear sRGB color space"),
		z.literal("display-p3").describe("Display P3 color space"),
		z.literal("display-p3-linear").describe("linear Display P3 color space"),
		z.literal("a98-rgb").describe("Adobe RGB (1998) color space"),
		z.literal("prophoto-rgb").describe("ProPhoto RGB color space"),
		z.literal("rec2020").describe("Rec. 2020 color space"),
		z.literal("lab").describe("CIE LAB color space"),
		z.literal("oklab").describe("OKLab color space"),
		z.literal("xyz").describe("CIE XYZ color space"),
		z.literal("xyz-d50").describe("CIE XYZ color space with D50 white point"),
		z.literal("xyz-d65").describe("CIE XYZ color space with D65 white point"),
	])
	.describe("Rectangular color spaces for color interpolation");

/**
 * Polar color space keywords for color interpolation.
 *
 * Polar (cylindrical) color spaces use hue as a circular component
 * and other attributes as radial distances. Used for color interpolation
 * in gradients, animations, and color-mix() function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 * @public
 */
export const polarColorSpaceKeywordsSchema = z
	.union([
		z.literal("hsl").describe("HSL color space"),
		z.literal("hwb").describe("HWB color space"),
		z.literal("lch").describe("CIE LCH color space"),
		z.literal("oklch").describe("OKLCh color space"),
	])
	.describe("Polar color spaces for color interpolation");

/**
 * Hue interpolation method keywords for polar color spaces.
 *
 * When using polar color spaces, hue can be interpolated in different ways
 * around the color wheel. These keywords control that interpolation.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/hue-interpolation-method}
 * @public
 */
export const hueInterpolationMethodKeywordsSchema = z
	.union([
		z.literal("shorter").describe("shorter hue interpolation (default)"),
		z.literal("longer").describe("longer hue interpolation"),
		z.literal("increasing").describe("increasing hue interpolation"),
		z.literal("decreasing").describe("decreasing hue interpolation"),
	])
	.describe("Hue interpolation methods for polar color spaces");

/**
 * CSS color interpolation keywords.
 *
 * Color interpolation methods specify how colors are interpolated
 * in gradients, animations, and the color-mix() function.
 *
 * Includes:
 * - Rectangular color spaces (sRGB, Display P3, LAB, etc.)
 * - Polar color spaces (HSL, HWB, LCH, OKLCH)
 * - Hue interpolation methods (shorter, longer, increasing, decreasing)
 *
 * Used in:
 * - CSS gradients with `in` keyword
 * - color-mix() function
 * - CSS animations and transitions
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 *
 * @example
 * ```typescript
 * import { colorInterpolationKeywordsSchema } from "@/core/keywords/color-interpolation-keywords";
 *
 * const keyword = colorInterpolationKeywordsSchema.parse("oklch"); // "oklch"
 * ```
 *
 * @public
 */
export const colorInterpolationKeywordsSchema = z
	.union([
		// Rectangular color spaces
		z
			.literal("srgb")
			.describe("sRGB color space"),
		z.literal("srgb-linear").describe("linear sRGB color space"),
		z.literal("display-p3").describe("Display P3 color space"),
		z.literal("display-p3-linear").describe("linear Display P3 color space"),
		z.literal("a98-rgb").describe("Adobe RGB (1998) color space"),
		z.literal("prophoto-rgb").describe("ProPhoto RGB color space"),
		z.literal("rec2020").describe("Rec. 2020 color space"),
		z.literal("lab").describe("CIE LAB color space"),
		z.literal("oklab").describe("OKLab color space"),
		z.literal("xyz").describe("CIE XYZ color space"),
		z.literal("xyz-d50").describe("CIE XYZ color space with D50 white point"),
		z.literal("xyz-d65").describe("CIE XYZ color space with D65 white point"),

		// Polar color spaces
		z
			.literal("hsl")
			.describe("HSL color space"),
		z.literal("hwb").describe("HWB color space"),
		z.literal("lch").describe("CIE LCH color space"),
		z.literal("oklch").describe("OKLCh color space"),

		// Hue interpolation methods
		z
			.literal("shorter")
			.describe("shorter hue interpolation (default)"),
		z.literal("longer").describe("longer hue interpolation"),
		z.literal("increasing").describe("increasing hue interpolation"),
		z.literal("decreasing").describe("decreasing hue interpolation"),
	])
	.describe(
		"Color interpolation methods specify how colors are interpolated in gradients and animations. " +
			"Can use rectangular or polar color spaces with optional hue interpolation.",
	);

/**
 * Array of all color interpolation keyword values.
 *
 * @example
 * ```typescript
 * import { COLOR_INTERPOLATION_KEYWORDS } from "@/core/keywords/color-interpolation-keywords";
 *
 * console.log(COLOR_INTERPOLATION_KEYWORDS);
 * // ["srgb", "srgb-linear", "display-p3", "hsl", "hwb", "shorter", ...]
 * ```
 *
 * @public
 */
export const COLOR_INTERPOLATION_KEYWORDS = colorInterpolationKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for color interpolation keywords.
 *
 * @public
 */
export type ColorInterpolationKeyword = z.infer<typeof colorInterpolationKeywordsSchema>;

/**
 * Metadata for color interpolation keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { colorInterpolationKeywordOptions } from "@/core/keywords/color-interpolation-keywords";
 *
 * colorInterpolationKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const colorInterpolationKeywordOptions = colorInterpolationKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for color interpolation keyword options metadata.
 *
 * @public
 */
export type ColorInterpolationKeywordOptions = typeof colorInterpolationKeywordOptions;


=== File: src/core/keywords/color-keywords.test.ts ===
// b_path:: src/core/keywords/color-keywords.test.ts
import { describe, expect, it } from "vitest";
import { SPECIAL_COLOR_KEYWORDS, type SpecialColorKeyword, specialColorKeywordsSchema } from "./color-keywords";

describe("specialColorKeywordsSchema", () => {
	it("accepts all valid special color keywords", () => {
		const keywords: SpecialColorKeyword[] = ["transparent", "currentcolor"];

		for (const keyword of keywords) {
			expect(specialColorKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid special color keywords", () => {
		expect(specialColorKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(specialColorKeywordsSchema.safeParse("").success).toBe(false);
		expect(specialColorKeywordsSchema.safeParse(123).success).toBe(false);
		expect(specialColorKeywordsSchema.safeParse("red").success).toBe(false);
		expect(specialColorKeywordsSchema.safeParse("inherit").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(SPECIAL_COLOR_KEYWORDS).toHaveLength(2);
		expect(SPECIAL_COLOR_KEYWORDS).toContain("transparent");
		expect(SPECIAL_COLOR_KEYWORDS).toContain("currentcolor");
	});
});


=== File: src/core/keywords/color-keywords.ts ===
// b_path:: src/core/keywords/color-keywords.ts
import { z } from "zod";

/**
 * CSS special color keywords.
 *
 * These keywords have special meaning in CSS color contexts.
 * - `transparent`: Fully transparent color
 * - `currentcolor`: Uses the current text color
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @public
 */
export const specialColorKeywordsSchema = z
	.union([
		z.literal("transparent").describe("Fully transparent color"),
		z.literal("currentcolor").describe("Uses the current text color value"),
	])
	.describe("CSS special color keywords");

/**
 * Array of all special color keyword values.
 *
 * @example
 * ```typescript
 * import { SPECIAL_COLOR_KEYWORDS } from "@/core/keywords/color-keywords";
 *
 * console.log(SPECIAL_COLOR_KEYWORDS); // ["transparent", "currentcolor"]
 * ```
 *
 * @public
 */
export const SPECIAL_COLOR_KEYWORDS = specialColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for special color keywords.
 *
 * @public
 */
export type SpecialColorKeyword = z.infer<typeof specialColorKeywordsSchema>;

/**
 * Metadata for special color keyword options.
 *
 * Provides value and description for each special color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { specialColorKeywordOptions } from "@/core/keywords/color-keywords";
 *
 * specialColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const specialColorKeywordOptions = specialColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for special color keyword options metadata.
 *
 * @public
 */
export type SpecialColorKeywordOptions = typeof specialColorKeywordOptions;


=== File: src/core/keywords/color-value-keywords.ts ===
// b_path:: src/core/keywords/color-value-keywords.ts
import { z } from "zod";

/**
 * CSS hex color pattern.
 *
 * Matches 3, 4, 6, or 8 digit hex colors with # prefix.
 * Supports alpha channel (4 and 8 digit formats).
 *
 * @example
 * ```typescript
 * "#f00"      // 3-digit
 * "#ff0000"   // 6-digit
 * "#f00f"     // 4-digit with alpha
 * "#ff0000ff" // 8-digit with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color}
 * @public
 */
export const hexColorKeywordsSchema = z
	.string()
	.regex(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/)
	.describe("CSS hex color");

/**
 * CSS rgb() or rgba() function pattern.
 *
 * Simplified pattern for rgb() and rgba() functions.
 * Supports both legacy comma syntax and modern space syntax.
 *
 * @example
 * ```typescript
 * "rgb(255, 0, 0)"          // Legacy comma syntax
 * "rgba(255, 0, 0, 0.5)"    // Legacy with alpha
 * "rgb(255 0 0)"            // Modern space syntax
 * "rgb(255 0 0 / 0.5)"      // Modern with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb}
 * @public
 */
export const rgbColorKeywordsSchema = z
	.string()
	.regex(/^rgba?\(\s*\d+\s*(?:,\s*\d+\s*,\s*\d+|[\s]+\d+[\s]+\d+)\s*(?:[,/]\s*[\d.]+\s*)?\)$/)
	.describe("CSS rgb() or rgba() function");

/**
 * CSS hsl() or hsla() function pattern.
 *
 * Simplified pattern for hsl() and hsla() functions.
 * Supports both legacy comma syntax and modern space syntax.
 *
 * @example
 * ```typescript
 * "hsl(0, 100%, 50%)"       // Legacy comma syntax
 * "hsla(0, 100%, 50%, 0.5)" // Legacy with alpha
 * "hsl(0 100% 50%)"         // Modern space syntax
 * "hsl(0 100% 50% / 0.5)"   // Modern with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl}
 * @public
 */
export const hslColorKeywordsSchema = z
	.string()
	.regex(/^hsla?\(\s*\d+\s*(?:,\s*\d+%\s*,\s*\d+%|[\s]+\d+%[\s]+\d+%)\s*(?:[,/]\s*[\d.]+\s*)?\)$/)
	.describe("CSS hsl() or hsla() function");

/**
 * All CSS named colors (special + basic + extended = ~148 colors).
 *
 * Complete set of named colors supported in CSS Color Module Level 4.
 * Colors are case-insensitive in CSS - normalize to lowercase before validation.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#named-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const namedColorKeywordsSchema = z
	.union([
		z.literal("transparent"),
		z.literal("currentcolor"),
		z.literal("black"),
		z.literal("white"),
		z.literal("red"),
		z.literal("green"),
		z.literal("blue"),
		z.literal("yellow"),
		z.literal("orange"),
		z.literal("purple"),
		z.literal("pink"),
		z.literal("brown"),
		z.literal("gray"),
		z.literal("grey"),
		z.literal("silver"),
		z.literal("gold"),
		z.literal("navy"),
		z.literal("teal"),
		z.literal("lime"),
		z.literal("aqua"),
		z.literal("fuchsia"),
		z.literal("maroon"),
		z.literal("olive"),
		z.literal("cyan"),
		z.literal("aliceblue"),
		z.literal("antiquewhite"),
		z.literal("aquamarine"),
		z.literal("azure"),
		z.literal("beige"),
		z.literal("bisque"),
		z.literal("blanchedalmond"),
		z.literal("blueviolet"),
		z.literal("burlywood"),
		z.literal("cadetblue"),
		z.literal("chartreuse"),
		z.literal("chocolate"),
		z.literal("coral"),
		z.literal("cornflowerblue"),
		z.literal("cornsilk"),
		z.literal("crimson"),
		z.literal("darkblue"),
		z.literal("darkcyan"),
		z.literal("darkgoldenrod"),
		z.literal("darkgray"),
		z.literal("darkgrey"),
		z.literal("darkgreen"),
		z.literal("darkkhaki"),
		z.literal("darkmagenta"),
		z.literal("darkolivegreen"),
		z.literal("darkorange"),
		z.literal("darkorchid"),
		z.literal("darkred"),
		z.literal("darksalmon"),
		z.literal("darkseagreen"),
		z.literal("darkslateblue"),
		z.literal("darkslategray"),
		z.literal("darkslategrey"),
		z.literal("darkturquoise"),
		z.literal("darkviolet"),
		z.literal("deeppink"),
		z.literal("deepskyblue"),
		z.literal("dimgray"),
		z.literal("dimgrey"),
		z.literal("dodgerblue"),
		z.literal("firebrick"),
		z.literal("floralwhite"),
		z.literal("forestgreen"),
		z.literal("gainsboro"),
		z.literal("ghostwhite"),
		z.literal("goldenrod"),
		z.literal("greenyellow"),
		z.literal("honeydew"),
		z.literal("hotpink"),
		z.literal("indianred"),
		z.literal("indigo"),
		z.literal("ivory"),
		z.literal("khaki"),
		z.literal("lavender"),
		z.literal("lavenderblush"),
		z.literal("lawngreen"),
		z.literal("lemonchiffon"),
		z.literal("lightblue"),
		z.literal("lightcoral"),
		z.literal("lightcyan"),
		z.literal("lightgoldenrodyellow"),
		z.literal("lightgray"),
		z.literal("lightgrey"),
		z.literal("lightgreen"),
		z.literal("lightpink"),
		z.literal("lightsalmon"),
		z.literal("lightseagreen"),
		z.literal("lightskyblue"),
		z.literal("lightslategray"),
		z.literal("lightslategrey"),
		z.literal("lightsteelblue"),
		z.literal("lightyellow"),
		z.literal("limegreen"),
		z.literal("linen"),
		z.literal("magenta"),
		z.literal("mediumaquamarine"),
		z.literal("mediumblue"),
		z.literal("mediumorchid"),
		z.literal("mediumpurple"),
		z.literal("mediumseagreen"),
		z.literal("mediumslateblue"),
		z.literal("mediumspringgreen"),
		z.literal("mediumturquoise"),
		z.literal("mediumvioletred"),
		z.literal("midnightblue"),
		z.literal("mintcream"),
		z.literal("mistyrose"),
		z.literal("moccasin"),
		z.literal("navajowhite"),
		z.literal("oldlace"),
		z.literal("olivedrab"),
		z.literal("orangered"),
		z.literal("orchid"),
		z.literal("palegoldenrod"),
		z.literal("palegreen"),
		z.literal("paleturquoise"),
		z.literal("palevioletred"),
		z.literal("papayawhip"),
		z.literal("peachpuff"),
		z.literal("peru"),
		z.literal("plum"),
		z.literal("powderblue"),
		z.literal("rebeccapurple"),
		z.literal("rosybrown"),
		z.literal("royalblue"),
		z.literal("saddlebrown"),
		z.literal("salmon"),
		z.literal("sandybrown"),
		z.literal("seagreen"),
		z.literal("seashell"),
		z.literal("sienna"),
		z.literal("skyblue"),
		z.literal("slateblue"),
		z.literal("slategray"),
		z.literal("slategrey"),
		z.literal("snow"),
		z.literal("springgreen"),
		z.literal("steelblue"),
		z.literal("tan"),
		z.literal("thistle"),
		z.literal("tomato"),
		z.literal("turquoise"),
		z.literal("violet"),
		z.literal("wheat"),
		z.literal("whitesmoke"),
		z.literal("yellowgreen"),
	])
	.describe("CSS named colors");

/**
 * Complete CSS color value.
 *
 * Supports all common CSS color formats:
 * - Named colors (transparent, currentColor, red, etc.)
 * - Hex colors (#RGB, #RRGGBB, with optional alpha)
 * - RGB/RGBA functions
 * - HSL/HSLA functions
 *
 * Note: Modern color spaces (lab, lch, oklab, oklch, color()) are not yet supported.
 *
 * @example
 * ```typescript
 * import { colorValueKeywordsSchema } from "@/core/keywords/color-value-keywords";
 *
 * const color1 = colorValueKeywordsSchema.parse("red");
 * const color2 = colorValueKeywordsSchema.parse("#ff0000");
 * const color3 = colorValueKeywordsSchema.parse("rgb(255, 0, 0)");
 * const color4 = colorValueKeywordsSchema.parse("hsl(0, 100%, 50%)");
 * const color5 = colorValueKeywordsSchema.parse("transparent");
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @public
 */
export const colorValueKeywordsSchema = z
	.union([namedColorKeywordsSchema, hexColorKeywordsSchema, rgbColorKeywordsSchema, hslColorKeywordsSchema])
	.describe("CSS color value");

/**
 * TypeScript types for color values.
 *
 * @public
 */
export type HexColorKeyword = z.infer<typeof hexColorKeywordsSchema>;
export type RgbColorKeyword = z.infer<typeof rgbColorKeywordsSchema>;
export type HslColorKeyword = z.infer<typeof hslColorKeywordsSchema>;
export type NamedColorKeyword = z.infer<typeof namedColorKeywordsSchema>;
export type ColorValueKeyword = z.infer<typeof colorValueKeywordsSchema>;

/**
 * Combined array of all named color keywords.
 *
 * This is a convenience export that combines all color categories.
 *
 * @example
 * ```typescript
 * import { ALL_NAMED_COLOR_KEYWORDS } from "@/core/keywords/color-value-keywords";
 *
 * console.log(ALL_NAMED_COLOR_KEYWORDS.length); // 148
 * ```
 *
 * @public
 */
export const ALL_NAMED_COLOR_KEYWORDS = [
	"transparent",
	"currentcolor",
	"black",
	"white",
	"red",
	"green",
	"blue",
	"yellow",
	"orange",
	"purple",
	"pink",
	"brown",
	"gray",
	"grey",
	"silver",
	"gold",
	"navy",
	"teal",
	"lime",
	"aqua",
	"fuchsia",
	"maroon",
	"olive",
	"cyan",
	"aliceblue",
	"antiquewhite",
	"aquamarine",
	"azure",
	"beige",
	"bisque",
	"blanchedalmond",
	"blueviolet",
	"burlywood",
	"cadetblue",
	"chartreuse",
	"chocolate",
	"coral",
	"cornflowerblue",
	"cornsilk",
	"crimson",
	"darkblue",
	"darkcyan",
	"darkgoldenrod",
	"darkgray",
	"darkgrey",
	"darkgreen",
	"darkkhaki",
	"darkmagenta",
	"darkolivegreen",
	"darkorange",
	"darkorchid",
	"darkred",
	"darksalmon",
	"darkseagreen",
	"darkslateblue",
	"darkslategray",
	"darkslategrey",
	"darkturquoise",
	"darkviolet",
	"deeppink",
	"deepskyblue",
	"dimgray",
	"dimgrey",
	"dodgerblue",
	"firebrick",
	"floralwhite",
	"forestgreen",
	"gainsboro",
	"ghostwhite",
	"goldenrod",
	"greenyellow",
	"honeydew",
	"hotpink",
	"indianred",
	"indigo",
	"ivory",
	"khaki",
	"lavender",
	"lavenderblush",
	"lawngreen",
	"lemonchiffon",
	"lightblue",
	"lightcoral",
	"lightcyan",
	"lightgoldenrodyellow",
	"lightgray",
	"lightgrey",
	"lightgreen",
	"lightpink",
	"lightsalmon",
	"lightseagreen",
	"lightskyblue",
	"lightslategray",
	"lightslategrey",
	"lightsteelblue",
	"lightyellow",
	"limegreen",
	"linen",
	"magenta",
	"mediumaquamarine",
	"mediumblue",
	"mediumorchid",
	"mediumpurple",
	"mediumseagreen",
	"mediumslateblue",
	"mediumspringgreen",
	"mediumturquoise",
	"mediumvioletred",
	"midnightblue",
	"mintcream",
	"mistyrose",
	"moccasin",
	"navajowhite",
	"oldlace",
	"olivedrab",
	"orangered",
	"orchid",
	"palegoldenrod",
	"palegreen",
	"paleturquoise",
	"palevioletred",
	"papayawhip",
	"peachpuff",
	"peru",
	"plum",
	"powderblue",
	"rebeccapurple",
	"rosybrown",
	"royalblue",
	"saddlebrown",
	"salmon",
	"sandybrown",
	"seagreen",
	"seashell",
	"sienna",
	"skyblue",
	"slateblue",
	"slategray",
	"slategrey",
	"snow",
	"springgreen",
	"steelblue",
	"tan",
	"thistle",
	"tomato",
	"turquoise",
	"violet",
	"wheat",
	"whitesmoke",
	"yellowgreen",
] as const;

/**
 * Metadata for color values.
 *
 * @public
 */
export const colorKeywordsMetadata = {
	totalNamedColors: ALL_NAMED_COLOR_KEYWORDS.length,
	hexPattern: "#RGB, #RRGGBB, #RGBA, #RRGGBBAA",
	rgbPattern: "rgb(r, g, b) or rgba(r, g, b, a)",
	hslPattern: "hsl(h, s%, l%) or hsla(h, s%, l%, a)",
} as const;

/**
 * Type for color keywords metadata.
 *
 * @public
 */
export type ColorKeywordsMetadata = typeof colorKeywordsMetadata;


=== File: src/core/keywords/content-distribution-keywords.test.ts ===
// b_path:: src/core/keywords/content-distribution-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	CONTENT_DISTRIBUTION_KEYWORDS,
	type ContentDistributionKeyword,
	contentDistributionKeywordOptions,
	contentDistributionKeywordsSchema,
} from "./content-distribution-keywords";

describe("contentDistributionKeywordsSchema", () => {
	it("accepts all valid content distribution keywords", () => {
		const keywords: ContentDistributionKeyword[] = ["space-between", "space-around", "space-evenly", "stretch"];
		for (const keyword of keywords) {
			expect(contentDistributionKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keywords", () => {
		const invalid = ["invalid", "center", "start", "space-apart", "", 123, null, undefined];
		for (const value of invalid) {
			expect(contentDistributionKeywordsSchema.safeParse(value).success).toBe(false);
		}
	});

	it("exports correct CONTENT_DISTRIBUTION_KEYWORDS array", () => {
		expect(CONTENT_DISTRIBUTION_KEYWORDS).toHaveLength(4);
		expect(CONTENT_DISTRIBUTION_KEYWORDS).toContain("space-between");
		expect(CONTENT_DISTRIBUTION_KEYWORDS).toContain("space-around");
		expect(CONTENT_DISTRIBUTION_KEYWORDS).toContain("space-evenly");
		expect(CONTENT_DISTRIBUTION_KEYWORDS).toContain("stretch");
	});

	it("exports keyword options with descriptions", () => {
		expect(contentDistributionKeywordOptions).toHaveLength(4);
		for (const option of contentDistributionKeywordOptions) {
			expect(option).toHaveProperty("value");
			expect(option).toHaveProperty("description");
			expect(typeof option.value).toBe("string");
			expect(typeof option.description).toBe("string");
		}
	});

	it("has description for each keyword", () => {
		const spaceBetweenOption = contentDistributionKeywordOptions.find((opt) => opt.value === "space-between");
		expect(spaceBetweenOption?.description).toContain("evenly");

		const stretchOption = contentDistributionKeywordOptions.find((opt) => opt.value === "stretch");
		expect(stretchOption?.description).toContain("fill");
	});
});


=== File: src/core/keywords/content-distribution-keywords.ts ===
// b_path:: src/core/keywords/content-distribution-keywords.ts
import { z } from "zod";

/**
 * CSS content distribution keywords.
 *
 * Content distribution values control how extra space is distributed
 * among flex items or grid tracks within their alignment container.
 *
 * Used in:
 * - `justify-content` - Alignment along main axis
 * - `align-content` - Alignment along cross axis
 * - `place-content` - Shorthand for both axes
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Alignment#content_distribution}
 *
 * @example
 * ```typescript
 * import { contentDistributionKeywordsSchema } from "@/core/keywords/content-distribution-keywords";
 *
 * const keyword = contentDistributionKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const contentDistributionKeywordsSchema = z
	.union([
		z.literal("space-between").describe("evenly distributes items with first/last flush to edges"),
		z.literal("space-around").describe("evenly distributes items with half-size space on ends"),
		z.literal("space-evenly").describe("evenly distributes items with full-size space on ends"),
		z.literal("stretch").describe("grows items equally to fill container"),
	])
	.describe(
		"Content distribution values control how extra space is distributed among alignment subjects. " +
			"Used in justify-content, align-content, and place-content properties.",
	);

/**
 * Array of all content distribution keyword values.
 *
 * @example
 * ```typescript
 * import { CONTENT_DISTRIBUTION_KEYWORDS } from "@/core/keywords/content-distribution-keywords";
 *
 * console.log(CONTENT_DISTRIBUTION_KEYWORDS);
 * // ["space-between", "space-around", "space-evenly", "stretch"]
 * ```
 *
 * @public
 */
export const CONTENT_DISTRIBUTION_KEYWORDS = contentDistributionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for content distribution keywords.
 *
 * @public
 */
export type ContentDistributionKeyword = z.infer<typeof contentDistributionKeywordsSchema>;

/**
 * Metadata for content distribution keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { contentDistributionKeywordOptions } from "@/core/keywords/content-distribution-keywords";
 *
 * contentDistributionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const contentDistributionKeywordOptions = contentDistributionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for content distribution keyword options metadata.
 *
 * @public
 */
export type ContentDistributionKeywordOptions = typeof contentDistributionKeywordOptions;


=== File: src/core/keywords/content-position-keywords.test.ts ===
// b_path:: src/core/keywords/content-position-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	CONTENT_POSITION_KEYWORDS,
	type ContentPositionKeyword,
	contentPositionKeywordOptions,
	contentPositionKeywordsSchema,
} from "./content-position-keywords";

describe("contentPositionKeywordsSchema", () => {
	it("accepts all valid content position keywords", () => {
		const keywords: ContentPositionKeyword[] = ["center", "start", "end", "flex-start", "flex-end"];
		for (const keyword of keywords) {
			expect(contentPositionKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keywords", () => {
		const invalid = ["invalid", "left", "right", "space-between", "stretch", "", 123, null, undefined];
		for (const value of invalid) {
			expect(contentPositionKeywordsSchema.safeParse(value).success).toBe(false);
		}
	});

	it("exports correct CONTENT_POSITION_KEYWORDS array", () => {
		expect(CONTENT_POSITION_KEYWORDS).toHaveLength(5);
		expect(CONTENT_POSITION_KEYWORDS).toContain("center");
		expect(CONTENT_POSITION_KEYWORDS).toContain("start");
		expect(CONTENT_POSITION_KEYWORDS).toContain("end");
		expect(CONTENT_POSITION_KEYWORDS).toContain("flex-start");
		expect(CONTENT_POSITION_KEYWORDS).toContain("flex-end");
	});

	it("exports keyword options with descriptions", () => {
		expect(contentPositionKeywordOptions).toHaveLength(5);
		for (const option of contentPositionKeywordOptions) {
			expect(option).toHaveProperty("value");
			expect(option).toHaveProperty("description");
			expect(typeof option.value).toBe("string");
			expect(typeof option.description).toBe("string");
		}
	});

	it("has description for each keyword", () => {
		const centerOption = contentPositionKeywordOptions.find((opt) => opt.value === "center");
		expect(centerOption?.description).toContain("center");

		const startOption = contentPositionKeywordOptions.find((opt) => opt.value === "start");
		expect(startOption?.description).toContain("start");
	});
});


=== File: src/core/keywords/content-position-keywords.ts ===
// b_path:: src/core/keywords/content-position-keywords.ts
import { z } from "zod";

/**
 * CSS content position keywords.
 *
 * Content position values align the box's contents within itself
 * along a single axis (main or cross axis for flex, inline or block for grid).
 *
 * Used in:
 * - `justify-content` - Alignment along main/inline axis
 * - `align-content` - Alignment along cross/block axis
 * - `place-content` - Shorthand for both axes
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Alignment#positional_alignment}
 *
 * @example
 * ```typescript
 * import { contentPositionKeywordsSchema } from "@/core/keywords/content-position-keywords";
 *
 * const keyword = contentPositionKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const contentPositionKeywordsSchema = z
	.union([
		z.literal("center").describe("centers the alignment subject within its alignment container"),
		z.literal("start").describe("aligns the alignment subject flush with the alignment container's start edge"),
		z.literal("end").describe("aligns the alignment subject flush with the alignment container's end edge"),
		z.literal("flex-start").describe("aligns flush with flex container's main-start or cross-start side"),
		z.literal("flex-end").describe("aligns flush with flex container's main-end or cross-end side"),
	])
	.describe(
		"Content position values align the box's contents within itself. " +
			"Used in justify-content, align-content, and place-content properties.",
	);

/**
 * Array of all content position keyword values.
 *
 * @example
 * ```typescript
 * import { CONTENT_POSITION_KEYWORDS } from "@/core/keywords/content-position-keywords";
 *
 * console.log(CONTENT_POSITION_KEYWORDS);
 * // ["center", "start", "end", "flex-start", "flex-end"]
 * ```
 *
 * @public
 */
export const CONTENT_POSITION_KEYWORDS = contentPositionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for content position keywords.
 *
 * @public
 */
export type ContentPositionKeyword = z.infer<typeof contentPositionKeywordsSchema>;

/**
 * Metadata for content position keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { contentPositionKeywordOptions } from "@/core/keywords/content-position-keywords";
 *
 * contentPositionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const contentPositionKeywordOptions = contentPositionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for content position keyword options metadata.
 *
 * @public
 */
export type ContentPositionKeywordOptions = typeof contentPositionKeywordOptions;


=== File: src/core/keywords/corner-shape-keywords.test.ts ===
// b_path:: src/core/keywords/corner-shape-keywords.test.ts
import { describe, expect, it } from "vitest";
import { CORNER_SHAPE_KEYWORDS, type CornerShapeKeyword, cornerShapeKeywordsSchema } from "./corner-shape-keywords";

describe("cornerShapeKeywordsSchema", () => {
	it("accepts all valid corner-shape keywords", () => {
		const keywords: CornerShapeKeyword[] = ["round", "scoop", "bevel", "notch", "square", "squircle"];

		for (const keyword of keywords) {
			expect(cornerShapeKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid corner-shape keywords", () => {
		expect(cornerShapeKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(cornerShapeKeywordsSchema.safeParse("").success).toBe(false);
		expect(cornerShapeKeywordsSchema.safeParse(123).success).toBe(false);
		expect(cornerShapeKeywordsSchema.safeParse("circle").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(CORNER_SHAPE_KEYWORDS).toHaveLength(6);
		expect(CORNER_SHAPE_KEYWORDS).toContain("round");
		expect(CORNER_SHAPE_KEYWORDS).toContain("squircle");
	});
});


=== File: src/core/keywords/corner-shape-keywords.ts ===
// b_path:: src/core/keywords/corner-shape-keywords.ts
import { z } from "zod";

/**
 * CSS corner-shape keyword values.
 *
 * Corner shape values describe the shape of container corners.
 * Used in corner-shape property to specify custom corner shapes beyond standard border-radius.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/corner-shape}
 *
 * @example
 * ```typescript
 * import { cornerShapeKeywordsSchema } from "@/core/keywords/corner-shape-keywords";
 *
 * const keyword = cornerShapeKeywordsSchema.parse("round");
 * ```
 *
 * @public
 */
export const cornerShapeKeywordsSchema = z
	.union([
		z.literal("round").describe("convex ordinary ellipse (default rounded corner)"),
		z.literal("scoop").describe("concave ordinary ellipse"),
		z.literal("bevel").describe("straight diagonal corner (neither convex nor concave)"),
		z.literal("notch").describe("90-degree concave square corner"),
		z.literal("square").describe("90-degree convex square corner"),
		z.literal("squircle").describe("convex curve between round and square"),
	])
	.describe(
		"Corner shape values describe the shape of container corners. " +
			"Used in corner-shape property to specify custom corner shapes beyond standard border-radius.",
	);

/**
 * Array of all corner-shape keyword values.
 *
 * @public
 */
export const CORNER_SHAPE_KEYWORDS = cornerShapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for corner-shape keywords.
 *
 * @public
 */
export type CornerShapeKeyword = z.infer<typeof cornerShapeKeywordsSchema>;

/**
 * Metadata for corner-shape keyword options.
 *
 * @public
 */
export const cornerShapeKeywordOptions = cornerShapeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for corner-shape keyword options metadata.
 *
 * @public
 */
export type CornerShapeKeywordOptions = typeof cornerShapeKeywordOptions;


=== File: src/core/keywords/cursor-keywords.test.ts ===
// b_path:: src/core/keywords/cursor-keywords.test.ts
import { describe, expect, it } from "vitest";
import { CURSOR_KEYWORDS, type CursorKeyword, cursorKeywordOptions, cursorKeywordsSchema } from "./cursor-keywords";

describe("cursorKeywordsSchema", () => {
	it("accepts all valid cursor keywords", () => {
		const keywords: CursorKeyword[] = [
			"auto",
			"default",
			"none",
			"context-menu",
			"help",
			"pointer",
			"progress",
			"wait",
			"cell",
			"crosshair",
			"text",
			"vertical-text",
			"alias",
			"copy",
			"move",
			"no-drop",
			"not-allowed",
			"grab",
			"grabbing",
			"e-resize",
			"n-resize",
			"ne-resize",
			"nw-resize",
			"s-resize",
			"se-resize",
			"sw-resize",
			"w-resize",
			"ew-resize",
			"ns-resize",
			"nesw-resize",
			"nwse-resize",
			"col-resize",
			"row-resize",
			"all-scroll",
			"zoom-in",
			"zoom-out",
		];
		for (const keyword of keywords) {
			expect(cursorKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keywords", () => {
		const invalid = ["invalid", "hand", "arrow", "resize", "", 123, null, undefined];
		for (const value of invalid) {
			expect(cursorKeywordsSchema.safeParse(value).success).toBe(false);
		}
	});

	it("exports correct CURSOR_KEYWORDS array", () => {
		expect(CURSOR_KEYWORDS).toHaveLength(36);
		expect(CURSOR_KEYWORDS).toContain("pointer");
		expect(CURSOR_KEYWORDS).toContain("auto");
		expect(CURSOR_KEYWORDS).toContain("default");
		expect(CURSOR_KEYWORDS).toContain("none");
		expect(CURSOR_KEYWORDS).toContain("grab");
		expect(CURSOR_KEYWORDS).toContain("grabbing");
	});

	it("exports keyword options with descriptions", () => {
		expect(cursorKeywordOptions).toHaveLength(36);
		for (const option of cursorKeywordOptions) {
			expect(option).toHaveProperty("value");
			expect(option).toHaveProperty("description");
			expect(typeof option.value).toBe("string");
			expect(typeof option.description).toBe("string");
		}
	});

	it("has description for pointer keyword", () => {
		const pointerOption = cursorKeywordOptions.find((opt) => opt.value === "pointer");
		expect(pointerOption?.description).toContain("link");
	});

	it("has description for resize keywords", () => {
		const eResizeOption = cursorKeywordOptions.find((opt) => opt.value === "e-resize");
		expect(eResizeOption?.description).toContain("east");

		const nResizeOption = cursorKeywordOptions.find((opt) => opt.value === "n-resize");
		expect(nResizeOption?.description).toContain("north");
	});

	it("includes all directional resize cursors", () => {
		const resizeKeywords = [
			"e-resize",
			"n-resize",
			"ne-resize",
			"nw-resize",
			"s-resize",
			"se-resize",
			"sw-resize",
			"w-resize",
		];
		for (const keyword of resizeKeywords) {
			expect(CURSOR_KEYWORDS).toContain(keyword);
		}
	});

	it("includes bidirectional resize cursors", () => {
		const biResizeKeywords = ["ew-resize", "ns-resize", "nesw-resize", "nwse-resize"];
		for (const keyword of biResizeKeywords) {
			expect(CURSOR_KEYWORDS).toContain(keyword);
		}
	});
});


=== File: src/core/keywords/cursor-keywords.ts ===
// b_path:: src/core/keywords/cursor-keywords.ts
import { z } from "zod";

/**
 * CSS cursor keyword values.
 *
 * The cursor property sets the mouse cursor to display when the mouse pointer is over an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}
 *
 * @example
 * ```typescript
 * import { cursorKeywordsSchema } from "@/core/keywords/cursor-keywords";
 *
 * const keyword = cursorKeywordsSchema.parse("pointer");
 * ```
 *
 * @public
 */
export const cursorKeywordsSchema = z.enum(
	[
		"auto",
		"default",
		"none",
		"context-menu",
		"help",
		"pointer",
		"progress",
		"wait",
		"cell",
		"crosshair",
		"text",
		"vertical-text",
		"alias",
		"copy",
		"move",
		"no-drop",
		"not-allowed",
		"grab",
		"grabbing",
		"e-resize",
		"n-resize",
		"ne-resize",
		"nw-resize",
		"s-resize",
		"se-resize",
		"sw-resize",
		"w-resize",
		"ew-resize",
		"ns-resize",
		"nesw-resize",
		"nwse-resize",
		"col-resize",
		"row-resize",
		"all-scroll",
		"zoom-in",
		"zoom-out",
	],
	{
		error: () => ({
			message:
				"Expected auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | grab | grabbing | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out",
		}),
	},
);

/**
 * Array of all cursor keyword values.
 *
 * @public
 */
export const CURSOR_KEYWORDS = cursorKeywordsSchema.options;

/**
 * TypeScript type for cursor keywords.
 *
 * @public
 */
export type CursorKeyword = z.infer<typeof cursorKeywordsSchema>;

/**
 * Descriptions for cursor keywords.
 *
 * @internal
 */
const CURSOR_DESCRIPTIONS: Record<CursorKeyword, string> = {
	auto: "browser determines cursor based on context",
	default: "platform-dependent default cursor (usually arrow)",
	none: "no cursor is rendered",
	"context-menu": "context menu is available",
	help: "help information is available",
	pointer: "link or clickable element (usually hand)",
	progress: "program is busy but user can still interact",
	wait: "program is busy",
	cell: "cell or set of cells can be selected",
	crosshair: "simple crosshair",
	text: "text can be selected (usually I-beam)",
	"vertical-text": "vertical text can be selected",
	alias: "alias or shortcut is to be created",
	copy: "something is to be copied",
	move: "something is to be moved",
	"no-drop": "drop is not allowed at current location",
	"not-allowed": "requested action will not be executed",
	grab: "something can be grabbed",
	grabbing: "something is being grabbed",
	"e-resize": "edge is to be moved east",
	"n-resize": "edge is to be moved north",
	"ne-resize": "edge is to be moved northeast",
	"nw-resize": "edge is to be moved northwest",
	"s-resize": "edge is to be moved south",
	"se-resize": "edge is to be moved southeast",
	"sw-resize": "edge is to be moved southwest",
	"w-resize": "edge is to be moved west",
	"ew-resize": "bidirectional resize cursor (east-west)",
	"ns-resize": "bidirectional resize cursor (north-south)",
	"nesw-resize": "bidirectional resize cursor (northeast-southwest)",
	"nwse-resize": "bidirectional resize cursor (northwest-southeast)",
	"col-resize": "column can be resized horizontally",
	"row-resize": "row can be resized vertically",
	"all-scroll": "scrolling in any direction",
	"zoom-in": "something can be zoomed in",
	"zoom-out": "something can be zoomed out",
};

/**
 * Metadata for cursor keyword options.
 *
 * @public
 */
export const cursorKeywordOptions = CURSOR_KEYWORDS.map((value) => ({
	value,
	description: CURSOR_DESCRIPTIONS[value],
}));

/**
 * Type for cursor keyword options metadata.
 *
 * @public
 */
export type CursorKeywordOptions = typeof cursorKeywordOptions;


=== File: src/core/keywords/display-keywords.ts ===
// b_path:: src/core/keywords/display-keywords.ts
import { z } from "zod";

/**
 * CSS display box keywords.
 *
 * Display box values control whether an element generates a box at all.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#box}
 * @public
 */
export const displayBoxKeywordsSchema = z
	.union([
		z.literal("contents").describe("element doesn't produce a specific box by itself"),
		z.literal("none").describe("turns off the display of an element"),
	])
	.describe("Display box values that control whether an element generates a box");

/**
 * CSS display inside keywords.
 *
 * Display inside values specify the element's inner display type,
 * which defines how its contents are laid out.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#inside}
 * @public
 */
export const displayInsideKeywordsSchema = z
	.union([
		z.literal("flow").describe("element lays out its contents using flow layout"),
		z.literal("flow-root").describe("generates a block element box that establishes a new block formatting context"),
		z.literal("table").describe("behaves like HTML table elements"),
		z.literal("flex").describe("behaves like a block element and lays out content according to the flexbox model"),
		z.literal("grid").describe("behaves like a block element and lays out content according to the grid model"),
		z
			.literal("ruby")
			.describe("behaves like an inline element and lays out content according to the ruby formatting model"),
	])
	.describe("Display inside values that specify the element's inner display type");

/**
 * CSS display internal keywords.
 *
 * Display internal values are for complex layout models like table and ruby.
 * These elements have internal structures with specific roles.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#internal}
 * @public
 */
export const displayInternalKeywordsSchema = z
	.union([
		z.literal("table-row-group").describe("behaves like tbody HTML elements"),
		z.literal("table-header-group").describe("behaves like thead HTML elements"),
		z.literal("table-footer-group").describe("behaves like tfoot HTML elements"),
		z.literal("table-row").describe("behaves like tr HTML elements"),
		z.literal("table-cell").describe("behaves like td HTML elements"),
		z.literal("table-column-group").describe("behaves like colgroup HTML elements"),
		z.literal("table-column").describe("behaves like col HTML elements"),
		z.literal("table-caption").describe("behaves like caption HTML elements"),
		z.literal("ruby-base").describe("behaves like rb HTML elements"),
		z.literal("ruby-text").describe("behaves like rt HTML elements"),
		z.literal("ruby-base-container").describe("generated as anonymous boxes"),
		z.literal("ruby-text-container").describe("behaves like rtc HTML elements"),
	])
	.describe("Display internal values for complex layout models like table and ruby");

/**
 * CSS display legacy keywords.
 *
 * Display legacy values are from CSS 2 single-keyword syntax.
 * These combine outer and inner display types in a single keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#legacy}
 * @public
 */
export const displayLegacyKeywordsSchema = z
	.union([
		z.literal("inline-block").describe("generates a block element box flowed with surrounding content as inline"),
		z.literal("inline-table").describe("behaves like HTML table element but as an inline box"),
		z.literal("inline-flex").describe("behaves like an inline element and lays out content according to flexbox model"),
		z.literal("inline-grid").describe("behaves like an inline element and lays out content according to grid model"),
	])
	.describe("Display legacy values from CSS 2 single-keyword syntax");

/**
 * CSS display outside keywords.
 *
 * Display outside values specify the element's outer display type,
 * which determines how it participates in flow layout.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#outside}
 * @public
 */
export const displayOutsideKeywordsSchema = z
	.union([
		z.literal("block").describe("generates a block element box with line breaks before and after"),
		z.literal("inline").describe("generates inline element boxes without line breaks"),
		z.literal("run-in").describe("element runs into the next block if possible"),
	])
	.describe("Display outside values that specify the element's outer display type");

/**
 * CSS display list-item keyword.
 *
 * The list-item keyword makes an element behave like a list item,
 * generating both a principal box and a marker box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#list-item}
 * @public
 */
export const displayListItemKeywordsSchema = z.literal("list-item").describe("element behaves like a list item");

/**
 * CSS display keywords.
 *
 * The display property controls how an element is displayed in the layout,
 * including its box generation, inner layout type, and outer display type.
 *
 * This schema includes all valid display values:
 * - Box values (contents, none)
 * - Inside values (flow, flex, grid, table, etc.)
 * - Internal values (table-row, table-cell, etc.)
 * - Legacy values (inline-block, inline-flex, etc.)
 * - Outside values (block, inline, run-in)
 * - List item
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display}
 *
 * @example
 * ```typescript
 * import { displayKeywordsSchema } from "@/core/keywords/display-keywords";
 *
 * const keyword = displayKeywordsSchema.parse("flex"); // "flex"
 * ```
 *
 * @public
 */
export const displayKeywordsSchema = z.enum(
	[
		// Display Box
		"contents",
		"none",
		// Display Inside
		"flow",
		"flow-root",
		"table",
		"flex",
		"grid",
		"ruby",
		// Display Internal
		"table-row-group",
		"table-header-group",
		"table-footer-group",
		"table-row",
		"table-cell",
		"table-column-group",
		"table-column",
		"table-caption",
		"ruby-base",
		"ruby-text",
		"ruby-base-container",
		"ruby-text-container",
		// Display Legacy
		"inline-block",
		"inline-table",
		"inline-flex",
		"inline-grid",
		// Display Outside
		"block",
		"inline",
		"run-in",
		// List Item
		"list-item",
	],
	{
		error: () => ({
			message:
				"Expected contents | none | flow | flow-root | table | flex | grid | ruby | table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container | inline-block | inline-table | inline-flex | inline-grid | block | inline | run-in | list-item",
		}),
	},
);

/**
 * Array of all display keyword values.
 *
 * @example
 * ```typescript
 * import { DISPLAY_KEYWORDS } from "@/core/keywords/display-keywords";
 *
 * console.log(DISPLAY_KEYWORDS);
 * // ["contents", "none", "flow", "flex", "grid", "block", "inline", ...]
 * ```
 *
 * @public
 */
export const DISPLAY_KEYWORDS = displayKeywordsSchema.options;

/**
 * TypeScript type for display keywords.
 *
 * @public
 */
export type DisplayKeyword = z.infer<typeof displayKeywordsSchema>;

/**
 * Descriptions for display keywords.
 *
 * @internal
 */
const DISPLAY_DESCRIPTIONS: Record<DisplayKeyword, string> = {
	// Display Box
	contents: "element doesn't produce a specific box by itself",
	none: "turns off the display of an element",
	// Display Inside
	flow: "element lays out its contents using flow layout",
	"flow-root": "generates a block element box that establishes a new block formatting context",
	table: "behaves like HTML table elements",
	flex: "behaves like a block element and lays out content according to the flexbox model",
	grid: "behaves like a block element and lays out content according to the grid model",
	ruby: "behaves like an inline element and lays out content according to the ruby formatting model",
	// Display Internal
	"table-row-group": "behaves like tbody HTML elements",
	"table-header-group": "behaves like thead HTML elements",
	"table-footer-group": "behaves like tfoot HTML elements",
	"table-row": "behaves like tr HTML elements",
	"table-cell": "behaves like td HTML elements",
	"table-column-group": "behaves like colgroup HTML elements",
	"table-column": "behaves like col HTML elements",
	"table-caption": "behaves like caption HTML elements",
	"ruby-base": "behaves like rb HTML elements",
	"ruby-text": "behaves like rt HTML elements",
	"ruby-base-container": "generated as anonymous boxes",
	"ruby-text-container": "behaves like rtc HTML elements",
	// Display Legacy
	"inline-block": "generates a block element box flowed with surrounding content as inline",
	"inline-table": "behaves like HTML table element but as an inline box",
	"inline-flex": "behaves like an inline element and lays out content according to flexbox model",
	"inline-grid": "behaves like an inline element and lays out content according to grid model",
	// Display Outside
	block: "generates a block element box with line breaks before and after",
	inline: "generates inline element boxes without line breaks",
	"run-in": "element runs into the next block if possible",
	// List Item
	"list-item": "element behaves like a list item",
};

/**
 * Metadata for display keyword options.
 *
 * Provides value and description for each display keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { displayKeywordOptions } from "@/core/keywords/display-keywords";
 *
 * displayKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const displayKeywordOptions = DISPLAY_KEYWORDS.map((value) => ({
	value,
	description: DISPLAY_DESCRIPTIONS[value],
}));

/**
 * Type for display keyword options metadata.
 *
 * @public
 */
export type DisplayKeywordOptions = typeof displayKeywordOptions;


=== File: src/core/keywords/extended-color-keywords.ts ===
// b_path:: src/core/keywords/extended-color-keywords.ts
import { z } from "zod";

/**
 * CSS extended named colors (~125 colors).
 *
 * Full X11/SVG color set from CSS Color Module Level 4.
 * These are additional named colors beyond the basic set.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#named-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const extendedNamedColorKeywordsSchema = z
	.union([
		z.literal("aliceblue").describe("Alice blue color (#F0F8FF)"),
		z.literal("antiquewhite").describe("Antique white color (#FAEBD7)"),
		z.literal("aquamarine").describe("Aquamarine color (#7FFFD4)"),
		z.literal("azure").describe("Azure color (#F0FFFF)"),
		z.literal("beige").describe("Beige color (#F5F5DC)"),
		z.literal("bisque").describe("Bisque color (#FFE4C4)"),
		z.literal("blanchedalmond").describe("Blanched almond color (#FFEBCD)"),
		z.literal("blueviolet").describe("Blue violet color (#8A2BE2)"),
		z.literal("burlywood").describe("Burlywood color (#DEB887)"),
		z.literal("cadetblue").describe("Cadet blue color (#5F9EA0)"),
		z.literal("chartreuse").describe("Chartreuse color (#7FFF00)"),
		z.literal("chocolate").describe("Chocolate color (#D2691E)"),
		z.literal("coral").describe("Coral color (#FF7F50)"),
		z.literal("cornflowerblue").describe("Cornflower blue color (#6495ED)"),
		z.literal("cornsilk").describe("Cornsilk color (#FFF8DC)"),
		z.literal("crimson").describe("Crimson color (#DC143C)"),
		z.literal("darkblue").describe("Dark blue color (#00008B)"),
		z.literal("darkcyan").describe("Dark cyan color (#008B8B)"),
		z.literal("darkgoldenrod").describe("Dark goldenrod color (#B8860B)"),
		z.literal("darkgray").describe("Dark gray color (#A9A9A9)"),
		z.literal("darkgrey").describe("Alternative spelling of darkgray"),
		z.literal("darkgreen").describe("Dark green color (#006400)"),
		z.literal("darkkhaki").describe("Dark khaki color (#BDB76B)"),
		z.literal("darkmagenta").describe("Dark magenta color (#8B008B)"),
		z.literal("darkolivegreen").describe("Dark olive green color (#556B2F)"),
		z.literal("darkorange").describe("Dark orange color (#FF8C00)"),
		z.literal("darkorchid").describe("Dark orchid color (#9932CC)"),
		z.literal("darkred").describe("Dark red color (#8B0000)"),
		z.literal("darksalmon").describe("Dark salmon color (#E9967A)"),
		z.literal("darkseagreen").describe("Dark sea green color (#8FBC8F)"),
		z.literal("darkslateblue").describe("Dark slate blue color (#483D8B)"),
		z.literal("darkslategray").describe("Dark slate gray color (#2F4F4F)"),
		z.literal("darkslategrey").describe("Alternative spelling of darkslategray"),
		z.literal("darkturquoise").describe("Dark turquoise color (#00CED1)"),
		z.literal("darkviolet").describe("Dark violet color (#9400D3)"),
		z.literal("deeppink").describe("Deep pink color (#FF1493)"),
		z.literal("deepskyblue").describe("Deep sky blue color (#00BFFF)"),
		z.literal("dimgray").describe("Dim gray color (#696969)"),
		z.literal("dimgrey").describe("Alternative spelling of dimgrey"),
		z.literal("dodgerblue").describe("Dodger blue color (#1E90FF)"),
		z.literal("firebrick").describe("Fire brick color (#B22222)"),
		z.literal("floralwhite").describe("Floral white color (#FFFAF0)"),
		z.literal("forestgreen").describe("Forest green color (#228B22)"),
		z.literal("gainsboro").describe("Gainsboro color (#DCDCDC)"),
		z.literal("ghostwhite").describe("Ghost white color (#F8F8FF)"),
		z.literal("goldenrod").describe("Goldenrod color (#DAA520)"),
		z.literal("greenyellow").describe("Green yellow color (#ADFF2F)"),
		z.literal("honeydew").describe("Honeydew color (#F0FFF0)"),
		z.literal("hotpink").describe("Hot pink color (#FF69B4)"),
		z.literal("indianred").describe("Indian red color (#CD5C5C)"),
		z.literal("indigo").describe("Indigo color (#4B0082)"),
		z.literal("ivory").describe("Ivory color (#FFFFF0)"),
		z.literal("khaki").describe("Khaki color (#F0E68C)"),
		z.literal("lavender").describe("Lavender color (#E6E6FA)"),
		z.literal("lavenderblush").describe("Lavender blush color (#FFF0F5)"),
		z.literal("lawngreen").describe("Lawn green color (#7CFC00)"),
		z.literal("lemonchiffon").describe("Lemon chiffon color (#FFFACD)"),
		z.literal("lightblue").describe("Light blue color (#ADD8E6)"),
		z.literal("lightcoral").describe("Light coral color (#F08080)"),
		z.literal("lightcyan").describe("Light cyan color (#E0FFFF)"),
		z.literal("lightgoldenrodyellow").describe("Light goldenrod yellow color (#FAFAD2)"),
		z.literal("lightgray").describe("Light gray color (#D3D3D3)"),
		z.literal("lightgrey").describe("Alternative spelling of lightgrey"),
		z.literal("lightgreen").describe("Light green color (#90EE90)"),
		z.literal("lightpink").describe("Light pink color (#FFB6C1)"),
		z.literal("lightsalmon").describe("Light salmon color (#FFA07A)"),
		z.literal("lightseagreen").describe("Light sea green color (#20B2AA)"),
		z.literal("lightskyblue").describe("Light sky blue color (#87CEFA)"),
		z.literal("lightslategray").describe("Light slate gray color (#778899)"),
		z.literal("lightslategrey").describe("Alternative spelling of lightslategrey"),
		z.literal("lightsteelblue").describe("Light steel blue color (#B0C4DE)"),
		z.literal("lightyellow").describe("Light yellow color (#FFFFE0)"),
		z.literal("limegreen").describe("Lime green color (#32CD32)"),
		z.literal("linen").describe("Linen color (#FAF0E6)"),
		z.literal("magenta").describe("Magenta color (#FF00FF)"),
		z.literal("mediumaquamarine").describe("Medium aquamarine color (#66CDAA)"),
		z.literal("mediumblue").describe("Medium blue color (#0000CD)"),
		z.literal("mediumorchid").describe("Medium orchid color (#BA55D3)"),
		z.literal("mediumpurple").describe("Medium purple color (#9370DB)"),
		z.literal("mediumseagreen").describe("Medium sea green color (#3CB371)"),
		z.literal("mediumslateblue").describe("Medium slate blue color (#7B68EE)"),
		z.literal("mediumspringgreen").describe("Medium spring green color (#00FA9A)"),
		z.literal("mediumturquoise").describe("Medium turquoise color (#48D1CC)"),
		z.literal("mediumvioletred").describe("Medium violet red color (#C71585)"),
		z.literal("midnightblue").describe("Midnight blue color (#191970)"),
		z.literal("mintcream").describe("Mint cream color (#F5FFFA)"),
		z.literal("mistyrose").describe("Misty rose color (#FFE4E1)"),
		z.literal("moccasin").describe("Moccasin color (#FFE4B5)"),
		z.literal("navajowhite").describe("Navajo white color (#FFDEAD)"),
		z.literal("oldlace").describe("Old lace color (#FDF5E6)"),
		z.literal("olivedrab").describe("Olive drab color (#6B8E23)"),
		z.literal("orangered").describe("Orange red color (#FF4500)"),
		z.literal("orchid").describe("Orchid color (#DA70D6)"),
		z.literal("palegoldenrod").describe("Pale goldenrod color (#EEE8AA)"),
		z.literal("palegreen").describe("Pale green color (#98FB98)"),
		z.literal("paleturquoise").describe("Pale turquoise color (#AFEEEE)"),
		z.literal("palevioletred").describe("Pale violet red color (#DB7093)"),
		z.literal("papayawhip").describe("Papaya whip color (#FFEFD5)"),
		z.literal("peachpuff").describe("Peach puff color (#FFDAB9)"),
		z.literal("peru").describe("Peru color (#CD853F)"),
		z.literal("plum").describe("Plum color (#DDA0DD)"),
		z.literal("powderblue").describe("Powder blue color (#B0E0E6)"),
		z.literal("rebeccapurple").describe("Rebecca purple color (#663399)"),
		z.literal("rosybrown").describe("Rosy brown color (#BC8F8F)"),
		z.literal("royalblue").describe("Royal blue color (#4169E1)"),
		z.literal("saddlebrown").describe("Saddle brown color (#8B4513)"),
		z.literal("salmon").describe("Salmon color (#FA8072)"),
		z.literal("sandybrown").describe("Sandy brown color (#F4A460)"),
		z.literal("seagreen").describe("Sea green color (#2E8B57)"),
		z.literal("seashell").describe("Seashell color (#FFF5EE)"),
		z.literal("sienna").describe("Sienna color (#A0522D)"),
		z.literal("skyblue").describe("Sky blue color (#87CEEB)"),
		z.literal("slateblue").describe("Slate blue color (#6A5ACD)"),
		z.literal("slategray").describe("Slate gray color (#708090)"),
		z.literal("slategrey").describe("Alternative spelling of slategray"),
		z.literal("snow").describe("Snow color (#FFFAFA)"),
		z.literal("springgreen").describe("Spring green color (#00FF7F)"),
		z.literal("steelblue").describe("Steel blue color (#4682B4)"),
		z.literal("tan").describe("Tan color (#D2B48C)"),
		z.literal("thistle").describe("Thistle color (#D8BFD8)"),
		z.literal("tomato").describe("Tomato color (#FF6347)"),
		z.literal("turquoise").describe("Turquoise color (#40E0D0)"),
		z.literal("violet").describe("Violet color (#EE82EE)"),
		z.literal("wheat").describe("Wheat color (#F5DEB3)"),
		z.literal("whitesmoke").describe("White smoke color (#F5F5F5)"),
		z.literal("yellowgreen").describe("Yellow green color (#9ACD32)"),
	])
	.describe("CSS extended named colors");

/**
 * Array of all extended named color keyword values.
 *
 * @example
 * ```typescript
 * import { EXTENDED_NAMED_COLOR_KEYWORDS } from "@/core/keywords/extended-color-keywords";
 *
 * console.log(EXTENDED_NAMED_COLOR_KEYWORDS.length); // 125
 * ```
 *
 * @public
 */
export const EXTENDED_NAMED_COLOR_KEYWORDS = extendedNamedColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for extended named color keywords.
 *
 * @public
 */
export type ExtendedNamedColorKeyword = z.infer<typeof extendedNamedColorKeywordsSchema>;

/**
 * Metadata for extended named color keyword options.
 *
 * Provides value and description for each extended named color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { extendedNamedColorKeywordOptions } from "@/core/keywords/extended-color-keywords";
 *
 * extendedNamedColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const extendedNamedColorKeywordOptions = extendedNamedColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for extended named color keyword options metadata.
 *
 * @public
 */
export type ExtendedNamedColorKeywordOptions = typeof extendedNamedColorKeywordOptions;


=== File: src/core/keywords/flex-direction-keywords.test.ts ===
// b_path:: src/core/keywords/flex-direction-keywords.test.ts

import { describe, expect, it } from "vitest";
import {
	FLEX_DIRECTION_KEYWORDS,
	type FlexDirectionKeyword,
	flexDirectionKeywordOptions,
	flexDirectionKeywordsSchema,
} from "./flex-direction-keywords";

describe("flexDirectionKeywordsSchema", () => {
	it("validates row", () => {
		expect(flexDirectionKeywordsSchema.safeParse("row").success).toBe(true);
	});

	it("validates row-reverse", () => {
		expect(flexDirectionKeywordsSchema.safeParse("row-reverse").success).toBe(true);
	});

	it("validates column", () => {
		expect(flexDirectionKeywordsSchema.safeParse("column").success).toBe(true);
	});

	it("validates column-reverse", () => {
		expect(flexDirectionKeywordsSchema.safeParse("column-reverse").success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		expect(flexDirectionKeywordsSchema.safeParse("invalid").success).toBe(false);
	});
});

describe("FLEX_DIRECTION_KEYWORDS", () => {
	it("contains all keywords", () => {
		expect(FLEX_DIRECTION_KEYWORDS).toEqual(["row", "row-reverse", "column", "column-reverse"]);
	});
});

describe("flexDirectionKeywordOptions", () => {
	it("includes descriptions", () => {
		expect(flexDirectionKeywordOptions[0]).toHaveProperty("value");
		expect(flexDirectionKeywordOptions[0]).toHaveProperty("description");
	});
});

describe("FlexDirectionKeyword type", () => {
	it("accepts valid keywords", () => {
		const keyword: FlexDirectionKeyword = "row";
		expect(keyword).toBe("row");
	});
});


=== File: src/core/keywords/flex-direction-keywords.ts ===
// b_path:: src/core/keywords/flex-direction-keywords.ts
import { z } from "zod";

/**
 * CSS `flex-direction` property keyword values.
 *
 * The flex-direction property sets how flex items are placed in the flex container,
 * defining the main axis and the direction (normal or reversed).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction}
 *
 * @example
 * ```typescript
 * import { flexDirectionKeywordsSchema } from "@/core/keywords/flex-direction-keywords";
 *
 * const keyword = flexDirectionKeywordsSchema.parse("row");
 * ```
 *
 * @public
 */
export const flexDirectionKeywordsSchema = z
	.union([
		z.literal("row").describe("horizontal direction in left-to-right layout"),
		z.literal("row-reverse").describe("horizontal direction reversed"),
		z.literal("column").describe("vertical direction from top to bottom"),
		z.literal("column-reverse").describe("vertical direction reversed"),
	])
	.describe("CSS flex-direction property keyword values");

/**
 * Array of all flex-direction keyword values.
 *
 * @public
 */
export const FLEX_DIRECTION_KEYWORDS = flexDirectionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for flex-direction keywords.
 *
 * @public
 */
export type FlexDirectionKeyword = z.infer<typeof flexDirectionKeywordsSchema>;

/**
 * Metadata for flex-direction keyword options.
 *
 * @public
 */
export const flexDirectionKeywordOptions = flexDirectionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for flex-direction keyword options metadata.
 *
 * @public
 */
export type FlexDirectionKeywordOptions = typeof flexDirectionKeywordOptions;


=== File: src/core/keywords/flex-wrap-keywords.test.ts ===
// b_path:: src/core/keywords/flex-wrap-keywords.test.ts

import { describe, expect, it } from "vitest";
import {
	FLEX_WRAP_KEYWORDS,
	type FlexWrapKeyword,
	flexWrapKeywordOptions,
	flexWrapKeywordsSchema,
} from "./flex-wrap-keywords";

describe("flexWrapKeywordsSchema", () => {
	it("validates nowrap", () => {
		expect(flexWrapKeywordsSchema.safeParse("nowrap").success).toBe(true);
	});

	it("validates wrap", () => {
		expect(flexWrapKeywordsSchema.safeParse("wrap").success).toBe(true);
	});

	it("validates wrap-reverse", () => {
		expect(flexWrapKeywordsSchema.safeParse("wrap-reverse").success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		expect(flexWrapKeywordsSchema.safeParse("invalid").success).toBe(false);
	});
});

describe("FLEX_WRAP_KEYWORDS", () => {
	it("contains all keywords", () => {
		expect(FLEX_WRAP_KEYWORDS).toEqual(["nowrap", "wrap", "wrap-reverse"]);
	});
});

describe("flexWrapKeywordOptions", () => {
	it("includes descriptions", () => {
		expect(flexWrapKeywordOptions[0]).toHaveProperty("value");
		expect(flexWrapKeywordOptions[0]).toHaveProperty("description");
	});
});

describe("FlexWrapKeyword type", () => {
	it("accepts valid keywords", () => {
		const keyword: FlexWrapKeyword = "wrap";
		expect(keyword).toBe("wrap");
	});
});


=== File: src/core/keywords/flex-wrap-keywords.ts ===
// b_path:: src/core/keywords/flex-wrap-keywords.ts
import { z } from "zod";

/**
 * CSS `flex-wrap` property keyword values.
 *
 * The flex-wrap property sets whether flex items are forced onto one line
 * or can wrap onto multiple lines.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap}
 *
 * @example
 * ```typescript
 * import { flexWrapKeywordsSchema } from "@/core/keywords/flex-wrap-keywords";
 *
 * const keyword = flexWrapKeywordsSchema.parse("wrap");
 * ```
 *
 * @public
 */
export const flexWrapKeywordsSchema = z
	.union([
		z.literal("nowrap").describe("items laid out in single line (may overflow)"),
		z.literal("wrap").describe("items wrap onto multiple lines top to bottom"),
		z.literal("wrap-reverse").describe("items wrap onto multiple lines bottom to top"),
	])
	.describe("CSS flex-wrap property keyword values");

/**
 * Array of all flex-wrap keyword values.
 *
 * @public
 */
export const FLEX_WRAP_KEYWORDS = flexWrapKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for flex-wrap keywords.
 *
 * @public
 */
export type FlexWrapKeyword = z.infer<typeof flexWrapKeywordsSchema>;

/**
 * Metadata for flex-wrap keyword options.
 *
 * @public
 */
export const flexWrapKeywordOptions = flexWrapKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for flex-wrap keyword options metadata.
 *
 * @public
 */
export type FlexWrapKeywordOptions = typeof flexWrapKeywordOptions;


=== File: src/core/keywords/font-size-keywords.ts ===
// b_path:: src/core/keywords/font-size-keywords.ts
import { z } from "zod";

/**
 * CSS font-size absolute size keywords.
 *
 * Absolute size keywords are mapped to font sizes computed and kept by the browser.
 * These values scale relative to each other based on the user's preferred font size (medium).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size#absolute-size}
 * @public
 */
export const fontSizeAbsoluteKeywordsSchema = z
	.union([
		z.literal("xx-small").describe("absolute size 60% the size of medium"),
		z.literal("x-small").describe("absolute size 75% the size of medium"),
		z.literal("small").describe("absolute size 89% the size of medium"),
		z.literal("medium").describe("user's preferred font size (reference middle value)"),
		z.literal("large").describe("absolute size 20% larger than medium"),
		z.literal("x-large").describe("absolute size 50% larger than medium"),
		z.literal("xx-large").describe("absolute size twice the size of medium"),
		z.literal("xxx-large").describe("absolute size three times the size of medium"),
	])
	.describe(
		"Absolute size keywords for font sizing. " +
			"Used in font shorthand and font-size properties, mapped to deprecated HTML size attributes.",
	);

/**
 * CSS font-size relative size keywords.
 *
 * Relative size keywords scale relative to the parent element's computed font size.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size#relative-size}
 * @public
 */
export const fontSizeRelativeKeywordsSchema = z
	.union([
		z.literal("smaller").describe("one relative size smaller than parent element"),
		z.literal("larger").describe("one relative size larger than parent element"),
	])
	.describe("Relative size keywords scale relative to the parent element's font size.");

/**
 * CSS font-size keywords (all absolute and relative values).
 *
 * The font-size property sets the size of the font. Can be specified using
 * absolute size keywords (xx-small through xxx-large) or relative keywords (smaller, larger).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size}
 *
 * @example
 * ```typescript
 * import { fontSizeKeywordsSchema } from "@/core/keywords/font-size-keywords";
 *
 * const keyword = fontSizeKeywordsSchema.parse("medium"); // "medium"
 * ```
 *
 * @public
 */
export const fontSizeKeywordsSchema = z
	.union([
		// Absolute sizes
		z
			.literal("xx-small")
			.describe("absolute size 60% the size of medium"),
		z.literal("x-small").describe("absolute size 75% the size of medium"),
		z.literal("small").describe("absolute size 89% the size of medium"),
		z.literal("medium").describe("user's preferred font size (reference middle value)"),
		z.literal("large").describe("absolute size 20% larger than medium"),
		z.literal("x-large").describe("absolute size 50% larger than medium"),
		z.literal("xx-large").describe("absolute size twice the size of medium"),
		z.literal("xxx-large").describe("absolute size three times the size of medium"),

		// Relative sizes
		z
			.literal("smaller")
			.describe("one relative size smaller than parent element"),
		z.literal("larger").describe("one relative size larger than parent element"),
	])
	.describe("CSS font-size keywords (absolute and relative)");

/**
 * Array of all absolute font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_ABSOLUTE_KEYWORDS } from "@/core/keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_ABSOLUTE_KEYWORDS);
 * // ["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_ABSOLUTE_KEYWORDS = fontSizeAbsoluteKeywordsSchema.options.map((option) => option.value);

/**
 * Array of all relative font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_RELATIVE_KEYWORDS } from "@/core/keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_RELATIVE_KEYWORDS); // ["smaller", "larger"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_RELATIVE_KEYWORDS = fontSizeRelativeKeywordsSchema.options.map((option) => option.value);

/**
 * Array of all font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_KEYWORDS } from "@/core/keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_KEYWORDS);
 * // ["xx-small", "x-small", ..., "smaller", "larger"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_KEYWORDS = fontSizeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-size keywords.
 *
 * @public
 */
export type FontSizeKeyword = z.infer<typeof fontSizeKeywordsSchema>;

/**
 * TypeScript type for absolute font-size keywords.
 *
 * @public
 */
export type FontSizeAbsoluteKeyword = z.infer<typeof fontSizeAbsoluteKeywordsSchema>;

/**
 * TypeScript type for relative font-size keywords.
 *
 * @public
 */
export type FontSizeRelativeKeyword = z.infer<typeof fontSizeRelativeKeywordsSchema>;

/**
 * Metadata for font-size keyword options.
 *
 * Provides value and description for each font-size keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { fontSizeKeywordOptions } from "@/core/keywords/font-size-keywords";
 *
 * fontSizeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const fontSizeKeywordOptions = fontSizeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeKeywordOptions = typeof fontSizeKeywordOptions;

/**
 * Metadata for absolute font-size keyword options.
 *
 * @public
 */
export const fontSizeAbsoluteKeywordOptions = fontSizeAbsoluteKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for absolute font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeAbsoluteKeywordOptions = typeof fontSizeAbsoluteKeywordOptions;

/**
 * Metadata for relative font-size keyword options.
 *
 * @public
 */
export const fontSizeRelativeKeywordOptions = fontSizeRelativeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for relative font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeRelativeKeywordOptions = typeof fontSizeRelativeKeywordOptions;


=== File: src/core/keywords/font-style-keywords.test.ts ===
// b_path:: src/core/keywords/font-style-keywords.test.ts

import { describe, expect, it } from "vitest";
import {
	FONT_STYLE_KEYWORDS,
	type FontStyleKeyword,
	fontStyleKeywordOptions,
	fontStyleKeywordsSchema,
} from "./font-style-keywords";

describe("fontStyleKeywordsSchema", () => {
	it("validates normal", () => {
		expect(fontStyleKeywordsSchema.safeParse("normal").success).toBe(true);
	});

	it("validates italic", () => {
		expect(fontStyleKeywordsSchema.safeParse("italic").success).toBe(true);
	});

	it("validates oblique", () => {
		expect(fontStyleKeywordsSchema.safeParse("oblique").success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		expect(fontStyleKeywordsSchema.safeParse("invalid").success).toBe(false);
	});
});

describe("FONT_STYLE_KEYWORDS", () => {
	it("contains all keywords", () => {
		expect(FONT_STYLE_KEYWORDS).toEqual(["normal", "italic", "oblique"]);
	});
});

describe("fontStyleKeywordOptions", () => {
	it("includes descriptions", () => {
		expect(fontStyleKeywordOptions[0]).toHaveProperty("value");
		expect(fontStyleKeywordOptions[0]).toHaveProperty("description");
	});
});

describe("FontStyleKeyword type", () => {
	it("accepts valid keywords", () => {
		const keyword: FontStyleKeyword = "italic";
		expect(keyword).toBe("italic");
	});
});


=== File: src/core/keywords/font-style-keywords.ts ===
// b_path:: src/core/keywords/font-style-keywords.ts
import { z } from "zod";

/**
 * CSS font-style keyword values.
 *
 * The font-style property sets whether a font should be styled with a normal, italic,
 * or oblique face from its font-family.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style}
 *
 * @example
 * ```typescript
 * import { fontStyleKeywordsSchema } from "@/core/keywords/font-style-keywords";
 *
 * const keyword = fontStyleKeywordsSchema.parse("italic");
 * ```
 *
 * @public
 */
export const fontStyleKeywordsSchema = z
	.union([
		z.literal("normal").describe("normal font style"),
		z.literal("italic").describe("italic font style using dedicated italic font face"),
		z.literal("oblique").describe("oblique font style using slanted version of normal font"),
	])
	.describe("CSS font-style property keyword values");

/**
 * Array of all font-style keyword values.
 *
 * @public
 */
export const FONT_STYLE_KEYWORDS = fontStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-style keywords.
 *
 * @public
 */
export type FontStyleKeyword = z.infer<typeof fontStyleKeywordsSchema>;

/**
 * Metadata for font-style keyword options.
 *
 * @public
 */
export const fontStyleKeywordOptions = fontStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-style keyword options metadata.
 *
 * @public
 */
export type FontStyleKeywordOptions = typeof fontStyleKeywordOptions;


=== File: src/core/keywords/font-weight-keywords.test.ts ===
// b_path:: src/core/keywords/font-weight-keywords.test.ts

import { describe, expect, it } from "vitest";
import {
	FONT_WEIGHT_KEYWORDS,
	type FontWeightKeyword,
	fontWeightKeywordOptions,
	fontWeightKeywordsSchema,
} from "./font-weight-keywords";

describe("fontWeightKeywordsSchema", () => {
	it("validates normal", () => {
		expect(fontWeightKeywordsSchema.safeParse("normal").success).toBe(true);
	});

	it("validates bold", () => {
		expect(fontWeightKeywordsSchema.safeParse("bold").success).toBe(true);
	});

	it("validates lighter", () => {
		expect(fontWeightKeywordsSchema.safeParse("lighter").success).toBe(true);
	});

	it("validates bolder", () => {
		expect(fontWeightKeywordsSchema.safeParse("bolder").success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		expect(fontWeightKeywordsSchema.safeParse("invalid").success).toBe(false);
	});
});

describe("FONT_WEIGHT_KEYWORDS", () => {
	it("contains all keywords", () => {
		expect(FONT_WEIGHT_KEYWORDS).toEqual(["normal", "bold", "lighter", "bolder"]);
	});
});

describe("fontWeightKeywordOptions", () => {
	it("includes descriptions", () => {
		expect(fontWeightKeywordOptions[0]).toHaveProperty("value");
		expect(fontWeightKeywordOptions[0]).toHaveProperty("description");
	});
});

describe("FontWeightKeyword type", () => {
	it("accepts valid keywords", () => {
		const keyword: FontWeightKeyword = "bold";
		expect(keyword).toBe("bold");
	});
});


=== File: src/core/keywords/font-weight-keywords.ts ===
// b_path:: src/core/keywords/font-weight-keywords.ts
import { z } from "zod";

/**
 * CSS font-weight keyword values.
 *
 * The font-weight property sets the weight (or boldness) of the font.
 * These keyword values are relative to the inherited weight or absolute weights.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight}
 *
 * @example
 * ```typescript
 * import { fontWeightKeywordsSchema } from "@/core/keywords/font-weight-keywords";
 *
 * const keyword = fontWeightKeywordsSchema.parse("bold");
 * ```
 *
 * @public
 */
export const fontWeightKeywordsSchema = z
	.union([
		z.literal("normal").describe("normal font weight (equivalent to 400)"),
		z.literal("bold").describe("bold font weight (equivalent to 700)"),
		z.literal("lighter").describe("one relative font weight lighter than parent"),
		z.literal("bolder").describe("one relative font weight bolder than parent"),
	])
	.describe("CSS font-weight property keyword values");

/**
 * Array of all font-weight keyword values.
 *
 * @public
 */
export const FONT_WEIGHT_KEYWORDS = fontWeightKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-weight keywords.
 *
 * @public
 */
export type FontWeightKeyword = z.infer<typeof fontWeightKeywordsSchema>;

/**
 * Metadata for font-weight keyword options.
 *
 * @public
 */
export const fontWeightKeywordOptions = fontWeightKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-weight keyword options metadata.
 *
 * @public
 */
export type FontWeightKeywordOptions = typeof fontWeightKeywordOptions;


=== File: src/core/keywords/geometry-box.test.ts ===
// b_path:: src/core/keywords/geometry-box.test.ts
import { describe, expect, it } from "vitest";
import {
	geometryBoxKeywords,
	geometryBoxKeywordsSchema,
	shapeBoxKeywords,
	shapeBoxKeywordsSchema,
	visualBoxKeywords,
	visualBoxKeywordsSchema,
} from "./geometry-box";

describe("visual box keywords", () => {
	it("exports keywords array", () => {
		expect(visualBoxKeywords).toEqual(["content-box", "padding-box", "border-box"]);
	});

	it("validates 'content-box'", () => {
		const result = visualBoxKeywordsSchema.safeParse("content-box");
		expect(result.success).toBe(true);
	});

	it("validates 'padding-box'", () => {
		const result = visualBoxKeywordsSchema.safeParse("padding-box");
		expect(result.success).toBe(true);
	});

	it("validates 'border-box'", () => {
		const result = visualBoxKeywordsSchema.safeParse("border-box");
		expect(result.success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		const result = visualBoxKeywordsSchema.safeParse("margin-box");
		expect(result.success).toBe(false);
	});
});

describe("shape box keywords", () => {
	it("exports keywords array with margin-box", () => {
		expect(shapeBoxKeywords).toEqual(["content-box", "padding-box", "border-box", "margin-box"]);
	});

	it("validates 'margin-box'", () => {
		const result = shapeBoxKeywordsSchema.safeParse("margin-box");
		expect(result.success).toBe(true);
	});

	it("validates visual box keywords", () => {
		const result = shapeBoxKeywordsSchema.safeParse("content-box");
		expect(result.success).toBe(true);
	});
});

describe("geometry box keywords", () => {
	it("exports keywords array with SVG keywords", () => {
		expect(geometryBoxKeywords).toEqual([
			"content-box",
			"padding-box",
			"border-box",
			"margin-box",
			"fill-box",
			"stroke-box",
			"view-box",
		]);
	});

	it("validates 'fill-box'", () => {
		const result = geometryBoxKeywordsSchema.safeParse("fill-box");
		expect(result.success).toBe(true);
	});

	it("validates 'stroke-box'", () => {
		const result = geometryBoxKeywordsSchema.safeParse("stroke-box");
		expect(result.success).toBe(true);
	});

	it("validates 'view-box'", () => {
		const result = geometryBoxKeywordsSchema.safeParse("view-box");
		expect(result.success).toBe(true);
	});

	it("validates all visual and shape keywords", () => {
		const result = geometryBoxKeywordsSchema.safeParse("margin-box");
		expect(result.success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		const result = geometryBoxKeywordsSchema.safeParse("invalid-box");
		expect(result.success).toBe(false);
	});
});


=== File: src/core/keywords/geometry-box.ts ===
// b_path:: src/core/keywords/geometry-box.ts

import { z } from "zod";

/**
 * Visual box keywords used in layout and clipping contexts.
 *
 * Defines the box model edges for visual rendering:
 * - content-box: Content area only
 * - padding-box: Content + padding
 * - border-box: Content + padding + border
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-edge}
 *
 * @public
 */
export const visualBoxKeywords = ["content-box", "padding-box", "border-box"] as const;

export const visualBoxKeywordsSchema = z.enum(visualBoxKeywords);
export type VisualBoxKeyword = z.infer<typeof visualBoxKeywordsSchema>;

/**
 * Shape box keywords extend visual box with margin-box.
 *
 * Used for shape-outside and clip-path to define the reference box
 * for shape positioning.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-edge}
 *
 * @public
 */
export const shapeBoxKeywords = [...visualBoxKeywords, "margin-box"] as const;

export const shapeBoxKeywordsSchema = z.enum(shapeBoxKeywords);
export type ShapeBoxKeyword = z.infer<typeof shapeBoxKeywordsSchema>;

/**
 * Geometry box keywords extend shape box with SVG-specific keywords.
 *
 * Used for clip-path to define the clipping region reference box.
 * SVG keywords (fill-box, stroke-box, view-box) only apply in SVG context.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path#geometry-box}
 *
 * @public
 */
export const geometryBoxKeywords = [...shapeBoxKeywords, "fill-box", "stroke-box", "view-box"] as const;

export const geometryBoxKeywordsSchema = z.enum(geometryBoxKeywords);
export type GeometryBoxKeyword = z.infer<typeof geometryBoxKeywordsSchema>;


=== File: src/core/keywords/grid-auto-flow-keywords.test.ts ===
// b_path:: src/core/keywords/grid-auto-flow-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	GRID_AUTO_FLOW_KEYWORDS,
	type GridAutoFlowKeyword,
	type GridAutoFlowKeywordOptions,
	gridAutoFlowKeywordOptions,
	gridAutoFlowKeywordsSchema,
} from "./grid-auto-flow-keywords";

describe("gridAutoFlowKeywordsSchema", () => {
	it("accepts all valid grid-auto-flow keywords", () => {
		const keywords: GridAutoFlowKeyword[] = ["row", "column", "dense", "row dense", "column dense"];

		for (const keyword of keywords) {
			expect(gridAutoFlowKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid grid-auto-flow keywords", () => {
		expect(gridAutoFlowKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(gridAutoFlowKeywordsSchema.safeParse("").success).toBe(false);
		expect(gridAutoFlowKeywordsSchema.safeParse(123).success).toBe(false);
		expect(gridAutoFlowKeywordsSchema.safeParse("dense row").success).toBe(false);
	});

	it("accepts row keyword", () => {
		expect(gridAutoFlowKeywordsSchema.safeParse("row").success).toBe(true);
	});

	it("accepts column keyword", () => {
		expect(gridAutoFlowKeywordsSchema.safeParse("column").success).toBe(true);
	});

	it("accepts dense packing keywords", () => {
		expect(gridAutoFlowKeywordsSchema.safeParse("dense").success).toBe(true);
		expect(gridAutoFlowKeywordsSchema.safeParse("row dense").success).toBe(true);
		expect(gridAutoFlowKeywordsSchema.safeParse("column dense").success).toBe(true);
	});
});

describe("GRID_AUTO_FLOW_KEYWORDS", () => {
	it("contains exactly 5 keywords", () => {
		expect(GRID_AUTO_FLOW_KEYWORDS).toHaveLength(5);
	});

	it("contains all valid grid-auto-flow keywords", () => {
		expect(GRID_AUTO_FLOW_KEYWORDS).toContain("row");
		expect(GRID_AUTO_FLOW_KEYWORDS).toContain("column");
		expect(GRID_AUTO_FLOW_KEYWORDS).toContain("dense");
		expect(GRID_AUTO_FLOW_KEYWORDS).toContain("row dense");
		expect(GRID_AUTO_FLOW_KEYWORDS).toContain("column dense");
	});
});

describe("gridAutoFlowKeywordOptions", () => {
	it("contains metadata for all keywords", () => {
		expect(gridAutoFlowKeywordOptions).toHaveLength(5);
		expect(gridAutoFlowKeywordOptions[0]).toHaveProperty("value");
		expect(gridAutoFlowKeywordOptions[0]).toHaveProperty("description");
	});

	it("has descriptions for all keywords", () => {
		for (const option of gridAutoFlowKeywordOptions) {
			expect(option.description).toBeTruthy();
			expect(typeof option.description).toBe("string");
		}
	});

	it("describes dense packing", () => {
		const denseOption = gridAutoFlowKeywordOptions.find((opt) => opt.value === "dense");
		expect(denseOption).toBeDefined();
		expect(denseOption?.description).toContain("dense packing");
	});
});

describe("GridAutoFlowKeywordOptions type", () => {
	it("is correctly typed", () => {
		const options: GridAutoFlowKeywordOptions = gridAutoFlowKeywordOptions;
		expect(options).toBeDefined();
		expect(Array.isArray(options)).toBe(true);
	});
});


=== File: src/core/keywords/grid-auto-flow-keywords.ts ===
// b_path:: src/core/keywords/grid-auto-flow-keywords.ts
import { z } from "zod";

/**
 * CSS `grid-auto-flow` property keyword values.
 *
 * The grid-auto-flow property controls how auto-placed items get inserted into the grid.
 * It determines whether to place items by filling rows or columns, and whether to use
 * dense packing to fill holes.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow}
 *
 * @example
 * ```typescript
 * import { gridAutoFlowKeywordsSchema } from "@/core/keywords/grid-auto-flow-keywords";
 *
 * const keyword = gridAutoFlowKeywordsSchema.parse("row");
 * ```
 *
 * @public
 */
export const gridAutoFlowKeywordsSchema = z
	.union([
		z.literal("row").describe("auto-placed items fill rows"),
		z.literal("column").describe("auto-placed items fill columns"),
		z.literal("dense").describe("use dense packing algorithm to fill holes"),
		z.literal("row dense").describe("auto-placed items fill rows with dense packing"),
		z.literal("column dense").describe("auto-placed items fill columns with dense packing"),
	])
	.describe("CSS grid-auto-flow property keyword values");

/**
 * Array of all grid-auto-flow keyword values.
 *
 * @public
 */
export const GRID_AUTO_FLOW_KEYWORDS = gridAutoFlowKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for grid-auto-flow keywords.
 *
 * @public
 */
export type GridAutoFlowKeyword = z.infer<typeof gridAutoFlowKeywordsSchema>;

/**
 * Metadata for grid-auto-flow keyword options.
 *
 * @public
 */
export const gridAutoFlowKeywordOptions = gridAutoFlowKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for grid-auto-flow keyword options metadata.
 *
 * @public
 */
export type GridAutoFlowKeywordOptions = typeof gridAutoFlowKeywordOptions;


=== File: src/core/keywords/index.ts ===
// b_path:: src/core/keywords/index.ts

export * from "./align-content-keywords";
export * from "./align-items-keywords";
export * from "./align-self-keywords";
export * from "./animation";
export * from "./auto-keyword";
export * from "./background-attachment-keywords";
export * from "./basic-color-keywords";
export * from "./blend-mode-keywords";
export * from "./border-style-keywords";
export * from "./border-width-keywords";
export * from "./box-edge-keywords";
export * from "./color-interpolation-keywords";
export * from "./color-keywords";
export * from "./color-value-keywords";
export * from "./content-distribution-keywords";
export * from "./content-position-keywords";
export * from "./corner-shape-keywords";
export * from "./cursor-keywords";
export * from "./display-keywords";
export * from "./extended-color-keywords";
export * from "./flex-direction-keywords";
export * from "./flex-wrap-keywords";
export * from "./font-size-keywords";
export * from "./font-style-keywords";
export * from "./font-weight-keywords";
export * from "./geometry-box";
export * from "./grid-auto-flow-keywords";
export * from "./justify-content-keywords";
export * from "./justify-items-keywords";
export * from "./justify-items-keywords";
export * from "./justify-self-keywords";
export * from "./outline-style-keywords";
export * from "./overflow-keywords";
export * from "./overflow-wrap-keywords";
export * from "./position-keywords";
export * from "./position-property-keywords";
export * from "./repeat-keywords";
export * from "./shape-keywords";
export * from "./sizing-keywords";
export * from "./text-align-keywords";
export * from "./text-decoration-line-keywords";
export * from "./text-decoration-style-keywords";
export * from "./text-decoration-thickness-keywords";
export * from "./text-transform-keywords";
export * from "./transform-keywords";
export * from "./vertical-align-keywords";
export * from "./visibility-keywords";
export * from "./white-space-keywords";
export * from "./width-height-keywords";
export * from "./word-break-keywords";


=== File: src/core/keywords/justify-content-keywords.test.ts ===
// b_path:: src/core/keywords/justify-content-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	JUSTIFY_CONTENT_KEYWORDS,
	type JustifyContentKeyword,
	justifyContentKeywordsSchema,
} from "./justify-content-keywords";

describe("justifyContentKeywordsSchema", () => {
	it("accepts all valid justify-content keywords", () => {
		const keywords: JustifyContentKeyword[] = [
			"flex-start",
			"flex-end",
			"center",
			"space-between",
			"space-around",
			"space-evenly",
			"start",
			"end",
			"left",
			"right",
		];

		for (const keyword of keywords) {
			expect(justifyContentKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid justify-content keywords", () => {
		expect(justifyContentKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(justifyContentKeywordsSchema.safeParse("").success).toBe(false);
		expect(justifyContentKeywordsSchema.safeParse(123).success).toBe(false);
		expect(justifyContentKeywordsSchema.safeParse("baseline").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(JUSTIFY_CONTENT_KEYWORDS).toHaveLength(10);
		expect(JUSTIFY_CONTENT_KEYWORDS).toContain("flex-start");
		expect(JUSTIFY_CONTENT_KEYWORDS).toContain("space-evenly");
	});
});


=== File: src/core/keywords/justify-content-keywords.ts ===
// b_path:: src/core/keywords/justify-content-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-content` property keyword values.
 *
 * The justify-content property defines how the browser distributes space between
 * and around content items along the main-axis of a flex container, and the inline
 * axis of a grid container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content}
 *
 * @example
 * ```typescript
 * import { justifyContentKeywordsSchema } from "@/core/keywords/justify-content-keywords";
 *
 * const keyword = justifyContentKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const justifyContentKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items packed at start of flex direction"),
		z.literal("flex-end").describe("items packed at end of flex direction"),
		z.literal("center").describe("items centered along main axis"),
		z.literal("space-between").describe("items evenly distributed, first/last at edges"),
		z.literal("space-around").describe("items evenly distributed with equal space around"),
		z.literal("space-evenly").describe("items evenly distributed with equal space between"),
		z.literal("start").describe("items packed at start of writing mode direction"),
		z.literal("end").describe("items packed at end of writing mode direction"),
		z.literal("left").describe("items packed toward left edge"),
		z.literal("right").describe("items packed toward right edge"),
	])
	.describe("CSS justify-content property keyword values");

/**
 * Array of all justify-content keyword values.
 *
 * @public
 */
export const JUSTIFY_CONTENT_KEYWORDS = justifyContentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-content keywords.
 *
 * @public
 */
export type JustifyContentKeyword = z.infer<typeof justifyContentKeywordsSchema>;

/**
 * Metadata for justify-content keyword options.
 *
 * @public
 */
export const justifyContentKeywordOptions = justifyContentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-content keyword options metadata.
 *
 * @public
 */
export type JustifyContentKeywordOptions = typeof justifyContentKeywordOptions;


=== File: src/core/keywords/justify-items-keywords.test.ts ===
// b_path:: src/core/keywords/justify-items-keywords.test.ts
import { describe, expect, it } from "vitest";
import { JUSTIFY_ITEMS_KEYWORDS, type JustifyItemsKeyword, justifyItemsKeywordsSchema } from "./justify-items-keywords";

describe("justifyItemsKeywordsSchema", () => {
	it("accepts all valid justify-items keywords", () => {
		const keywords: JustifyItemsKeyword[] = [
			"start",
			"end",
			"center",
			"stretch",
			"baseline",
			"flex-start",
			"flex-end",
			"self-start",
			"self-end",
			"left",
			"right",
		];

		for (const keyword of keywords) {
			expect(justifyItemsKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid justify-items keywords", () => {
		expect(justifyItemsKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(justifyItemsKeywordsSchema.safeParse("").success).toBe(false);
		expect(justifyItemsKeywordsSchema.safeParse(123).success).toBe(false);
		expect(justifyItemsKeywordsSchema.safeParse("space-between").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(JUSTIFY_ITEMS_KEYWORDS).toHaveLength(11);
		expect(JUSTIFY_ITEMS_KEYWORDS).toContain("center");
		expect(JUSTIFY_ITEMS_KEYWORDS).toContain("self-end");
	});
});


=== File: src/core/keywords/justify-items-keywords.ts ===
// b_path:: src/core/keywords/justify-items-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-items` property keyword values.
 *
 * The justify-items property defines the default justify-self for all items of the box,
 * giving them all a default way of justifying each box along the appropriate axis.
 * In grid layout, it controls the inline axis (horizontal) alignment of items within their grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items}
 *
 * @example
 * ```typescript
 * import { justifyItemsKeywordsSchema } from "@/core/keywords/justify-items-keywords";
 *
 * const keyword = justifyItemsKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const justifyItemsKeywordsSchema = z
	.union([
		z.literal("start").describe("items aligned at start of writing mode direction"),
		z.literal("end").describe("items aligned at end of writing mode direction"),
		z.literal("center").describe("items centered along inline axis"),
		z.literal("stretch").describe("items stretched to fill grid area"),
		z.literal("baseline").describe("items aligned along their baselines"),
		z.literal("flex-start").describe("items aligned at start of flex direction"),
		z.literal("flex-end").describe("items aligned at end of flex direction"),
		z.literal("self-start").describe("items aligned at start of their own writing mode"),
		z.literal("self-end").describe("items aligned at end of their own writing mode"),
		z.literal("left").describe("items aligned to left edge"),
		z.literal("right").describe("items aligned to right edge"),
	])
	.describe("CSS justify-items property keyword values");

/**
 * Array of all justify-items keyword values.
 *
 * @public
 */
export const JUSTIFY_ITEMS_KEYWORDS = justifyItemsKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-items keywords.
 *
 * @public
 */
export type JustifyItemsKeyword = z.infer<typeof justifyItemsKeywordsSchema>;

/**
 * Metadata for justify-items keyword options.
 *
 * @public
 */
export const justifyItemsKeywordOptions = justifyItemsKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-items keyword options metadata.
 *
 * @public
 */
export type JustifyItemsKeywordOptions = typeof justifyItemsKeywordOptions;


=== File: src/core/keywords/justify-self-keywords.test.ts ===
// b_path:: src/core/keywords/justify-self-keywords.test.ts
import { describe, expect, it } from "vitest";
import { JUSTIFY_SELF_KEYWORDS, type JustifySelfKeyword, justifySelfKeywordsSchema } from "./justify-self-keywords";

describe("justifySelfKeywordsSchema", () => {
	it("accepts all valid justify-self keywords", () => {
		const keywords: JustifySelfKeyword[] = [
			"auto",
			"start",
			"end",
			"center",
			"stretch",
			"baseline",
			"flex-start",
			"flex-end",
			"self-start",
			"self-end",
			"left",
			"right",
		];

		for (const keyword of keywords) {
			expect(justifySelfKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid justify-self keywords", () => {
		expect(justifySelfKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(justifySelfKeywordsSchema.safeParse("").success).toBe(false);
		expect(justifySelfKeywordsSchema.safeParse(123).success).toBe(false);
		expect(justifySelfKeywordsSchema.safeParse("space-between").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(JUSTIFY_SELF_KEYWORDS).toHaveLength(12);
		expect(JUSTIFY_SELF_KEYWORDS).toContain("auto");
		expect(JUSTIFY_SELF_KEYWORDS).toContain("right");
	});
});


=== File: src/core/keywords/justify-self-keywords.ts ===
// b_path:: src/core/keywords/justify-self-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-self` property keyword values.
 *
 * The justify-self property sets the way a box is justified inside its alignment container
 * along the appropriate axis. In grid layout, it controls the inline axis (horizontal)
 * alignment of a single item within its grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self}
 *
 * @example
 * ```typescript
 * import { justifySelfKeywordsSchema } from "@/core/keywords/justify-self-keywords";
 *
 * const keyword = justifySelfKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const justifySelfKeywordsSchema = z
	.union([
		z.literal("auto").describe("uses parent's justify-items value"),
		z.literal("start").describe("item aligned at start of writing mode direction"),
		z.literal("end").describe("item aligned at end of writing mode direction"),
		z.literal("center").describe("item centered along inline axis"),
		z.literal("stretch").describe("item stretched to fill grid area"),
		z.literal("baseline").describe("item aligned along its baseline"),
		z.literal("flex-start").describe("item aligned at start of flex direction"),
		z.literal("flex-end").describe("item aligned at end of flex direction"),
		z.literal("self-start").describe("item aligned at start of its own writing mode"),
		z.literal("self-end").describe("item aligned at end of its own writing mode"),
		z.literal("left").describe("item aligned to left edge"),
		z.literal("right").describe("item aligned to right edge"),
	])
	.describe("CSS justify-self property keyword values");

/**
 * Array of all justify-self keyword values.
 *
 * @public
 */
export const JUSTIFY_SELF_KEYWORDS = justifySelfKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-self keywords.
 *
 * @public
 */
export type JustifySelfKeyword = z.infer<typeof justifySelfKeywordsSchema>;

/**
 * Metadata for justify-self keyword options.
 *
 * @public
 */
export const justifySelfKeywordOptions = justifySelfKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-self keyword options metadata.
 *
 * @public
 */
export type JustifySelfKeywordOptions = typeof justifySelfKeywordOptions;


=== File: src/core/keywords/outline-style-keywords.test.ts ===
// b_path:: src/core/keywords/outline-style-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	OUTLINE_STYLE_KEYWORDS,
	type OutlineStyleKeyword,
	type OutlineStyleKeywordOptions,
	outlineStyleKeywordOptions,
	outlineStyleKeywordsSchema,
} from "./outline-style-keywords";

describe("outlineStyleKeywordsSchema", () => {
	it("accepts all valid outline-style keywords", () => {
		const keywords: OutlineStyleKeyword[] = [
			"auto",
			"none",
			"hidden",
			"dotted",
			"dashed",
			"solid",
			"double",
			"groove",
			"ridge",
			"inset",
			"outset",
		];

		for (const keyword of keywords) {
			expect(outlineStyleKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid outline-style keywords", () => {
		expect(outlineStyleKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(outlineStyleKeywordsSchema.safeParse("").success).toBe(false);
		expect(outlineStyleKeywordsSchema.safeParse(123).success).toBe(false);
	});

	it("includes auto keyword specific to outline-style", () => {
		expect(outlineStyleKeywordsSchema.safeParse("auto").success).toBe(true);
	});
});

describe("OUTLINE_STYLE_KEYWORDS", () => {
	it("contains all valid outline-style keywords", () => {
		expect(OUTLINE_STYLE_KEYWORDS).toHaveLength(11);
		expect(OUTLINE_STYLE_KEYWORDS).toContain("auto");
		expect(OUTLINE_STYLE_KEYWORDS).toContain("none");
		expect(OUTLINE_STYLE_KEYWORDS).toContain("solid");
		expect(OUTLINE_STYLE_KEYWORDS).toContain("double");
	});

	it("has unique keywords", () => {
		const uniqueKeywords = [...new Set(OUTLINE_STYLE_KEYWORDS)];
		expect(uniqueKeywords.length).toBe(OUTLINE_STYLE_KEYWORDS.length);
	});
});

describe("outlineStyleKeywordOptions", () => {
	it("contains metadata for all keywords", () => {
		expect(outlineStyleKeywordOptions).toHaveLength(11);
		expect(outlineStyleKeywordOptions[0]).toHaveProperty("value");
		expect(outlineStyleKeywordOptions[0]).toHaveProperty("description");
	});

	it("has descriptions for all keywords", () => {
		for (const option of outlineStyleKeywordOptions) {
			expect(option.description).toBeTruthy();
			expect(typeof option.description).toBe("string");
		}
	});

	it("auto keyword has browser-specific description", () => {
		const autoOption = outlineStyleKeywordOptions.find((opt) => opt.value === "auto");
		expect(autoOption).toBeDefined();
		expect(autoOption?.description).toContain("browser");
	});
});

describe("OutlineStyleKeywordOptions type", () => {
	it("is correctly typed", () => {
		const options: OutlineStyleKeywordOptions = outlineStyleKeywordOptions;
		expect(options).toBeDefined();
		expect(Array.isArray(options)).toBe(true);
	});
});


=== File: src/core/keywords/outline-style-keywords.ts ===
// b_path:: src/core/keywords/outline-style-keywords.ts
import { z } from "zod";

/**
 * CSS outline-style keyword values.
 *
 * The outline-style property sets the style of an element's outline.
 * Includes 'auto' which is outline-specific, plus all border-style values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style}
 *
 * @public
 */
export const outlineStyleKeywordsSchema = z
	.union([
		z.literal("auto").describe("browser determines outline style"),
		z.literal("none").describe("no outline"),
		z.literal("hidden").describe("same as none, but with different behavior in table elements"),
		z.literal("dotted").describe("series of round dots"),
		z.literal("dashed").describe("series of short square-ended dashes"),
		z.literal("solid").describe("single, straight, solid line"),
		z.literal("double").describe("two straight lines that add up to the pixel size"),
		z.literal("groove").describe("carved effect - opposite of ridge"),
		z.literal("ridge").describe("extruded effect - opposite of groove"),
		z.literal("inset").describe("outline makes element appear embedded"),
		z.literal("outset").describe("outline makes element appear raised"),
	])
	.describe("CSS outline-style property keyword values");

/**
 * Array of all outline-style keyword values.
 *
 * @public
 */
export const OUTLINE_STYLE_KEYWORDS = outlineStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for outline-style keywords.
 *
 * @public
 */
export type OutlineStyleKeyword = z.infer<typeof outlineStyleKeywordsSchema>;

/**
 * Metadata for outline-style keyword options.
 *
 * @public
 */
export const outlineStyleKeywordOptions = outlineStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for outline-style keyword options metadata.
 *
 * @public
 */
export type OutlineStyleKeywordOptions = typeof outlineStyleKeywordOptions;


=== File: src/core/keywords/overflow-keywords.test.ts ===
// b_path:: src/core/keywords/overflow-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	OVERFLOW_KEYWORDS,
	type OverflowKeyword,
	type OverflowKeywordOptions,
	overflowKeywordOptions,
	overflowKeywordsSchema,
} from "./overflow-keywords";

describe("overflowKeywordsSchema", () => {
	it("accepts all valid overflow keywords", () => {
		const keywords: OverflowKeyword[] = ["visible", "hidden", "clip", "scroll", "auto"];

		for (const keyword of keywords) {
			expect(overflowKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid overflow keywords", () => {
		expect(overflowKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(overflowKeywordsSchema.safeParse("").success).toBe(false);
		expect(overflowKeywordsSchema.safeParse(123).success).toBe(false);
		expect(overflowKeywordsSchema.safeParse("none").success).toBe(false);
	});

	it("accepts visible keyword", () => {
		expect(overflowKeywordsSchema.safeParse("visible").success).toBe(true);
	});

	it("accepts hidden keyword", () => {
		expect(overflowKeywordsSchema.safeParse("hidden").success).toBe(true);
	});

	it("accepts clip keyword", () => {
		expect(overflowKeywordsSchema.safeParse("clip").success).toBe(true);
	});

	it("accepts scroll and auto keywords", () => {
		expect(overflowKeywordsSchema.safeParse("scroll").success).toBe(true);
		expect(overflowKeywordsSchema.safeParse("auto").success).toBe(true);
	});
});

describe("OVERFLOW_KEYWORDS", () => {
	it("contains exactly 5 keywords", () => {
		expect(OVERFLOW_KEYWORDS).toHaveLength(5);
	});

	it("contains all valid overflow keywords", () => {
		expect(OVERFLOW_KEYWORDS).toContain("visible");
		expect(OVERFLOW_KEYWORDS).toContain("hidden");
		expect(OVERFLOW_KEYWORDS).toContain("clip");
		expect(OVERFLOW_KEYWORDS).toContain("scroll");
		expect(OVERFLOW_KEYWORDS).toContain("auto");
	});
});

describe("overflowKeywordOptions", () => {
	it("contains metadata for all keywords", () => {
		expect(overflowKeywordOptions).toHaveLength(5);
		expect(overflowKeywordOptions[0]).toHaveProperty("value");
		expect(overflowKeywordOptions[0]).toHaveProperty("description");
	});

	it("has descriptions for all keywords", () => {
		for (const option of overflowKeywordOptions) {
			expect(option.description).toBeTruthy();
			expect(typeof option.description).toBe("string");
		}
	});

	it("describes clipping behavior", () => {
		const hiddenOption = overflowKeywordOptions.find((opt) => opt.value === "hidden");
		expect(hiddenOption).toBeDefined();
		if (hiddenOption?.description) {
			expect(hiddenOption.description.toLowerCase()).toContain("clip");
		}
	});

	it("describes scrollbar behavior", () => {
		const scrollOption = overflowKeywordOptions.find((opt) => opt.value === "scroll");
		expect(scrollOption).toBeDefined();
		if (scrollOption?.description) {
			expect(scrollOption.description.toLowerCase()).toContain("scrollbar");
		}
	});
});

describe("OverflowKeywordOptions type", () => {
	it("is correctly typed", () => {
		const options: OverflowKeywordOptions = overflowKeywordOptions;
		expect(options).toBeDefined();
		expect(Array.isArray(options)).toBe(true);
	});
});


=== File: src/core/keywords/overflow-keywords.ts ===
// b_path:: src/core/keywords/overflow-keywords.ts
import { z } from "zod";

/**
 * CSS overflow keyword values.
 *
 * The overflow, overflow-x, and overflow-y properties control what happens when content
 * overflows an element's box. These properties apply to block containers, flex containers,
 * and grid containers.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow}
 * @see {@link https://www.w3.org/TR/css-overflow-3/#overflow-properties}
 *
 * @example
 * ```typescript
 * import { overflowKeywordsSchema } from "@/core/keywords/overflow-keywords";
 *
 * const keyword = overflowKeywordsSchema.parse("hidden");
 * ```
 *
 * @public
 */
export const overflowKeywordsSchema = z.enum(["visible", "hidden", "clip", "scroll", "auto"], {
	error: () => ({ message: "Expected visible | hidden | clip | scroll | auto" }),
});

/**
 * Array of all overflow keyword values.
 *
 * @public
 */
export const OVERFLOW_KEYWORDS = overflowKeywordsSchema.options;

/**
 * TypeScript type for overflow keywords.
 *
 * @public
 */
export type OverflowKeyword = z.infer<typeof overflowKeywordsSchema>;

/**
 * Descriptions for overflow keywords.
 *
 * @internal
 */
const OVERFLOW_DESCRIPTIONS: Record<OverflowKeyword, string> = {
	visible: "content is not clipped and may overflow the element's box",
	hidden: "content is clipped and no scrollbars are provided",
	clip: "content is clipped at the overflow clip edge, no scrollbars",
	scroll: "content is clipped and scrollbars are always shown",
	auto: "content is clipped and scrollbars shown only when needed",
};

/**
 * Metadata for overflow keyword options.
 *
 * @public
 */
export const overflowKeywordOptions = OVERFLOW_KEYWORDS.map((value) => ({
	value,
	description: OVERFLOW_DESCRIPTIONS[value],
}));

/**
 * Type for overflow keyword options metadata.
 *
 * @public
 */
export type OverflowKeywordOptions = typeof overflowKeywordOptions;


=== File: src/core/keywords/overflow-wrap-keywords.test.ts ===
// b_path:: src/core/keywords/overflow-wrap-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	OVERFLOW_WRAP_KEYWORDS,
	type OverflowWrapKeyword,
	overflowWrapKeywordsMetadata,
	overflowWrapKeywordsSchema,
} from "./overflow-wrap-keywords";

describe("overflowWrapKeywordsSchema", () => {
	it("accepts all valid overflow-wrap keywords", () => {
		const keywords: OverflowWrapKeyword[] = ["normal", "anywhere", "break-word"];

		for (const keyword of keywords) {
			expect(overflowWrapKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid overflow-wrap keywords", () => {
		expect(overflowWrapKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(overflowWrapKeywordsSchema.safeParse("").success).toBe(false);
		expect(overflowWrapKeywordsSchema.safeParse(123).success).toBe(false);
		expect(overflowWrapKeywordsSchema.safeParse("break-all").success).toBe(false);
	});

	it("accepts normal keyword", () => {
		expect(overflowWrapKeywordsSchema.safeParse("normal").success).toBe(true);
	});

	it("accepts anywhere keyword", () => {
		expect(overflowWrapKeywordsSchema.safeParse("anywhere").success).toBe(true);
	});

	it("accepts break-word keyword", () => {
		expect(overflowWrapKeywordsSchema.safeParse("break-word").success).toBe(true);
	});
});

describe("OVERFLOW_WRAP_KEYWORDS", () => {
	it("contains exactly 3 keywords", () => {
		expect(OVERFLOW_WRAP_KEYWORDS).toHaveLength(3);
	});

	it("contains all valid overflow-wrap keywords", () => {
		expect(OVERFLOW_WRAP_KEYWORDS).toContain("normal");
		expect(OVERFLOW_WRAP_KEYWORDS).toContain("anywhere");
		expect(OVERFLOW_WRAP_KEYWORDS).toContain("break-word");
	});
});

describe("overflowWrapKeywordsMetadata", () => {
	it("contains metadata for all keywords", () => {
		expect(overflowWrapKeywordsMetadata.normal).toBeDefined();
		expect(overflowWrapKeywordsMetadata.anywhere).toBeDefined();
		expect(overflowWrapKeywordsMetadata["break-word"]).toBeDefined();
	});

	it("has value and description properties", () => {
		expect(overflowWrapKeywordsMetadata.normal).toHaveProperty("value");
		expect(overflowWrapKeywordsMetadata.normal).toHaveProperty("description");
		expect(overflowWrapKeywordsMetadata.anywhere).toHaveProperty("value");
		expect(overflowWrapKeywordsMetadata.anywhere).toHaveProperty("description");
	});

	it("describes normal break behavior", () => {
		expect(overflowWrapKeywordsMetadata.normal.description).toContain("normal break");
	});

	it("describes anywhere break behavior", () => {
		expect(overflowWrapKeywordsMetadata.anywhere.description.toLowerCase()).toContain("any character");
	});

	it("describes break-word behavior", () => {
		expect(overflowWrapKeywordsMetadata["break-word"].description.toLowerCase()).toContain("anywhere");
	});
});


=== File: src/core/keywords/overflow-wrap-keywords.ts ===
// b_path:: src/core/keywords/overflow-wrap-keywords.ts
import { z } from "zod";

/**
 * CSS overflow-wrap keyword values.
 *
 * The overflow-wrap property applies to inline elements, setting whether the browser
 * should insert line breaks within an otherwise unbreakable string to prevent text
 * from overflowing its line box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap}
 *
 * @example
 * ```typescript
 * import { overflowWrapKeywordsSchema } from "@/core/keywords/overflow-wrap-keywords";
 *
 * const keyword = overflowWrapKeywordsSchema.parse("break-word");
 * ```
 *
 * @public
 */
export const overflowWrapKeywordsSchema = z
	.union([
		z.literal("normal").describe("lines break only at normal break points"),
		z.literal("anywhere").describe("breaks at any character if no acceptable break point"),
		z.literal("break-word").describe("like anywhere but affects min-content size"),
	])
	.describe("CSS overflow-wrap property keyword values");

/**
 * Array of all overflow-wrap keyword values.
 *
 * @public
 */
export const OVERFLOW_WRAP_KEYWORDS = overflowWrapKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for overflow-wrap keywords.
 *
 * @public
 */
export type OverflowWrapKeyword = z.infer<typeof overflowWrapKeywordsSchema>;

/**
 * Metadata for overflow-wrap keyword options.
 *
 * @public
 */
export const overflowWrapKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Lines break only at normal break points",
	},
	anywhere: {
		value: "anywhere" as const,
		description: "Breaks at any character if no acceptable break point",
	},
	"break-word": {
		value: "break-word" as const,
		description: "Like anywhere but affects min-content size",
	},
} as const;


=== File: src/core/keywords/position-keywords.test.ts ===
// b_path:: src/core/keywords/position-keywords.test.ts
import { describe, expect, it } from "vitest";
import { POSITION_KEYWORDS, positionKeywordsSchema } from "./position-keywords";

describe("positionKeywordsSchema", () => {
	it("accepts all valid position keywords", () => {
		for (const keyword of POSITION_KEYWORDS) {
			expect(positionKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("accepts center", () => {
		expect(positionKeywordsSchema.safeParse("center").success).toBe(true);
	});

	it("accepts left", () => {
		expect(positionKeywordsSchema.safeParse("left").success).toBe(true);
	});

	it("accepts right", () => {
		expect(positionKeywordsSchema.safeParse("right").success).toBe(true);
	});

	it("accepts top", () => {
		expect(positionKeywordsSchema.safeParse("top").success).toBe(true);
	});

	it("accepts bottom", () => {
		expect(positionKeywordsSchema.safeParse("bottom").success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		expect(positionKeywordsSchema.safeParse("middle").success).toBe(false);
	});

	it("rejects empty string", () => {
		expect(positionKeywordsSchema.safeParse("").success).toBe(false);
	});
});

describe("POSITION_KEYWORDS array", () => {
	it("contains expected number of keywords", () => {
		expect(POSITION_KEYWORDS.length).toBe(5);
	});

	it("contains all position keywords", () => {
		expect(POSITION_KEYWORDS).toContain("center");
		expect(POSITION_KEYWORDS).toContain("left");
		expect(POSITION_KEYWORDS).toContain("right");
		expect(POSITION_KEYWORDS).toContain("top");
		expect(POSITION_KEYWORDS).toContain("bottom");
	});
});


=== File: src/core/keywords/position-keywords.ts ===
// b_path:: src/core/keywords/position-keywords.ts
import { z } from "zod";

/**
 * CSS position keywords.
 *
 * Position keywords specify locations along horizontal and vertical axes.
 * Used extensively in properties like background-position, object-position,
 * transform-origin, and perspective-origin.
 *
 * Keywords can be combined in various ways:
 * - Single keyword: `center` (applies to both axes)
 * - Horizontal + vertical: `left top`, `center bottom`
 * - Edge + offset: `left 10px top 20px`
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionKeywordsSchema } from "@/core/keywords/position-keywords";
 *
 * const keyword = positionKeywordsSchema.parse("center"); // "center"
 * ```
 *
 * @public
 */
export const positionKeywordsSchema = z.enum(["center", "left", "right", "top", "bottom"], {
	error: () => ({
		message: "Expected center | left | right | top | bottom",
	}),
});

/**
 * Array of all position keyword values.
 *
 * @example
 * ```typescript
 * import { POSITION_KEYWORDS } from "@/core/keywords/position-keywords";
 *
 * console.log(POSITION_KEYWORDS);
 * // ["center", "left", "right", "top", "bottom"]
 * ```
 *
 * @public
 */
export const POSITION_KEYWORDS = positionKeywordsSchema.options;

/**
 * TypeScript type for position keywords.
 *
 * @public
 */
export type PositionKeyword = z.infer<typeof positionKeywordsSchema>;

/**
 * Descriptions for position keywords.
 *
 * @internal
 */
const POSITION_DESCRIPTIONS: Record<PositionKeyword, string> = {
	center: "centered on both axes (50% 50%)",
	left: "left edge (0% on horizontal axis)",
	right: "right edge (100% on horizontal axis)",
	top: "top edge (0% on vertical axis)",
	bottom: "bottom edge (100% on vertical axis)",
};

/**
 * Metadata for position keyword options.
 *
 * Provides value and description for each position keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { positionKeywordOptions } from "@/core/keywords/position-keywords";
 *
 * positionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const positionKeywordOptions = POSITION_KEYWORDS.map((value) => ({
	value,
	description: POSITION_DESCRIPTIONS[value],
}));

/**
 * Type for position keyword options metadata.
 *
 * @public
 */
export type PositionKeywordOptions = typeof positionKeywordOptions;

/**
 * CSS horizontal edge position keywords.
 *
 * Subset of position keywords that specify horizontal edges.
 * Used in four-value syntax for properties like background-position:
 * `right 10px bottom 20px` (edge + offset pairs)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionHorizontalEdgeKeywordsSchema } from "@/core/keywords/position-keywords";
 *
 * const edge = positionHorizontalEdgeKeywordsSchema.parse("left"); // "left"
 * ```
 *
 * @public
 */
export const positionHorizontalEdgeKeywordsSchema = z.enum(["left", "right"], {
	error: () => ({
		message: "Expected left | right",
	}),
});

/**
 * Array of horizontal edge position keywords.
 *
 * @public
 */
export const POSITION_HORIZONTAL_EDGE_KEYWORDS = positionHorizontalEdgeKeywordsSchema.options;

/**
 * TypeScript type for horizontal edge position keywords.
 *
 * @public
 */
export type PositionHorizontalEdgeKeyword = z.infer<typeof positionHorizontalEdgeKeywordsSchema>;

/**
 * CSS vertical edge position keywords.
 *
 * Subset of position keywords that specify vertical edges.
 * Used in four-value syntax for properties like background-position:
 * `right 10px bottom 20px` (edge + offset pairs)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionVerticalEdgeKeywordsSchema } from "@/core/keywords/position-keywords";
 *
 * const edge = positionVerticalEdgeKeywordsSchema.parse("top"); // "top"
 * ```
 *
 * @public
 */
export const positionVerticalEdgeKeywordsSchema = z.enum(["top", "bottom"], {
	error: () => ({
		message: "Expected top | bottom",
	}),
});

/**
 * Array of vertical edge position keywords.
 *
 * @public
 */
export const POSITION_VERTICAL_EDGE_KEYWORDS = positionVerticalEdgeKeywordsSchema.options;

/**
 * TypeScript type for vertical edge position keywords.
 *
 * @public
 */
export type PositionVerticalEdgeKeyword = z.infer<typeof positionVerticalEdgeKeywordsSchema>;


=== File: src/core/keywords/position-property-keywords.test.ts ===
// b_path:: src/core/keywords/position-property-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	POSITION_PROPERTY_KEYWORDS,
	type PositionPropertyKeyword,
	positionPropertyKeywordsSchema,
} from "./position-property-keywords";

describe("positionPropertyKeywordsSchema", () => {
	it("accepts all valid position keywords", () => {
		const keywords: PositionPropertyKeyword[] = ["static", "relative", "absolute", "fixed", "sticky"];

		for (const keyword of keywords) {
			expect(positionPropertyKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid position keywords", () => {
		expect(positionPropertyKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(positionPropertyKeywordsSchema.safeParse("").success).toBe(false);
		expect(positionPropertyKeywordsSchema.safeParse(123).success).toBe(false);
		expect(positionPropertyKeywordsSchema.safeParse("flex").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(POSITION_PROPERTY_KEYWORDS).toHaveLength(5);
		expect(POSITION_PROPERTY_KEYWORDS).toContain("static");
		expect(POSITION_PROPERTY_KEYWORDS).toContain("sticky");
	});
});


=== File: src/core/keywords/position-property-keywords.ts ===
// b_path:: src/core/keywords/position-property-keywords.ts
import { z } from "zod";

/**
 * CSS position property keyword values.
 *
 * The position property sets how an element is positioned in a document.
 * The top, right, bottom, and left properties determine the final location
 * of positioned elements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position}
 * @see {@link https://www.w3.org/TR/css-position-3/#position-property}
 *
 * @example
 * ```typescript
 * import { positionPropertyKeywordsSchema } from "@/core/keywords/position-property-keywords";
 *
 * const keyword = positionPropertyKeywordsSchema.parse("absolute");
 * ```
 *
 * @public
 */
export const positionPropertyKeywordsSchema = z.enum(["static", "relative", "absolute", "fixed", "sticky"], {
	error: () => ({
		message: "Expected static | relative | absolute | fixed | sticky",
	}),
});

/**
 * Array of all position property keyword values.
 *
 * @public
 */
export const POSITION_PROPERTY_KEYWORDS = positionPropertyKeywordsSchema.options;

/**
 * TypeScript type for position property keywords.
 *
 * @public
 */
export type PositionPropertyKeyword = z.infer<typeof positionPropertyKeywordsSchema>;

/**
 * Descriptions for position property keywords.
 *
 * @internal
 */
const POSITION_DESCRIPTIONS: Record<PositionPropertyKeyword, string> = {
	static: "positioned according to normal flow (default)",
	relative: "positioned relative to its normal position",
	absolute: "positioned relative to nearest positioned ancestor",
	fixed: "positioned relative to the viewport",
	sticky: "positioned based on scroll position (hybrid of relative and fixed)",
};

/**
 * Metadata for position property keyword options.
 *
 * @public
 */
export const positionPropertyKeywordOptions = POSITION_PROPERTY_KEYWORDS.map((value) => ({
	value,
	description: POSITION_DESCRIPTIONS[value],
}));

/**
 * Type for position property keyword options metadata.
 *
 * @public
 */
export type PositionPropertyKeywordOptions = typeof positionPropertyKeywordOptions;


=== File: src/core/keywords/repeat-keywords.test.ts ===
// b_path:: src/core/keywords/repeat-keywords.test.ts
import { describe, expect, it } from "vitest";
import { REPEAT_KEYWORDS, repeatKeywordsSchema } from "./repeat-keywords";

describe("repeatKeywordsSchema", () => {
	it("accepts all valid repeat keywords", () => {
		for (const keyword of REPEAT_KEYWORDS) {
			expect(repeatKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("accepts repeat", () => {
		expect(repeatKeywordsSchema.safeParse("repeat").success).toBe(true);
	});

	it("accepts repeat-x", () => {
		expect(repeatKeywordsSchema.safeParse("repeat-x").success).toBe(true);
	});

	it("accepts repeat-y", () => {
		expect(repeatKeywordsSchema.safeParse("repeat-y").success).toBe(true);
	});

	it("accepts no-repeat", () => {
		expect(repeatKeywordsSchema.safeParse("no-repeat").success).toBe(true);
	});

	it("accepts space", () => {
		expect(repeatKeywordsSchema.safeParse("space").success).toBe(true);
	});

	it("accepts round", () => {
		expect(repeatKeywordsSchema.safeParse("round").success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		expect(repeatKeywordsSchema.safeParse("repeat-z").success).toBe(false);
	});

	it("rejects empty string", () => {
		expect(repeatKeywordsSchema.safeParse("").success).toBe(false);
	});
});

describe("REPEAT_KEYWORDS array", () => {
	it("contains expected number of keywords", () => {
		expect(REPEAT_KEYWORDS.length).toBe(6);
	});

	it("contains all repeat keywords", () => {
		expect(REPEAT_KEYWORDS).toContain("repeat");
		expect(REPEAT_KEYWORDS).toContain("repeat-x");
		expect(REPEAT_KEYWORDS).toContain("repeat-y");
		expect(REPEAT_KEYWORDS).toContain("no-repeat");
		expect(REPEAT_KEYWORDS).toContain("space");
		expect(REPEAT_KEYWORDS).toContain("round");
	});
});


=== File: src/core/keywords/repeat-keywords.ts ===
// b_path:: src/core/keywords/repeat-keywords.ts
import { z } from "zod";

/**
 * CSS background-repeat single value keywords.
 *
 * These keywords control how background images repeat along both axes.
 * Used in the single-value syntax of background-repeat.
 *
 * - `repeat`: Images repeat in both directions (tiles to fill area)
 * - `repeat-x`: Images repeat horizontally only (shorthand for `repeat no-repeat`)
 * - `repeat-y`: Images repeat vertically only (shorthand for `no-repeat repeat`)
 * - `no-repeat`: Images don't repeat (displayed once)
 * - `space`: Images repeat with spacing between them to fill area exactly
 * - `round`: Images repeat and scale to fill area without clipping
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat}
 *
 * @example
 * ```typescript
 * import { repeatKeywordsSchema } from "@/core/keywords/repeat-keywords";
 *
 * const keyword = repeatKeywordsSchema.parse("repeat-x"); // "repeat-x"
 * ```
 *
 * @public
 */
export const repeatKeywordsSchema = z
	.union([
		z.literal("repeat").describe("repeat in both directions"),
		z.literal("repeat-x").describe("repeat horizontally only"),
		z.literal("repeat-y").describe("repeat vertically only"),
		z.literal("no-repeat").describe("do not repeat"),
		z.literal("space").describe("repeat with spacing to fill area exactly"),
		z.literal("round").describe("repeat and scale to fill area without clipping"),
	])
	.describe(
		"Keywords for background-repeat single value syntax. " + "Controls how background images repeat along both axes.",
	);

/**
 * Array of all repeat keyword values.
 *
 * @example
 * ```typescript
 * import { REPEAT_KEYWORDS } from "@/core/keywords/repeat-keywords";
 *
 * console.log(REPEAT_KEYWORDS);
 * // ["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"]
 * ```
 *
 * @public
 */
export const REPEAT_KEYWORDS = repeatKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for repeat keywords.
 *
 * @public
 */
export type RepeatKeyword = z.infer<typeof repeatKeywordsSchema>;

/**
 * Metadata for repeat keyword options.
 *
 * Provides value and description for each repeat keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { repeatKeywordOptions } from "@/core/keywords/repeat-keywords";
 *
 * repeatKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const repeatKeywordOptions = repeatKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for repeat keyword options metadata.
 *
 * @public
 */
export type RepeatKeywordOptions = typeof repeatKeywordOptions;

/**
 * CSS background-repeat two-value keywords.
 *
 * Subset of repeat keywords valid in two-value syntax.
 * Used to specify separate horizontal and vertical repeat behavior.
 *
 * Note: `repeat-x` and `repeat-y` are NOT valid in two-value syntax
 * as they are themselves shorthand for two-value combinations:
 * - `repeat-x` = `repeat no-repeat`
 * - `repeat-y` = `no-repeat repeat`
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat}
 *
 * @example
 * ```typescript
 * import { repeatTwoValueKeywordsSchema } from "@/core/keywords/repeat-keywords";
 *
 * // Valid in two-value syntax
 * const horizontal = repeatTwoValueKeywordsSchema.parse("repeat"); // "repeat"
 * const vertical = repeatTwoValueKeywordsSchema.parse("space"); // "space"
 *
 * // Invalid in two-value syntax (would fail validation)
 * // repeatTwoValueKeywordsSchema.parse("repeat-x"); // Error!
 * ```
 *
 * @public
 */
export const repeatTwoValueKeywordsSchema = z
	.union([
		z.literal("repeat").describe("repeat along axis"),
		z.literal("space").describe("repeat with spacing along axis"),
		z.literal("round").describe("repeat and scale along axis"),
		z.literal("no-repeat").describe("do not repeat along axis"),
	])
	.describe(
		"Keywords for background-repeat two-value syntax (horizontal/vertical). " +
			"Note: repeat-x and repeat-y are not valid in two-value syntax.",
	);

/**
 * Array of two-value repeat keywords.
 *
 * @public
 */
export const REPEAT_TWO_VALUE_KEYWORDS = repeatTwoValueKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for two-value repeat keywords.
 *
 * @public
 */
export type RepeatTwoValueKeyword = z.infer<typeof repeatTwoValueKeywordsSchema>;

/**
 * Metadata for two-value repeat keyword options.
 *
 * @public
 */
export const repeatTwoValueKeywordOptions = repeatTwoValueKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for two-value repeat keyword options metadata.
 *
 * @public
 */
export type RepeatTwoValueKeywordOptions = typeof repeatTwoValueKeywordOptions;


=== File: src/core/keywords/shape-keywords.ts ===
// b_path:: src/core/keywords/shape-keywords.ts
import { z } from "zod";

/**
 * CSS shape radius keywords for circles and ellipses.
 *
 * Shape radius keywords specify the radius of circles and ellipses relative to the reference box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape}
 * @public
 */
export const shapeRadiusKeywordsSchema = z
	.union([
		z.literal("closest-side").describe("length from center to closest side of reference box"),
		z.literal("farthest-side").describe("length from center to farthest side of reference box"),
	])
	.describe("Shape radius keywords for circles and ellipses");

/**
 * Array of all shape radius keyword values.
 *
 * @public
 */
export const SHAPE_RADIUS_KEYWORDS = shapeRadiusKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for shape radius keywords.
 *
 * @public
 */
export type ShapeRadiusKeyword = z.infer<typeof shapeRadiusKeywordsSchema>;

/**
 * CSS fill-rule keywords.
 *
 * Fill rule determines how the interior of shapes is filled.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule}
 * @public
 */
export const fillRuleKeywordsSchema = z
	.union([
		z.literal("nonzero").describe("nonzero winding rule (default)"),
		z.literal("evenodd").describe("even-odd winding rule"),
	])
	.describe("Fill rule determines how interior of shapes is filled");

/**
 * Array of all fill-rule keyword values.
 *
 * @public
 */
export const FILL_RULE_KEYWORDS = fillRuleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for fill-rule keywords.
 *
 * @public
 */
export type FillRuleKeyword = z.infer<typeof fillRuleKeywordsSchema>;

/**
 * CSS basic shape function keywords.
 *
 * Basic shape functions create geometric shapes for use in clip-path, shape-outside,
 * and other CSS properties.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape}
 * @public
 */
export const basicShapeKeywordsSchema = z
	.union([
		z.literal("inset").describe("rectangle by container inset"),
		z.literal("circle").describe("circular shape"),
		z.literal("ellipse").describe("elliptical shape"),
		z.literal("polygon").describe("polygonal shape with multiple points"),
		z.literal("path").describe("custom path shape"),
		z.literal("rect").describe("rectangle by coordinates"),
		z.literal("xywh").describe("rectangle by x, y, width, height"),
	])
	.describe(
		"Basic shape functions for creating geometric shapes. " +
			"Used in clip-path, shape-outside, and other CSS properties.",
	);

/**
 * Array of all basic shape keyword values.
 *
 * @public
 */
export const BASIC_SHAPE_KEYWORDS = basicShapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for basic shape keywords.
 *
 * @public
 */
export type BasicShapeKeyword = z.infer<typeof basicShapeKeywordsSchema>;

/**
 * Combined CSS shape keywords.
 *
 * Includes basic shapes, shape radius keywords, and fill rules.
 *
 * @public
 */
export const shapeKeywordsSchema = z
	.union([
		// Basic shapes
		z
			.literal("inset")
			.describe("rectangle by container inset"),
		z.literal("circle").describe("circular shape"),
		z.literal("ellipse").describe("elliptical shape"),
		z.literal("polygon").describe("polygonal shape with multiple points"),
		z.literal("path").describe("custom path shape"),
		z.literal("rect").describe("rectangle by coordinates"),
		z.literal("xywh").describe("rectangle by x, y, width, height"),

		// Shape radius
		z
			.literal("closest-side")
			.describe("length from center to closest side of reference box"),
		z.literal("farthest-side").describe("length from center to farthest side of reference box"),

		// Fill rules
		z
			.literal("nonzero")
			.describe("nonzero winding rule (default)"),
		z.literal("evenodd").describe("even-odd winding rule"),
	])
	.describe("CSS shape-related keywords");

/**
 * Array of all shape keyword values.
 *
 * @public
 */
export const SHAPE_KEYWORDS = shapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for shape keywords.
 *
 * @public
 */
export type ShapeKeyword = z.infer<typeof shapeKeywordsSchema>;

/**
 * Metadata for shape keyword options.
 *
 * @public
 */
export const shapeKeywordOptions = shapeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for shape keyword options metadata.
 *
 * @public
 */
export type ShapeKeywordOptions = typeof shapeKeywordOptions;


=== File: src/core/keywords/sizing-keywords.test.ts ===
// b_path:: src/core/keywords/sizing-keywords.test.ts
import { describe, expect, it } from "vitest";
import { SIZING_KEYWORDS, type SizingKeyword, sizingKeywordOptions, sizingKeywordsSchema } from "./sizing-keywords";

describe("sizingKeywordsSchema", () => {
	it("accepts all valid sizing keywords", () => {
		const keywords: SizingKeyword[] = ["cover", "contain"];
		for (const keyword of keywords) {
			expect(sizingKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keywords", () => {
		const invalid = ["invalid", "fill", "scale", "fit", "auto", "", 123, null, undefined];
		for (const value of invalid) {
			expect(sizingKeywordsSchema.safeParse(value).success).toBe(false);
		}
	});

	it("exports correct SIZING_KEYWORDS array", () => {
		expect(SIZING_KEYWORDS).toHaveLength(2);
		expect(SIZING_KEYWORDS).toContain("cover");
		expect(SIZING_KEYWORDS).toContain("contain");
	});

	it("exports keyword options with descriptions", () => {
		expect(sizingKeywordOptions).toHaveLength(2);
		for (const option of sizingKeywordOptions) {
			expect(option).toHaveProperty("value");
			expect(option).toHaveProperty("description");
			expect(typeof option.value).toBe("string");
			expect(typeof option.description).toBe("string");
		}
	});

	it("has description for each keyword", () => {
		const coverOption = sizingKeywordOptions.find((opt) => opt.value === "cover");
		expect(coverOption?.description).toContain("cover");

		const containOption = sizingKeywordOptions.find((opt) => opt.value === "contain");
		expect(containOption?.description).toContain("fit");
	});
});


=== File: src/core/keywords/sizing-keywords.ts ===
// b_path:: src/core/keywords/sizing-keywords.ts
import { z } from "zod";

/**
 * CSS sizing keywords for properties like `background-size`, `object-fit`, etc.
 *
 * These keywords control how content is sized to fit its container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit}
 *
 * @example
 * ```typescript
 * import { sizingKeywordsSchema } from "@/core/keywords/sizing-keywords";
 *
 * // Parse and validate
 * const size = sizingKeywordsSchema.parse("cover"); // "cover"
 *
 * // Use in background-size
 * const backgroundSize = "contain";
 * ```
 *
 * @public
 */
export const sizingKeywordsSchema = z
	.union([
		z.literal("cover").describe("scale content to cover container (may crop to maintain aspect ratio)"),
		z
			.literal("contain")
			.describe("scale content to fit inside container (maintains aspect ratio, may have empty space)"),
	])
	.describe("sizing keywords that control how content is sized to fit its container");

/**
 * TypeScript type for sizing keywords.
 *
 * @public
 */
export type SizingKeyword = z.infer<typeof sizingKeywordsSchema>;

/**
 * Array of all valid sizing keyword values.
 *
 * Extracted from the schema for runtime iteration.
 *
 * @example
 * ```typescript
 * import { SIZING_KEYWORDS } from "@/core/keywords/sizing-keywords";
 *
 * // Iterate over keywords
 * SIZING_KEYWORDS.forEach(keyword => {
 *   console.log(keyword); // "cover", "contain"
 * });
 *
 * // Check if value is valid
 * if (SIZING_KEYWORDS.includes(input)) {
 *   // Valid sizing keyword
 * }
 * ```
 *
 * @public
 */
export const SIZING_KEYWORDS = sizingKeywordsSchema.options.map((option) => option.value);

/**
 * Metadata for sizing keywords including descriptions.
 *
 * Provides both value and description for each keyword option,
 * useful for generating Studio UI select menus or documentation.
 *
 * @example
 * ```typescript
 * import { sizingKeywordOptions } from "@/core/keywords/sizing-keywords";
 *
 * // Generate UI options
 * sizingKeywordOptions.forEach(({ value, description }) => {
 *   <Option value={value} tooltip={description} />
 * });
 * ```
 *
 * @public
 */
export const sizingKeywordOptions = sizingKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for sizing keyword options metadata array.
 *
 * @public
 */
export type SizingKeywordOptions = typeof sizingKeywordOptions;


=== File: src/core/keywords/system-color-keywords.test.ts ===
// b_path:: src/core/keywords/system-color-keywords.test.ts
import { describe, expect, it } from "vitest";
import { SYSTEM_COLOR_KEYWORDS, systemColorKeywordsSchema } from "./system-color-keywords";

describe("systemColorKeywordsSchema", () => {
	it("accepts all valid system color keywords", () => {
		for (const keyword of SYSTEM_COLOR_KEYWORDS) {
			expect(systemColorKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid keyword", () => {
		expect(systemColorKeywordsSchema.safeParse("InvalidColor").success).toBe(false);
	});

	it("rejects empty string", () => {
		expect(systemColorKeywordsSchema.safeParse("").success).toBe(false);
	});

	it("rejects null", () => {
		expect(systemColorKeywordsSchema.safeParse(null).success).toBe(false);
	});

	it("rejects undefined", () => {
		expect(systemColorKeywordsSchema.safeParse(undefined).success).toBe(false);
	});

	it("rejects number", () => {
		expect(systemColorKeywordsSchema.safeParse(123).success).toBe(false);
	});
});

describe("SYSTEM_COLOR_KEYWORDS array", () => {
	it("contains expected number of keywords", () => {
		expect(SYSTEM_COLOR_KEYWORDS.length).toBe(19);
	});

	it("contains AccentColor", () => {
		expect(SYSTEM_COLOR_KEYWORDS).toContain("AccentColor");
	});

	it("contains Canvas", () => {
		expect(SYSTEM_COLOR_KEYWORDS).toContain("Canvas");
	});

	it("contains HighlightText", () => {
		expect(SYSTEM_COLOR_KEYWORDS).toContain("HighlightText");
	});
});


=== File: src/core/keywords/system-color-keywords.ts ===
// b_path:: src/core/keywords/system-color-keywords.ts
import { z } from "zod";

/**
 * CSS system color keywords (CSS Color Module Level 4).
 *
 * System colors represent colors from the user's operating system or browser theme.
 * These allow web content to integrate with the user's system appearance.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#css-system-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/system-color}
 * @public
 */
export const systemColorKeywordsSchema = z
	.union([
		z.literal("AccentColor").describe("Accent color from the user's system"),
		z.literal("AccentColorText").describe("Text color on accent color backgrounds"),
		z.literal("ActiveText").describe("Text color of active links"),
		z.literal("ButtonBorder").describe("Border color of controls"),
		z.literal("ButtonFace").describe("Background color of controls"),
		z.literal("ButtonText").describe("Text color of controls"),
		z.literal("Canvas").describe("Background color of application content or documents"),
		z.literal("CanvasText").describe("Text color in application content or documents"),
		z.literal("Field").describe("Background color of input fields"),
		z.literal("FieldText").describe("Text color in input fields"),
		z.literal("GrayText").describe("Text color for disabled items"),
		z.literal("Highlight").describe("Background color of selected items"),
		z.literal("HighlightText").describe("Text color of selected items"),
		z.literal("LinkText").describe("Text color of non-active, non-visited links"),
		z.literal("Mark").describe("Background color of marked/highlighted text"),
		z.literal("MarkText").describe("Text color of marked/highlighted text"),
		z.literal("SelectedItem").describe("Background color of selected items"),
		z.literal("SelectedItemText").describe("Text color of selected items"),
		z.literal("VisitedText").describe("Text color of visited links"),
	])
	.describe("CSS system color keywords");

/**
 * Array of all system color keyword values.
 *
 * @example
 * ```typescript
 * import { SYSTEM_COLOR_KEYWORDS } from "@/core/keywords/system-color-keywords";
 *
 * console.log(SYSTEM_COLOR_KEYWORDS);
 * // ["AccentColor", "AccentColorText", "ActiveText", ...]
 * ```
 *
 * @public
 */
export const SYSTEM_COLOR_KEYWORDS = systemColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for system color keywords.
 *
 * @public
 */
export type SystemColorKeyword = z.infer<typeof systemColorKeywordsSchema>;

/**
 * Metadata for system color keyword options.
 *
 * Provides value and description for each system color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { systemColorKeywordOptions } from "@/core/keywords/system-color-keywords";
 *
 * systemColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const systemColorKeywordOptions = systemColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for system color keyword options metadata.
 *
 * @public
 */
export type SystemColorKeywordOptions = typeof systemColorKeywordOptions;


=== File: src/core/keywords/text-align-keywords.test.ts ===
// b_path:: src/core/keywords/text-align-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	TEXT_ALIGN_KEYWORDS,
	type TextAlignKeyword,
	type TextAlignKeywordOptions,
	textAlignKeywordOptions,
	textAlignKeywordsSchema,
} from "./text-align-keywords";

describe("textAlignKeywordsSchema", () => {
	it("accepts all valid text-align keywords", () => {
		const keywords: TextAlignKeyword[] = ["left", "right", "center", "justify", "start", "end"];

		for (const keyword of keywords) {
			expect(textAlignKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid text-align keywords", () => {
		expect(textAlignKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(textAlignKeywordsSchema.safeParse("").success).toBe(false);
		expect(textAlignKeywordsSchema.safeParse(123).success).toBe(false);
		expect(textAlignKeywordsSchema.safeParse("middle").success).toBe(false);
	});

	it("accepts basic alignment keywords", () => {
		expect(textAlignKeywordsSchema.safeParse("left").success).toBe(true);
		expect(textAlignKeywordsSchema.safeParse("right").success).toBe(true);
		expect(textAlignKeywordsSchema.safeParse("center").success).toBe(true);
	});

	it("accepts justify keyword", () => {
		expect(textAlignKeywordsSchema.safeParse("justify").success).toBe(true);
	});

	it("accepts logical alignment keywords", () => {
		expect(textAlignKeywordsSchema.safeParse("start").success).toBe(true);
		expect(textAlignKeywordsSchema.safeParse("end").success).toBe(true);
	});
});

describe("TEXT_ALIGN_KEYWORDS", () => {
	it("contains exactly 6 keywords", () => {
		expect(TEXT_ALIGN_KEYWORDS).toHaveLength(6);
	});

	it("contains all valid text-align keywords", () => {
		expect(TEXT_ALIGN_KEYWORDS).toContain("left");
		expect(TEXT_ALIGN_KEYWORDS).toContain("right");
		expect(TEXT_ALIGN_KEYWORDS).toContain("center");
		expect(TEXT_ALIGN_KEYWORDS).toContain("justify");
		expect(TEXT_ALIGN_KEYWORDS).toContain("start");
		expect(TEXT_ALIGN_KEYWORDS).toContain("end");
	});
});

describe("textAlignKeywordOptions", () => {
	it("contains metadata for all keywords", () => {
		expect(textAlignKeywordOptions).toHaveLength(6);
		expect(textAlignKeywordOptions[0]).toHaveProperty("value");
		expect(textAlignKeywordOptions[0]).toHaveProperty("description");
	});

	it("has descriptions for all keywords", () => {
		for (const option of textAlignKeywordOptions) {
			expect(option.description).toBeTruthy();
			expect(typeof option.description).toBe("string");
		}
	});

	it("describes justify behavior", () => {
		const justifyOption = textAlignKeywordOptions.find((opt) => opt.value === "justify");
		expect(justifyOption).toBeDefined();
		if (justifyOption?.description) {
			expect(justifyOption.description.toLowerCase()).toContain("justif");
		}
	});
});

describe("TextAlignKeywordOptions type", () => {
	it("is correctly typed", () => {
		const options: TextAlignKeywordOptions = textAlignKeywordOptions;
		expect(options).toBeDefined();
		expect(Array.isArray(options)).toBe(true);
	});
});


=== File: src/core/keywords/text-align-keywords.ts ===
// b_path:: src/core/keywords/text-align-keywords.ts
import { z } from "zod";

/**
 * CSS text-align keyword values.
 *
 * The text-align property sets the horizontal alignment of the inline-level content
 * inside a block element or table-cell box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-align}
 *
 * @example
 * ```typescript
 * import { textAlignKeywordsSchema } from "@/core/keywords/text-align-keywords";
 *
 * const keyword = textAlignKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const textAlignKeywordsSchema = z
	.union([
		z.literal("left").describe("inline contents aligned to left edge"),
		z.literal("right").describe("inline contents aligned to right edge"),
		z.literal("center").describe("inline contents centered"),
		z.literal("justify").describe("inline contents justified (text spaced to fill line)"),
		z.literal("start").describe("aligned to start edge of writing mode direction"),
		z.literal("end").describe("aligned to end edge of writing mode direction"),
	])
	.describe("CSS text-align property keyword values");

/**
 * Array of all text-align keyword values.
 *
 * @public
 */
export const TEXT_ALIGN_KEYWORDS = textAlignKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-align keywords.
 *
 * @public
 */
export type TextAlignKeyword = z.infer<typeof textAlignKeywordsSchema>;

/**
 * Metadata for text-align keyword options.
 *
 * @public
 */
export const textAlignKeywordOptions = textAlignKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-align keyword options metadata.
 *
 * @public
 */
export type TextAlignKeywordOptions = typeof textAlignKeywordOptions;


=== File: src/core/keywords/text-decoration-line-keywords.test.ts ===
// b_path:: src/core/keywords/text-decoration-line-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	TEXT_DECORATION_LINE_KEYWORDS,
	type TextDecorationLineKeyword,
	type TextDecorationLineKeywordOptions,
	textDecorationLineKeywordOptions,
	textDecorationLineKeywordsSchema,
} from "./text-decoration-line-keywords";

describe("textDecorationLineKeywordsSchema", () => {
	it("accepts all valid text-decoration-line keywords", () => {
		const keywords: TextDecorationLineKeyword[] = ["none", "underline", "overline", "line-through"];

		for (const keyword of keywords) {
			expect(textDecorationLineKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid text-decoration-line keywords", () => {
		expect(textDecorationLineKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(textDecorationLineKeywordsSchema.safeParse("").success).toBe(false);
		expect(textDecorationLineKeywordsSchema.safeParse(123).success).toBe(false);
		expect(textDecorationLineKeywordsSchema.safeParse("blink").success).toBe(false);
	});

	it("accepts none keyword", () => {
		expect(textDecorationLineKeywordsSchema.safeParse("none").success).toBe(true);
	});

	it("accepts underline keyword", () => {
		expect(textDecorationLineKeywordsSchema.safeParse("underline").success).toBe(true);
	});
});

describe("TEXT_DECORATION_LINE_KEYWORDS", () => {
	it("contains exactly 4 keywords", () => {
		expect(TEXT_DECORATION_LINE_KEYWORDS).toHaveLength(4);
	});

	it("contains all valid text-decoration-line keywords", () => {
		expect(TEXT_DECORATION_LINE_KEYWORDS).toContain("none");
		expect(TEXT_DECORATION_LINE_KEYWORDS).toContain("underline");
		expect(TEXT_DECORATION_LINE_KEYWORDS).toContain("overline");
		expect(TEXT_DECORATION_LINE_KEYWORDS).toContain("line-through");
	});

	it("has unique keywords", () => {
		const uniqueKeywords = [...new Set(TEXT_DECORATION_LINE_KEYWORDS)];
		expect(uniqueKeywords.length).toBe(TEXT_DECORATION_LINE_KEYWORDS.length);
	});
});

describe("textDecorationLineKeywordOptions", () => {
	it("contains metadata for all keywords", () => {
		expect(textDecorationLineKeywordOptions).toHaveLength(4);
		expect(textDecorationLineKeywordOptions[0]).toHaveProperty("value");
		expect(textDecorationLineKeywordOptions[0]).toHaveProperty("description");
	});

	it("has descriptions for all keywords", () => {
		for (const option of textDecorationLineKeywordOptions) {
			expect(option.description).toBeTruthy();
			expect(typeof option.description).toBe("string");
		}
	});

	it("underline has descriptive text", () => {
		const underlineOption = textDecorationLineKeywordOptions.find((opt) => opt.value === "underline");
		expect(underlineOption).toBeDefined();
		expect(underlineOption?.description).toContain("below");
	});

	it("overline has descriptive text", () => {
		const overlineOption = textDecorationLineKeywordOptions.find((opt) => opt.value === "overline");
		expect(overlineOption).toBeDefined();
		expect(overlineOption?.description).toContain("above");
	});
});

describe("TextDecorationLineKeywordOptions type", () => {
	it("is correctly typed", () => {
		const options: TextDecorationLineKeywordOptions = textDecorationLineKeywordOptions;
		expect(options).toBeDefined();
		expect(Array.isArray(options)).toBe(true);
	});
});


=== File: src/core/keywords/text-decoration-line-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-line-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-line keyword values.
 *
 * The text-decoration-line property sets the kind of decoration that is used on text
 * in an element, such as an underline or overline.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-line}
 *
 * @example
 * ```typescript
 * import { textDecorationLineKeywordsSchema } from "@/core/keywords/text-decoration-line-keywords";
 *
 * const keyword = textDecorationLineKeywordsSchema.parse("underline");
 * ```
 *
 * @public
 */
export const textDecorationLineKeywordsSchema = z
	.union([
		z.literal("none").describe("no text decoration"),
		z.literal("underline").describe("line below the text"),
		z.literal("overline").describe("line above the text"),
		z.literal("line-through").describe("line through the middle of the text"),
	])
	.describe("CSS text-decoration-line property keyword values");

/**
 * Array of all text-decoration-line keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_LINE_KEYWORDS = textDecorationLineKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-decoration-line keywords.
 *
 * @public
 */
export type TextDecorationLineKeyword = z.infer<typeof textDecorationLineKeywordsSchema>;

/**
 * Metadata for text-decoration-line keyword options.
 *
 * @public
 */
export const textDecorationLineKeywordOptions = textDecorationLineKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-line keyword options metadata.
 *
 * @public
 */
export type TextDecorationLineKeywordOptions = typeof textDecorationLineKeywordOptions;


=== File: src/core/keywords/text-decoration-style-keywords.test.ts ===
// b_path:: src/core/keywords/text-decoration-style-keywords.test.ts

import { describe, expect, it } from "vitest";
import {
	TEXT_DECORATION_STYLE_KEYWORDS,
	type TextDecorationStyleKeyword,
	textDecorationStyleKeywordOptions,
	textDecorationStyleKeywordsSchema,
} from "./text-decoration-style-keywords";

describe("textDecorationStyleKeywordsSchema", () => {
	it("validates solid", () => {
		const result = textDecorationStyleKeywordsSchema.safeParse("solid");
		expect(result.success).toBe(true);
	});

	it("validates double", () => {
		const result = textDecorationStyleKeywordsSchema.safeParse("double");
		expect(result.success).toBe(true);
	});

	it("validates dotted", () => {
		const result = textDecorationStyleKeywordsSchema.safeParse("dotted");
		expect(result.success).toBe(true);
	});

	it("validates dashed", () => {
		const result = textDecorationStyleKeywordsSchema.safeParse("dashed");
		expect(result.success).toBe(true);
	});

	it("validates wavy", () => {
		const result = textDecorationStyleKeywordsSchema.safeParse("wavy");
		expect(result.success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		const result = textDecorationStyleKeywordsSchema.safeParse("invalid");
		expect(result.success).toBe(false);
	});
});

describe("TEXT_DECORATION_STYLE_KEYWORDS", () => {
	it("contains all style keywords", () => {
		expect(TEXT_DECORATION_STYLE_KEYWORDS).toContain("solid");
		expect(TEXT_DECORATION_STYLE_KEYWORDS).toContain("double");
		expect(TEXT_DECORATION_STYLE_KEYWORDS).toContain("dotted");
		expect(TEXT_DECORATION_STYLE_KEYWORDS).toContain("dashed");
		expect(TEXT_DECORATION_STYLE_KEYWORDS).toContain("wavy");
	});

	it("has correct length", () => {
		expect(TEXT_DECORATION_STYLE_KEYWORDS).toHaveLength(5);
	});
});

describe("textDecorationStyleKeywordOptions", () => {
	it("includes descriptions", () => {
		expect(textDecorationStyleKeywordOptions.length).toBeGreaterThan(0);
		expect(textDecorationStyleKeywordOptions[0]).toHaveProperty("value");
		expect(textDecorationStyleKeywordOptions[0]).toHaveProperty("description");
	});
});

describe("TextDecorationStyleKeyword type", () => {
	it("accepts valid keywords", () => {
		const keyword: TextDecorationStyleKeyword = "solid";
		expect(keyword).toBe("solid");
	});
});


=== File: src/core/keywords/text-decoration-style-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-style-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-style keyword values.
 *
 * The text-decoration-style property sets the style of the lines specified
 * by text-decoration-line.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-style}
 *
 * @public
 */
export const textDecorationStyleKeywordsSchema = z
	.union([
		z.literal("solid").describe("single line"),
		z.literal("double").describe("double line"),
		z.literal("dotted").describe("dotted line"),
		z.literal("dashed").describe("dashed line"),
		z.literal("wavy").describe("wavy line"),
	])
	.describe("CSS text-decoration-style property keyword values");

/**
 * Array of all text-decoration-style keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_STYLE_KEYWORDS = textDecorationStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-decoration-style keywords.
 *
 * @public
 */
export type TextDecorationStyleKeyword = z.infer<typeof textDecorationStyleKeywordsSchema>;

/**
 * Metadata for text-decoration-style keyword options.
 *
 * @public
 */
export const textDecorationStyleKeywordOptions = textDecorationStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-style keyword options metadata.
 *
 * @public
 */
export type TextDecorationStyleKeywordOptions = typeof textDecorationStyleKeywordOptions;


=== File: src/core/keywords/text-decoration-thickness-keywords.test.ts ===
// b_path:: src/core/keywords/text-decoration-thickness-keywords.test.ts

import { describe, expect, it } from "vitest";
import {
	TEXT_DECORATION_THICKNESS_KEYWORDS,
	type TextDecorationThicknessKeyword,
	textDecorationThicknessKeywordOptions,
	textDecorationThicknessKeywordsSchema,
} from "./text-decoration-thickness-keywords";

describe("textDecorationThicknessKeywordsSchema", () => {
	it("validates auto", () => {
		const result = textDecorationThicknessKeywordsSchema.safeParse("auto");
		expect(result.success).toBe(true);
	});

	it("validates from-font", () => {
		const result = textDecorationThicknessKeywordsSchema.safeParse("from-font");
		expect(result.success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		const result = textDecorationThicknessKeywordsSchema.safeParse("invalid");
		expect(result.success).toBe(false);
	});
});

describe("TEXT_DECORATION_THICKNESS_KEYWORDS", () => {
	it("contains auto", () => {
		expect(TEXT_DECORATION_THICKNESS_KEYWORDS).toContain("auto");
	});

	it("contains from-font", () => {
		expect(TEXT_DECORATION_THICKNESS_KEYWORDS).toContain("from-font");
	});

	it("has correct length", () => {
		expect(TEXT_DECORATION_THICKNESS_KEYWORDS).toHaveLength(2);
	});
});

describe("textDecorationThicknessKeywordOptions", () => {
	it("includes descriptions", () => {
		expect(textDecorationThicknessKeywordOptions.length).toBeGreaterThan(0);
		expect(textDecorationThicknessKeywordOptions[0]).toHaveProperty("value");
		expect(textDecorationThicknessKeywordOptions[0]).toHaveProperty("description");
	});
});

describe("TextDecorationThicknessKeyword type", () => {
	it("accepts valid keywords", () => {
		const keyword1: TextDecorationThicknessKeyword = "auto";
		const keyword2: TextDecorationThicknessKeyword = "from-font";
		expect(keyword1).toBe("auto");
		expect(keyword2).toBe("from-font");
	});
});


=== File: src/core/keywords/text-decoration-thickness-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-thickness-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-thickness keyword values.
 *
 * The text-decoration-thickness property sets the thickness of the decoration
 * line used on text.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-thickness}
 *
 * @public
 */
export const textDecorationThicknessKeywordsSchema = z
	.union([
		z.literal("auto").describe("browser chooses thickness"),
		z.literal("from-font").describe("use thickness from font file"),
	])
	.describe("CSS text-decoration-thickness property keyword values");

/**
 * Array of all text-decoration-thickness keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_THICKNESS_KEYWORDS = textDecorationThicknessKeywordsSchema.options.map(
	(option) => option.value,
);

/**
 * TypeScript type for text-decoration-thickness keywords.
 *
 * @public
 */
export type TextDecorationThicknessKeyword = z.infer<typeof textDecorationThicknessKeywordsSchema>;

/**
 * Metadata for text-decoration-thickness keyword options.
 *
 * @public
 */
export const textDecorationThicknessKeywordOptions = textDecorationThicknessKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-thickness keyword options metadata.
 *
 * @public
 */
export type TextDecorationThicknessKeywordOptions = typeof textDecorationThicknessKeywordOptions;


=== File: src/core/keywords/text-transform-keywords.test.ts ===
// b_path:: src/core/keywords/text-transform-keywords.test.ts
import { describe, expect, it } from "vitest";
import {
	TEXT_TRANSFORM_KEYWORDS,
	type TextTransformKeyword,
	textTransformKeywordsSchema,
} from "./text-transform-keywords";

describe("textTransformKeywordsSchema", () => {
	it("accepts all valid text-transform keywords", () => {
		const keywords: TextTransformKeyword[] = [
			"none",
			"capitalize",
			"uppercase",
			"lowercase",
			"full-width",
			"full-size-kana",
		];

		for (const keyword of keywords) {
			expect(textTransformKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid text-transform keywords", () => {
		expect(textTransformKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(textTransformKeywordsSchema.safeParse("").success).toBe(false);
		expect(textTransformKeywordsSchema.safeParse(123).success).toBe(false);
		expect(textTransformKeywordsSchema.safeParse("camelCase").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(TEXT_TRANSFORM_KEYWORDS).toHaveLength(6);
		expect(TEXT_TRANSFORM_KEYWORDS).toContain("uppercase");
		expect(TEXT_TRANSFORM_KEYWORDS).toContain("full-width");
	});
});


=== File: src/core/keywords/text-transform-keywords.ts ===
// b_path:: src/core/keywords/text-transform-keywords.ts
import { z } from "zod";

/**
 * CSS text-transform keyword values.
 *
 * The text-transform property specifies how to capitalize an element's text.
 * It can be used to make text appear in all-uppercase or all-lowercase, or with
 * each word capitalized.
 *
 * Includes CSS Text Level 4 values for CJK (Chinese/Japanese/Korean) typography support.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform}
 * @see {@link https://www.w3.org/TR/css-text-4/#text-transform-property}
 *
 * @example
 * ```typescript
 * import { textTransformKeywordsSchema } from "@/core/keywords/text-transform-keywords";
 *
 * const keyword = textTransformKeywordsSchema.parse("uppercase");
 * ```
 *
 * @public
 */
export const textTransformKeywordsSchema = z
	.union([
		z.literal("none").describe("no capitalization, text renders as is"),
		z.literal("capitalize").describe("first letter of each word capitalized"),
		z.literal("uppercase").describe("all characters converted to uppercase"),
		z.literal("lowercase").describe("all characters converted to lowercase"),
		z.literal("full-width").describe("transforms characters to their fullwidth forms (CJK typography)"),
		z.literal("full-size-kana").describe("converts small Kana to full-size characters (Japanese typography)"),
	])
	.describe("CSS text-transform property keyword values (includes CSS Text Level 4 values)");

/**
 * Array of all text-transform keyword values.
 *
 * @public
 */
export const TEXT_TRANSFORM_KEYWORDS = textTransformKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-transform keywords.
 *
 * @public
 */
export type TextTransformKeyword = z.infer<typeof textTransformKeywordsSchema>;

/**
 * Metadata for text-transform keyword options.
 *
 * @public
 */
export const textTransformKeywordOptions = textTransformKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-transform keyword options metadata.
 *
 * @public
 */
export type TextTransformKeywordOptions = typeof textTransformKeywordOptions;


=== File: src/core/keywords/transform-keywords.test.ts ===
// b_path:: src/core/keywords/transform-keywords.test.ts

import { describe, expect, it } from "vitest";
import { isTransformFunctionName, TRANSFORM_FUNCTION_NAMES, type TransformFunctionName } from "./transform-keywords";

describe("TRANSFORM_FUNCTION_NAMES", () => {
	it("contains translate functions", () => {
		expect(TRANSFORM_FUNCTION_NAMES).toContain("translate");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("translatex");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("translatey");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("translatez");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("translate3d");
	});

	it("contains rotate functions", () => {
		expect(TRANSFORM_FUNCTION_NAMES).toContain("rotate");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("rotatex");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("rotatey");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("rotatez");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("rotate3d");
	});

	it("contains scale functions", () => {
		expect(TRANSFORM_FUNCTION_NAMES).toContain("scale");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("scalex");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("scaley");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("scalez");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("scale3d");
	});

	it("contains skew functions", () => {
		expect(TRANSFORM_FUNCTION_NAMES).toContain("skew");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("skewx");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("skewy");
	});

	it("contains matrix and perspective", () => {
		expect(TRANSFORM_FUNCTION_NAMES).toContain("matrix");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("matrix3d");
		expect(TRANSFORM_FUNCTION_NAMES).toContain("perspective");
	});

	it("has correct total count", () => {
		expect(TRANSFORM_FUNCTION_NAMES).toHaveLength(21);
	});
});

describe("isTransformFunctionName", () => {
	it("validates translate", () => {
		expect(isTransformFunctionName("translate")).toBe(true);
	});

	it("validates translateX case-insensitive", () => {
		expect(isTransformFunctionName("translateX")).toBe(true);
		expect(isTransformFunctionName("TRANSLATEX")).toBe(true);
	});

	it("validates rotate", () => {
		expect(isTransformFunctionName("rotate")).toBe(true);
	});

	it("validates scale", () => {
		expect(isTransformFunctionName("scale")).toBe(true);
	});

	it("validates matrix3d", () => {
		expect(isTransformFunctionName("matrix3d")).toBe(true);
	});

	it("rejects invalid function name", () => {
		expect(isTransformFunctionName("invalid")).toBe(false);
	});

	it("rejects empty string", () => {
		expect(isTransformFunctionName("")).toBe(false);
	});
});

describe("TransformFunctionName type", () => {
	it("accepts valid function names", () => {
		const name: TransformFunctionName = "translate";
		expect(name).toBe("translate");
	});
});


=== File: src/core/keywords/transform-keywords.ts ===
// b_path:: src/core/keywords/transform-keywords.ts

/**
 * CSS transform function names.
 *
 * All valid CSS transform function identifiers used in the transform property.
 * These are the canonical lowercase names as they appear in CSS.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function}
 *
 * @public
 */
export const TRANSFORM_FUNCTION_NAMES = [
	"translate",
	"translatex",
	"translatey",
	"translatez",
	"translate3d",
	"rotate",
	"rotatex",
	"rotatey",
	"rotatez",
	"rotate3d",
	"scale",
	"scalex",
	"scaley",
	"scalez",
	"scale3d",
	"skew",
	"skewx",
	"skewy",
	"matrix",
	"matrix3d",
	"perspective",
] as const;

/**
 * Type representing valid CSS transform function names.
 * @public
 */
export type TransformFunctionName = (typeof TRANSFORM_FUNCTION_NAMES)[number];

/**
 * Check if a string is a valid transform function name.
 *
 * @param name - String to check (case-insensitive)
 * @returns True if the name is a valid transform function
 *
 * @public
 */
export function isTransformFunctionName(name: string): name is TransformFunctionName {
	return TRANSFORM_FUNCTION_NAMES.includes(name.toLowerCase() as TransformFunctionName);
}


=== File: src/core/keywords/vertical-align-keywords.test.ts ===
// b_path:: src/core/keywords/vertical-align-keywords.test.ts

import { describe, expect, it } from "vitest";
import {
	VERTICAL_ALIGN_KEYWORDS,
	type VerticalAlignKeyword,
	verticalAlignKeywordOptions,
	verticalAlignKeywordsSchema,
} from "./vertical-align-keywords";

describe("verticalAlignKeywordsSchema", () => {
	it("validates baseline", () => {
		const result = verticalAlignKeywordsSchema.safeParse("baseline");
		expect(result.success).toBe(true);
	});

	it("validates sub", () => {
		const result = verticalAlignKeywordsSchema.safeParse("sub");
		expect(result.success).toBe(true);
	});

	it("validates super", () => {
		const result = verticalAlignKeywordsSchema.safeParse("super");
		expect(result.success).toBe(true);
	});

	it("validates text-top", () => {
		const result = verticalAlignKeywordsSchema.safeParse("text-top");
		expect(result.success).toBe(true);
	});

	it("validates text-bottom", () => {
		const result = verticalAlignKeywordsSchema.safeParse("text-bottom");
		expect(result.success).toBe(true);
	});

	it("validates middle", () => {
		const result = verticalAlignKeywordsSchema.safeParse("middle");
		expect(result.success).toBe(true);
	});

	it("validates top", () => {
		const result = verticalAlignKeywordsSchema.safeParse("top");
		expect(result.success).toBe(true);
	});

	it("validates bottom", () => {
		const result = verticalAlignKeywordsSchema.safeParse("bottom");
		expect(result.success).toBe(true);
	});

	it("rejects invalid keyword", () => {
		const result = verticalAlignKeywordsSchema.safeParse("invalid");
		expect(result.success).toBe(false);
	});
});

describe("VERTICAL_ALIGN_KEYWORDS", () => {
	it("contains all alignment keywords", () => {
		expect(VERTICAL_ALIGN_KEYWORDS).toContain("baseline");
		expect(VERTICAL_ALIGN_KEYWORDS).toContain("sub");
		expect(VERTICAL_ALIGN_KEYWORDS).toContain("super");
		expect(VERTICAL_ALIGN_KEYWORDS).toContain("text-top");
		expect(VERTICAL_ALIGN_KEYWORDS).toContain("text-bottom");
		expect(VERTICAL_ALIGN_KEYWORDS).toContain("middle");
		expect(VERTICAL_ALIGN_KEYWORDS).toContain("top");
		expect(VERTICAL_ALIGN_KEYWORDS).toContain("bottom");
	});

	it("has correct length", () => {
		expect(VERTICAL_ALIGN_KEYWORDS).toHaveLength(8);
	});
});

describe("verticalAlignKeywordOptions", () => {
	it("includes descriptions", () => {
		expect(verticalAlignKeywordOptions.length).toBeGreaterThan(0);
		expect(verticalAlignKeywordOptions[0]).toHaveProperty("value");
		expect(verticalAlignKeywordOptions[0]).toHaveProperty("description");
	});
});

describe("VerticalAlignKeyword type", () => {
	it("accepts valid keywords", () => {
		const keyword: VerticalAlignKeyword = "baseline";
		expect(keyword).toBe("baseline");
	});
});


=== File: src/core/keywords/vertical-align-keywords.ts ===
// b_path:: src/core/keywords/vertical-align-keywords.ts
import { z } from "zod";

/**
 * CSS vertical-align keyword values.
 *
 * The vertical-align property sets vertical alignment of an inline, inline-block
 * or table-cell box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align}
 *
 * @public
 */
export const verticalAlignKeywordsSchema = z
	.union([
		z.literal("baseline").describe("align baseline with parent baseline"),
		z.literal("sub").describe("align baseline with parent subscript baseline"),
		z.literal("super").describe("align baseline with parent superscript baseline"),
		z.literal("text-top").describe("align top with parent font top"),
		z.literal("text-bottom").describe("align bottom with parent font bottom"),
		z.literal("middle").describe("align middle with parent baseline plus half x-height"),
		z.literal("top").describe("align top with line top"),
		z.literal("bottom").describe("align bottom with line bottom"),
	])
	.describe("CSS vertical-align property keyword values");

/**
 * Array of all vertical-align keyword values.
 *
 * @public
 */
export const VERTICAL_ALIGN_KEYWORDS = verticalAlignKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for vertical-align keywords.
 *
 * @public
 */
export type VerticalAlignKeyword = z.infer<typeof verticalAlignKeywordsSchema>;

/**
 * Metadata for vertical-align keyword options.
 *
 * @public
 */
export const verticalAlignKeywordOptions = verticalAlignKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for vertical-align keyword options metadata.
 *
 * @public
 */
export type VerticalAlignKeywordOptions = typeof verticalAlignKeywordOptions;


=== File: src/core/keywords/visibility-keywords.test.ts ===
// b_path:: src/core/keywords/visibility-keywords.test.ts
import { describe, expect, it } from "vitest";
import { VISIBILITY_KEYWORDS, type VisibilityKeyword, visibilityKeywordsSchema } from "./visibility-keywords";

describe("visibilityKeywordsSchema", () => {
	it("accepts all valid visibility keywords", () => {
		const keywords: VisibilityKeyword[] = ["visible", "hidden", "collapse"];

		for (const keyword of keywords) {
			expect(visibilityKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid visibility keywords", () => {
		expect(visibilityKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(visibilityKeywordsSchema.safeParse("").success).toBe(false);
		expect(visibilityKeywordsSchema.safeParse(123).success).toBe(false);
		expect(visibilityKeywordsSchema.safeParse("none").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(VISIBILITY_KEYWORDS).toHaveLength(3);
		expect(VISIBILITY_KEYWORDS).toContain("visible");
		expect(VISIBILITY_KEYWORDS).toContain("hidden");
		expect(VISIBILITY_KEYWORDS).toContain("collapse");
	});
});


=== File: src/core/keywords/visibility-keywords.ts ===
// b_path:: src/core/keywords/visibility-keywords.ts
import { z } from "zod";

/**
 * CSS visibility keywords.
 *
 * The visibility property controls whether an element is visible or hidden.
 * Unlike display: none, visibility: hidden elements still take up space in the layout.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility}
 *
 * @example
 * ```typescript
 * import { visibilityKeywordsSchema } from "@/core/keywords/visibility-keywords";
 *
 * const keyword = visibilityKeywordsSchema.parse("hidden"); // "hidden"
 * ```
 *
 * @public
 */
export const visibilityKeywordsSchema = z.enum(["visible", "hidden", "collapse"], {
	error: () => ({
		message: "Expected visible | hidden | collapse",
	}),
});

/**
 * Array of all visibility keyword values.
 *
 * @example
 * ```typescript
 * import { VISIBILITY_KEYWORDS } from "@/core/keywords/visibility-keywords";
 *
 * console.log(VISIBILITY_KEYWORDS); // ["visible", "hidden", "collapse"]
 * ```
 *
 * @public
 */
export const VISIBILITY_KEYWORDS = visibilityKeywordsSchema.options;

/**
 * TypeScript type for visibility keywords.
 *
 * @public
 */
export type VisibilityKeyword = z.infer<typeof visibilityKeywordsSchema>;

/**
 * Descriptions for visibility keywords.
 *
 * @internal
 */
const VISIBILITY_DESCRIPTIONS: Record<VisibilityKeyword, string> = {
	visible: "element is visible",
	hidden: "element is invisible but still takes up space",
	collapse: "for table elements, removes row/column without affecting layout",
};

/**
 * Metadata for visibility keyword options.
 *
 * Provides value and description for each visibility keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { visibilityKeywordOptions } from "@/core/keywords/visibility-keywords";
 *
 * visibilityKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const visibilityKeywordOptions = VISIBILITY_KEYWORDS.map((value) => ({
	value,
	description: VISIBILITY_DESCRIPTIONS[value],
}));

/**
 * Type for visibility keyword options metadata.
 *
 * @public
 */
export type VisibilityKeywordOptions = typeof visibilityKeywordOptions;


=== File: src/core/keywords/white-space-keywords.test.ts ===
// b_path:: src/core/keywords/white-space-keywords.test.ts
import { describe, expect, it } from "vitest";
import { WHITE_SPACE_KEYWORDS, type WhiteSpaceKeyword, whiteSpaceKeywordsSchema } from "./white-space-keywords";

describe("whiteSpaceKeywordsSchema", () => {
	it("accepts all valid white-space keywords", () => {
		const keywords: WhiteSpaceKeyword[] = ["normal", "nowrap", "pre", "pre-wrap", "pre-line", "break-spaces"];

		for (const keyword of keywords) {
			expect(whiteSpaceKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid white-space keywords", () => {
		expect(whiteSpaceKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(whiteSpaceKeywordsSchema.safeParse("").success).toBe(false);
		expect(whiteSpaceKeywordsSchema.safeParse(123).success).toBe(false);
		expect(whiteSpaceKeywordsSchema.safeParse("wrap").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(WHITE_SPACE_KEYWORDS).toHaveLength(6);
		expect(WHITE_SPACE_KEYWORDS).toContain("normal");
		expect(WHITE_SPACE_KEYWORDS).toContain("break-spaces");
	});
});


=== File: src/core/keywords/white-space-keywords.ts ===
// b_path:: src/core/keywords/white-space-keywords.ts
import { z } from "zod";

/**
 * CSS white-space keyword values.
 *
 * The white-space property sets how white space inside an element is handled.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space}
 *
 * @example
 * ```typescript
 * import { whiteSpaceKeywordsSchema } from "@/core/keywords/white-space-keywords";
 *
 * const keyword = whiteSpaceKeywordsSchema.parse("nowrap");
 * ```
 *
 * @public
 */
export const whiteSpaceKeywordsSchema = z
	.union([
		z.literal("normal").describe("sequences of whitespace collapsed, newlines ignored"),
		z.literal("nowrap").describe("collapses whitespace, prevents wrapping"),
		z.literal("pre").describe("preserves whitespace and newlines, no wrapping"),
		z.literal("pre-wrap").describe("preserves whitespace and newlines, wraps normally"),
		z.literal("pre-line").describe("collapses whitespace, preserves newlines, wraps normally"),
		z.literal("break-spaces").describe("like pre-wrap but preserves sequences of spaces"),
	])
	.describe("CSS white-space property keyword values");

/**
 * Array of all white-space keyword values.
 *
 * @public
 */
export const WHITE_SPACE_KEYWORDS = whiteSpaceKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for white-space keywords.
 *
 * @public
 */
export type WhiteSpaceKeyword = z.infer<typeof whiteSpaceKeywordsSchema>;

/**
 * Metadata for white-space keyword options.
 *
 * @public
 */
export const whiteSpaceKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Sequences of whitespace collapsed, newlines ignored",
	},
	nowrap: {
		value: "nowrap" as const,
		description: "Collapses whitespace, prevents wrapping",
	},
	pre: {
		value: "pre" as const,
		description: "Preserves whitespace and newlines, no wrapping",
	},
	"pre-wrap": {
		value: "pre-wrap" as const,
		description: "Preserves whitespace and newlines, wraps normally",
	},
	"pre-line": {
		value: "pre-line" as const,
		description: "Collapses whitespace, preserves newlines, wraps normally",
	},
	"break-spaces": {
		value: "break-spaces" as const,
		description: "Like pre-wrap but preserves sequences of spaces",
	},
} as const;


=== File: src/core/keywords/width-height-keywords.test.ts ===
// b_path:: src/core/keywords/width-height-keywords.test.ts
import { describe, expect, it } from "vitest";
import { WIDTH_HEIGHT_KEYWORDS, widthHeightKeywordsSchema } from "./width-height-keywords";

describe("width-height keywords", () => {
	it("exports keywords array", () => {
		expect(WIDTH_HEIGHT_KEYWORDS).toEqual(["min-content", "max-content", "fit-content"]);
	});

	it("validates 'min-content'", () => {
		const result = widthHeightKeywordsSchema.safeParse("min-content");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("min-content");
		}
	});

	it("validates 'max-content'", () => {
		const result = widthHeightKeywordsSchema.safeParse("max-content");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("max-content");
		}
	});

	it("validates 'fit-content'", () => {
		const result = widthHeightKeywordsSchema.safeParse("fit-content");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("fit-content");
		}
	});

	it("rejects invalid keyword", () => {
		const result = widthHeightKeywordsSchema.safeParse("invalid");
		expect(result.success).toBe(false);
	});

	it("rejects empty string", () => {
		const result = widthHeightKeywordsSchema.safeParse("");
		expect(result.success).toBe(false);
	});

	it("is case sensitive", () => {
		const result = widthHeightKeywordsSchema.safeParse("Min-Content");
		expect(result.success).toBe(false);
	});
});


=== File: src/core/keywords/width-height-keywords.ts ===
// b_path:: src/core/keywords/width-height-keywords.ts
import { z } from "zod";

/**
 * CSS width/height intrinsic sizing keywords.
 *
 * These keywords represent intrinsic sizes based on content.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#sizing-values}
 *
 * @example
 * ```typescript
 * import { widthHeightKeywordsSchema } from "@/core/keywords/width-height-keywords";
 *
 * const size = widthHeightKeywordsSchema.parse("min-content");
 * ```
 *
 * @public
 */
export const widthHeightKeywordsSchema = z
	.union([
		z.literal("min-content").describe("intrinsic minimum width/height"),
		z.literal("max-content").describe("intrinsic preferred width/height"),
		z.literal("fit-content").describe("use available space but not more than max-content"),
	])
	.describe("intrinsic sizing keywords for width/height properties");

/**
 * TypeScript type for width/height keywords.
 *
 * @public
 */
export type WidthHeightKeyword = z.infer<typeof widthHeightKeywordsSchema>;

/**
 * Array of all valid width/height keyword values.
 *
 * @public
 */
export const WIDTH_HEIGHT_KEYWORDS = widthHeightKeywordsSchema.options.map((option) => option.value);


=== File: src/core/keywords/word-break-keywords.test.ts ===
// b_path:: src/core/keywords/word-break-keywords.test.ts
import { describe, expect, it } from "vitest";
import { WORD_BREAK_KEYWORDS, type WordBreakKeyword, wordBreakKeywordsSchema } from "./word-break-keywords";

describe("wordBreakKeywordsSchema", () => {
	it("accepts all valid word-break keywords", () => {
		const keywords: WordBreakKeyword[] = ["normal", "break-all", "keep-all", "break-word"];

		for (const keyword of keywords) {
			expect(wordBreakKeywordsSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid word-break keywords", () => {
		expect(wordBreakKeywordsSchema.safeParse("invalid").success).toBe(false);
		expect(wordBreakKeywordsSchema.safeParse("").success).toBe(false);
		expect(wordBreakKeywordsSchema.safeParse(123).success).toBe(false);
		expect(wordBreakKeywordsSchema.safeParse("wrap").success).toBe(false);
	});

	it("exports complete keyword array", () => {
		expect(WORD_BREAK_KEYWORDS).toHaveLength(4);
		expect(WORD_BREAK_KEYWORDS).toContain("normal");
		expect(WORD_BREAK_KEYWORDS).toContain("break-all");
	});
});


=== File: src/core/keywords/word-break-keywords.ts ===
// b_path:: src/core/keywords/word-break-keywords.ts
import { z } from "zod";

/**
 * CSS word-break keyword values.
 *
 * The word-break property sets whether line breaks appear wherever the text would
 * otherwise overflow its content box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/word-break}
 *
 * @example
 * ```typescript
 * import { wordBreakKeywordsSchema } from "@/core/keywords/word-break-keywords";
 *
 * const keyword = wordBreakKeywordsSchema.parse("break-all");
 * ```
 *
 * @public
 */
export const wordBreakKeywordsSchema = z
	.union([
		z.literal("normal").describe("default line break rules"),
		z.literal("break-all").describe("breaks can be inserted between any characters"),
		z.literal("keep-all").describe("breaks prohibited between CJK characters"),
		z.literal("break-word").describe("like word-break: normal with overflow-wrap: anywhere"),
	])
	.describe("CSS word-break property keyword values");

/**
 * Array of all word-break keyword values.
 *
 * @public
 */
export const WORD_BREAK_KEYWORDS = wordBreakKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for word-break keywords.
 *
 * @public
 */
export type WordBreakKeyword = z.infer<typeof wordBreakKeywordsSchema>;

/**
 * Metadata for word-break keyword options.
 *
 * @public
 */
export const wordBreakKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Default line break rules",
	},
	"break-all": {
		value: "break-all" as const,
		description: "Breaks can be inserted between any characters",
	},
	"keep-all": {
		value: "keep-all" as const,
		description: "Breaks prohibited between CJK characters",
	},
	"break-word": {
		value: "break-word" as const,
		description: "Like word-break: normal with overflow-wrap: anywhere",
	},
} as const;


=== File: src/core/result.test.ts ===
// b_path:: src/core/result.test.ts

import { describe, expect, it } from "vitest";
import { andThen, err, fromZod, map, ok, unwrap, unwrapOr } from "./result";

describe("Result utilities", () => {
	describe("ok()", () => {
		it("should create successful result", () => {
			const result = ok(42);
			expect(result.ok).toBe(true);
			expect(result.value).toBe(42);
			expect(result.error).toBeUndefined();
		});

		it("should work with complex types", () => {
			const result = ok({ name: "test", count: 5 });
			expect(result.ok).toBe(true);
			expect(result.value).toEqual({ name: "test", count: 5 });
		});
	});

	describe("err()", () => {
		it("should create error result with string", () => {
			const result = err("Something failed");
			expect(result.ok).toBe(false);
			expect(result.error).toBe("Something failed");
			expect(result.value).toBeUndefined();
		});

		it("should create error result with Error object", () => {
			const error = new Error("Test error");
			const result = err(error);
			expect(result.ok).toBe(false);
			expect(result.error).toBe(error);
		});
	});

	describe("fromZod()", () => {
		it("should convert successful Zod parse to ok result", () => {
			const zodResult = { success: true as const, data: 42 };
			const result = fromZod(zodResult);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe(42);
			}
		});

		it("should convert failed Zod parse to err result", () => {
			const zodError = new Error("Validation failed");
			const zodResult = { success: false as const, error: zodError };
			const result = fromZod(zodResult);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBe(zodError);
			}
		});
	});

	describe("unwrap()", () => {
		it("should return value for ok result", () => {
			const result = ok(42);
			expect(unwrap(result)).toBe(42);
		});

		it("should throw Error for err result with Error", () => {
			const error = new Error("Test error");
			const result = err(error);
			expect(() => unwrap(result)).toThrow(error);
		});

		it("should throw Error for err result with string", () => {
			const result = err("Failed");
			expect(() => unwrap(result)).toThrow("Failed");
		});

		it("should throw Error for err result with other types", () => {
			const result = err(123);
			expect(() => unwrap(result)).toThrow("123");
		});
	});

	describe("unwrapOr()", () => {
		it("should return value for ok result", () => {
			const result = ok(42);
			expect(unwrapOr(result, 0)).toBe(42);
		});

		it("should return default value for err result", () => {
			const result = err("Failed");
			expect(unwrapOr(result, 0)).toBe(0);
		});

		it("should work with complex default values", () => {
			const result = err("Failed");
			const defaultValue = { name: "default", count: 0 };
			expect(unwrapOr(result, defaultValue)).toEqual(defaultValue);
		});
	});

	describe("map()", () => {
		it("should transform ok result value", () => {
			const result = ok(2);
			const doubled = map(result, (x) => x * 2);
			expect(doubled.ok).toBe(true);
			if (doubled.ok) {
				expect(doubled.value).toBe(4);
			}
		});

		it("should preserve err result", () => {
			const result = err("Failed");
			const mapped = map(result, (x: number) => x * 2);
			expect(mapped.ok).toBe(false);
			if (!mapped.ok) {
				expect(mapped.error).toBe("Failed");
			}
		});

		it("should allow type transformation", () => {
			const result = ok(42);
			const stringResult = map(result, (x) => `Value: ${x}`);
			expect(stringResult.ok).toBe(true);
			if (stringResult.ok) {
				expect(stringResult.value).toBe("Value: 42");
			}
		});
	});

	describe("andThen()", () => {
		it("should chain successful results", () => {
			const result = ok(2);
			const doubled = andThen(result, (x) => ok(x * 2));
			expect(doubled.ok).toBe(true);
			if (doubled.ok) {
				expect(doubled.value).toBe(4);
			}
		});

		it("should short-circuit on error", () => {
			const result = err("Initial error");
			const chained = andThen(result, (x: number) => ok(x * 2));
			expect(chained.ok).toBe(false);
			if (!chained.ok) {
				expect(chained.error).toBe("Initial error");
			}
		});

		it("should propagate errors from chained function", () => {
			const result = ok(0);
			const chained = andThen(result, (x) => (x > 0 ? ok(x * 2) : err("Must be positive")));
			expect(chained.ok).toBe(false);
			if (!chained.ok) {
				expect(chained.error).toBe("Must be positive");
			}
		});

		it("should allow type transformation", () => {
			const result = ok(42);
			const stringResult = andThen(result, (x) => ok(`Value: ${x}`));
			expect(stringResult.ok).toBe(true);
			if (stringResult.ok) {
				expect(stringResult.value).toBe("Value: 42");
			}
		});
	});
});


=== File: src/core/result.ts ===
// b_path:: src/core/result.ts

/**
 * Result type for operations that may fail.
 *
 * Provides a type-safe way to handle errors without throwing exceptions.
 * Inspired by Rust's Result<T, E> and functional programming patterns.
 *
 * Supports destructuring for convenient access:
 * - `ok: true` → `value` is available, `error` is undefined
 * - `ok: false` → `error` is available, `value` is undefined
 *
 * @example
 * ```typescript
 * import { Result, ok, err } from "@/core/result";
 *
 * function divide(a: number, b: number): Result<number, string> {
 *   if (b === 0) return err("Division by zero");
 *   return ok(a / b);
 * }
 *
 * const { ok, value, error } = divide(10, 2);
 * if (ok) {
 *   console.log(value); // 5 (type: number)
 * } else {
 *   console.error(error); // string
 * }
 * ```
 *
 * @public
 */
export type Result<T, E = Error> = { ok: true; value: T; error: undefined } | { ok: false; value: undefined; error: E };

/**
 * Create a successful result.
 *
 * @example
 * ```typescript
 * const result = ok(42);
 * console.log(result.ok); // true
 * console.log(result.value); // 42
 * console.log(result.error); // undefined
 * ```
 *
 * @public
 */
export function ok<T>(value: T): Result<T, never> {
	return { ok: true, value, error: undefined };
}

/**
 * Create an error result.
 *
 * @example
 * ```typescript
 * const result = err("Something went wrong");
 * console.log(result.ok); // false
 * console.log(result.error); // "Something went wrong"
 * console.log(result.value); // undefined
 * ```
 *
 * @public
 */
export function err<E>(error: E): Result<never, E> {
	return { ok: false, value: undefined, error };
}

/**
 * Convert a Zod SafeParseReturnType to a Result.
 *
 * @example
 * ```typescript
 * import { z } from "zod";
 * import { fromZod } from "@/core/result";
 *
 * const schema = z.number();
 * const zodResult = schema.safeParse("not a number");
 * const result = fromZod(zodResult);
 *
 * if (!result.ok) {
 *   console.error(result.error); // ZodError
 * }
 * ```
 *
 * @public
 */
export function fromZod<T, E = unknown>(
	zodResult: { success: true; data: T } | { success: false; error: E },
): Result<T, E> {
	if (zodResult.success) {
		return ok(zodResult.data);
	}
	return err(zodResult.error);
}

/**
 * Unwrap a result, throwing if it's an error.
 * Use sparingly - prefer explicit error handling.
 *
 * @example
 * ```typescript
 * const result = ok(42);
 * const value = unwrap(result); // 42
 *
 * const errorResult = err("Failed");
 * unwrap(errorResult); // throws Error("Failed")
 * ```
 *
 * @public
 */
export function unwrap<T, E>(result: Result<T, E>): T {
	if (result.ok) {
		return result.value;
	}
	throw result.error instanceof Error ? result.error : new Error(String(result.error));
}

/**
 * Get the value or a default if error.
 *
 * @example
 * ```typescript
 * const result = err("Failed");
 * const value = unwrapOr(result, 42); // 42
 * ```
 *
 * @public
 */
export function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {
	return result.ok ? result.value : defaultValue;
}

/**
 * Map over a successful result.
 *
 * @example
 * ```typescript
 * const result = ok(2);
 * const doubled = map(result, x => x * 2);
 * console.log(doubled.value); // 4
 * ```
 *
 * @public
 */
export function map<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E> {
	return result.ok ? ok(fn(result.value)) : result;
}

/**
 * Chain results together (flatMap).
 *
 * @example
 * ```typescript
 * const result = ok(2);
 * const doubled = andThen(result, x =>
 *   x > 0 ? ok(x * 2) : err("Must be positive")
 * );
 * ```
 *
 * @public
 */
export function andThen<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E> {
	return result.ok ? fn(result.value) : result;
}

// ============================================================================
// ParseResult and GenerateResult - Public API Types
// ============================================================================

/**
 * Longhand CSS property names - properties supported by b_value.
 * @public
 */
export type CSSLonghandProperty =
	// Color
	| "color"
	| "background-color"
	| "border-color"
	| "border-top-color"
	| "border-right-color"
	| "border-bottom-color"
	| "border-left-color"
	| "outline-color"
	| "text-decoration-color"
	// Clip-path
	| "clip-path"
	// Background
	| "background-image"
	| "background-position"
	| "background-size"
	| "background-repeat"
	| "background-attachment"
	| "background-clip"
	| "background-origin"
	// Filter
	| "filter"
	| "backdrop-filter"
	// Transform
	| "transform"
	| "transform-origin"
	// Shadow
	| "box-shadow"
	| "text-shadow"
	// Border
	| "border-width"
	| "border-top-width"
	| "border-right-width"
	| "border-bottom-width"
	| "border-left-width"
	| "border-style"
	| "border-top-style"
	| "border-right-style"
	| "border-bottom-style"
	| "border-left-style"
	| "border-top-left-radius"
	| "border-top-right-radius"
	| "border-bottom-right-radius"
	| "border-bottom-left-radius"
	// Outline
	| "outline-width"
	| "outline-style"
	| "outline-offset"
	// Animation
	| "animation-name"
	| "animation-duration"
	| "animation-timing-function"
	| "animation-delay"
	| "animation-iteration-count"
	| "animation-direction"
	| "animation-fill-mode"
	| "animation-play-state"
	// Transition
	| "transition-property"
	| "transition-duration"
	| "transition-timing-function"
	| "transition-delay"
	// Layout
	| "width"
	| "height"
	| "min-width"
	| "min-height"
	| "max-width"
	| "max-height"
	| "top"
	| "right"
	| "bottom"
	| "left"
	| "position"
	| "display"
	| "overflow-x"
	| "overflow-y"
	| "visibility"
	| "z-index"
	| "opacity"
	| "cursor"
	// Text decoration
	| "text-decoration-line"
	| "text-decoration-style"
	| "text-decoration-thickness";

/**
 * Shorthand CSS property names - NOT supported by b_value, but detected for helpful errors.
 * @public
 */
export type CSSShorthandProperty =
	| "border"
	| "border-top"
	| "border-right"
	| "border-bottom"
	| "border-left"
	| "border-radius"
	| "margin"
	| "padding"
	| "background"
	| "font"
	| "text-decoration"
	| "animation"
	| "transition"
	| "outline"
	| "overflow"
	| "flex"
	| "grid"
	| "gap"
	| "inset";

/**
 * All CSS property names (longhand + shorthand for detection).
 * @public
 */
export type CSSPropertyName = CSSLonghandProperty | CSSShorthandProperty;

/**
 * Issue codes for categorization and filtering.
 * @public
 */
export type IssueCode =
	// Parse errors
	| "invalid-value"
	| "unknown-property"
	| "shorthand-not-supported"
	| "invalid-syntax"
	| "missing-value"
	// Parse warnings
	| "duplicate-property"
	| "deprecated-syntax"
	| "legacy-syntax"
	// Generate errors
	| "invalid-ir"
	| "missing-required-field"
	| "unsupported-kind";

/**
 * Issue reported during parsing or generation.
 * All fields are strongly typed for type safety and IDE autocomplete.
 *
 * @public
 */
export type Issue = {
	/** Issue code for categorization and filtering */
	code: IssueCode;
	/** Property name that caused the issue (strongly typed) */
	property?: CSSPropertyName;
	/** Severity level */
	severity: "error" | "warning" | "info";
	/** Human-readable message */
	message: string;
	/** Optional path to the field in IR that caused the issue (for generate errors) */
	path?: (string | number)[];
	/** Optional suggestion for fixing the issue */
	suggestion?: string;
	/** Optional action to take (e.g., "use modern syntax") */
	action?: string;
	/** Optional location in input string (for parse errors) */
	location?: {
		offset: number;
		length: number;
	};
	/** Optional metadata for debugging and advanced filtering */
	metadata?: {
		zodCode?: string;
		[key: string]: unknown;
	};
};

/**
 * Result of parsing CSS to intermediate representation.
 *
 * Used by Module API (e.g., Parse.Color.parse()) and Universal API (e.g., parse()).
 *
 * Discriminated union ensures type safety:
 * - When `ok: true`, `value` is guaranteed to be present (type T)
 * - When `ok: false`, `value` is undefined
 *
 * This means `if (result.ok)` is sufficient - no need for `if (result.ok && result.value)`.
 *
 * @example
 * ```typescript
 * const result = Parse.Color.parse("#ff0000");
 * if (result.ok) {
 *   console.log(result.value);  // Color IR - TypeScript knows it's defined
 * } else {
 *   console.error(result.issues[0].message);
 *   console.log(result.issues[0].suggestion);
 * }
 * ```
 *
 * @public
 */
export type ParseResult<T = unknown> =
	| { ok: true; value: T; property?: string; issues: Issue[] }
	| { ok: false; value?: undefined; property?: string; issues: Issue[] };

/**
 * Result of generating CSS from intermediate representation.
 *
 * Used by Module API (e.g., Generate.Color.generate()) and Universal API.
 *
 * Discriminated union ensures type safety:
 * - When `ok: true`, `value` is guaranteed to be present (string)
 * - When `ok: false`, `value` is undefined
 *
 * @example
 * ```typescript
 * const result = Generate.Color.generate(colorIR);
 * if (result.ok) {
 *   console.log(result.value);  // "#ff0000" - TypeScript knows it's defined
 * }
 * ```
 *
 * @public
 */
export type GenerateResult =
	| { ok: true; value: string; property?: string; issues: Issue[] }
	| { ok: false; value?: undefined; property?: string; issues: Issue[] };

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Create a successful ParseResult.
 *
 * @example
 * ```typescript
 * return parseOk(colorIR);
 * return parseOk(colorIR, "background-color");  // with property
 * ```
 *
 * @public
 */
export function parseOk<T>(value: T, property?: string): ParseResult<T> {
	const result: ParseResult<T> = {
		ok: true,
		value,
		issues: [],
	};
	if (property !== undefined) {
		result.property = property;
	}
	return result;
}

/**
 * Create a failed ParseResult.
 *
 * @example
 * ```typescript
 * return parseErr("invalid-value", "Invalid color format");
 * return parseErr("invalid-value", "Invalid hex color", {
 *   suggestion: "Use #RRGGBB format",
 *   property: "color"
 * });
 * ```
 *
 * @public
 */
export function parseErr<T = never>(
	code: IssueCode,
	message: string,
	options?: {
		suggestion?: string;
		action?: string;
		location?: { offset: number; length: number };
		property?: CSSPropertyName;
	},
): ParseResult<T> {
	const issue: Issue = {
		code,
		severity: "error",
		message,
	};
	if (options?.suggestion !== undefined) issue.suggestion = options.suggestion;
	if (options?.action !== undefined) issue.action = options.action;
	if (options?.location !== undefined) issue.location = options.location;
	if (options?.property !== undefined) issue.property = options.property;

	const result: ParseResult<T> = {
		ok: false,
		issues: [issue],
	};
	if (options?.property !== undefined) {
		result.property = options.property;
	}
	return result;
}

/**
 * Create a successful GenerateResult.
 *
 * @example
 * ```typescript
 * return generateOk("#ff0000");
 * return generateOk("#ff0000", "color");  // with property
 * ```
 *
 * @public
 */
export function generateOk(value: string, property?: string): GenerateResult {
	const result: GenerateResult = {
		ok: true,
		value,
		issues: [],
	};
	if (property !== undefined) {
		result.property = property;
	}
	return result;
}

/**
 * Create a failed GenerateResult.
 *
 * @example
 * ```typescript
 * return generateErr("invalid-ir", "Invalid IR structure");
 * return generateErr("missing-required-field", "Missing 'kind' field", {
 *   suggestion: "Add 'kind' field",
 *   property: "color"
 * });
 * ```
 *
 * @public
 */
export function generateErr(
	code: IssueCode,
	message: string,
	options?: {
		suggestion?: string;
		action?: string;
		property?: CSSPropertyName;
	},
): GenerateResult {
	const issue: Issue = {
		code,
		severity: "error",
		message,
	};
	if (options?.suggestion !== undefined) issue.suggestion = options.suggestion;
	if (options?.action !== undefined) issue.action = options.action;
	if (options?.property !== undefined) issue.property = options.property;

	const result: GenerateResult = {
		ok: false,
		issues: [issue],
	};
	if (options?.property !== undefined) {
		result.property = options.property;
	}
	return result;
}

/**
 * Add an issue to a ParseResult (preserves success state).
 *
 * @example
 * ```typescript
 * let result = parseOk(colorIR);
 * result = addIssue(result, {
 *   severity: "warning",
 *   message: "Legacy syntax",
 *   suggestion: "Use modern syntax"
 * });
 * ```
 *
 * @public
 */
export function addIssue<T>(result: ParseResult<T>, issue: Issue): ParseResult<T> {
	return {
		...result,
		issues: [...result.issues, issue],
	};
}

/**
 * Add a warning to a ParseResult (preserves success state).
 *
 * @example
 * ```typescript
 * return withWarning(parseOk(colorIR), "deprecated-syntax", "Legacy comma syntax");
 * ```
 *
 * @public
 */
export function withWarning<T>(
	result: ParseResult<T>,
	code: IssueCode,
	message: string,
	suggestion?: string,
): ParseResult<T> {
	const issue: Issue = {
		code,
		severity: "warning",
		message,
	};
	if (suggestion !== undefined) issue.suggestion = suggestion;
	return addIssue(result, issue);
}

// ============================================================================
// Issue Creation Helpers
// ============================================================================

/**
 * Predefined issue creators for common error cases.
 * Provides type-safe, consistent issue creation with standardized messages.
 *
 * @example
 * ```typescript
 * // In parseAll()
 * if (duplicateCount > 1) {
 *   issues.push(Issues.duplicateProperty("color", duplicateCount));
 * }
 *
 * if (!result.ok) {
 *   issues.push(Issues.invalidValue("width", "not-a-number"));
 * }
 * ```
 *
 * @public
 */
export const Issues = {
	/**
	 * Create issue for duplicate property declaration (warning).
	 */
	duplicateProperty(property: CSSLonghandProperty, count: number): Issue {
		return {
			code: "duplicate-property",
			severity: "warning",
			property,
			message: `Duplicate property '${property}' declared ${count} times - using last value`,
		};
	},

	/**
	 * Create issue for invalid property value (error).
	 */
	invalidValue(property: CSSLonghandProperty, value: string): Issue {
		return {
			code: "invalid-value",
			severity: "error",
			property,
			message: `Invalid value '${value}' for property '${property}'`,
		};
	},

	/**
	 * Create issue for shorthand property detection (error with b_short promotion).
	 */
	shorthandNotSupported(property: CSSShorthandProperty, longhands: string[]): Issue {
		return {
			code: "shorthand-not-supported",
			severity: "error",
			property,
			message: `Shorthand property '${property}' is not supported in b_value. Use longhand properties: ${longhands.join(", ")}. For shorthand support, use the 'b_short' library.`,
			suggestion: "Use b_short to expand shorthands first",
		};
	},

	/**
	 * Create issue for unknown CSS property (error).
	 */
	unknownProperty(property: string): Issue {
		return {
			code: "unknown-property",
			severity: "error",
			message: `Unknown CSS property '${property}'`,
		};
	},

	/**
	 * Create issue for invalid syntax (error).
	 */
	invalidSyntax(message: string, location?: { offset: number; length: number }): Issue {
		const issue: Issue = {
			code: "invalid-syntax",
			severity: "error",
			message,
		};
		if (location !== undefined) {
			issue.location = location;
		}
		return issue;
	},

	/**
	 * Create issue for deprecated syntax (warning).
	 */
	deprecatedSyntax(property: CSSLonghandProperty, message: string, suggestion?: string): Issue {
		const issue: Issue = {
			code: "deprecated-syntax",
			severity: "warning",
			property,
			message,
		};
		if (suggestion !== undefined) {
			issue.suggestion = suggestion;
		}
		return issue;
	},

	/**
	 * Create issue for legacy syntax (warning).
	 */
	legacySyntax(property: CSSLonghandProperty, message: string, suggestion?: string): Issue {
		const issue: Issue = {
			code: "legacy-syntax",
			severity: "warning",
			property,
			message,
		};
		if (suggestion !== undefined) {
			issue.suggestion = suggestion;
		}
		return issue;
	},
};

/**
 * Combine multiple ParseResults into one (for layer/list parsing).
 *
 * @example
 * ```typescript
 * const results = [parseOk(color1), parseOk(color2)];
 * const combined = combineResults(results);
 * // { ok: true, value: [color1, color2], issues: [] }
 * ```
 *
 * @public
 */
export function combineResults<T>(results: ParseResult<T>[]): ParseResult<T[]> {
	const allOk = results.every((r) => r.ok);
	const values = results.map((r) => r.value).filter((v): v is T => v !== undefined);
	const allIssues = results.flatMap((r) => r.issues);

	if (allOk && values.length === results.length) {
		return {
			ok: true,
			value: values,
			issues: allIssues,
		};
	}

	return {
		ok: false,
		issues: allIssues,
	};
}

/**
 * Convert internal Result<T, string> to public ParseResult<T>.
 *
 * @internal
 */
export function toParseResult<T>(result: Result<T, string>, property?: CSSPropertyName): ParseResult<T> {
	if (result.ok) {
		return parseOk(result.value, property);
	}
	// Use generic invalid-value code for Result<T, string> conversions
	return parseErr("invalid-value", result.error, property ? { property } : undefined);
}


=== File: src/core/types/angle.test.ts ===
// b_path:: src/core/types/angle.test.ts

import { describe, expect, it } from "vitest";
import { type Angle, angleSchema } from "./angle";

describe("angleSchema", () => {
	it("validates degrees", () => {
		const result = angleSchema.safeParse({ value: 45, unit: "deg" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.value).toBe(45);
			expect(result.data.unit).toBe("deg");
		}
	});

	it("validates radians", () => {
		const result = angleSchema.safeParse({ value: 1.57, unit: "rad" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.value).toBe(1.57);
			expect(result.data.unit).toBe("rad");
		}
	});

	it("validates gradians", () => {
		const result = angleSchema.safeParse({ value: 100, unit: "grad" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.unit).toBe("grad");
		}
	});

	it("validates turns", () => {
		const result = angleSchema.safeParse({ value: 0.5, unit: "turn" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.unit).toBe("turn");
		}
	});

	it("validates negative values", () => {
		const result = angleSchema.safeParse({ value: -45, unit: "deg" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.value).toBe(-45);
		}
	});

	it("validates zero", () => {
		const result = angleSchema.safeParse({ value: 0, unit: "deg" });
		expect(result.success).toBe(true);
	});

	it("rejects missing value", () => {
		const result = angleSchema.safeParse({ unit: "deg" });
		expect(result.success).toBe(false);
	});

	it("rejects missing unit", () => {
		const result = angleSchema.safeParse({ value: 45 });
		expect(result.success).toBe(false);
	});

	it("rejects invalid unit", () => {
		const result = angleSchema.safeParse({ value: 45, unit: "px" });
		expect(result.success).toBe(false);
	});
});

describe("Angle type", () => {
	it("accepts valid angle in degrees", () => {
		const angle: Angle = { value: 90, unit: "deg" };
		expect(angle.value).toBe(90);
		expect(angle.unit).toBe("deg");
	});

	it("accepts valid angle in radians", () => {
		const angle: Angle = { value: 3.14, unit: "rad" };
		expect(angle.value).toBe(3.14);
		expect(angle.unit).toBe("rad");
	});
});


=== File: src/core/types/angle.ts ===
// b_path:: src/core/types/angle.ts
import { z } from "zod";
import * as Unit from "../units";

/**
 * CSS `<angle>` dimension.
 *
 * An angle is a rotation measurement consisting of a number and an angle unit.
 * Used in transforms, gradients, and other CSS properties requiring angular measurements.
 *
 * Per CSS Values & Units Module Level 4 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/angle}
 * @see {@link https://www.w3.org/TR/css-values-4/#angles}
 *
 * @example
 * ```typescript
 * import { angleSchema } from "@/core/types/angle";
 *
 * const rotation: Angle = { value: 45, unit: "deg" };
 * const fullCircle: Angle = { value: 360, unit: "deg" };
 * const radians: Angle = { value: 1.57, unit: "rad" };
 * ```
 *
 * @public
 */
export const angleSchema = z.object({
	value: z.number(),
	unit: Unit.angleUnitSchema,
});

/**
 * TypeScript type for `<angle>` dimension.
 *
 * @public
 */
export type Angle = z.infer<typeof angleSchema>;


=== File: src/core/types/animation.test.ts ===
// b_path:: src/core/types/animation.test.ts
import { describe, expect, test } from "vitest";
import { cubicBezierSchema, linearEasingSchema, linearStopSchema, stepsSchema } from "./animation";

/**
 * Schema validation tests for animation timing functions.
 *
 * These tests validate Zod schemas directly using `.safeParse()` to ensure
 * they reject invalid IR values (NaN, Infinity, out-of-range, etc.) before
 * reaching parsers or generators.
 *
 * Per CSS Easing Spec: https://www.w3.org/TR/css-easing-1/
 */

describe("cubicBezierSchema", () => {
	describe("valid values", () => {
		test("accepts standard ease curve", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0.25,
				y1: 0.1,
				x2: 0.25,
				y2: 1.0,
			});
			expect(result.success).toBe(true);
		});

		test("accepts y values outside 0-1 (bounce effects)", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0.5,
				y1: -0.5,
				x2: 0.5,
				y2: 1.5,
			});
			expect(result.success).toBe(true);
		});

		test("accepts boundary x values (0 and 1)", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: 1,
				y2: 1,
			});
			expect(result.success).toBe(true);
		});

		test("accepts linear curve (0,0,1,1)", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: 1,
				y2: 1,
			});
			expect(result.success).toBe(true);
		});

		test("accepts large negative y values", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0.5,
				y1: -100,
				x2: 0.5,
				y2: 100,
			});
			expect(result.success).toBe(true);
		});
	});

	describe("invalid values - x constraints", () => {
		test("rejects x1 > 1", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 1.5,
				y1: 0,
				x2: 0,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects x1 < 0", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: -0.1,
				y1: 0,
				x2: 0,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects x2 > 1", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: 1.1,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects x2 < 0", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: -0.5,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});
	});

	describe("invalid values - special numbers", () => {
		test("rejects x1 = Infinity", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: Number.POSITIVE_INFINITY,
				y1: 0,
				x2: 0,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects x1 = -Infinity", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: Number.NEGATIVE_INFINITY,
				y1: 0,
				x2: 0,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects x1 = NaN", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: Number.NaN,
				y1: 0,
				x2: 0,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects y1 = NaN", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: Number.NaN,
				x2: 1,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects y1 = Infinity", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: Number.POSITIVE_INFINITY,
				x2: 1,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});
	});

	describe("invalid values - missing/wrong fields", () => {
		test("rejects missing x2", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects missing y2", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects wrong type field", () => {
			const result = cubicBezierSchema.safeParse({
				type: "steps",
				x1: 0,
				y1: 0,
				x2: 1,
				y2: 1,
			});
			expect(result.success).toBe(false);
		});

		test("allows extra fields (zod default behavior)", () => {
			const result = cubicBezierSchema.safeParse({
				type: "cubic-bezier",
				x1: 0,
				y1: 0,
				x2: 1,
				y2: 1,
				extra: "field",
			});
			// Zod allows extra fields by default unless using .strict()
			expect(result.success).toBe(true);
		});
	});
});

describe("stepsSchema", () => {
	describe("valid values", () => {
		test("accepts single step", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 1,
			});
			expect(result.success).toBe(true);
		});

		test("accepts steps with end position", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 4,
				position: "end",
			});
			expect(result.success).toBe(true);
		});

		test("accepts steps with start position", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 3,
				position: "start",
			});
			expect(result.success).toBe(true);
		});

		test("accepts steps with jump-start", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 5,
				position: "jump-start",
			});
			expect(result.success).toBe(true);
		});

		test("accepts steps with jump-end", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 2,
				position: "jump-end",
			});
			expect(result.success).toBe(true);
		});

		test("accepts steps with jump-none", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 4,
				position: "jump-none",
			});
			expect(result.success).toBe(true);
		});

		test("accepts steps with jump-both", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 3,
				position: "jump-both",
			});
			expect(result.success).toBe(true);
		});

		test("accepts large step count", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 1000,
			});
			expect(result.success).toBe(true);
		});
	});

	describe("invalid values - step constraints", () => {
		test("rejects zero steps", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 0,
			});
			expect(result.success).toBe(false);
		});

		test("rejects negative steps", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: -5,
			});
			expect(result.success).toBe(false);
		});

		test("rejects float steps", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 3.5,
			});
			expect(result.success).toBe(false);
		});

		test("rejects NaN steps", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: Number.NaN,
			});
			expect(result.success).toBe(false);
		});

		test("rejects Infinity steps", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: Number.POSITIVE_INFINITY,
			});
			expect(result.success).toBe(false);
		});
	});

	describe("invalid values - position constraints", () => {
		test("rejects invalid position keyword", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 4,
				position: "middle",
			});
			expect(result.success).toBe(false);
		});

		test("rejects numeric position", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
				steps: 4,
				position: 123,
			});
			expect(result.success).toBe(false);
		});
	});

	describe("invalid values - missing/wrong fields", () => {
		test("rejects missing steps field", () => {
			const result = stepsSchema.safeParse({
				type: "steps",
			});
			expect(result.success).toBe(false);
		});

		test("rejects wrong type field", () => {
			const result = stepsSchema.safeParse({
				type: "cubic-bezier",
				steps: 4,
			});
			expect(result.success).toBe(false);
		});
	});
});

describe("linearStopSchema", () => {
	describe("valid values", () => {
		test("accepts stop with output only", () => {
			const result = linearStopSchema.safeParse({
				output: 0.5,
			});
			expect(result.success).toBe(true);
		});

		test("accepts stop with output and input", () => {
			const result = linearStopSchema.safeParse({
				output: 0.5,
				input: 0.25,
			});
			expect(result.success).toBe(true);
		});

		test("accepts boundary input values (0 and 1)", () => {
			const result = linearStopSchema.safeParse({
				output: 1,
				input: 1,
			});
			expect(result.success).toBe(true);
		});

		test("accepts negative output", () => {
			const result = linearStopSchema.safeParse({
				output: -0.5,
				input: 0.5,
			});
			expect(result.success).toBe(true);
		});

		test("accepts output > 1", () => {
			const result = linearStopSchema.safeParse({
				output: 1.5,
				input: 0.8,
			});
			expect(result.success).toBe(true);
		});
	});

	describe("invalid values - input constraints", () => {
		test("rejects input < 0", () => {
			const result = linearStopSchema.safeParse({
				output: 0.5,
				input: -0.1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects input > 1", () => {
			const result = linearStopSchema.safeParse({
				output: 0.5,
				input: 1.1,
			});
			expect(result.success).toBe(false);
		});

		test("rejects input = NaN", () => {
			const result = linearStopSchema.safeParse({
				output: 0.5,
				input: Number.NaN,
			});
			expect(result.success).toBe(false);
		});

		test("rejects input = Infinity", () => {
			const result = linearStopSchema.safeParse({
				output: 0.5,
				input: Number.POSITIVE_INFINITY,
			});
			expect(result.success).toBe(false);
		});
	});

	describe("invalid values - output constraints", () => {
		test("rejects output = NaN", () => {
			const result = linearStopSchema.safeParse({
				output: Number.NaN,
				input: 0.5,
			});
			expect(result.success).toBe(false);
		});

		test("rejects output = Infinity", () => {
			const result = linearStopSchema.safeParse({
				output: Number.POSITIVE_INFINITY,
				input: 0.5,
			});
			expect(result.success).toBe(false);
		});

		test("rejects missing output", () => {
			const result = linearStopSchema.safeParse({
				input: 0.5,
			});
			expect(result.success).toBe(false);
		});
	});
});

describe("linearEasingSchema", () => {
	describe("valid values", () => {
		test("accepts single stop", () => {
			const result = linearEasingSchema.safeParse({
				type: "linear",
				stops: [{ output: 0.5 }],
			});
			expect(result.success).toBe(true);
		});

		test("accepts multiple stops", () => {
			const result = linearEasingSchema.safeParse({
				type: "linear",
				stops: [{ output: 0 }, { output: 0.5, input: 0.5 }, { output: 1 }],
			});
			expect(result.success).toBe(true);
		});

		test("accepts stops with mixed input presence", () => {
			const result = linearEasingSchema.safeParse({
				type: "linear",
				stops: [{ output: 0 }, { output: 0.5, input: 0.25 }, { output: 1 }],
			});
			expect(result.success).toBe(true);
		});
	});

	describe("invalid values", () => {
		test("rejects empty stops array", () => {
			const result = linearEasingSchema.safeParse({
				type: "linear",
				stops: [],
			});
			expect(result.success).toBe(false);
		});

		test("rejects invalid stop in array", () => {
			const result = linearEasingSchema.safeParse({
				type: "linear",
				stops: [{ output: 0 }, { output: Number.NaN }],
			});
			expect(result.success).toBe(false);
		});

		test("rejects missing type", () => {
			const result = linearEasingSchema.safeParse({
				stops: [{ output: 0.5 }],
			});
			expect(result.success).toBe(false);
		});

		test("rejects wrong type", () => {
			const result = linearEasingSchema.safeParse({
				type: "steps",
				stops: [{ output: 0.5 }],
			});
			expect(result.success).toBe(false);
		});

		test("rejects missing stops", () => {
			const result = linearEasingSchema.safeParse({
				type: "linear",
			});
			expect(result.success).toBe(false);
		});
	});
});


=== File: src/core/types/animation.ts ===
// b_path:: src/core/types/animation.ts
import { z } from "zod";
import * as Keyword from "../keywords/animation";
import { autoSchema } from "./auto";
import { delayTimeSchema, timeSchema } from "./time";

/**
 * CSS animation-delay property IR.
 *
 * Specifies when an animation should start.
 * Comma-separated list of time values (can be negative).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-delay}
 *
 * @public
 */
export const animationDelaySchema = z.object({
	kind: z.literal("animation-delay"),
	delays: z.array(delayTimeSchema).min(1),
});

/**
 * CSS animation-delay type.
 *
 * @public
 */
export type AnimationDelay = z.infer<typeof animationDelaySchema>;

/**
 * CSS animation-duration property IR.
 *
 * Specifies how long an animation should take to complete one cycle.
 * Comma-separated list of time values or 'auto'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-duration}
 *
 * @public
 */

const timeExtendedSchema = timeSchema.extend({
	type: z.literal("time"),
});

export const animationDurationSchema = z.object({
	kind: z.literal("animation-duration"),
	durations: z.array(z.discriminatedUnion("type", [autoSchema, timeExtendedSchema])).min(1),
});

/**
 * CSS animation-duration type.
 *
 * @public
 */
export type AnimationDuration = z.infer<typeof animationDurationSchema>;

/**
 * CSS animation-iteration-count property IR.
 *
 * Specifies the number of times an animation should repeat.
 * Comma-separated list of numbers or 'infinite'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-iteration-count}
 *
 * @public
 */
export const animationIterationCountSchema = z.object({
	kind: z.literal("animation-iteration-count"),
	counts: z
		.array(
			z.union(
				[
					z.object({ type: z.literal("infinite") }),
					z.object({ type: z.literal("number"), value: z.number().nonnegative() }),
				],
				{
					error: (issue) =>
						issue.code === "invalid_union"
							? 'Invalid iteration count. Expected { type: "infinite" } or { type: "number", value: <non-negative number> }.'
							: "Invalid input",
				},
			),
		)
		.min(1),
});

/**
 * CSS animation-iteration-count type.
 *
 * @public
 */
export type AnimationIterationCount = z.infer<typeof animationIterationCountSchema>;

/**
 * CSS animation-direction property IR.
 *
 * Specifies whether an animation should play forwards, backwards, or alternate.
 * Comma-separated list of direction keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-direction}
 *
 * @public
 */
export const animationDirectionSchema = z.object({
	kind: z.literal("animation-direction"),
	directions: z.array(z.enum(Keyword.ANIMATION_DIRECTION_KEYWORDS)).min(1),
});

/**
 * CSS animation-direction type.
 *
 * @public
 */
export type AnimationDirection = z.infer<typeof animationDirectionSchema>;

/**
 * CSS animation-fill-mode property IR.
 *
 * Specifies how styles are applied before/after animation execution.
 * Comma-separated list of fill mode keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-fill-mode}
 *
 * @public
 */
export const animationFillModeSchema = z.object({
	kind: z.literal("animation-fill-mode"),
	modes: z.array(z.enum(Keyword.ANIMATION_FILL_MODE_KEYWORDS)).min(1),
});

/**
 * CSS animation-fill-mode type.
 *
 * @public
 */
export type AnimationFillMode = z.infer<typeof animationFillModeSchema>;

/**
 * CSS animation-play-state property IR.
 *
 * Specifies whether an animation is running or paused.
 * Comma-separated list of play state keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-play-state}
 *
 * @public
 */
export const animationPlayStateSchema = z.object({
	kind: z.literal("animation-play-state"),
	states: z.array(z.enum(Keyword.ANIMATION_PLAY_STATE_KEYWORDS)).min(1),
});

/**
 * CSS animation-play-state type.
 *
 * @public
 */
export type AnimationPlayState = z.infer<typeof animationPlayStateSchema>;

/**
 * CSS animation-name property IR.
 *
 * Specifies the names of @keyframes at-rules.
 * Comma-separated list of identifiers or 'none'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-name}
 *
 * @public
 */
export const animationNameSchema = z.object({
	kind: z.literal("animation-name"),
	names: z
		.array(
			z.union([z.object({ type: z.literal("none") }), z.object({ type: z.literal("identifier"), value: z.string() })], {
				error: (issue) =>
					issue.code === "invalid_union"
						? 'Invalid animation name. Expected { type: "none" } or { type: "identifier", value: <string> }.'
						: "Invalid input",
			}),
		)
		.min(1),
});

/**
 * CSS animation-name type.
 *
 * @public
 */
export type AnimationName = z.infer<typeof animationNameSchema>;

/**
 * CSS cubic-bezier() easing function IR.
 *
 * Defines a cubic Bezier curve for easing.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#cubic-bezier}
 * @see {@link https://www.w3.org/TR/css-easing-1/#cubic-bezier-easing-functions}
 *
 * @public
 */
export const cubicBezierSchema = z.object({
	type: z.literal("cubic-bezier"),
	x1: z.number().min(0).max(1),
	y1: z.number(),
	x2: z.number().min(0).max(1),
	y2: z.number(),
});

/**
 * CSS cubic-bezier() type.
 *
 * @public
 */
export type CubicBezier = z.infer<typeof cubicBezierSchema>;

/**
 * CSS steps() easing function IR.
 *
 * Defines a step easing function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#steps}
 * @see {@link https://www.w3.org/TR/css-easing-1/#step-easing-functions}
 *
 * @public
 */
export const stepsSchema = z.object({
	type: z.literal("steps"),
	steps: z.number().positive().int(),
	position: z.enum(Keyword.STEP_POSITION_KEYWORDS).optional(),
});

/**
 * CSS steps() type.
 *
 * @public
 */
export type Steps = z.infer<typeof stepsSchema>;

/**
 * CSS linear() stop IR.
 *
 * A single stop in a linear() easing function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#linear}
 * @see {@link https://www.w3.org/TR/css-easing-1/#linear-easing-function}
 *
 * @public
 */
export const linearStopSchema = z.object({
	output: z.number(),
	input: z.number().min(0).max(1).optional(),
});

/**
 * CSS linear() stop type.
 *
 * @public
 */
export type LinearStop = z.infer<typeof linearStopSchema>;

/**
 * CSS linear() easing function IR.
 *
 * Defines a piecewise linear easing function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function#linear}
 * @see {@link https://www.w3.org/TR/css-easing-1/#linear-easing-function}
 *
 * @public
 */
export const linearEasingSchema = z.object({
	type: z.literal("linear"),
	stops: z.array(linearStopSchema).min(1),
});

/**
 * CSS linear() type.
 *
 * @public
 */
export type LinearEasing = z.infer<typeof linearEasingSchema>;

/**
 * CSS easing function IR.
 *
 * Union of all easing function types: keywords, cubic-bezier(), steps(), linear().
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function}
 * @see {@link https://www.w3.org/TR/css-easing-1/#easing-functions}
 *
 * @public
 */
export const easingFunctionSchema = z.union(
	[z.enum(Keyword.EASING_KEYWORD_KEYWORDS), cubicBezierSchema, stepsSchema, linearEasingSchema],
	{
		error: (issue) =>
			issue.code === "invalid_union"
				? "Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear()."
				: "Invalid input",
	},
);

/**
 * CSS easing function type.
 *
 * @public
 */
export type EasingFunction = z.infer<typeof easingFunctionSchema>;

/**
 * CSS animation-timing-function property IR.
 *
 * Specifies the timing function for animations.
 * Comma-separated list of easing functions.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-timing-function}
 *
 * @public
 */
export const animationTimingFunctionSchema = z.object({
	kind: z.literal("animation-timing-function"),
	functions: z.array(easingFunctionSchema).min(1),
});

/**
 * CSS animation-timing-function type.
 *
 * @public
 */
export type AnimationTimingFunction = z.infer<typeof animationTimingFunctionSchema>;


=== File: src/core/types/auto.ts ===
// b_path:: src/core/types/auto.ts
import { z } from "zod";

export const autoSchema = z.object({
	type: z.literal("auto"),
});


=== File: src/core/types/border.test.ts ===
// b_path:: src/core/types/border.test.ts
import { describe, expect, it } from "vitest";
import {
	type BorderColor,
	type BorderColorValue,
	type BorderSides,
	type BorderStyle,
	type BorderStyleValue,
	type BorderWidth,
	type BorderWidthValue,
	borderColorSchema,
	borderColorValueSchema,
	borderRadiusValueSchema,
	borderSidesSchema,
	borderStyleSchema,
	borderStyleValueSchema,
	borderWidthSchema,
	borderWidthValueSchema,
	type UnifiedBorder,
	unifiedBorderSchema,
} from "./border";

describe("borderWidthSchema", () => {
	it("accepts length values", () => {
		const result = borderWidthSchema.safeParse({ value: 1, unit: "px" });
		expect(result.success).toBe(true);
	});

	it("accepts border-width keywords", () => {
		const keywords = ["thin", "medium", "thick"];
		for (const keyword of keywords) {
			expect(borderWidthSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid values", () => {
		expect(borderWidthSchema.safeParse("invalid").success).toBe(false);
		expect(borderWidthSchema.safeParse(123).success).toBe(false);
	});
});

describe("borderStyleSchema", () => {
	it("accepts border-style keywords", () => {
		const keywords = ["none", "solid", "dashed", "dotted", "double"];
		for (const keyword of keywords) {
			expect(borderStyleSchema.safeParse(keyword).success).toBe(true);
		}
	});

	it("rejects invalid values", () => {
		expect(borderStyleSchema.safeParse("invalid").success).toBe(false);
	});
});

describe("borderColorSchema", () => {
	it("accepts color keywords", () => {
		const keywords = ["currentcolor", "transparent", "red", "#ff0000"];
		for (const keyword of keywords) {
			expect(borderColorSchema.safeParse(keyword).success).toBe(true);
		}
	});
});

describe("borderSidesSchema", () => {
	it("accepts array of sides", () => {
		const result = borderSidesSchema.safeParse(["top", "bottom"]);
		expect(result.success).toBe(true);
	});

	it("accepts undefined (optional)", () => {
		const result = borderSidesSchema.safeParse(undefined);
		expect(result.success).toBe(true);
	});

	it("rejects invalid sides", () => {
		const result = borderSidesSchema.safeParse(["invalid"]);
		expect(result.success).toBe(false);
	});
});

describe("unifiedBorderSchema", () => {
	it("validates unified border object", () => {
		const border: UnifiedBorder = {
			sides: ["top"],
			width: { value: 1, unit: "px" },
			style: "solid",
			color: "red",
		};
		const result = unifiedBorderSchema.safeParse(border);
		expect(result.success).toBe(true);
	});

	it("accepts border without sides", () => {
		const border = {
			width: "thin",
			style: "dashed",
			color: "transparent",
		};
		const result = unifiedBorderSchema.safeParse(border);
		expect(result.success).toBe(true);
	});
});

describe("borderWidthValueSchema", () => {
	it("validates border-width property IR", () => {
		const value: BorderWidthValue = {
			kind: "border-width",
			width: { value: 2, unit: "px" },
		};
		const result = borderWidthValueSchema.safeParse(value);
		expect(result.success).toBe(true);
	});

	it("accepts keyword width", () => {
		const value: BorderWidthValue = {
			kind: "border-width",
			width: "medium",
		};
		const result = borderWidthValueSchema.safeParse(value);
		expect(result.success).toBe(true);
	});

	it("rejects wrong kind", () => {
		const value = {
			kind: "wrong-kind",
			width: { value: 1, unit: "px" },
		};
		const result = borderWidthValueSchema.safeParse(value);
		expect(result.success).toBe(false);
	});
});

describe("borderStyleValueSchema", () => {
	it("validates border-style property IR", () => {
		const value: BorderStyleValue = {
			kind: "border-style",
			style: "solid",
		};
		const result = borderStyleValueSchema.safeParse(value);
		expect(result.success).toBe(true);
	});

	it("accepts all valid styles", () => {
		const styles = ["none", "solid", "dashed", "dotted", "double"];
		for (const style of styles) {
			const value = { kind: "border-style" as const, style };
			expect(borderStyleValueSchema.safeParse(value).success).toBe(true);
		}
	});
});

describe("borderColorValueSchema", () => {
	it("validates border-color property IR", () => {
		const value: BorderColorValue = {
			kind: "border-color",
			color: "red",
		};
		const result = borderColorValueSchema.safeParse(value);
		expect(result.success).toBe(true);
	});
});

describe("borderRadiusValueSchema", () => {
	it("validates border-radius property IR", () => {
		const value = {
			kind: "border-radius",
			radius: { value: 4, unit: "px" },
		};
		const result = borderRadiusValueSchema.safeParse(value);
		expect(result.success).toBe(true);
	});

	it("accepts percentage values", () => {
		const value = {
			kind: "border-radius",
			radius: { value: 50, unit: "%" },
		};
		const result = borderRadiusValueSchema.safeParse(value);
		expect(result.success).toBe(true);
	});

	it("rejects wrong kind", () => {
		const value = {
			kind: "wrong-kind",
			radius: { value: 4, unit: "px" },
		};
		const result = borderRadiusValueSchema.safeParse(value);
		expect(result.success).toBe(false);
	});
});

describe("Type exports", () => {
	it("exports BorderWidth type", () => {
		const width: BorderWidth = { value: 1, unit: "px" };
		expect(width).toBeDefined();
	});

	it("exports BorderStyle type", () => {
		const style: BorderStyle = "solid";
		expect(style).toBeDefined();
	});

	it("exports BorderColor type", () => {
		const color: BorderColor = "red";
		expect(color).toBeDefined();
	});

	it("exports BorderSides type", () => {
		const sides: BorderSides = ["top", "bottom"];
		expect(sides).toBeDefined();
	});
});


=== File: src/core/types/border.ts ===
// b_path:: src/core/types/border.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthPercentageSchema, lengthSchema } from "./length-percentage";

/**
 * CSS <border-width> data type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width}
 * @public
 */
export const borderWidthSchema = z.union([lengthSchema, Keyword.borderWidthKeywordsSchema], {
	error: (issue) =>
		issue.code === "invalid_union"
			? 'Invalid border width. Expected a length or keyword ("thin", "medium", "thick").'
			: "Invalid input",
});

/**
 * CSS <border-style> data type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style}
 * @public
 */
export const borderStyleSchema = Keyword.borderStyleKeywordsSchema;

/**
 * CSS <color> data type for borders.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color}
 * @public
 */
export const borderColorSchema = Keyword.colorValueKeywordsSchema;

/**
 * Side specification for multi-side operations.
 * Optional - when omitted, applies to all sides.
 *
 * @public
 */
export const borderSidesSchema = z.array(z.enum(["top", "right", "bottom", "left"])).optional();

/**
 * Unified border specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying complete borders to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { width: { value: 1, unit: "px" }, style: "solid", color: "red" }
 *
 * // Specific sides
 * { sides: ["top"], width: { value: 2, unit: "px" }, style: "dashed", color: "blue" }
 * ```
 *
 * @public
 */
export const unifiedBorderSchema = z.object({
	sides: borderSidesSchema,
	width: borderWidthSchema,
	style: borderStyleSchema,
	color: borderColorSchema,
});

export type BorderWidth = z.infer<typeof borderWidthSchema>;
export type BorderStyle = z.infer<typeof borderStyleSchema>;
export type BorderColor = z.infer<typeof borderColorSchema>;
export type BorderSides = z.infer<typeof borderSidesSchema>;
export type UnifiedBorder = z.infer<typeof unifiedBorderSchema>;

/**
 * CSS border-width property IR.
 *
 * Specifies the width of the border.
 * Single length value or keyword (thin, medium, thick).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-width}
 *
 * @public
 */
export const borderWidthValueSchema = z.object({
	kind: z.literal("border-width"),
	width: borderWidthSchema,
});

/**
 * CSS border-width property type.
 *
 * @public
 */
export type BorderWidthValue = z.infer<typeof borderWidthValueSchema>;

/**
 * CSS border-style property IR.
 *
 * Specifies the style of the border line.
 * Single style keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-style}
 *
 * @public
 */
export const borderStyleValueSchema = z.object({
	kind: z.literal("border-style"),
	style: borderStyleSchema,
});

/**
 * CSS border-style property type.
 *
 * @public
 */
export type BorderStyleValue = z.infer<typeof borderStyleValueSchema>;

/**
 * CSS border-color property IR.
 *
 * Specifies the color of the border.
 * Single color value or keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-color}
 *
 * @public
 */
export const borderColorValueSchema = z.object({
	kind: z.literal("border-color"),
	color: borderColorSchema,
});

/**
 * CSS border-color property type.
 *
 * @public
 */
export type BorderColorValue = z.infer<typeof borderColorValueSchema>;

/**
 * CSS border-radius property IR.
 *
 * Specifies the radius of the border corners.
 * Single length-percentage value.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-radius}
 *
 * @public
 */
export const borderRadiusValueSchema = z.object({
	kind: z.literal("border-radius"),
	radius: lengthPercentageSchema,
});

/**
 * CSS border-radius property type.
 *
 * @public
 */
export type BorderRadiusValue = z.infer<typeof borderRadiusValueSchema>;


=== File: src/core/types/box-model.test.ts ===
// b_path:: src/core/types/box-model.test.ts
import { describe, expect, it } from "vitest";
import type { BoxSides, UnifiedMargin, UnifiedPadding } from "./box-model";
import { boxSidesSchema, unifiedMarginSchema, unifiedPaddingSchema } from "./box-model";

describe("boxSidesSchema", () => {
	it("accepts valid side arrays", () => {
		const validSides: BoxSides[] = [
			["top"],
			["right"],
			["bottom"],
			["left"],
			["top", "bottom"],
			["left", "right"],
			["top", "right", "bottom", "left"],
		];

		for (const sides of validSides) {
			expect(boxSidesSchema.safeParse(sides).success).toBe(true);
		}
	});

	it("accepts undefined (optional)", () => {
		expect(boxSidesSchema.safeParse(undefined).success).toBe(true);
	});

	it("rejects invalid side names", () => {
		expect(boxSidesSchema.safeParse(["invalid"]).success).toBe(false);
		expect(boxSidesSchema.safeParse(["center"]).success).toBe(false);
	});

	it("rejects non-array values", () => {
		expect(boxSidesSchema.safeParse("top").success).toBe(false);
		expect(boxSidesSchema.safeParse(123).success).toBe(false);
	});
});

describe("unifiedMarginSchema", () => {
	it("accepts valid margin with all sides", () => {
		const margin: UnifiedMargin = {
			value: { value: 10, unit: "px" },
		};
		expect(unifiedMarginSchema.safeParse(margin).success).toBe(true);
	});

	it("accepts valid margin with specific sides", () => {
		const margin: UnifiedMargin = {
			sides: ["top", "bottom"],
			value: { value: 20, unit: "px" },
		};
		expect(unifiedMarginSchema.safeParse(margin).success).toBe(true);
	});

	it("accepts auto value for margin", () => {
		const margin: UnifiedMargin = {
			value: "auto",
		};
		expect(unifiedMarginSchema.safeParse(margin).success).toBe(true);
	});

	it("accepts percentage value for margin", () => {
		const margin: UnifiedMargin = {
			value: { value: 50, unit: "%" },
		};
		expect(unifiedMarginSchema.safeParse(margin).success).toBe(true);
	});

	it("accepts margin without sides (applies to all)", () => {
		const margin = {
			value: { value: 10, unit: "px" },
		};
		expect(unifiedMarginSchema.safeParse(margin).success).toBe(true);
	});
});

describe("unifiedPaddingSchema", () => {
	it("accepts valid padding with all sides", () => {
		const padding: UnifiedPadding = {
			value: { value: 10, unit: "px" },
		};
		expect(unifiedPaddingSchema.safeParse(padding).success).toBe(true);
	});

	it("accepts valid padding with specific sides", () => {
		const padding: UnifiedPadding = {
			sides: ["left", "right"],
			value: { value: 15, unit: "px" },
		};
		expect(unifiedPaddingSchema.safeParse(padding).success).toBe(true);
	});

	it("accepts percentage value for padding", () => {
		const padding: UnifiedPadding = {
			value: { value: 25, unit: "%" },
		};
		expect(unifiedPaddingSchema.safeParse(padding).success).toBe(true);
	});

	it("rejects auto value for padding (not valid for padding)", () => {
		const padding = {
			value: "auto",
		};
		expect(unifiedPaddingSchema.safeParse(padding).success).toBe(false);
	});

	it("accepts padding without sides (applies to all)", () => {
		const padding = {
			value: { value: 10, unit: "px" },
		};
		expect(unifiedPaddingSchema.safeParse(padding).success).toBe(true);
	});

	it("accepts multiple sides", () => {
		const padding: UnifiedPadding = {
			sides: ["top", "right", "bottom"],
			value: { value: 8, unit: "em" },
		};
		expect(unifiedPaddingSchema.safeParse(padding).success).toBe(true);
	});
});

describe("Box model type consistency", () => {
	it("margin and padding schemas are structurally similar", () => {
		const margin = { value: { value: 10, unit: "px" as const } };
		const padding = { value: { value: 10, unit: "px" as const } };

		expect(unifiedMarginSchema.safeParse(margin).success).toBe(true);
		expect(unifiedPaddingSchema.safeParse(padding).success).toBe(true);
	});
});


=== File: src/core/types/box-model.ts ===
// b_path:: src/core/types/box-model.ts
import { z } from "zod";
import { lengthPercentageAutoSchema, lengthPercentageSchema } from "./length-percentage";

/**
 * Side specification for multi-side operations.
 * Optional - when omitted, applies to all sides.
 *
 * @public
 */
export const boxSidesSchema = z.array(z.enum(["top", "right", "bottom", "left"])).optional();

/**
 * Unified margin specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying margins to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { value: 10, unit: "px" }
 *
 * // Specific sides
 * { sides: ["top", "bottom"], value: 20, unit: "px" }
 * ```
 *
 * @public
 */
export const unifiedMarginSchema = z.object({
	sides: boxSidesSchema,
	value: lengthPercentageAutoSchema,
});

/**
 * Unified padding specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying padding to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { value: 10, unit: "px" }
 *
 * // Specific sides
 * { sides: ["left", "right"], value: 15, unit: "px" }
 * ```
 *
 * @public
 */
export const unifiedPaddingSchema = z.object({
	sides: boxSidesSchema,
	value: lengthPercentageSchema,
});

export type BoxSides = z.infer<typeof boxSidesSchema>;
export type UnifiedMargin = z.infer<typeof unifiedMarginSchema>;
export type UnifiedPadding = z.infer<typeof unifiedPaddingSchema>;


=== File: src/core/types/clip-path.ts ===
// b_path:: src/core/types/clip-path.ts

import { z } from "zod";
import type { GeometryBoxKeyword } from "@/core/keywords/geometry-box";
import { lengthPercentageSchema } from "./length-percentage";
import { position2DSchema } from "./position";
import type { Url } from "./url";

/**
 * CSS clip-path value.
 *
 * Defines the visible region of an element by clipping.
 * Can be a URL reference to SVG clipPath, geometry-box keyword, basic shape, or 'none'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @public
 */
export type ClipPathValue =
	| Url
	| ClipPathNone
	| ClipPathGeometryBox
	| ClipPathInset
	| ClipPathCircle
	| ClipPathEllipse
	| ClipPathPolygon
	| ClipPathRect
	| ClipPathXywh
	| ClipPathPath;

/**
 * 'none' keyword for clip-path.
 *
 * No clipping is applied; the element is fully visible.
 *
 * @public
 */
export const clipPathNoneSchema = z.object({
	kind: z.literal("clip-path-none"),
});

export type ClipPathNone = z.infer<typeof clipPathNoneSchema>;

/**
 * Geometry box keyword for clip-path.
 *
 * Defines the reference box for clipping. Can be a visual box
 * (content-box, padding-box, border-box), shape box (adds margin-box),
 * or SVG-specific box (fill-box, stroke-box, view-box).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path#geometry-box}
 *
 * @public
 */
export const clipPathGeometryBoxSchema = z.object({
	kind: z.literal("clip-path-geometry-box"),
	value: z.custom<GeometryBoxKeyword>(),
});

export type ClipPathGeometryBox = z.infer<typeof clipPathGeometryBoxSchema>;

/**
 * Border-radius shorthand for inset() shapes.
 *
 * Simplified version without elliptical corners.
 * All corners use same radius for horizontal and vertical.
 *
 * @public
 */
export type InsetBorderRadius = {
	topLeft: z.infer<typeof lengthPercentageSchema>;
	topRight: z.infer<typeof lengthPercentageSchema>;
	bottomRight: z.infer<typeof lengthPercentageSchema>;
	bottomLeft: z.infer<typeof lengthPercentageSchema>;
};

/**
 * inset() basic shape function.
 *
 * Defines an inset rectangle by specifying offsets from each edge.
 * Optionally accepts rounded corners via border-radius syntax.
 *
 * Syntax: inset( <length-percentage>{1,4} [ round <border-radius> ]? )
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/inset}
 *
 * @public
 */
export const clipPathInsetSchema = z.object({
	kind: z.literal("clip-path-inset"),
	top: lengthPercentageSchema,
	right: lengthPercentageSchema,
	bottom: lengthPercentageSchema,
	left: lengthPercentageSchema,
	borderRadius: z
		.object({
			topLeft: lengthPercentageSchema,
			topRight: lengthPercentageSchema,
			bottomRight: lengthPercentageSchema,
			bottomLeft: lengthPercentageSchema,
		})
		.optional(),
});

export type ClipPathInset = z.infer<typeof clipPathInsetSchema>;

/**
 * circle() basic shape function.
 *
 * Defines a circular clipping region with an optional radius and center position.
 *
 * Syntax: circle( <length-percentage>? [ at <position> ]? )
 *
 * Defaults: radius = "closest-side", position = center
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/circle}
 *
 * @public
 */
export const clipPathCircleSchema = z.object({
	kind: z.literal("clip-path-circle"),
	radius: z
		.union([lengthPercentageSchema, z.enum(["closest-side", "farthest-side"])], {
			error: (issue) =>
				issue.code === "invalid_union"
					? 'Invalid circle radius. Expected a length-percentage or "closest-side"/"farthest-side".'
					: "Invalid input",
		})
		.optional(),
	position: position2DSchema.optional(),
});

export type ClipPathCircle = z.infer<typeof clipPathCircleSchema>;

/**
 * ellipse() basic shape function.
 *
 * Defines an elliptical clipping region with optional horizontal/vertical radii and center position.
 *
 * Syntax: ellipse( <radial-size>{2}? [ at <position> ]? )
 *
 * Defaults: radiusX = "closest-side", radiusY = "closest-side", position = center
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/ellipse}
 *
 * @public
 */
export const clipPathEllipseSchema = z.object({
	kind: z.literal("clip-path-ellipse"),
	radiusX: z
		.union([lengthPercentageSchema, z.enum(["closest-side", "farthest-side"])], {
			error: (issue) =>
				issue.code === "invalid_union"
					? 'Invalid ellipse radiusX. Expected a length-percentage or "closest-side"/"farthest-side".'
					: "Invalid input",
		})
		.optional(),
	radiusY: z
		.union([lengthPercentageSchema, z.enum(["closest-side", "farthest-side"])], {
			error: (issue) =>
				issue.code === "invalid_union"
					? 'Invalid ellipse radiusY. Expected a length-percentage or "closest-side"/"farthest-side".'
					: "Invalid input",
		})
		.optional(),
	position: position2DSchema.optional(),
});

export type ClipPathEllipse = z.infer<typeof clipPathEllipseSchema>;

/**
 * polygon() basic shape function.
 *
 * Defines a polygonal clipping region from a list of coordinate pairs.
 * Optionally accepts a fill-rule to determine interior points.
 *
 * Syntax: polygon( <fill-rule>? , <shape-arg># )
 *
 * Default: fillRule = "nonzero" (per CSS spec)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/polygon}
 *
 * @public
 */
export const clipPathPolygonSchema = z.object({
	kind: z.literal("clip-path-polygon"),
	fillRule: z.enum(["nonzero", "evenodd"]).optional(),
	points: z.array(
		z.object({
			x: lengthPercentageSchema,
			y: lengthPercentageSchema,
		}),
	),
});

export type ClipPathPolygon = z.infer<typeof clipPathPolygonSchema>;

/**
 * rect() basic shape function.
 *
 * Defines a rectangle using edge offsets (TRBL).
 * Each edge can be a length-percentage or 'auto'.
 * Optionally accepts rounded corners via border-radius syntax.
 *
 * Syntax: rect( [<length-percentage> | auto]{1,4} [ round <border-radius> ]? )
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/rect}
 *
 * @public
 */
export const clipPathRectSchema = z.object({
	kind: z.literal("clip-path-rect"),
	top: z.union([lengthPercentageSchema, z.literal("auto")], {
		error: (issue) =>
			issue.code === "invalid_union" ? 'Invalid rect top. Expected a length-percentage or "auto".' : "Invalid input",
	}),
	right: z.union([lengthPercentageSchema, z.literal("auto")], {
		error: (issue) =>
			issue.code === "invalid_union" ? 'Invalid rect right. Expected a length-percentage or "auto".' : "Invalid input",
	}),
	bottom: z.union([lengthPercentageSchema, z.literal("auto")], {
		error: (issue) =>
			issue.code === "invalid_union" ? 'Invalid rect bottom. Expected a length-percentage or "auto".' : "Invalid input",
	}),
	left: z.union([lengthPercentageSchema, z.literal("auto")], {
		error: (issue) =>
			issue.code === "invalid_union" ? 'Invalid rect left. Expected a length-percentage or "auto".' : "Invalid input",
	}),
	borderRadius: z
		.object({
			topLeft: lengthPercentageSchema,
			topRight: lengthPercentageSchema,
			bottomRight: lengthPercentageSchema,
			bottomLeft: lengthPercentageSchema,
		})
		.optional(),
});

export type ClipPathRect = z.infer<typeof clipPathRectSchema>;

/**
 * xywh() basic shape function.
 *
 * Defines a rectangle using position (x, y) and dimensions (width, height).
 * All values are length-percentages. Width and height must be non-negative.
 * Optionally accepts rounded corners via border-radius syntax.
 *
 * Syntax: xywh( <length-percentage>{4} [ round <border-radius> ]? )
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/xywh}
 *
 * @public
 */
export const clipPathXywhSchema = z.object({
	kind: z.literal("clip-path-xywh"),
	x: lengthPercentageSchema,
	y: lengthPercentageSchema,
	width: lengthPercentageSchema,
	height: lengthPercentageSchema,
	borderRadius: z
		.object({
			topLeft: lengthPercentageSchema,
			topRight: lengthPercentageSchema,
			bottomRight: lengthPercentageSchema,
			bottomLeft: lengthPercentageSchema,
		})
		.optional(),
});

export type ClipPathXywh = z.infer<typeof clipPathXywhSchema>;

/**
 * path() basic shape function.
 *
 * Defines a clipping region using SVG path data.
 * Optionally accepts a fill-rule to determine interior points.
 *
 * Syntax: path( [<fill-rule>,]? <string> )
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/path}
 *
 * @public
 */
export const clipPathPathSchema = z.object({
	kind: z.literal("clip-path-path"),
	fillRule: z.enum(["nonzero", "evenodd"]).optional(),
	pathData: z.string(),
});

export type ClipPathPath = z.infer<typeof clipPathPathSchema>;


=== File: src/core/types/color-stop.ts ===
// b_path:: src/core/types/color-stop.ts
import { z } from "zod";
import { angleSchema } from "./angle";
import { colorSchema } from "./color";
import { lengthPercentageSchema } from "./length-percentage";

/**
 * CSS color stop value.
 *
 * A color stop consists of a color value and an optional position.
 * Used in CSS gradients and other color-based properties.
 *
 * Per CSS spec:
 * - For linear/radial gradients: <color-stop> = <color> [ <length-percentage> ]?
 * - For conic gradients: <color-stop> = <color> [ <angle> | <percentage> ]?
 *
 * This type supports both length-percentage and angle units to accommodate all gradient types.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient}
 *
 * @example
 * ```typescript
 * import { colorStopSchema } from "@/core/types/color-stop";
 *
 * // Color only
 * const stop1: ColorStop = {
 *   color: { kind: "named", name: "red" }
 * };
 *
 * // Color with percentage position (all gradient types)
 * const stop2: ColorStop = {
 *   color: { kind: "named", name: "blue" },
 *   position: { value: 50, unit: "%" }
 * };
 *
 * // Color with length position (linear/radial gradients)
 * const stop3: ColorStop = {
 *   color: { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 },
 *   position: { value: 10, unit: "px" }
 * };
 *
 * // Color with angle position (conic gradients)
 * const stop4: ColorStop = {
 *   color: { kind: "named", name: "green" },
 *   position: { value: 45, unit: "deg" }
 * };
 * ```
 *
 * @public
 */
export const colorStopSchema = z.object({
	color: colorSchema.describe("color value for the stop"),
	position: z
		.union([lengthPercentageSchema, angleSchema])
		.optional()
		.describe(
			"optional position of the color stop (length-percentage for linear/radial, angle or percentage for conic)",
		),
});

/**
 * TypeScript type for color stop.
 * @public
 */
export type ColorStop = z.infer<typeof colorStopSchema>;

/**
 * CSS color stop list.
 *
 * An array of color stops used in gradients and other multi-stop color properties.
 * Must contain at least 2 color stops for valid gradients.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient}
 *
 * @example
 * ```typescript
 * import { colorStopListSchema } from "@/core/types/color-stop";
 *
 * const stops: ColorStopList = [
 *   { color: { kind: "named", name: "red" } },
 *   { color: { kind: "named", name: "yellow" }, position: { value: 50, unit: "%" } },
 *   { color: { kind: "named", name: "blue" } }
 * ];
 * ```
 *
 * @public
 */
export const colorStopListSchema = z
	.array(colorStopSchema)
	.min(2, "Color stop list must contain at least 2 stops")
	.describe("array of color stops for gradients and multi-stop color properties");

/**
 * TypeScript type for color stop list.
 * @public
 */
export type ColorStopList = z.infer<typeof colorStopListSchema>;


=== File: src/core/types/color.ts ===
// b_path:: src/core/types/color.ts
import { z } from "zod";

/**
 * CSS hex color value.
 *
 * Represents a color in hexadecimal notation: #RGB, #RRGGBB, #RGBA, or #RRGGBBAA.
 * Values are always normalized to uppercase #RRGGBB or #RRGGBBAA format.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color}
 *
 * @example
 * ```typescript
 * import type { HexColor } from "@/core/types/color";
 *
 * const color1: HexColor = { kind: "hex", value: "#FF5733" };
 * const color2: HexColor = { kind: "hex", value: "#FF573380" }; // with alpha
 * ```
 *
 * @public
 */
export const hexColorSchema = z.object({
	kind: z.literal("hex"),
	value: z.string().regex(/^#[0-9A-F]{6}([0-9A-F]{2})?$/), // #RRGGBB or #RRGGBBAA (uppercase)
});

/**
 * TypeScript type for hex color.
 * @public
 */
export type HexColor = z.infer<typeof hexColorSchema>;

/**
 * CSS named color value.
 *
 * Represents a color using a CSS color keyword name.
 * Includes basic colors (red, blue, etc.) and extended X11/SVG colors.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 *
 * @example
 * ```typescript
 * import type { NamedColor } from "@/core/types/color";
 *
 * const color1: NamedColor = { kind: "named", name: "red" };
 * const color2: NamedColor = { kind: "named", name: "cornflowerblue" };
 * ```
 *
 * @public
 */
export const namedColorSchema = z.object({
	kind: z.literal("named"),
	name: z.string(), // validated against keyword list at parse time
});

/**
 * TypeScript type for named color.
 * @public
 */
export type NamedColor = z.infer<typeof namedColorSchema>;

/**
 * CSS RGB color value.
 *
 * Represents a color in RGB (Red, Green, Blue) color space.
 * Supports optional alpha channel for transparency.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb}
 *
 * @example
 * ```typescript
 * import type { RGBColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: RGBColor = { kind: "rgb", r: 255, g: 87, b: 51 };
 *
 * // With alpha
 * const color2: RGBColor = { kind: "rgb", r: 255, g: 87, b: 51, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const rgbColorSchema = z.object({
	kind: z.literal("rgb"),
	r: z.number().min(0).max(255),
	g: z.number().min(0).max(255),
	b: z.number().min(0).max(255),
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for RGB color.
 * @public
 */
export type RGBColor = z.infer<typeof rgbColorSchema>;

/**
 * CSS HSL color value.
 *
 * Represents a color in HSL (Hue, Saturation, Lightness) color space.
 * Hue is normalized to 0-360 degrees. Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl}
 *
 * @example
 * ```typescript
 * import type { HSLColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: HSLColor = { kind: "hsl", h: 120, s: 100, l: 50 };
 *
 * // With alpha
 * const color2: HSLColor = { kind: "hsl", h: 120, s: 100, l: 50, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const hslColorSchema = z.object({
	kind: z.literal("hsl"),
	h: z.number(), // degrees 0-360 (wraps around)
	s: z.number().min(0).max(100), // saturation percentage
	l: z.number().min(0).max(100), // lightness percentage
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for HSL color.
 * @public
 */
export type HSLColor = z.infer<typeof hslColorSchema>;

/**
 * CSS HWB color value.
 *
 * Represents a color in HWB (Hue, Whiteness, Blackness) color space.
 * Hue is normalized to 0-360 degrees. Whiteness and blackness are percentages.
 * Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb}
 *
 * @example
 * ```typescript
 * import type { HWBColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: HWBColor = { kind: "hwb", h: 120, w: 20, b: 30 };
 *
 * // With alpha
 * const color2: HWBColor = { kind: "hwb", h: 120, w: 20, b: 30, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const hwbColorSchema = z.object({
	kind: z.literal("hwb"),
	h: z.number(), // degrees 0-360 (wraps around)
	w: z.number().min(0).max(100), // whiteness percentage
	b: z.number().min(0).max(100), // blackness percentage
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for HWB color.
 * @public
 */
export type HWBColor = z.infer<typeof hwbColorSchema>;

/**
 * CSS LAB color value.
 *
 * Represents a color in CIE LAB (Lightness, a, b) color space.
 * LAB is a perceptual color space where distances correspond to perceived color differences.
 * Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lab}
 *
 * @example
 * ```typescript
 * import type { LABColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: LABColor = { kind: "lab", l: 50, a: -20, b: 30 };
 *
 * // With alpha
 * const color2: LABColor = { kind: "lab", l: 50, a: -20, b: 30, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const labColorSchema = z.object({
	kind: z.literal("lab"),
	l: z.number().min(0).max(100), // lightness percentage
	a: z.number().min(-125).max(125), // green-red axis
	b: z.number().min(-125).max(125), // blue-yellow axis
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for LAB color.
 * @public
 */
export type LABColor = z.infer<typeof labColorSchema>;

/**
 * CSS LCH color value.
 *
 * Represents a color in CIE LCH (Lightness, Chroma, Hue) color space.
 * LCH is the cylindrical representation of LAB color space.
 * Hue is normalized to 0-360 degrees. Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lch}
 *
 * @example
 * ```typescript
 * import type { LCHColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: LCHColor = { kind: "lch", l: 50, c: 50, h: 180 };
 *
 * // With alpha
 * const color2: LCHColor = { kind: "lch", l: 50, c: 50, h: 180, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const lchColorSchema = z.object({
	kind: z.literal("lch"),
	l: z.number().min(0).max(100), // lightness percentage
	c: z.number().min(0).max(150), // chroma
	h: z.number(), // hue degrees 0-360 (wraps around)
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for LCH color.
 * @public
 */
export type LCHColor = z.infer<typeof lchColorSchema>;

/**
 * CSS OKLab color value.
 *
 * Represents a color in OKLab (Oklab Lightness, a, b) color space.
 * OKLab is a perceptual color space designed for better perceptual uniformity than CIE LAB.
 * Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklab}
 *
 * @example
 * ```typescript
 * import type { OKLabColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: OKLabColor = { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 };
 *
 * // With alpha
 * const color2: OKLabColor = { kind: "oklab", l: 0.5, a: -0.2, b: 0.3, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const oklabColorSchema = z.object({
	kind: z.literal("oklab"),
	l: z.number().min(0).max(1), // lightness 0-1 (or 0-100% at parse time)
	a: z.number().min(-0.4).max(0.4), // green-red axis
	b: z.number().min(-0.4).max(0.4), // blue-yellow axis
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for OKLab color.
 * @public
 */
export type OKLabColor = z.infer<typeof oklabColorSchema>;

/**
 * CSS OKLCH color value.
 *
 * Represents a color in OKLCH (Oklab Lightness, Chroma, Hue) color space.
 * OKLCH is the cylindrical representation of OKLab color space.
 * Hue is normalized to 0-360 degrees. Supports optional alpha channel.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklch}
 *
 * @example
 * ```typescript
 * import type { OKLCHColor } from "@/core/types/color";
 *
 * // Opaque color
 * const color1: OKLCHColor = { kind: "oklch", l: 0.5, c: 0.2, h: 180 };
 *
 * // With alpha
 * const color2: OKLCHColor = { kind: "oklch", l: 0.5, c: 0.2, h: 180, alpha: 0.5 };
 * ```
 *
 * @public
 */
export const oklchColorSchema = z.object({
	kind: z.literal("oklch"),
	l: z.number().min(0).max(1), // lightness 0-1 (or 0-100% at parse time)
	c: z.number().min(0).max(0.4), // chroma
	h: z.number(), // hue degrees 0-360 (wraps around)
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for OKLCH color.
 * @public
 */
export type OKLCHColor = z.infer<typeof oklchColorSchema>;

/**
 * CSS system color value.
 *
 * Represents a system color using a CSS system color keyword.
 * System colors integrate with the user's operating system or browser theme.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#css-system-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/system-color}
 *
 * @example
 * ```typescript
 * import type { SystemColor } from "@/core/types/color";
 *
 * const color1: SystemColor = { kind: "system", keyword: "ButtonText" };
 * const color2: SystemColor = { kind: "system", keyword: "Canvas" };
 * ```
 *
 * @public
 */
export const systemColorSchema = z.object({
	kind: z.literal("system"),
	keyword: z.string(), // validated against system color keyword list at parse time
});

/**
 * TypeScript type for system color.
 * @public
 */
export type SystemColor = z.infer<typeof systemColorSchema>;

/**
 * CSS special color value.
 *
 * Represents special CSS color keywords with unique behavior.
 * - `transparent`: Fully transparent color (rgba(0, 0, 0, 0))
 * - `currentcolor`: Uses the current value of the color property
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 *
 * @example
 * ```typescript
 * import type { SpecialColor } from "@/core/types/color";
 *
 * const color1: SpecialColor = { kind: "special", keyword: "transparent" };
 * const color2: SpecialColor = { kind: "special", keyword: "currentcolor" };
 * ```
 *
 * @public
 */
export const specialColorSchema = z.object({
	kind: z.literal("special"),
	keyword: z.enum(["transparent", "currentcolor"]),
});

/**
 * TypeScript type for special color.
 * @public
 */
export type SpecialColor = z.infer<typeof specialColorSchema>;

/**
 * CSS color() function with explicit color space.
 *
 * Represents a color in a specific color space with explicit channel values.
 * Supports wide-gamut color spaces like display-p3 and professional spaces.
 *
 * Syntax: color(colorspace c1 c2 c3 [ / alpha ]?)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color}
 *
 * @example
 * ```typescript
 * import type { ColorFunction } from "@/core/types/color";
 *
 * // Display P3 color
 * const color1: ColorFunction = {
 *   kind: "color",
 *   colorSpace: "display-p3",
 *   channels: [0.928, 0.322, 0.203],
 *   alpha: 0.8
 * };
 *
 * // sRGB linear
 * const color2: ColorFunction = {
 *   kind: "color",
 *   colorSpace: "srgb-linear",
 *   channels: [0.5, 0.2, 0.8]
 * };
 * ```
 *
 * @public
 */
export const colorFunctionSchema = z.object({
	kind: z.literal("color"),
	colorSpace: z.enum([
		"srgb",
		"srgb-linear",
		"display-p3",
		"a98-rgb",
		"prophoto-rgb",
		"rec2020",
		"xyz",
		"xyz-d50",
		"xyz-d65",
	]),
	channels: z.tuple([z.number(), z.number(), z.number()]),
	alpha: z.number().min(0).max(1).optional(),
});

/**
 * TypeScript type for color() function.
 * @public
 */
export type ColorFunction = z.infer<typeof colorFunctionSchema>;

/**
 * CSS color value.
 *
 * Discriminated union of all supported CSS color formats.
 * Supports hex, named, RGB, HSL, HWB, LAB, LCH, OKLab, OKLCH, system, special, and color() function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 *
 * @example
 * ```typescript
 * import type { Color } from "@/core/types/color";
 *
 * const hex: Color = { kind: "hex", value: "#FF5733" };
 * const named: Color = { kind: "named", name: "red" };
 * const rgb: Color = { kind: "rgb", r: 255, g: 87, b: 51 };
 * const hsl: Color = { kind: "hsl", h: 120, s: 100, l: 50 };
 * const hwb: Color = { kind: "hwb", h: 120, w: 20, b: 30 };
 * const lab: Color = { kind: "lab", l: 50, a: -20, b: 30 };
 * const lch: Color = { kind: "lch", l: 50, c: 50, h: 180 };
 * const oklab: Color = { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 };
 * const oklch: Color = { kind: "oklch", l: 0.5, c: 0.2, h: 180 };
 * const system: Color = { kind: "system", keyword: "ButtonText" };
 * const special: Color = { kind: "special", keyword: "transparent" };
 * const colorFn: Color = { kind: "color", colorSpace: "display-p3", channels: [0.928, 0.322, 0.203] };
 * ```
 *
 * @public
 */
export const colorSchema = z.union(
	[
		hexColorSchema,
		namedColorSchema,
		rgbColorSchema,
		hslColorSchema,
		hwbColorSchema,
		labColorSchema,
		lchColorSchema,
		oklabColorSchema,
		oklchColorSchema,
		systemColorSchema,
		specialColorSchema,
		colorFunctionSchema,
	],
	{
		error: (issue) =>
			issue.code === "invalid_union"
				? "Invalid color. Expected hex, named color, rgb(), hsl(), hwb(), lab(), lch(), oklab(), oklch(), system color, or color() function."
				: "Invalid input",
	},
);

/**
 * TypeScript type for color value.
 *
 *
 * @public
 */
export type Color = z.infer<typeof colorSchema>;

/**
 * Type guard helper for narrowing Color discriminated union.
 *
 * @example
 * ```typescript
 * const parsed = Parse.Color.parse("color(display-p3 1 0.5 0)");
 * if (parsed.ok && isColorKind(parsed.value, "color")) {
 *   // TypeScript knows parsed.value is ColorFunction
 *   console.log(parsed.value.colorSpace); // no need for manual kind check
 * }
 * ```
 *
 * @public
 */
export function isColorKind<K extends Color["kind"]>(color: Color, kind: K): color is Extract<Color, { kind: K }> {
	return color.kind === kind;
}

/**
 * Assertion function that narrows Color to ColorFunction.
 * Throws if the color is not a color() function.
 *
 * @example
 * ```typescript
 * const parsed = Parse.Color.parse("color(display-p3 1 0.5 0)");
 * if (parsed.ok) {
 *   assertColorFunction(parsed.value);
 *   // TypeScript now knows parsed.value is ColorFunction
 *   console.log(parsed.value.colorSpace); // works!
 * }
 * ```
 *
 * @public
 */
export function assertColorFunction(color: Color): asserts color is ColorFunction {
	if (color.kind !== "color") {
		throw new TypeError(`Expected color() function, got ${color.kind}`);
	}
}


=== File: src/core/types/css-value.ts ===
// b_path:: src/core/types/css-value.ts

/**
 * Union of all CSS value types that can be parsed/generated by b_value.
 *
 * This type represents the complete set of intermediate representations (IR)
 * for all supported CSS longhand properties. Used by `parseAll()` and `generateAll()`
 * for batch processing of CSS declarations.
 *
 * @module
 * @public
 */

import type * as Type from "./index";

/**
 * Union of all CSS value IR types supported by b_value.
 *
 * Includes all color, gradient, filter, transform, position, layout,
 * animation, transition, border, outline, and shadow value types.
 *
 * @example
 * ```typescript
 * import type { CSSValue } from "b_value";
 *
 * const color: CSSValue = { kind: "hex", value: "#FF0000" };
 * const length: CSSValue = { kind: "length", value: 10, unit: "px" };
 * ```
 *
 * @public
 */
export type CSSValue =
	// Color values
	| Type.HexColor
	| Type.RGBColor
	| Type.HSLColor
	| Type.HWBColor
	| Type.LABColor
	| Type.LCHColor
	| Type.OKLabColor
	| Type.OKLCHColor
	| Type.NamedColor
	| Type.ColorFunction
	// Clip-path values
	| Type.ClipPathCircle
	| Type.ClipPathEllipse
	| Type.ClipPathPolygon
	| Type.ClipPathInset
	| Type.ClipPathRect
	| Type.ClipPathXywh
	| Type.ClipPathPath
	| Type.ClipPathNone
	// Gradient values
	| Type.LinearGradient
	| Type.RadialGradient
	| Type.ConicGradient
	// Filter values
	| Type.FilterFunction
	// Shadow values
	| Type.BoxShadow
	| Type.TextShadow
	// Transform values
	| Type.Transform
	// Position values
	| Type.Position2D
	// Border values
	| Type.BorderWidth
	| Type.BorderStyle
	| Type.BorderColor
	| Type.BorderRadiusValue
	// Outline values
	| Type.OutlineWidthValue
	| Type.OutlineStyleValue
	| Type.OutlineColorValue
	| Type.OutlineOffsetValue
	// Animation values
	| Type.AnimationName
	| Type.AnimationDuration
	| Type.AnimationTimingFunction
	| Type.AnimationDelay
	| Type.AnimationIterationCount
	| Type.AnimationDirection
	| Type.AnimationFillMode
	| Type.AnimationPlayState
	// Transition values
	| Type.TransitionProperty
	| Type.TransitionDuration
	| Type.TransitionTimingFunction
	| Type.TransitionDelay
	// Layout values
	| Type.LengthPercentage
	| Type.Display
	| Type.PositionProperty
	| Type.OverflowX
	| Type.OverflowY
	| Type.ZIndex
	| Type.Width
	| Type.Height
	| Type.Top
	| Type.Right
	| Type.Bottom
	| Type.Left
	| Type.Opacity
	| Type.Visibility
	| Type.Cursor
	// Angle, Time primitives
	| Type.Angle
	| Type.Time;

/**
 * Type guard to check if a value is a CSSValue (parsed IR).
 *
 * @param value - Value to check
 * @returns True if value is a parsed CSS value (IR object with 'kind' field)
 *
 * @example
 * ```typescript
 * if (isCSSValue(value)) {
 *   console.log(value.kind); // Safe to access kind field
 * }
 * ```
 *
 * @public
 */
export function isCSSValue(value: unknown): value is CSSValue {
	return typeof value === "object" && value !== null && "kind" in value;
}

/**
 * Type guard to check if a value is an unparsed string.
 *
 * @param value - Value to check (CSSValue or string)
 * @returns True if value is a string (unparsed CSS)
 *
 * @example
 * ```typescript
 * if (isUnparsedString(value)) {
 *   console.log("Raw CSS:", value); // It's a string
 * }
 * ```
 *
 * @public
 */
export function isUnparsedString(value: CSSValue | string): value is string {
	return typeof value === "string";
}


=== File: src/core/types/filter.ts ===
// b_path:: src/core/types/filter.ts
import { z } from "zod";
import type { Angle } from "./angle";
import type { Color } from "./color";
import type { Length } from "./length-percentage";

/**
 * CSS blur() filter function.
 *
 * Applies a Gaussian blur to the element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur}
 *
 * @example
 * ```typescript
 * import type { BlurFilter } from "@/core/types/filter";
 *
 * const filter: BlurFilter = { kind: "blur", radius: { value: 5, unit: "px" } };
 * // CSS: blur(5px)
 * ```
 *
 * @public
 */
export const blurFilterSchema = z.object({
	kind: z.literal("blur"),
	radius: z.custom<Length>(),
});

/**
 * TypeScript type for blur filter.
 * @public
 */
export type BlurFilter = z.infer<typeof blurFilterSchema>;

/**
 * CSS brightness() filter function.
 *
 * Applies a linear multiplier to the element, making it appear brighter or darker.
 * Values: number (1 = 100%) or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness}
 *
 * @example
 * ```typescript
 * import type { BrightnessFilter } from "@/core/types/filter";
 *
 * const filter1: BrightnessFilter = { kind: "brightness", value: 1.5 }; // 150%
 * const filter2: BrightnessFilter = { kind: "brightness", value: 0.5 }; // 50%
 * // CSS: brightness(1.5) or brightness(0.5)
 * ```
 *
 * @public
 */
export const brightnessFilterSchema = z.object({
	kind: z.literal("brightness"),
	value: z.number().nonnegative(), // 0 to infinity, 1 = 100%
});

/**
 * TypeScript type for brightness filter.
 * @public
 */
export type BrightnessFilter = z.infer<typeof brightnessFilterSchema>;

/**
 * CSS contrast() filter function.
 *
 * Adjusts the contrast of the element.
 * Values: number (1 = 100%) or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast}
 *
 * @example
 * ```typescript
 * import type { ContrastFilter } from "@/core/types/filter";
 *
 * const filter: ContrastFilter = { kind: "contrast", value: 1.2 }; // 120%
 * // CSS: contrast(1.2)
 * ```
 *
 * @public
 */
export const contrastFilterSchema = z.object({
	kind: z.literal("contrast"),
	value: z.number().nonnegative(), // 0 to infinity, 1 = 100%
});

/**
 * TypeScript type for contrast filter.
 * @public
 */
export type ContrastFilter = z.infer<typeof contrastFilterSchema>;

/**
 * CSS grayscale() filter function.
 *
 * Converts the element to grayscale.
 * Values: number (0-1, where 1 = 100%) or percentage (0-100%).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale}
 *
 * @example
 * ```typescript
 * import type { GrayscaleFilter } from "@/core/types/filter";
 *
 * const filter: GrayscaleFilter = { kind: "grayscale", value: 0.5 }; // 50%
 * // CSS: grayscale(0.5)
 * ```
 *
 * @public
 */
export const grayscaleFilterSchema = z.object({
	kind: z.literal("grayscale"),
	value: z.number().min(0).max(1), // 0 to 1, where 1 = 100%
});

/**
 * TypeScript type for grayscale filter.
 * @public
 */
export type GrayscaleFilter = z.infer<typeof grayscaleFilterSchema>;

/**
 * CSS hue-rotate() filter function.
 *
 * Rotates the hue of the element.
 * Value: angle (deg, grad, rad, turn).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate}
 *
 * @example
 * ```typescript
 * import type { HueRotateFilter } from "@/core/types/filter";
 *
 * const filter: HueRotateFilter = { kind: "hue-rotate", angle: { value: 90, unit: "deg" } };
 * // CSS: hue-rotate(90deg)
 * ```
 *
 * @public
 */
export const hueRotateFilterSchema = z.object({
	kind: z.literal("hue-rotate"),
	angle: z.custom<Angle>(),
});

/**
 * TypeScript type for hue-rotate filter.
 * @public
 */
export type HueRotateFilter = z.infer<typeof hueRotateFilterSchema>;

/**
 * CSS invert() filter function.
 *
 * Inverts the colors of the element.
 * Values: number (0-1, where 1 = 100%) or percentage (0-100%).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert}
 *
 * @example
 * ```typescript
 * import type { InvertFilter } from "@/core/types/filter";
 *
 * const filter: InvertFilter = { kind: "invert", value: 1 }; // 100%
 * // CSS: invert(1)
 * ```
 *
 * @public
 */
export const invertFilterSchema = z.object({
	kind: z.literal("invert"),
	value: z.number().min(0).max(1), // 0 to 1, where 1 = 100%
});

/**
 * TypeScript type for invert filter.
 * @public
 */
export type InvertFilter = z.infer<typeof invertFilterSchema>;

/**
 * CSS opacity() filter function.
 *
 * Applies transparency to the element.
 * Values: number (0-1, where 1 = 100%) or percentage (0-100%).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/opacity}
 *
 * @example
 * ```typescript
 * import type { OpacityFilter } from "@/core/types/filter";
 *
 * const filter: OpacityFilter = { kind: "opacity", value: 0.5 }; // 50%
 * // CSS: opacity(0.5)
 * ```
 *
 * @public
 */
export const opacityFilterSchema = z.object({
	kind: z.literal("opacity"),
	value: z.number().min(0).max(1), // 0 to 1, where 1 = 100%
});

/**
 * TypeScript type for opacity filter.
 * @public
 */
export type OpacityFilter = z.infer<typeof opacityFilterSchema>;

/**
 * CSS saturate() filter function.
 *
 * Adjusts the saturation of the element.
 * Values: number (1 = 100%) or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate}
 *
 * @example
 * ```typescript
 * import type { SaturateFilter } from "@/core/types/filter";
 *
 * const filter: SaturateFilter = { kind: "saturate", value: 2 }; // 200%
 * // CSS: saturate(2)
 * ```
 *
 * @public
 */
export const saturateFilterSchema = z.object({
	kind: z.literal("saturate"),
	value: z.number().nonnegative(), // 0 to infinity, 1 = 100%
});

/**
 * TypeScript type for saturate filter.
 * @public
 */
export type SaturateFilter = z.infer<typeof saturateFilterSchema>;

/**
 * CSS sepia() filter function.
 *
 * Converts the element to sepia.
 * Values: number (0-1, where 1 = 100%) or percentage (0-100%).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia}
 *
 * @example
 * ```typescript
 * import type { SepiaFilter } from "@/core/types/filter";
 *
 * const filter: SepiaFilter = { kind: "sepia", value: 0.8 }; // 80%
 * // CSS: sepia(0.8)
 * ```
 *
 * @public
 */
export const sepiaFilterSchema = z.object({
	kind: z.literal("sepia"),
	value: z.number().min(0).max(1), // 0 to 1, where 1 = 100%
});

/**
 * TypeScript type for sepia filter.
 * @public
 */
export type SepiaFilter = z.infer<typeof sepiaFilterSchema>;

/**
 * CSS drop-shadow() filter function.
 *
 * Applies a drop shadow effect to the element.
 * Syntax: drop-shadow(offset-x offset-y blur-radius color)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow}
 *
 * @example
 * ```typescript
 * import type { DropShadowFilter } from "@/core/types/filter";
 *
 * const filter: DropShadowFilter = {
 *   kind: "drop-shadow",
 *   offsetX: { value: 2, unit: "px" },
 *   offsetY: { value: 2, unit: "px" },
 *   blurRadius: { value: 4, unit: "px" },
 *   color: { kind: "named", name: "black" }
 * };
 * // CSS: drop-shadow(2px 2px 4px black)
 * ```
 *
 * @public
 */
export const dropShadowFilterSchema = z.object({
	kind: z.literal("drop-shadow"),
	offsetX: z.custom<Length>(),
	offsetY: z.custom<Length>(),
	blurRadius: z.custom<Length>().optional(),
	color: z.custom<Color>().optional(),
});

/**
 * TypeScript type for drop-shadow filter.
 * @public
 */
export type DropShadowFilter = z.infer<typeof dropShadowFilterSchema>;

/**
 * CSS url() filter function.
 *
 * References an SVG filter element by URL.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/url}
 *
 * @example
 * ```typescript
 * import type { UrlFilter } from "@/core/types/filter";
 *
 * const filter: UrlFilter = { kind: "url", url: "#my-filter" };
 * // CSS: url(#my-filter)
 * ```
 *
 * @public
 */
export const urlFilterSchema = z.object({
	kind: z.literal("url"),
	url: z.string(),
});

/**
 * TypeScript type for url filter.
 * @public
 */
export type UrlFilter = z.infer<typeof urlFilterSchema>;

/**
 * Union of all CSS filter function types.
 *
 * Represents any valid CSS filter function with a discriminated union
 * on the `kind` field for type-safe narrowing.
 *
 * @example
 * ```typescript
 * import type { FilterFunction } from "@/core/types/filter";
 *
 * const filter: FilterFunction = { kind: "blur", radius: { value: 5, unit: "px" } };
 *
 * // Type narrowing with discriminated union
 * if (filter.kind === "blur") {
 *   console.log(filter.radius); // TypeScript knows this is BlurFilter
 * }
 * ```
 *
 * @public
 */
export type FilterFunction =
	| BlurFilter
	| BrightnessFilter
	| ContrastFilter
	| GrayscaleFilter
	| HueRotateFilter
	| InvertFilter
	| OpacityFilter
	| SaturateFilter
	| SepiaFilter
	| DropShadowFilter
	| UrlFilter;


=== File: src/core/types/flexbox.ts ===
// b_path:: src/core/types/flexbox.ts
import { z } from "zod";
import { lengthPercentageAutoSchema } from "./length-percentage";

/**
 * CSS flex-direction property IR.
 *
 * Establishes the main-axis, defining the direction flex items are placed in the flex container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction}
 *
 * @public
 */
export const flexDirectionSchema = z.object({
	kind: z.literal("flex-direction"),
	value: z.enum(["row", "row-reverse", "column", "column-reverse"], {
		error: () => ({ message: "Expected row | row-reverse | column | column-reverse" }),
	}),
});

export type FlexDirection = z.infer<typeof flexDirectionSchema>;

/**
 * CSS flex-wrap property IR.
 *
 * Sets whether flex items are forced onto one line or can wrap onto multiple lines.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap}
 *
 * @public
 */
export const flexWrapSchema = z.object({
	kind: z.literal("flex-wrap"),
	value: z.enum(["nowrap", "wrap", "wrap-reverse"], {
		error: () => ({ message: "Expected nowrap | wrap | wrap-reverse" }),
	}),
});

export type FlexWrap = z.infer<typeof flexWrapSchema>;

/**
 * CSS justify-content property IR.
 *
 * Defines how the browser distributes space between and around content items along the main-axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content}
 *
 * @public
 */
export const justifyContentSchema = z.object({
	kind: z.literal("justify-content"),
	value: z.enum(
		[
			"flex-start",
			"flex-end",
			"center",
			"space-between",
			"space-around",
			"space-evenly",
			"start",
			"end",
			"left",
			"right",
		],
		{
			error: () => ({
				message:
					"Expected flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right",
			}),
		},
	),
});

export type JustifyContent = z.infer<typeof justifyContentSchema>;

/**
 * CSS align-items property IR.
 *
 * Sets the align-self value on all direct children as a group.
 * Controls alignment of items on the cross-axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-items}
 *
 * @public
 */
export const alignItemsSchema = z.object({
	kind: z.literal("align-items"),
	value: z.enum(["flex-start", "flex-end", "center", "baseline", "stretch", "start", "end", "self-start", "self-end"], {
		error: () => ({
			message: "Expected flex-start | flex-end | center | baseline | stretch | start | end | self-start | self-end",
		}),
	}),
});

export type AlignItems = z.infer<typeof alignItemsSchema>;

/**
 * CSS align-content property IR.
 *
 * Sets the distribution of space between and around content items along the cross-axis.
 * Only has an effect on multi-line flex containers.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-content}
 *
 * @public
 */
export const alignContentSchema = z.object({
	kind: z.literal("align-content"),
	value: z.enum(
		["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "stretch", "start", "end"],
		{
			error: () => ({
				message:
					"Expected flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end",
			}),
		},
	),
});

export type AlignContent = z.infer<typeof alignContentSchema>;

/**
 * CSS align-self property IR.
 *
 * Overrides the align-items value for a flex item.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-self}
 *
 * @public
 */
export const alignSelfSchema = z.object({
	kind: z.literal("align-self"),
	value: z.enum(
		["auto", "flex-start", "flex-end", "center", "baseline", "stretch", "start", "end", "self-start", "self-end"],
		{
			error: () => ({
				message:
					"Expected auto | flex-start | flex-end | center | baseline | stretch | start | end | self-start | self-end",
			}),
		},
	),
});

export type AlignSelf = z.infer<typeof alignSelfSchema>;

/**
 * CSS flex-grow property IR.
 *
 * Sets the flex grow factor, which specifies how much of the remaining space
 * should be assigned to the flex item's main size.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-grow}
 *
 * @public
 */
export const flexGrowSchema = z.object({
	kind: z.literal("flex-grow"),
	value: z.number().min(0),
});

export type FlexGrow = z.infer<typeof flexGrowSchema>;

/**
 * CSS flex-shrink property IR.
 *
 * Sets the flex shrink factor, which determines how much the flex item will
 * shrink relative to the rest of the flex items when negative free space is distributed.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-shrink}
 *
 * @public
 */
export const flexShrinkSchema = z.object({
	kind: z.literal("flex-shrink"),
	value: z.number().min(0),
});

export type FlexShrink = z.infer<typeof flexShrinkSchema>;

/**
 * CSS flex-basis property IR.
 *
 * Sets the initial main size of a flex item before remaining space is distributed.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-basis}
 *
 * @public
 */
export const flexBasisSchema = z.object({
	kind: z.literal("flex-basis"),
	value: z.union(
		[
			lengthPercentageAutoSchema,
			z.literal("content"),
			z.literal("max-content"),
			z.literal("min-content"),
			z.literal("fit-content"),
		],
		{
			error: (issue) =>
				issue.code === "invalid_union"
					? { message: "Expected <length-percentage> | auto | content | max-content | min-content | fit-content" }
					: { message: "Invalid flex-basis value" },
		},
	),
});

export type FlexBasis = z.infer<typeof flexBasisSchema>;

/**
 * CSS order property IR.
 *
 * Sets the order to lay out an item in a flex or grid container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/order}
 *
 * @public
 */
export const orderSchema = z.object({
	kind: z.literal("order"),
	value: z.number().int(),
});

export type Order = z.infer<typeof orderSchema>;

/**
 * CSS gap property IR.
 *
 * Sets the gaps (gutters) between rows and columns.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gap}
 *
 * @public
 */
export const gapSchema = z.object({
	kind: z.literal("gap"),
	value: z.union([lengthPercentageAutoSchema, z.literal("normal")], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <length-percentage> | auto | normal" }
				: { message: "Invalid gap value" },
	}),
});

export type Gap = z.infer<typeof gapSchema>;


=== File: src/core/types/gradient/conic.ts ===
// b_path:: src/core/types/gradient/conic.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import { angleSchema } from "../angle";
import { colorStopListSchema } from "../color-stop";
import { position2DSchema } from "../position";

/**
 * CSS conic gradient value.
 *
 * A conic gradient transitions colors progressively around a center point.
 * The gradient sweeps in a circular arc, starting from a specified angle.
 * It can have optional starting angle, position, color interpolation method,
 * and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 4 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient}
 * @see {@link https://www.w3.org/TR/css-images-4/#conic-gradients}
 *
 * @example
 * ```typescript
 * import { conicGradientSchema } from "@/core/types/gradient/conic";
 *
 * // Simple conic gradient (defaults to starting from top, center position)
 * const grad1: ConicGradient = {
 *   kind: "conic",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With starting angle
 * const grad2: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 45, unit: "deg" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // At specific position
 * const grad3: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 0, unit: "deg" },
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With color interpolation
 * const grad4: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 90, unit: "deg" },
 *   position: { horizontal: "center", vertical: "center" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "yellow", position: { value: 120, unit: "deg" } },
 *     { color: "blue", position: { value: 240, unit: "deg" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating conic gradient
 * const grad5: ConicGradient = {
 *   kind: "conic",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 45, unit: "deg" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const conicGradientSchema = z.object({
	kind: z.literal("conic"),
	fromAngle: angleSchema.optional().describe("starting angle (default: 0deg from top)"),
	position: position2DSchema.optional().describe("gradient center position (default: center)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for conic gradient.
 *
 * @public
 */
export type ConicGradient = z.infer<typeof conicGradientSchema>;


=== File: src/core/types/gradient/direction.ts ===
// b_path:: src/core/types/gradient/direction.ts
import { z } from "zod";
import * as Type from "../../types";

/**
 * CSS gradient direction value.
 *
 * Specifies the direction of a linear gradient. Can be an angle,
 * a side keyword (to top, to right, etc.), or a corner keyword
 * (to top left, to bottom right, etc.).
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients}
 *
 * @example
 * ```typescript
 * import { gradientDirectionSchema } from "@/core/types/gradient/direction";
 *
 * // Angle direction
 * const dir1: GradientDirection = {
 *   kind: "angle",
 *   value: { value: 45, unit: "deg" }
 * };
 *
 * // Side direction
 * const dir2: GradientDirection = {
 *   kind: "to-side",
 *   value: "right"
 * };
 *
 * // Corner direction
 * const dir3: GradientDirection = {
 *   kind: "to-corner",
 *   value: "top right"
 * };
 * ```
 *
 * @public
 */
export const gradientDirectionSchema = z.union([
	z.object({
		kind: z.literal("angle"),
		value: Type.angleSchema,
	}),
	z.object({
		kind: z.literal("to-side"),
		value: z.union([z.literal("top"), z.literal("right"), z.literal("bottom"), z.literal("left")]),
	}),
	z.object({
		kind: z.literal("to-corner"),
		value: z.union([
			z.literal("top left"),
			z.literal("top right"),
			z.literal("bottom left"),
			z.literal("bottom right"),
		]),
	}),
]);

/**
 * TypeScript type for gradient direction.
 *
 * @public
 */
export type GradientDirection = z.infer<typeof gradientDirectionSchema>;


=== File: src/core/types/gradient/index.ts ===
// b_path:: src/core/types/gradient/index.ts

export * from "./conic";
export * from "./direction";
export * from "./linear";
export * from "./radial";
export * from "./radial-shape";
export * from "./radial-size";

import type { ConicGradient } from "./conic";
import type { LinearGradient } from "./linear";
import type { RadialGradient } from "./radial";

/**
 * Union type for all gradient types.
 *
 * @public
 */
export type Gradient = LinearGradient | RadialGradient | ConicGradient;


=== File: src/core/types/gradient/linear.ts ===
// b_path:: src/core/types/gradient/linear.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import * as Type from "../../types";
import { gradientDirectionSchema } from "./direction";

/**
 * CSS linear gradient value.
 *
 * A linear gradient transitions colors progressively along a straight line.
 * The gradient can have an optional direction (angle or side/corner keyword),
 * optional color interpolation method, and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients}
 *
 * @example
 * ```typescript
 * import { linearGradientSchema } from "@/core/types/gradient/linear";
 *
 * // Simple gradient (defaults to top to bottom)
 * const grad1: LinearGradient = {
 *   kind: "linear",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With angle direction
 * const grad2: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With color interpolation
 * const grad3: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "to-side", value: "right" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating gradient
 * const grad4: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const linearGradientSchema = z.object({
	kind: z.literal("linear"),
	direction: gradientDirectionSchema.optional().describe("gradient direction (default: to bottom)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: Type.colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for linear gradient.
 *
 * @public
 */
export type LinearGradient = z.infer<typeof linearGradientSchema>;


=== File: src/core/types/gradient/radial-shape.test.ts ===
// b_path:: src/core/types/gradient/radial-shape.test.ts

import { describe, expect, it } from "vitest";
import { type RadialGradientShape, radialGradientShapeSchema } from "./radial-shape";

describe("radialGradientShapeSchema", () => {
	it("validates circle", () => {
		const result = radialGradientShapeSchema.safeParse("circle");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("circle");
		}
	});

	it("validates ellipse", () => {
		const result = radialGradientShapeSchema.safeParse("ellipse");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("ellipse");
		}
	});

	it("rejects invalid value", () => {
		const result = radialGradientShapeSchema.safeParse("square");
		expect(result.success).toBe(false);
	});

	it("rejects non-string value", () => {
		const result = radialGradientShapeSchema.safeParse(123);
		expect(result.success).toBe(false);
	});
});

describe("RadialGradientShape type", () => {
	it("accepts circle", () => {
		const shape: RadialGradientShape = "circle";
		expect(shape).toBe("circle");
	});

	it("accepts ellipse", () => {
		const shape: RadialGradientShape = "ellipse";
		expect(shape).toBe("ellipse");
	});
});


=== File: src/core/types/gradient/radial-shape.ts ===
// b_path:: src/core/types/gradient/radial-shape.ts
import { z } from "zod";

/**
 * CSS radial gradient shape value.
 *
 * Specifies the shape of a radial gradient. Can be either a circle or an ellipse.
 * If omitted in CSS, the shape is inferred from the size specification.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients}
 *
 * @example
 * ```typescript
 * import { radialGradientShapeSchema } from "@/core/types/gradient/radial-shape";
 *
 * const shape1: RadialGradientShape = "circle";
 * const shape2: RadialGradientShape = "ellipse";
 * ```
 *
 * @public
 */
export const radialGradientShapeSchema = z.union([z.literal("circle"), z.literal("ellipse")]);

/**
 * TypeScript type for radial gradient shape.
 *
 * @public
 */
export type RadialGradientShape = z.infer<typeof radialGradientShapeSchema>;


=== File: src/core/types/gradient/radial-size.ts ===
// b_path:: src/core/types/gradient/radial-size.ts
import { z } from "zod";
import { lengthPercentageSchema } from "../length-percentage";

/**
 * CSS radial gradient size value.
 *
 * Specifies the size of a radial gradient. Can be a keyword describing
 * the ending shape's size relative to the gradient box, or explicit lengths.
 *
 * Per CSS Images Module Level 3 specification:
 * - closest-side: gradient ends at the side of the box closest to the gradient's center
 * - farthest-side: gradient ends at the side of the box farthest from the gradient's center
 * - closest-corner: gradient ends at the corner of the box closest to the gradient's center
 * - farthest-corner: gradient ends at the corner of the box farthest from the gradient's center (default)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-size-circle}
 *
 * @example
 * ```typescript
 * import { radialGradientSizeSchema } from "@/core/types/gradient/radial-size";
 *
 * // Keyword size
 * const size1: RadialGradientSize = {
 *   kind: "keyword",
 *   value: "closest-side"
 * };
 *
 * // Explicit circle size (single length)
 * const size2: RadialGradientSize = {
 *   kind: "circle-explicit",
 *   radius: { value: 100, unit: "px" }
 * };
 *
 * // Explicit ellipse size (two length-percentage values)
 * const size3: RadialGradientSize = {
 *   kind: "ellipse-explicit",
 *   radiusX: { value: 50, unit: "%" },
 *   radiusY: { value: 100, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const radialGradientSizeSchema = z.union([
	z.object({
		kind: z.literal("keyword"),
		value: z.union([
			z.literal("closest-side"),
			z.literal("farthest-side"),
			z.literal("closest-corner"),
			z.literal("farthest-corner"),
		]),
	}),
	z.object({
		kind: z.literal("circle-explicit"),
		radius: lengthPercentageSchema.describe("circle radius"),
	}),
	z.object({
		kind: z.literal("ellipse-explicit"),
		radiusX: lengthPercentageSchema.describe("horizontal radius"),
		radiusY: lengthPercentageSchema.describe("vertical radius"),
	}),
]);

/**
 * TypeScript type for radial gradient size.
 *
 * @public
 */
export type RadialGradientSize = z.infer<typeof radialGradientSizeSchema>;


=== File: src/core/types/gradient/radial.ts ===
// b_path:: src/core/types/gradient/radial.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import { colorStopListSchema } from "../color-stop";
import { position2DSchema } from "../position";
import { radialGradientShapeSchema } from "./radial-shape";
import { radialGradientSizeSchema } from "./radial-size";

/**
 * CSS radial gradient value.
 *
 * A radial gradient transitions colors progressively from a center point (origin)
 * outward in a circular or elliptical pattern. The gradient can have optional shape,
 * size, position, color interpolation method, and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients}
 *
 * @example
 * ```typescript
 * import { radialGradientSchema } from "@/core/types/gradient/radial";
 *
 * // Simple radial gradient (defaults to ellipse at center)
 * const grad1: RadialGradient = {
 *   kind: "radial",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // Circle with keyword size
 * const grad2: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "keyword", value: "closest-side" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // Ellipse at specific position
 * const grad3: RadialGradient = {
 *   kind: "radial",
 *   shape: "ellipse",
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With explicit size and color interpolation
 * const grad4: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "circle-explicit", radius: { value: 100, unit: "px" } },
 *   position: { horizontal: "center", vertical: "center" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating radial gradient
 * const grad5: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const radialGradientSchema = z.object({
	kind: z.literal("radial"),
	shape: radialGradientShapeSchema.optional().describe("gradient shape (default: ellipse)"),
	size: radialGradientSizeSchema.optional().describe("gradient size (default: farthest-corner)"),
	position: position2DSchema.optional().describe("gradient center position (default: center)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for radial gradient.
 *
 * @public
 */
export type RadialGradient = z.infer<typeof radialGradientSchema>;


=== File: src/core/types/grid-line.ts ===
// b_path:: src/core/types/grid-line.ts
import { z } from "zod";

/**
 * CSS Grid line value (simple version for Phase 1).
 *
 * Grid line values specify where grid items start and end.
 * This implementation supports:
 * - Integer values (positive, negative, or zero)
 * - The `auto` keyword (browser places item automatically)
 * - Span notation (e.g., `span 2` means span 2 grid tracks)
 *
 * Phase 2 will add support for named grid lines.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid}
 *
 * @example
 * ```typescript
 * import { gridLineSchema } from "@/core/types/grid-line";
 *
 * // Integer line number
 * const line1: GridLine = 1;
 * const line2: GridLine = -1; // Last line
 *
 * // Auto keyword
 * const line3: GridLine = "auto";
 *
 * // Span notation
 * const line4: GridLine = { type: "span", value: 2 };
 * ```
 *
 * @public
 */
export const gridLineSchema = z.union(
	[
		z.number().int().describe("integer grid line number (positive, negative, or zero)"),
		z.literal("auto").describe("browser automatically places the item"),
		z
			.object({
				type: z.literal("span"),
				value: z.number().int().positive().describe("number of tracks to span"),
			})
			.describe("span notation (e.g., span 2 means span across 2 tracks)"),
	],
	{
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: 'Expected <integer> | auto | { type: "span", value: <positive-integer> }' }
				: { message: "Invalid grid line value" },
	},
);

/**
 * TypeScript type for grid line values.
 *
 * @public
 */
export type GridLine = z.infer<typeof gridLineSchema>;

/**
 * Metadata for grid line values.
 *
 * Provides documentation for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { gridLineMetadata } from "@/core/types/grid-line";
 *
 * console.log(gridLineMetadata.description);
 * ```
 *
 * @public
 */
export const gridLineMetadata = {
	description: "Specifies grid line position (integer, auto, or span)",
	syntax: ["<integer>", "auto", "span <integer>"],
	examples: ["1", "-1", "auto", "span 2"],
} as const;

/**
 * Type for grid line metadata.
 *
 * @public
 */
export type GridLineMetadata = typeof gridLineMetadata;


=== File: src/core/types/index.ts ===
// b_path:: src/core/types/index.ts

export * from "./angle";
export * from "./animation";
export * from "./border";
export * from "./clip-path";
export * from "./color";
export * from "./color-stop";
export * from "./css-value";
export * from "./filter";
export * from "./flexbox";
export * from "./gradient";
export * from "./grid-line";
export * from "./interaction";
export * from "./layout";
export * from "./length-percentage";
export * from "./outline";
export * from "./position";
export * from "./position-layer";
export * from "./ratio";
export * from "./shadow";
export * from "./size-layer";
export * from "./time";
export * from "./transform";
export * from "./transition";
export * from "./typography";
export * from "./visual";


=== File: src/core/types/interaction.test.ts ===
// b_path:: src/core/types/interaction.test.ts

import { describe, expect, it } from "vitest";
import type { PointerEvents, UserSelect } from "./interaction";

describe("PointerEvents", () => {
	it("has correct type structure for auto", () => {
		const value: PointerEvents = { kind: "pointer-events", value: "auto" };
		expect(value.kind).toBe("pointer-events");
		expect(value.value).toBe("auto");
	});

	it("has correct type structure for none", () => {
		const value: PointerEvents = { kind: "pointer-events", value: "none" };
		expect(value.value).toBe("none");
	});

	it("has correct type structure for visiblePainted", () => {
		const value: PointerEvents = { kind: "pointer-events", value: "visiblePainted" };
		expect(value.value).toBe("visiblePainted");
	});

	it("has correct type structure for all", () => {
		const value: PointerEvents = { kind: "pointer-events", value: "all" };
		expect(value.value).toBe("all");
	});
});

describe("UserSelect", () => {
	it("has correct type structure for auto", () => {
		const value: UserSelect = { kind: "user-select", value: "auto" };
		expect(value.kind).toBe("user-select");
		expect(value.value).toBe("auto");
	});

	it("has correct type structure for none", () => {
		const value: UserSelect = { kind: "user-select", value: "none" };
		expect(value.value).toBe("none");
	});

	it("has correct type structure for text", () => {
		const value: UserSelect = { kind: "user-select", value: "text" };
		expect(value.value).toBe("text");
	});

	it("has correct type structure for all", () => {
		const value: UserSelect = { kind: "user-select", value: "all" };
		expect(value.value).toBe("all");
	});
});


=== File: src/core/types/interaction.ts ===
// b_path:: src/core/types/interaction.ts

/**
 * pointer-events property
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events}
 */
export interface PointerEvents {
	readonly kind: "pointer-events";
	readonly value:
		| "auto"
		| "none"
		| "visiblePainted"
		| "visibleFill"
		| "visibleStroke"
		| "visible"
		| "painted"
		| "fill"
		| "stroke"
		| "all"
		| "bounding-box";
}

/**
 * user-select property
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/user-select}
 */
export interface UserSelect {
	readonly kind: "user-select";
	readonly value: "auto" | "text" | "none" | "contain" | "all";
}


=== File: src/core/types/layout.ts ===
// b_path:: src/core/types/layout.ts
import { z } from "zod";
import { cursorKeywordsSchema } from "../keywords/cursor-keywords";
import { displayKeywordsSchema } from "../keywords/display-keywords";
import { overflowKeywordsSchema } from "../keywords/overflow-keywords";
import { positionPropertyKeywordsSchema } from "../keywords/position-property-keywords";
import { visibilityKeywordsSchema } from "../keywords/visibility-keywords";
import { lengthPercentageAutoSchema, lengthPercentageSchema } from "./length-percentage";

/**
 * CSS display property IR.
 *
 * The display property controls how an element is displayed in the layout,
 * including its box generation, inner layout type, and outer display type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display}
 *
 * @example
 * ```typescript
 * const display: Display = {
 *   kind: "display",
 *   value: "flex"
 * };
 * // CSS: display: flex;
 * ```
 *
 * @public
 */
export const displaySchema = z.object({
	kind: z.literal("display"),
	value: displayKeywordsSchema,
});

/**
 * TypeScript type for display property.
 *
 * @public
 */
export type Display = z.infer<typeof displaySchema>;

/**
 * CSS visibility property IR.
 *
 * The visibility property controls whether an element is visible or hidden.
 * Unlike display: none, visibility: hidden elements still take up space in the layout.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility}
 *
 * @example
 * ```typescript
 * const visibility: Visibility = {
 *   kind: "visibility",
 *   value: "hidden"
 * };
 * // CSS: visibility: hidden;
 * ```
 *
 * @public
 */
export const visibilitySchema = z.object({
	kind: z.literal("visibility"),
	value: visibilityKeywordsSchema,
});

/**
 * TypeScript type for visibility property.
 *
 * @public
 */
export type Visibility = z.infer<typeof visibilitySchema>;

/**
 * CSS opacity property IR.
 *
 * The opacity property sets the opacity level for an element.
 * Value range: 0 (fully transparent) to 1 (fully opaque).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/opacity}
 *
 * @example
 * ```typescript
 * const opacity: Opacity = {
 *   kind: "opacity",
 *   value: 0.5
 * };
 * // CSS: opacity: 0.5;
 * ```
 *
 * @public
 */
export const opacitySchema = z.object({
	kind: z.literal("opacity"),
	value: z.number().min(0).max(1),
});

/**
 * TypeScript type for opacity property.
 *
 * @public
 */
export type Opacity = z.infer<typeof opacitySchema>;

/**
 * CSS cursor property IR.
 *
 * The cursor property sets the mouse cursor to display when the mouse pointer is over an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}
 *
 * @example
 * ```typescript
 * const cursor: Cursor = {
 *   kind: "cursor",
 *   value: "pointer"
 * };
 * // CSS: cursor: pointer;
 * ```
 *
 * @public
 */
export const cursorSchema = z.object({
	kind: z.literal("cursor"),
	value: cursorKeywordsSchema,
});

/**
 * TypeScript type for cursor property.
 *
 * @public
 */
export type Cursor = z.infer<typeof cursorSchema>;

/**
 * CSS overflow-x property IR.
 *
 * The overflow-x property controls what happens when content overflows
 * an element's box horizontally (left and right edges).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x}
 *
 * @example
 * ```typescript
 * const overflowX: OverflowX = {
 *   kind: "overflow-x",
 *   value: "hidden"
 * };
 * // CSS: overflow-x: hidden;
 * ```
 *
 * @public
 */
export const overflowXSchema = z.object({
	kind: z.literal("overflow-x"),
	value: overflowKeywordsSchema,
});

/**
 * TypeScript type for overflow-x property.
 *
 * @public
 */
export type OverflowX = z.infer<typeof overflowXSchema>;

/**
 * CSS overflow-y property IR.
 *
 * The overflow-y property controls what happens when content overflows
 * an element's box vertically (top and bottom edges).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y}
 *
 * @example
 * ```typescript
 * const overflowY: OverflowY = {
 *   kind: "overflow-y",
 *   value: "scroll"
 * };
 * // CSS: overflow-y: scroll;
 * ```
 *
 * @public
 */
export const overflowYSchema = z.object({
	kind: z.literal("overflow-y"),
	value: overflowKeywordsSchema,
});

/**
 * TypeScript type for overflow-y property.
 *
 * @public
 */
export type OverflowY = z.infer<typeof overflowYSchema>;

/**
 * CSS position property IR.
 *
 * The position property sets how an element is positioned in a document.
 * The top, right, bottom, and left properties determine the final location
 * of positioned elements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position}
 *
 * @example
 * ```typescript
 * const position: PositionProperty = {
 *   kind: "position",
 *   value: "absolute"
 * };
 * // CSS: position: absolute;
 * ```
 *
 * @public
 */
export const positionPropertySchema = z.object({
	kind: z.literal("position"),
	value: positionPropertyKeywordsSchema,
});

/**
 * TypeScript type for position property.
 *
 * @public
 */
export type PositionProperty = z.infer<typeof positionPropertySchema>;

/**
 * CSS z-index property IR.
 *
 * The z-index property sets the z-order (stack level) of a positioned element.
 * Only works on positioned elements (position other than static).
 * Accepts integer values (positive, negative, or zero) or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/z-index}
 *
 * @example
 * ```typescript
 * const zIndex: ZIndex = {
 *   kind: "z-index",
 *   value: 10
 * };
 * // CSS: z-index: 10;
 * ```
 *
 * @example
 * ```typescript
 * const zIndex: ZIndex = {
 *   kind: "z-index",
 *   value: "auto"
 * };
 * // CSS: z-index: auto;
 * ```
 *
 * @public
 */
export const zIndexSchema = z.object({
	kind: z.literal("z-index"),
	value: z.union([z.number().int(), z.literal("auto")], {
		error: (issue) =>
			issue.code === "invalid_union" ? { message: "Expected <integer> | auto" } : { message: "Invalid z-index value" },
	}),
});

/**
 * TypeScript type for z-index property.
 *
 * @public
 */
export type ZIndex = z.infer<typeof zIndexSchema>;

/**
 * CSS top property IR.
 *
 * The top property affects the vertical position of a positioned element.
 * Accepts length-percentage values or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/top}
 *
 * @example
 * ```typescript
 * const top: Top = {
 *   kind: "top",
 *   value: { value: 10, unit: "px" }
 * };
 * // CSS: top: 10px;
 * ```
 *
 * @example
 * ```typescript
 * const top: Top = {
 *   kind: "top",
 *   value: "auto"
 * };
 * // CSS: top: auto;
 * ```
 *
 * @public
 */
export const topSchema = z.object({
	kind: z.literal("top"),
	value: lengthPercentageAutoSchema,
});

/**
 * TypeScript type for top property.
 *
 * @public
 */
export type Top = z.infer<typeof topSchema>;

/**
 * CSS right property IR.
 *
 * The right property affects the horizontal position of a positioned element.
 * Accepts length-percentage values or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/right}
 *
 * @example
 * ```typescript
 * const right: Right = {
 *   kind: "right",
 *   value: { value: 10, unit: "px" }
 * };
 * // CSS: right: 10px;
 * ```
 *
 * @example
 * ```typescript
 * const right: Right = {
 *   kind: "right",
 *   value: "auto"
 * };
 * // CSS: right: auto;
 * ```
 *
 * @public
 */
export const rightSchema = z.object({
	kind: z.literal("right"),
	value: lengthPercentageAutoSchema,
});

/**
 * TypeScript type for right property.
 *
 * @public
 */
export type Right = z.infer<typeof rightSchema>;

/**
 * CSS bottom property IR.
 *
 * The bottom property affects the vertical position of a positioned element.
 * Accepts length-percentage values or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/bottom}
 *
 * @example
 * ```typescript
 * const bottom: Bottom = {
 *   kind: "bottom",
 *   value: { value: 10, unit: "px" }
 * };
 * // CSS: bottom: 10px;
 * ```
 *
 * @example
 * ```typescript
 * const bottom: Bottom = {
 *   kind: "bottom",
 *   value: "auto"
 * };
 * // CSS: bottom: auto;
 * ```
 *
 * @public
 */
export const bottomSchema = z.object({
	kind: z.literal("bottom"),
	value: lengthPercentageAutoSchema,
});

/**
 * TypeScript type for bottom property.
 *
 * @public
 */
export type Bottom = z.infer<typeof bottomSchema>;

/**
 * CSS left property IR.
 *
 * The left property affects the horizontal position of a positioned element.
 * Accepts length-percentage values or the keyword "auto".
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/left}
 *
 * @example
 * ```typescript
 * const left: Left = {
 *   kind: "left",
 *   value: { value: 10, unit: "px" }
 * };
 * // CSS: left: 10px;
 * ```
 *
 * @example
 * ```typescript
 * const left: Left = {
 *   kind: "left",
 *   value: "auto"
 * };
 * // CSS: left: auto;
 * ```
 *
 * @public
 */
export const leftSchema = z.object({
	kind: z.literal("left"),
	value: lengthPercentageAutoSchema,
});

/**
 * TypeScript type for left property.
 *
 * @public
 */
export type Left = z.infer<typeof leftSchema>;

/**
 * CSS width property IR.
 *
 * The width property sets the width of an element.
 * Accepts length-percentage, auto, or intrinsic sizing keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width}
 *
 * @example
 * ```typescript
 * const width: Width = {
 *   kind: "width",
 *   value: { value: 200, unit: "px" }
 * };
 * // CSS: width: 200px;
 * ```
 *
 * @example
 * ```typescript
 * const width: Width = {
 *   kind: "width",
 *   value: "auto"
 * };
 * // CSS: width: auto;
 * ```
 *
 * @example
 * ```typescript
 * const width: Width = {
 *   kind: "width",
 *   value: "min-content"
 * };
 * // CSS: width: min-content;
 * ```
 *
 * @public
 */
export const widthSchema = z.object({
	kind: z.literal("width"),
	value: z.union([lengthPercentageAutoSchema, z.enum(["min-content", "max-content", "fit-content"])], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <length-percentage> | auto | min-content | max-content | fit-content" }
				: { message: "Invalid width value" },
	}),
});

/**
 * TypeScript type for width property.
 *
 * @public
 */
export type Width = z.infer<typeof widthSchema>;

/**
 * CSS height property IR.
 *
 * The height property sets the height of an element.
 * Accepts length-percentage, auto, or intrinsic sizing keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/height}
 *
 * @example
 * ```typescript
 * const height: Height = {
 *   kind: "height",
 *   value: { value: 100, unit: "px" }
 * };
 * // CSS: height: 100px;
 * ```
 *
 * @example
 * ```typescript
 * const height: Height = {
 *   kind: "height",
 *   value: "auto"
 * };
 * // CSS: height: auto;
 * ```
 *
 * @example
 * ```typescript
 * const height: Height = {
 *   kind: "height",
 *   value: "max-content"
 * };
 * // CSS: height: max-content;
 * ```
 *
 * @public
 */
export const heightSchema = z.object({
	kind: z.literal("height"),
	value: z.union([lengthPercentageAutoSchema, z.enum(["min-content", "max-content", "fit-content"])], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <length-percentage> | auto | min-content | max-content | fit-content" }
				: { message: "Invalid height value" },
	}),
});

/**
 * TypeScript type for height property.
 *
 * @public
 */
export type Height = z.infer<typeof heightSchema>;

/**
 * CSS min-width property IR.
 *
 * The min-width property sets the minimum width of an element.
 * Accepts length-percentage, auto, or intrinsic sizing keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/min-width}
 *
 * @public
 */
export const minWidthSchema = z.object({
	kind: z.literal("min-width"),
	value: z.union([lengthPercentageAutoSchema, z.enum(["min-content", "max-content", "fit-content"])], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <length-percentage> | auto | min-content | max-content | fit-content" }
				: { message: "Invalid min-width value" },
	}),
});

export type MinWidth = z.infer<typeof minWidthSchema>;

/**
 * CSS max-width property IR.
 *
 * The max-width property sets the maximum width of an element.
 * Accepts length-percentage, none keyword, or intrinsic sizing keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/max-width}
 *
 * @public
 */
export const maxWidthSchema = z.object({
	kind: z.literal("max-width"),
	value: z.union([lengthPercentageSchema, z.literal("none"), z.enum(["min-content", "max-content", "fit-content"])], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <length-percentage> | none | min-content | max-content | fit-content" }
				: { message: "Invalid max-width value" },
	}),
});

export type MaxWidth = z.infer<typeof maxWidthSchema>;

/**
 * CSS min-height property IR.
 *
 * The min-height property sets the minimum height of an element.
 * Accepts length-percentage, auto, or intrinsic sizing keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/min-height}
 *
 * @public
 */
export const minHeightSchema = z.object({
	kind: z.literal("min-height"),
	value: z.union([lengthPercentageAutoSchema, z.enum(["min-content", "max-content", "fit-content"])], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <length-percentage> | auto | min-content | max-content | fit-content" }
				: { message: "Invalid min-height value" },
	}),
});

export type MinHeight = z.infer<typeof minHeightSchema>;

/**
 * CSS max-height property IR.
 *
 * The max-height property sets the maximum height of an element.
 * Accepts length-percentage, none keyword, or intrinsic sizing keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/max-height}
 *
 * @public
 */
export const maxHeightSchema = z.object({
	kind: z.literal("max-height"),
	value: z.union([lengthPercentageSchema, z.literal("none"), z.enum(["min-content", "max-content", "fit-content"])], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <length-percentage> | none | min-content | max-content | fit-content" }
				: { message: "Invalid max-height value" },
	}),
});

export type MaxHeight = z.infer<typeof maxHeightSchema>;

/**
 * CSS margin-top property IR.
 *
 * The margin-top property sets the top margin of an element.
 * Accepts length-percentage or auto keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-top}
 *
 * @public
 */
export const marginTopSchema = z.object({
	kind: z.literal("margin-top"),
	value: lengthPercentageAutoSchema,
});

export type MarginTop = z.infer<typeof marginTopSchema>;

/**
 * CSS margin-right property IR.
 *
 * The margin-right property sets the right margin of an element.
 * Accepts length-percentage or auto keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-right}
 *
 * @public
 */
export const marginRightSchema = z.object({
	kind: z.literal("margin-right"),
	value: lengthPercentageAutoSchema,
});

export type MarginRight = z.infer<typeof marginRightSchema>;

/**
 * CSS margin-bottom property IR.
 *
 * The margin-bottom property sets the bottom margin of an element.
 * Accepts length-percentage or auto keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-bottom}
 *
 * @public
 */
export const marginBottomSchema = z.object({
	kind: z.literal("margin-bottom"),
	value: lengthPercentageAutoSchema,
});

export type MarginBottom = z.infer<typeof marginBottomSchema>;

/**
 * CSS margin-left property IR.
 *
 * The margin-left property sets the left margin of an element.
 * Accepts length-percentage or auto keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-left}
 *
 * @public
 */
export const marginLeftSchema = z.object({
	kind: z.literal("margin-left"),
	value: lengthPercentageAutoSchema,
});

export type MarginLeft = z.infer<typeof marginLeftSchema>;

/**
 * CSS padding-top property IR.
 *
 * The padding-top property sets the top padding of an element.
 * Accepts length-percentage values (non-negative).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-top}
 *
 * @public
 */
export const paddingTopSchema = z.object({
	kind: z.literal("padding-top"),
	value: lengthPercentageSchema,
});

export type PaddingTop = z.infer<typeof paddingTopSchema>;

/**
 * CSS padding-right property IR.
 *
 * The padding-right property sets the right padding of an element.
 * Accepts length-percentage values (non-negative).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-right}
 *
 * @public
 */
export const paddingRightSchema = z.object({
	kind: z.literal("padding-right"),
	value: lengthPercentageSchema,
});

export type PaddingRight = z.infer<typeof paddingRightSchema>;

/**
 * CSS padding-bottom property IR.
 *
 * The padding-bottom property sets the bottom padding of an element.
 * Accepts length-percentage values (non-negative).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-bottom}
 *
 * @public
 */
export const paddingBottomSchema = z.object({
	kind: z.literal("padding-bottom"),
	value: lengthPercentageSchema,
});

export type PaddingBottom = z.infer<typeof paddingBottomSchema>;

/**
 * CSS padding-left property IR.
 *
 * The padding-left property sets the left padding of an element.
 * Accepts length-percentage values (non-negative).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-left}
 *
 * @public
 */
export const paddingLeftSchema = z.object({
	kind: z.literal("padding-left"),
	value: lengthPercentageSchema,
});

export type PaddingLeft = z.infer<typeof paddingLeftSchema>;

/**
 * CSS box-sizing property IR.
 *
 * The box-sizing property defines how the width and height of an element are calculated,
 * whether they should include padding and borders or not.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing}
 *
 * @example
 * ```typescript
 * const boxSizing: BoxSizing = {
 *   kind: "box-sizing",
 *   value: "border-box"
 * };
 * // CSS: box-sizing: border-box;
 * ```
 *
 * @public
 */
export const boxSizingSchema = z.object({
	kind: z.literal("box-sizing"),
	value: z.enum(["content-box", "border-box"], {
		error: () => ({ message: "Expected content-box | border-box" }),
	}),
});

/**
 * TypeScript type for box-sizing property.
 *
 * @public
 */
export type BoxSizing = z.infer<typeof boxSizingSchema>;

/**
 * CSS clear property IR.
 *
 * The clear property sets whether an element must be moved below floating elements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clear}
 *
 * @example
 * ```typescript
 * const clear: Clear = {
 *   kind: "clear",
 *   value: "both"
 * };
 * ```
 *
 * @public
 */
export const clearSchema = z.object({
	kind: z.literal("clear"),
	value: z.enum(["left", "right", "both", "none", "inline-start", "inline-end"], {
		error: () => ({ message: "Expected left | right | both | none | inline-start | inline-end" }),
	}),
});

/**
 * TypeScript type for clear property.
 *
 * @public
 */
export type Clear = z.infer<typeof clearSchema>;

/**
 * CSS float property IR.
 *
 * The float property places an element on the left or right side of its container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/float}
 *
 * @example
 * ```typescript
 * const float: Float = {
 *   kind: "float",
 *   value: "left"
 * };
 * ```
 *
 * @public
 */
export const floatSchema = z.object({
	kind: z.literal("float"),
	value: z.enum(["left", "right", "none", "inline-start", "inline-end"], {
		error: () => ({ message: "Expected left | right | none | inline-start | inline-end" }),
	}),
});

/**
 * TypeScript type for float property.
 *
 * @public
 */
export type Float = z.infer<typeof floatSchema>;


=== File: src/core/types/length-percentage.ts ===
// b_path:: src/core/types/length-percentage.ts
import { z } from "zod";
import * as Unit from "@/core/units";

/**
 * All CSS length unit identifiers.
 *
 * Union of absolute, font-relative, and viewport-relative length units.
 * Per CSS Values & Units Module Level 4 specification.
 *
 * @see {@link https://www.w3.org/TR/css-values-4/#lengths}
 *
 * @internal
 */
const allLengthUnitsSchema = z.union(
	[Unit.absoluteLengthUnitSchema, Unit.fontLengthUnitSchema, Unit.viewportLengthUnitSchema],
	{
		error: (issue) =>
			issue.code === "invalid_union"
				? "Invalid length unit. Expected absolute (px, pt, cm, etc.), font-relative (em, rem, etc.), or viewport (vw, vh, etc.) units."
				: "Invalid input",
	},
);

/**
 * CSS `<length>` dimension.
 *
 * A length is a distance measurement consisting of a number and a unit.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length}
 *
 * @example
 * ```typescript
 * import { lengthSchema } from "@/core/types/length-percentage";
 *
 * const size: Length = { value: 100, unit: "px" };
 * const fontSize: Length = { value: 1.5, unit: "rem" };
 * ```
 *
 * @public
 */
export const lengthSchema = z.object({
	value: z.number(),
	unit: allLengthUnitsSchema,
});

/**
 * TypeScript type for `<length>` dimension.
 *
 * @public
 */
export type Length = z.infer<typeof lengthSchema>;

/**
 * CSS `<length-percentage>` data type.
 *
 * A type that can accept either a `<length>` or a `<percentage>` value.
 * This is a CSS spec-defined composite type.
 *
 * Per CSS spec: <length-percentage> = <length> | <percentage>
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage}
 *
 * @example
 * ```typescript
 * import { lengthPercentageSchema } from "@/core/types/length-percentage";
 *
 * // Percentage
 * const size1: LengthPercentage = { value: 50, unit: "%" };
 *
 * // Length (px)
 * const size2: LengthPercentage = { value: 100, unit: "px" };
 *
 * // Length (em)
 * const size3: LengthPercentage = { value: 2, unit: "em" };
 * ```
 *
 * @public
 */
export const lengthPercentageSchema = z.union([lengthSchema, Unit.percentageSchema], {
	error: (issue) =>
		issue.code === "invalid_union"
			? "Invalid length-percentage. Expected a length (with unit) or percentage."
			: "Invalid input",
});

/**
 * TypeScript type for `<length-percentage>` values.
 *
 * @public
 */
export type LengthPercentage = z.infer<typeof lengthPercentageSchema>;

/**
 * CSS `<length-percentage>` with `auto` keyword.
 *
 * Extends `<length-percentage>` to also accept the `auto` keyword.
 * Used in properties like `background-size` where auto is valid.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage}
 *
 * @example
 * ```typescript
 * import { lengthPercentageAutoSchema } from "@/core/types/length-percentage";
 *
 * // Auto keyword
 * const size1: LengthPercentageAuto = "auto";
 *
 * // Percentage
 * const size2: LengthPercentageAuto = { value: 50, unit: "%" };
 *
 * // Length
 * const size3: LengthPercentageAuto = { value: 100, unit: "px" };
 * ```
 *
 * @public
 */
export const lengthPercentageAutoSchema = z.union([z.literal("auto"), lengthPercentageSchema], {
	error: (issue) =>
		issue.code === "invalid_union"
			? 'Invalid value. Expected "auto", a length (with unit), or a percentage.'
			: "Invalid input",
});

/**
 * TypeScript type for `<length-percentage>` with `auto`.
 *
 * @public
 */
export type LengthPercentageAuto = z.infer<typeof lengthPercentageAutoSchema>;


=== File: src/core/types/outline.ts ===
// b_path:: src/core/types/outline.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthSchema } from "./length-percentage";

/**
 * CSS outline-width property IR.
 *
 * Specifies the width of the outline.
 * Single length value or keyword (thin, medium, thick).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-width}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-width}
 *
 * @public
 */
export const outlineWidthValueSchema = z.object({
	kind: z.literal("outline-width"),
	width: z.union([lengthSchema, Keyword.borderWidthKeywordsSchema], {
		error: (issue) =>
			issue.code === "invalid_union"
				? 'Invalid outline width. Expected a length or keyword ("thin", "medium", "thick").'
				: "Invalid input",
	}),
});

/**
 * CSS outline-width property type.
 *
 * @public
 */
export type OutlineWidthValue = z.infer<typeof outlineWidthValueSchema>;

/**
 * CSS outline-style property IR.
 *
 * Specifies the style of the outline line.
 * Single style keyword including 'auto' (outline-specific).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-style}
 *
 * @public
 */
export const outlineStyleValueSchema = z.object({
	kind: z.literal("outline-style"),
	style: Keyword.outlineStyleKeywordsSchema,
});

/**
 * CSS outline-style property type.
 *
 * @public
 */
export type OutlineStyleValue = z.infer<typeof outlineStyleValueSchema>;

/**
 * CSS outline-style keyword type (extracted from schema).
 *
 * @public
 */
export type OutlineStyle = z.infer<typeof Keyword.outlineStyleKeywordsSchema>;

/**
 * CSS outline-color property IR.
 *
 * Specifies the color of the outline.
 * Single color value or keyword including 'invert' (outline-specific).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-color}
 *
 * @public
 */
export const outlineColorValueSchema = z.object({
	kind: z.literal("outline-color"),
	color: z.union([Keyword.colorValueKeywordsSchema, z.literal("invert")], {
		error: (issue) =>
			issue.code === "invalid_union" ? 'Invalid outline color. Expected a color keyword or "invert".' : "Invalid input",
	}),
});

/**
 * CSS outline-color property type.
 *
 * @public
 */
export type OutlineColorValue = z.infer<typeof outlineColorValueSchema>;

/**
 * CSS outline-offset property IR.
 *
 * Specifies the space between outline and element edge.
 * Single length value (can be negative).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-offset}
 *
 * @public
 */
export const outlineOffsetValueSchema = z.object({
	kind: z.literal("outline-offset"),
	offset: lengthSchema,
});

/**
 * CSS outline-offset property type.
 *
 * @public
 */
export type OutlineOffsetValue = z.infer<typeof outlineOffsetValueSchema>;


=== File: src/core/types/position-layer.ts ===
// b_path:: src/core/types/position-layer.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import * as Type from "../types";

/**
 * CSS position value for background positioning.
 *
 * Can be a keyword, length, or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 * @public
 */
export const backgroundPositionValueSchema = z.union([Keyword.positionKeywordsSchema, Type.lengthPercentageSchema], {
	error: (issue) =>
		issue.code === "invalid_union"
			? "Invalid background position value. Expected a position keyword (left, right, top, bottom, center) or length-percentage."
			: "Invalid input",
});

/**
 * TypeScript type for background position value.
 * @public
 */
export type BackgroundPositionValue = z.infer<typeof backgroundPositionValueSchema>;

/**
 * CSS background-position layer value.
 *
 * Represents a single layer value for the background-position property.
 * Supports 1-value, 2-value, and 4-value syntax.
 *
 * Per CSS spec, background-position accepts:
 * - Single keyword: `center` | `left` | `right` | `top` | `bottom`
 * - One value: `<length-percentage>` | keyword
 * - Two values: `<length-percentage> <length-percentage>` | keyword combinations
 * - Four values: `<edge> <length-percentage> <edge> <length-percentage>` (edge offsets)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionLayerSchema } from "@/core/types/position-layer";
 *
 * // Center keyword
 * const layer1: PositionLayer = { kind: "center" };
 *
 * // One value
 * const layer2: PositionLayer = {
 *   kind: "one-value",
 *   value: { value: 50, unit: "%" }
 * };
 *
 * // Two values
 * const layer3: PositionLayer = {
 *   kind: "two-value",
 *   horizontal: "left",
 *   vertical: { value: 20, unit: "px" }
 * };
 *
 * // Four values (edge offsets)
 * const layer4: PositionLayer = {
 *   kind: "four-value",
 *   horizontalEdge: "right",
 *   horizontalOffset: { value: 10, unit: "px" },
 *   verticalEdge: "bottom",
 *   verticalOffset: { value: 20, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const positionLayerSchema = z.discriminatedUnion("kind", [
	// Center keyword (special case)
	z.object({
		kind: z.literal("center"),
	}),

	// One value: applies to horizontal, vertical is centered (50%)
	z.object({
		kind: z.literal("one-value"),
		value: backgroundPositionValueSchema,
	}),

	// Two values: horizontal vertical
	z.object({
		kind: z.literal("two-value"),
		horizontal: backgroundPositionValueSchema,
		vertical: backgroundPositionValueSchema,
	}),

	// Four values: edge offset pairs
	// Format: <horizontal-edge> <h-offset> <vertical-edge> <v-offset>
	// Example: right 10px bottom 20px
	z.object({
		kind: z.literal("four-value"),
		horizontalEdge: z.literal("left").or(z.literal("right")),
		horizontalOffset: Type.lengthPercentageSchema,
		verticalEdge: z.literal("top").or(z.literal("bottom")),
		verticalOffset: Type.lengthPercentageSchema,
	}),
]);

/**
 * TypeScript type for position layer.
 * @public
 */
export type PositionLayer = z.infer<typeof positionLayerSchema>;

/**
 * CSS position property (reusable across properties).
 *
 * Specifies the position of elements. Used in:
 * - `background-position` - Background image positioning
 * - `object-position` - Replaced element positioning
 * - `transform-origin` - Transform origin positioning
 * - `perspective-origin` - Perspective origin positioning
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionSchema, type Position } from "@/core/types/position-layer";
 *
 * // Single layer
 * const pos1: Position = {
 *   layers: [{ kind: "center" }]
 * };
 *
 * // Multiple layers with different syntaxes
 * const pos2: Position = {
 *   layers: [
 *     { kind: "center" },
 *     { kind: "two-value", horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } },
 *     {
 *       kind: "four-value",
 *       horizontalEdge: "right",
 *       horizontalOffset: { value: 10, unit: "px" },
 *       verticalEdge: "bottom",
 *       verticalOffset: { value: 20, unit: "px" }
 *     }
 *   ]
 * };
 * ```
 *
 * @public
 */
export const positionSchema = z.object({
	layers: z.array(positionLayerSchema).min(1),
});

/**
 * TypeScript type for position property.
 * @public
 */
export type Position = z.infer<typeof positionSchema>;


=== File: src/core/types/position.ts ===
// b_path:: src/core/types/position.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthPercentageSchema, lengthSchema } from "./length-percentage";

/**
 * CSS position value (single axis).
 *
 * A position value that can be used on a single axis (horizontal or vertical).
 * Used as a building block for 2D position values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionValueSchema } from "@/core/types/position";
 *
 * // Keyword
 * const pos1: PositionValue = "center";
 *
 * // Length
 * const pos2: PositionValue = { value: 100, unit: "px" };
 *
 * // Percentage
 * const pos3: PositionValue = { value: 50, unit: "%" };
 * ```
 *
 * @public
 */
export const positionValueSchema = z.union([Keyword.positionKeywordsSchema, lengthPercentageSchema], {
	error: (issue) =>
		issue.code === "invalid_union"
			? { message: "Expected left | center | right | top | bottom | <length-percentage>" }
			: { message: "Invalid position value" },
});

/**
 * TypeScript type for position value.
 * @public
 */
export type PositionValue = z.infer<typeof positionValueSchema>;

/**
 * CSS 2D position value.
 *
 * A position value that specifies both horizontal and vertical positions.
 * Used in properties like transform-origin, perspective-origin, object-position.
 *
 * Per CSS spec: <position> = [ [ left | center | right | top | bottom | <length-percentage> ] |
 *                            [ left | center | right ] && [ top | center | bottom ] |
 *                            [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] |
 *                            [ [ center | [ left | right ] <length-percentage>? ] &&
 *                              [ center | [ top | bottom ] <length-percentage>? ] ] ]
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { position2DSchema } from "@/core/types/position";
 *
 * // Keywords
 * const pos1: Position2D = { horizontal: "center", vertical: "center" };
 * const pos2: Position2D = { horizontal: "left", vertical: "top" };
 *
 * // Mixed keywords and values
 * const pos3: Position2D = {
 *   horizontal: { value: 25, unit: "%" },
 *   vertical: "center"
 * };
 *
 * // Both values
 * const pos4: Position2D = {
 *   horizontal: { value: 100, unit: "px" },
 *   vertical: { value: 50, unit: "%" }
 * };
 * ```
 *
 * @public
 */
export const position2DSchema = z.object({
	horizontal: positionValueSchema.describe("horizontal position"),
	vertical: positionValueSchema.describe("vertical position"),
});

/**
 * TypeScript type for 2D position.
 * @public
 */
export type Position2D = z.infer<typeof position2DSchema>;

/**
 * CSS 3D position value.
 *
 * A position value that specifies position in 3D space with x, y, and z coordinates.
 * Used in properties like transform-origin in 3D contexts.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin}
 *
 * @example
 * ```typescript
 * import { position3DSchema } from "@/core/types/position";
 *
 * const pos: Position3D = {
 *   x: { value: 100, unit: "px" },
 *   y: { value: 50, unit: "%" },
 *   z: { value: 10, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const position3DSchema = z.object({
	x: positionValueSchema.describe("x-axis position"),
	y: positionValueSchema.describe("y-axis position"),
	z: lengthSchema.describe("z-axis position (depth)"),
});

/**
 * TypeScript type for 3D position.
 * @public
 */
export type Position3D = z.infer<typeof position3DSchema>;

/**
 * CSS position list.
 *
 * An array of position values used in properties that accept multiple positions.
 * Common in animation keyframes and multi-position properties.
 *
 * @example
 * ```typescript
 * import { positionListSchema } from "@/core/types/position";
 *
 * const positions: PositionList = [
 *   { horizontal: "left", vertical: "top" },
 *   { horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } },
 *   { horizontal: "right", vertical: "bottom" }
 * ];
 * ```
 *
 * @public
 */
export const positionListSchema = z
	.array(position2DSchema)
	.min(1, "Position list must contain at least 1 position")
	.describe("array of 2D positions for multi-position CSS properties");

/**
 * TypeScript type for position list.
 * @public
 */
export type PositionList = z.infer<typeof positionListSchema>;

/**
 * Common position presets.
 *
 * Predefined positions for common use cases in CSS layout and positioning.
 *
 * @example
 * ```typescript
 * import { COMMON_POSITIONS } from "@/core/types/position";
 *
 * const centerPos = COMMON_POSITIONS.center; // { horizontal: "center", vertical: "center" }
 * const topLeftPos = COMMON_POSITIONS.topLeft; // { horizontal: "left", vertical: "top" }
 * ```
 *
 * @public
 */
export const COMMON_POSITIONS = {
	center: { horizontal: "center" as const, vertical: "center" as const },
	topLeft: { horizontal: "left" as const, vertical: "top" as const },
	topCenter: { horizontal: "center" as const, vertical: "top" as const },
	topRight: { horizontal: "right" as const, vertical: "top" as const },
	middleLeft: { horizontal: "left" as const, vertical: "center" as const },
	middleRight: { horizontal: "right" as const, vertical: "center" as const },
	bottomLeft: { horizontal: "left" as const, vertical: "bottom" as const },
	bottomCenter: { horizontal: "center" as const, vertical: "bottom" as const },
	bottomRight: { horizontal: "right" as const, vertical: "bottom" as const },
} as const;

/**
 * Type for common position presets.
 * @public
 */
export type CommonPositions = typeof COMMON_POSITIONS;


=== File: src/core/types/ratio.ts ===
// b_path:: src/core/types/ratio.ts
import { z } from "zod";

/**
 * CSS ratio value.
 *
 * A ratio consists of two numbers separated by a slash (/).
 * Used in properties like aspect-ratio, resolution, and other ratio-based values.
 *
 * Per CSS spec: <ratio> = <number> [ / <number> ]?
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/ratio}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio}
 *
 * @example
 * ```typescript
 * import { ratioSchema } from "@/core/types/ratio";
 *
 * // Simple ratio
 * const ratio1: Ratio = { numerator: 16, denominator: 9 };
 *
 * // Single number (denominator defaults to 1)
 * const ratio2: Ratio = { numerator: 4, denominator: 3 };
 *
 * // Auto keyword
 * const ratio3: Ratio = "auto";
 * ```
 *
 * @public
 */
export const ratioSchema = z.union(
	[
		// Explicit ratio with numerator and denominator
		z.object({
			numerator: z.number().positive().describe("numerator of the ratio"),
			denominator: z.number().positive().describe("denominator of the ratio"),
		}),

		// Auto keyword for automatic ratio
		z
			.literal("auto")
			.describe("automatic ratio based on content"),
	],
	{
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected { numerator: <positive-number>, denominator: <positive-number> } | auto" }
				: { message: "Invalid ratio value" },
	},
);

/**
 * TypeScript type for ratio.
 * @public
 */
export type Ratio = z.infer<typeof ratioSchema>;

/**
 * CSS ratio list.
 *
 * An array of ratios used in properties that accept multiple ratios.
 * Common in resolution and aspect-ratio contexts.
 *
 * @example
 * ```typescript
 * import { ratioListSchema } from "@/core/types/ratio";
 *
 * const ratios: RatioList = [
 *   { numerator: 16, denominator: 9 },
 *   { numerator: 4, denominator: 3 },
 *   "auto"
 * ];
 * ```
 *
 * @public
 */
export const ratioListSchema = z
	.array(ratioSchema)
	.min(1, "Ratio list must contain at least 1 ratio")
	.describe("array of ratios for multi-ratio CSS properties");

/**
 * TypeScript type for ratio list.
 * @public
 */
export type RatioList = z.infer<typeof ratioListSchema>;

/**
 * Common aspect ratio presets.
 *
 * Predefined ratios for common use cases like video, images, and design.
 *
 * @example
 * ```typescript
 * import { COMMON_ASPECT_RATIOS } from "@/core/types/ratio";
 *
 * const videoRatio = COMMON_ASPECT_RATIOS["16:9"]; // { numerator: 16, denominator: 9 }
 * const squareRatio = COMMON_ASPECT_RATIOS["1:1"]; // { numerator: 1, denominator: 1 }
 * ```
 *
 * @public
 */
export const COMMON_ASPECT_RATIOS = {
	"21:9": { numerator: 21, denominator: 9 },
	"16:9": { numerator: 16, denominator: 9 },
	"3:2": { numerator: 3, denominator: 2 },
	"4:3": { numerator: 4, denominator: 3 },
	"1:1": { numerator: 1, denominator: 1 },
	"3:4": { numerator: 3, denominator: 4 },
	"2:3": { numerator: 2, denominator: 3 },
	"9:16": { numerator: 9, denominator: 16 },
	"9:21": { numerator: 9, denominator: 21 },
} as const;

/**
 * Type for common aspect ratio presets.
 * @public
 */
export type CommonAspectRatio = typeof COMMON_ASPECT_RATIOS;

/**
 * Helper function to create a ratio from a string.
 *
 * @param ratioString - String in format "numerator:denominator" or "numerator/denominator"
 * @returns Ratio object or null if invalid format
 *
 * @example
 * ```typescript
 * import { createRatioFromString } from "@/core/types/ratio";
 *
 * const ratio1 = createRatioFromString("16:9"); // { numerator: 16, denominator: 9 }
 * const ratio2 = createRatioFromString("4/3"); // { numerator: 4, denominator: 3 }
 * ```
 *
 * @public
 */
export function createRatioFromString(ratioString: string): Ratio | null {
	const colonMatch = ratioString.match(/^(\d+):(\d+)$/);
	const slashMatch = ratioString.match(/^(\d+)\/(\d+)$/);

	if (colonMatch?.[1] && colonMatch?.[2]) {
		const numerator = Number.parseInt(colonMatch[1], 10);
		const denominator = Number.parseInt(colonMatch[2], 10);
		if (numerator > 0 && denominator > 0) {
			return { numerator, denominator };
		}
	}

	if (slashMatch?.[1] && slashMatch?.[2]) {
		const numerator = Number.parseInt(slashMatch[1], 10);
		const denominator = Number.parseInt(slashMatch[2], 10);
		if (numerator > 0 && denominator > 0) {
			return { numerator, denominator };
		}
	}

	return null;
}

/**
 * Helper function to format a ratio as a string.
 *
 * @param ratio - Ratio object
 * @returns Formatted string representation
 *
 * @example
 * ```typescript
 * import { formatRatioAsString } from "@/core/types/ratio";
 *
 * const ratioString = formatRatioAsString({ numerator: 16, denominator: 9 }); // "16:9"
 * ```
 *
 * @public
 */
export function formatRatioAsString(ratio: Ratio): string {
	if (ratio === "auto") {
		return "auto";
	}

	return `${ratio.numerator}:${ratio.denominator}`;
}


=== File: src/core/types/shadow.test.ts ===
// b_path:: src/core/types/shadow.test.ts
import { describe, expect, it } from "vitest";
import {
	type BoxShadow,
	type BoxShadowLayer,
	boxShadowSchema,
	type TextShadow,
	type TextShadowLayer,
	textShadowSchema,
} from "./shadow";

describe("boxShadowSchema", () => {
	it("validates simple box-shadow", () => {
		const shadow: BoxShadow = {
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
				},
			],
		};
		const result = boxShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("validates box-shadow with blur radius", () => {
		const shadow: BoxShadow = {
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 4, unit: "px" },
					blurRadius: { value: 8, unit: "px" },
				},
			],
		};
		const result = boxShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("validates box-shadow with spread radius", () => {
		const shadow: BoxShadow = {
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
					spreadRadius: { value: 2, unit: "px" },
				},
			],
		};
		const result = boxShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("validates inset box-shadow", () => {
		const shadow: BoxShadow = {
			kind: "box-shadow",
			shadows: [
				{
					inset: true,
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
				},
			],
		};
		const result = boxShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("validates box-shadow with color", () => {
		const shadow: BoxShadow = {
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
					color: { kind: "named", name: "black" },
				},
			],
		};
		const result = boxShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("validates multiple box-shadows", () => {
		const shadow: BoxShadow = {
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					blurRadius: { value: 2, unit: "px" },
				},
				{
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 4, unit: "px" },
					blurRadius: { value: 8, unit: "px" },
				},
			],
		};
		const result = boxShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("rejects wrong kind", () => {
		const shadow = {
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
				},
			],
		};
		const result = boxShadowSchema.safeParse(shadow);
		expect(result.success).toBe(false);
	});

	it("accepts empty shadows array", () => {
		const shadow = {
			kind: "box-shadow",
			shadows: [],
		};
		const result = boxShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});
});

describe("textShadowSchema", () => {
	it("validates simple text-shadow", () => {
		const shadow: TextShadow = {
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
				},
			],
		};
		const result = textShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("validates text-shadow with blur radius", () => {
		const shadow: TextShadow = {
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
				},
			],
		};
		const result = textShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("validates text-shadow with color", () => {
		const shadow: TextShadow = {
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					blurRadius: { value: 2, unit: "px" },
					color: { kind: "named", name: "gray" },
				},
			],
		};
		const result = textShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("validates multiple text-shadows", () => {
		const shadow: TextShadow = {
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					color: { kind: "named", name: "white" },
				},
				{
					offsetX: { value: -1, unit: "px" },
					offsetY: { value: -1, unit: "px" },
					color: { kind: "named", name: "black" },
				},
			],
		};
		const result = textShadowSchema.safeParse(shadow);
		expect(result.success).toBe(true);
	});

	it("rejects wrong kind", () => {
		const shadow = {
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
				},
			],
		};
		const result = textShadowSchema.safeParse(shadow);
		expect(result.success).toBe(false);
	});
});

describe("Type exports", () => {
	it("exports BoxShadowLayer type", () => {
		const layer: BoxShadowLayer = {
			offsetX: { value: 0, unit: "px" },
			offsetY: { value: 0, unit: "px" },
		};
		expect(layer).toBeDefined();
	});

	it("exports TextShadowLayer type", () => {
		const layer: TextShadowLayer = {
			offsetX: { value: 0, unit: "px" },
			offsetY: { value: 0, unit: "px" },
		};
		expect(layer).toBeDefined();
	});
});


=== File: src/core/types/shadow.ts ===
// b_path:: src/core/types/shadow.ts
import { z } from "zod";
import type { Color } from "./color";
import type { Length } from "./length-percentage";

/**
 * CSS box-shadow property value.
 *
 * Adds shadow effects around an element's frame.
 * Syntax: [inset?] offset-x offset-y [blur-radius] [spread-radius] [color]
 *
 * Multiple shadows can be stacked by comma separation.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow}
 *
 * @example
 * ```typescript
 * import type { BoxShadow } from "@/core/types/shadow";
 *
 * const shadow: BoxShadow = {
 *   kind: "box-shadow",
 *   shadows: [{
 *     offsetX: { value: 2, unit: "px" },
 *     offsetY: { value: 2, unit: "px" },
 *     blurRadius: { value: 4, unit: "px" },
 *     color: { kind: "named", name: "black" }
 *   }]
 * };
 * // CSS: 2px 2px 4px black
 * ```
 *
 * @public
 */
export const boxShadowSchema = z.object({
	kind: z.literal("box-shadow"),
	shadows: z.array(
		z.object({
			inset: z.boolean().optional(),
			offsetX: z.custom<Length>(),
			offsetY: z.custom<Length>(),
			blurRadius: z.custom<Length>().optional(),
			spreadRadius: z.custom<Length>().optional(),
			color: z.custom<Color>().optional(),
		}),
	),
});

/**
 * TypeScript type for box-shadow property.
 * @public
 */
export type BoxShadow = z.infer<typeof boxShadowSchema>;

/**
 * Single shadow layer in box-shadow.
 * @public
 */
export type BoxShadowLayer = BoxShadow["shadows"][number];

/**
 * CSS text-shadow property value.
 *
 * Adds shadow to text content.
 * Syntax: offset-x offset-y [blur-radius] [color]
 *
 * Multiple shadows can be stacked by comma separation.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow}
 *
 * @example
 * ```typescript
 * import type { TextShadow } from "@/core/types/shadow";
 *
 * const shadow: TextShadow = {
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" },
 *     blurRadius: { value: 2, unit: "px" },
 *     color: { kind: "named", name: "gray" }
 *   }]
 * };
 * // CSS: 1px 1px 2px gray
 * ```
 *
 * @public
 */
export const textShadowSchema = z.object({
	kind: z.literal("text-shadow"),
	shadows: z.array(
		z.object({
			offsetX: z.custom<Length>(),
			offsetY: z.custom<Length>(),
			blurRadius: z.custom<Length>().optional(),
			color: z.custom<Color>().optional(),
		}),
	),
});

/**
 * TypeScript type for text-shadow property.
 * @public
 */
export type TextShadow = z.infer<typeof textShadowSchema>;

/**
 * Single shadow layer in text-shadow.
 * @public
 */
export type TextShadowLayer = TextShadow["shadows"][number];


=== File: src/core/types/size-layer.ts ===
// b_path:: src/core/types/size-layer.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import * as Type from "../types";

/**
 * CSS size layer value.
 *
 * Represents a single layer value for sizing properties.
 * Can be a sizing keyword, auto, or explicit dimensions.
 *
 * Per CSS spec, size values accept:
 * - Keywords: `cover` | `contain`
 * - Single value: `<length-percentage>` | `auto`
 * - Two values: `<length-percentage>` | `auto` for width and height
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 *
 * @example
 * ```typescript
 * import { sizeLayerSchema } from "@/core/types/size-layer";
 *
 * // Keyword
 * const layer1: SizeLayer = { kind: "keyword", value: "cover" };
 *
 * // Auto
 * const layer2: SizeLayer = { kind: "auto" };
 *
 * // Single value
 * const layer3: SizeLayer = {
 *   kind: "one-value",
 *   value: { value: 50, unit: "%" }
 * };
 *
 * // Two values
 * const layer4: SizeLayer = {
 *   kind: "two-value",
 *   width: { value: 100, unit: "px" },
 *   height: "auto"
 * };
 * ```
 *
 * @public
 */
export const sizeLayerSchema = z.discriminatedUnion("kind", [
	// Sizing keywords: cover, contain
	z.object({
		kind: z.literal("keyword"),
		value: Keyword.sizingKeywordsSchema,
	}),

	// Auto keyword
	z.object({
		kind: z.literal("auto"),
	}),

	// Single value: <length-percentage> or auto
	// Applies to both width and height (maintaining aspect ratio)
	z.object({
		kind: z.literal("one-value"),
		value: Type.lengthPercentageAutoSchema,
	}),

	// Two values: width height
	// Each can be <length-percentage> or auto
	z.object({
		kind: z.literal("two-value"),
		width: Type.lengthPercentageAutoSchema,
		height: Type.lengthPercentageAutoSchema,
	}),
]);

/**
 * TypeScript type for size layer.
 * @public
 */
export type SizeLayer = z.infer<typeof sizeLayerSchema>;

/**
 * CSS size property (reusable across properties).
 *
 * Specifies the size of elements. Used in:
 * - `background-size` - Background image sizing
 * - `object-fit` - Replaced element sizing
 * - `column-size` - Multi-column sizing
 * - `box-size` - Box sizing (future)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 *
 * @example
 * ```typescript
 * import { sizeSchema, type Size } from "@/core/types/size-layer";
 *
 * // Single keyword
 * const size1: Size = {
 *   layers: [{ kind: "keyword", value: "cover" }]
 * };
 *
 * // Multiple layers
 * const size2: Size = {
 *   layers: [
 *     { kind: "keyword", value: "cover" },
 *     { kind: "two-value", width: { value: 100, unit: "px" }, height: "auto" },
 *     { kind: "keyword", value: "contain" }
 *   ]
 * };
 *
 * // Single value
 * const size3: Size = {
 *   layers: [{ kind: "one-value", value: { value: 50, unit: "%" } }]
 * };
 * ```
 *
 * @public
 */
export const sizeSchema = z.object({
	layers: z.array(sizeLayerSchema).min(1),
});

/**
 * TypeScript type for size property.
 * @public
 */
export type Size = z.infer<typeof sizeSchema>;


=== File: src/core/types/time.test.ts ===
// b_path:: src/core/types/time.test.ts

import { describe, expect, it } from "vitest";
import { type Time, timeSchema } from "./time";

describe("timeSchema", () => {
	it("validates seconds", () => {
		const result = timeSchema.safeParse({ value: 1, unit: "s" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.value).toBe(1);
			expect(result.data.unit).toBe("s");
		}
	});

	it("validates milliseconds", () => {
		const result = timeSchema.safeParse({ value: 500, unit: "ms" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.value).toBe(500);
			expect(result.data.unit).toBe("ms");
		}
	});

	it("validates decimal values", () => {
		const result = timeSchema.safeParse({ value: 0.5, unit: "s" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.value).toBe(0.5);
		}
	});

	it("validates zero", () => {
		const result = timeSchema.safeParse({ value: 0, unit: "s" });
		expect(result.success).toBe(true);
	});

	it("rejects missing value", () => {
		const result = timeSchema.safeParse({ unit: "s" });
		expect(result.success).toBe(false);
	});

	it("rejects missing unit", () => {
		const result = timeSchema.safeParse({ value: 1 });
		expect(result.success).toBe(false);
	});

	it("rejects invalid unit", () => {
		const result = timeSchema.safeParse({ value: 1, unit: "px" });
		expect(result.success).toBe(false);
	});
});

describe("Time type", () => {
	it("accepts valid time in seconds", () => {
		const time: Time = { value: 2, unit: "s" };
		expect(time.value).toBe(2);
		expect(time.unit).toBe("s");
	});

	it("accepts valid time in milliseconds", () => {
		const time: Time = { value: 1000, unit: "ms" };
		expect(time.value).toBe(1000);
		expect(time.unit).toBe("ms");
	});
});


=== File: src/core/types/time.ts ===
// b_path:: src/core/types/time.ts
import { z } from "zod";
import * as Unit from "../units";

/**
 * CSS `<time>` dimension.
 *
 * A time value consists of a number and a time unit (s or ms).
 * Used in animations, transitions, and other time-based CSS properties.
 *
 * Per CSS Values & Units Module Level 4 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/time}
 * @see {@link https://www.w3.org/TR/css-values-4/#time}
 *
 * @example
 * ```typescript
 * import { timeSchema } from "@/core/types/time";
 *
 * const delay: Time = { value: 1, unit: "s" };
 * const duration: Time = { value: 500, unit: "ms" };
 * ```
 *
 * @public
 */
export const timeSchema = z.object({
	value: z.number().nonnegative("Time value must be non-negative"),
	unit: Unit.timeUnitSchema,
});

/**
 * CSS `<time>` type.
 *
 * @public
 */
export type Time = z.infer<typeof timeSchema>;

/**
 * CSS `<time>` dimension for delay values.
 *
 * A delay time value consists of a number and a time unit (s or ms).
 * Unlike durations, delays can be negative to indicate the animation should start partway through.
 *
 * Used in animation-delay and transition-delay properties.
 *
 * Per CSS Animations Module Level 1 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-delay}
 *
 * @example
 * ```typescript
 * import { delayTimeSchema } from "@/core/types/time";
 *
 * const delay: DelayTime = { value: -500, unit: "ms" };
 * const positiveDelay: DelayTime = { value: 1, unit: "s" };
 * ```
 *
 * @public
 */
export const delayTimeSchema = z.object({
	value: z.number(),
	unit: Unit.timeUnitSchema,
});

/**
 * CSS delay `<time>` type.
 *
 * @public
 */
export type DelayTime = z.infer<typeof delayTimeSchema>;


=== File: src/core/types/transform.ts ===
// b_path:: src/core/types/transform.ts
import { z } from "zod";
import { angleSchema } from "./angle";
import { lengthPercentageSchema, lengthSchema } from "./length-percentage";

/**
 * CSS transform function types.
 *
 * Transform functions modify the coordinate space of an element's content.
 * Used in the transform property to apply geometric transformations.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform}
 *
 * @example
 * ```typescript
 * import { transformFunctionSchema } from "@/core/types/transform";
 *
 * // Translate
 * const translate: TransformFunction = {
 *   kind: "translate",
 *   x: { value: 100, unit: "px" },
 *   y: { value: 50, unit: "px" }
 * };
 *
 * // Rotate
 * const rotate: TransformFunction = {
 *   kind: "rotate",
 *   angle: { value: 45, unit: "deg" }
 * };
 *
 * // Scale
 * const scale: TransformFunction = {
 *   kind: "scale",
 *   x: 1.5,
 *   y: 2
 * };
 * ```
 *
 * @public
 */

// Note: numberOrPercentageSchema defined for future use in transform values
// const numberOrPercentageSchema = z.union([
//   z.number().describe("numeric value"),
//   percentageSchema.describe("percentage value")
// ]);

/**
 * Translate transform function.
 *
 * Moves an element along the x and/or y-axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/translate}
 */
export const translateFunctionSchema = z.object({
	kind: z.literal("translate").describe("translate function"),
	x: lengthPercentageSchema.describe("x-axis translation"),
	y: lengthPercentageSchema.optional().describe("y-axis translation"),
});

export type TranslateFunction = z.infer<typeof translateFunctionSchema>;

/**
 * TranslateX transform function.
 *
 * Moves an element along the x-axis only.
 */
export const translateXFunctionSchema = z.object({
	kind: z.literal("translateX").describe("translateX function"),
	x: lengthPercentageSchema.describe("x-axis translation"),
});

export type TranslateXFunction = z.infer<typeof translateXFunctionSchema>;

/**
 * TranslateY transform function.
 *
 * Moves an element along the y-axis only.
 */
export const translateYFunctionSchema = z.object({
	kind: z.literal("translateY").describe("translateY function"),
	y: lengthPercentageSchema.describe("y-axis translation"),
});

export type TranslateYFunction = z.infer<typeof translateYFunctionSchema>;

/**
 * TranslateZ transform function.
 *
 * Moves an element along the z-axis in 3D space.
 */
export const translateZFunctionSchema = z.object({
	kind: z.literal("translateZ").describe("translateZ function"),
	z: lengthSchema.describe("z-axis translation"),
});

export type TranslateZFunction = z.infer<typeof translateZFunctionSchema>;

/**
 * Translate3d transform function.
 *
 * Moves an element in 3D space along x, y, and z axes.
 */
export const translate3dFunctionSchema = z.object({
	kind: z.literal("translate3d").describe("translate3d function"),
	x: lengthPercentageSchema.describe("x-axis translation"),
	y: lengthPercentageSchema.describe("y-axis translation"),
	z: lengthSchema.describe("z-axis translation"),
});

export type Translate3dFunction = z.infer<typeof translate3dFunctionSchema>;

/**
 * Rotate transform function.
 *
 * Rotates an element around a fixed point.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate}
 */
export const rotateFunctionSchema = z.object({
	kind: z.literal("rotate").describe("rotate function"),
	angle: angleSchema.describe("rotation angle"),
});

export type RotateFunction = z.infer<typeof rotateFunctionSchema>;

/**
 * RotateX transform function.
 *
 * Rotates an element around the x-axis in 3D space.
 */
export const rotateXFunctionSchema = z.object({
	kind: z.literal("rotateX").describe("rotateX function"),
	angle: angleSchema.describe("rotation angle around x-axis"),
});

export type RotateXFunction = z.infer<typeof rotateXFunctionSchema>;

/**
 * RotateY transform function.
 *
 * Rotates an element around the y-axis in 3D space.
 */
export const rotateYFunctionSchema = z.object({
	kind: z.literal("rotateY").describe("rotateY function"),
	angle: angleSchema.describe("rotation angle around y-axis"),
});

export type RotateYFunction = z.infer<typeof rotateYFunctionSchema>;

/**
 * RotateZ transform function.
 *
 * Rotates an element around the z-axis in 3D space.
 */
export const rotateZFunctionSchema = z.object({
	kind: z.literal("rotateZ").describe("rotateZ function"),
	angle: angleSchema.describe("rotation angle around z-axis"),
});

export type RotateZFunction = z.infer<typeof rotateZFunctionSchema>;

/**
 * Rotate3d transform function.
 *
 * Rotates an element in 3D space around a custom axis.
 */
export const rotate3dFunctionSchema = z.object({
	kind: z.literal("rotate3d").describe("rotate3d function"),
	x: z.number().describe("x component of rotation axis vector"),
	y: z.number().describe("y component of rotation axis vector"),
	z: z.number().describe("z component of rotation axis vector"),
	angle: angleSchema.describe("rotation angle"),
});

export type Rotate3dFunction = z.infer<typeof rotate3dFunctionSchema>;

/**
 * Scale transform function.
 *
 * Scales an element up or down in size.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale}
 */
export const scaleFunctionSchema = z.object({
	kind: z.literal("scale").describe("scale function"),
	x: z.number().min(0).describe("x-axis scale factor"),
	y: z.number().min(0).optional().describe("y-axis scale factor"),
});

export type ScaleFunction = z.infer<typeof scaleFunctionSchema>;

/**
 * ScaleX transform function.
 *
 * Scales an element along the x-axis only.
 */
export const scaleXFunctionSchema = z.object({
	kind: z.literal("scaleX").describe("scaleX function"),
	x: z.number().min(0).describe("x-axis scale factor"),
});

export type ScaleXFunction = z.infer<typeof scaleXFunctionSchema>;

/**
 * ScaleY transform function.
 *
 * Scales an element along the y-axis only.
 */
export const scaleYFunctionSchema = z.object({
	kind: z.literal("scaleY").describe("scaleY function"),
	y: z.number().min(0).describe("y-axis scale factor"),
});

export type ScaleYFunction = z.infer<typeof scaleYFunctionSchema>;

/**
 * ScaleZ transform function.
 *
 * Scales an element along the z-axis in 3D space.
 */
export const scaleZFunctionSchema = z.object({
	kind: z.literal("scaleZ").describe("scaleZ function"),
	z: z.number().min(0).describe("z-axis scale factor"),
});

export type ScaleZFunction = z.infer<typeof scaleZFunctionSchema>;

/**
 * Scale3d transform function.
 *
 * Scales an element in 3D space along x, y, and z axes.
 */
export const scale3dFunctionSchema = z.object({
	kind: z.literal("scale3d").describe("scale3d function"),
	x: z.number().min(0).describe("x-axis scale factor"),
	y: z.number().min(0).describe("y-axis scale factor"),
	z: z.number().min(0).describe("z-axis scale factor"),
});

export type Scale3dFunction = z.infer<typeof scale3dFunctionSchema>;

/**
 * Skew transform function.
 *
 * Skews an element along the x and/or y-axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew}
 */
export const skewFunctionSchema = z.object({
	kind: z.literal("skew").describe("skew function"),
	x: angleSchema.describe("x-axis skew angle"),
	y: angleSchema.optional().describe("y-axis skew angle"),
});

export type SkewFunction = z.infer<typeof skewFunctionSchema>;

/**
 * SkewX transform function.
 *
 * Skews an element along the x-axis only.
 */
export const skewXFunctionSchema = z.object({
	kind: z.literal("skewX").describe("skewX function"),
	x: angleSchema.describe("x-axis skew angle"),
});

export type SkewXFunction = z.infer<typeof skewXFunctionSchema>;

/**
 * SkewY transform function.
 *
 * Skews an element along the y-axis only.
 */
export const skewYFunctionSchema = z.object({
	kind: z.literal("skewY").describe("skewY function"),
	y: angleSchema.describe("y-axis skew angle"),
});

export type SkewYFunction = z.infer<typeof skewYFunctionSchema>;

/**
 * Matrix transform function.
 *
 * Applies a 2D transformation matrix to an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix}
 */
export const matrixFunctionSchema = z.object({
	kind: z.literal("matrix").describe("matrix function"),
	a: z.number().describe("matrix value a"),
	b: z.number().describe("matrix value b"),
	c: z.number().describe("matrix value c"),
	d: z.number().describe("matrix value d"),
	e: lengthSchema.describe("matrix value e"),
	f: lengthSchema.describe("matrix value f"),
});

export type MatrixFunction = z.infer<typeof matrixFunctionSchema>;

/**
 * Matrix3d transform function.
 *
 * Applies a 3D transformation matrix to an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d}
 */
export const matrix3dFunctionSchema = z.object({
	kind: z.literal("matrix3d").describe("matrix3d function"),
	values: z.array(z.number()).length(16).describe("16 matrix values in column-major order"),
});

export type Matrix3dFunction = z.infer<typeof matrix3dFunctionSchema>;

/**
 * Perspective transform function.
 *
 * Gives an element a 3D appearance by defining a perspective point.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/perspective}
 */
export const perspectiveFunctionSchema = z.object({
	kind: z.literal("perspective").describe("perspective function"),
	depth: lengthSchema.describe("perspective depth"),
});

export type PerspectiveFunction = z.infer<typeof perspectiveFunctionSchema>;

/**
 * Union of all transform function types.
 */
export const transformFunctionSchema = z.discriminatedUnion("kind", [
	translateFunctionSchema,
	translateXFunctionSchema,
	translateYFunctionSchema,
	translateZFunctionSchema,
	translate3dFunctionSchema,
	rotateFunctionSchema,
	rotateXFunctionSchema,
	rotateYFunctionSchema,
	rotateZFunctionSchema,
	rotate3dFunctionSchema,
	scaleFunctionSchema,
	scaleXFunctionSchema,
	scaleYFunctionSchema,
	scaleZFunctionSchema,
	scale3dFunctionSchema,
	skewFunctionSchema,
	skewXFunctionSchema,
	skewYFunctionSchema,
	matrixFunctionSchema,
	matrix3dFunctionSchema,
	perspectiveFunctionSchema,
]);

/**
 * TypeScript type for all transform functions.
 * @public
 */
export type TransformFunction = z.infer<typeof transformFunctionSchema>;

/**
 * CSS transform value (list of transform functions).
 *
 * A space-separated list of transform functions that can be applied to an element.
 * Used in the transform CSS property.
 *
 * @example
 * ```typescript
 * import { transformSchema } from "@/core/types/transform";
 *
 * const transform: Transform = [
 *   { kind: "translateX", x: { value: 100, unit: "px" } },
 *   { kind: "rotate", angle: { value: 45, unit: "deg" } },
 *   { kind: "scale", x: 1.5, y: 1.5 }
 * ];
 * ```
 *
 * @public
 */
export const transformSchema = z
	.array(transformFunctionSchema)
	.min(1, "Transform must contain at least one function")
	.describe("array of transform functions for CSS transform property");

export type Transform = z.infer<typeof transformSchema>;


=== File: src/core/types/transition.ts ===
// b_path:: src/core/types/transition.ts
import { z } from "zod";
import { easingFunctionSchema } from "./animation";
import { delayTimeSchema, timeSchema } from "./time";

/**
 * CSS transition-delay property IR.
 *
 * Specifies when a transition should start.
 * Comma-separated list of time values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-delay-property}
 *
 * @public
 */
export const transitionDelaySchema = z.object({
	kind: z.literal("transition-delay"),
	delays: z.array(delayTimeSchema).min(1),
});

/**
 * CSS transition-delay type.
 *
 * @public
 */
export type TransitionDelay = z.infer<typeof transitionDelaySchema>;

/**
 * CSS transition-duration property IR.
 *
 * Specifies how long a transition should take to complete.
 * Comma-separated list of time values (non-negative only).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-duration-property}
 *
 * @public
 */
export const transitionDurationSchema = z.object({
	kind: z.literal("transition-duration"),
	durations: z.array(timeSchema).min(1),
});

/**
 * CSS transition-duration type.
 *
 * @public
 */
export type TransitionDuration = z.infer<typeof transitionDurationSchema>;

/**
 * CSS transition-timing-function property IR.
 *
 * Specifies the timing function for transitions.
 * Comma-separated list of easing functions.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property}
 *
 * @public
 */
export const transitionTimingFunctionSchema = z.object({
	kind: z.literal("transition-timing-function"),
	functions: z.array(easingFunctionSchema).min(1),
});

/**
 * CSS transition-timing-function type.
 *
 * @public
 */
export type TransitionTimingFunction = z.infer<typeof transitionTimingFunctionSchema>;

/**
 * CSS transition-property property IR.
 *
 * Specifies which CSS properties should be transitioned.
 * Comma-separated list of property names, 'none', or 'all'.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-property-property}
 *
 * @public
 */
export const transitionPropertySchema = z.object({
	kind: z.literal("transition-property"),
	properties: z
		.array(
			z.union(
				[
					z.object({ type: z.literal("none") }),
					z.object({ type: z.literal("all") }),
					z.object({ type: z.literal("identifier"), value: z.string() }),
				],
				{
					error: (issue) =>
						issue.code === "invalid_union"
							? 'Invalid transition property. Expected { type: "none" }, { type: "all" }, or { type: "identifier", value: <string> }.'
							: "Invalid input",
				},
			),
		)
		.min(1),
});

/**
 * CSS transition-property type.
 *
 * @public
 */
export type TransitionProperty = z.infer<typeof transitionPropertySchema>;


=== File: src/core/types/typography.ts ===
// b_path:: src/core/types/typography.ts
import { z } from "zod";
import { lengthPercentageSchema } from "./length-percentage";

/**
 * CSS font-size property IR.
 *
 * The font-size property sets the size of the font.
 * Accepts length, percentage, or keyword values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size}
 *
 * @example
 * ```typescript
 * const fontSize: FontSize = {
 *   kind: "font-size",
 *   value: { value: 16, unit: "px" }
 * };
 * // CSS: font-size: 16px;
 * ```
 *
 * @public
 */
export const fontSizeSchema = z.object({
	kind: z.literal("font-size"),
	value: z.union(
		[
			lengthPercentageSchema,
			z.enum([
				"xx-small",
				"x-small",
				"small",
				"medium",
				"large",
				"x-large",
				"xx-large",
				"xxx-large",
				"larger",
				"smaller",
			]),
		],
		{
			error: (issue) =>
				issue.code === "invalid_union"
					? {
							message:
								"Expected <length-percentage> | xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large | larger | smaller",
						}
					: { message: "Invalid font-size value" },
		},
	),
});

export type FontSize = z.infer<typeof fontSizeSchema>;

/**
 * CSS font-family property IR.
 *
 * The font-family property specifies a prioritized list of font family names.
 * The browser will use the first font in the list that is available.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-family}
 *
 * @example
 * ```typescript
 * const fontFamily: FontFamily = {
 *   kind: "font-family",
 *   families: ["Arial", "sans-serif"]
 * };
 * // CSS: font-family: Arial, sans-serif;
 * ```
 *
 * @public
 */
export const fontFamilySchema = z.object({
	kind: z.literal("font-family"),
	families: z.array(z.string()).min(1),
});

export type FontFamily = z.infer<typeof fontFamilySchema>;

/**
 * CSS font-weight property IR.
 *
 * The font-weight property sets the weight (or boldness) of the font.
 * Accepts numeric values (1-1000) or keyword values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight}
 *
 * @example
 * ```typescript
 * const fontWeight: FontWeight = {
 *   kind: "font-weight",
 *   value: 700
 * };
 * // CSS: font-weight: 700;
 * ```
 *
 * @public
 */
export const fontWeightSchema = z.object({
	kind: z.literal("font-weight"),
	value: z.union([z.number().min(1).max(1000), z.enum(["normal", "bold", "bolder", "lighter"])], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <number 1-1000> | normal | bold | bolder | lighter" }
				: { message: "Invalid font-weight value" },
	}),
});

export type FontWeight = z.infer<typeof fontWeightSchema>;

/**
 * CSS line-height property IR.
 *
 * The line-height property sets the height of a line box.
 * Accepts unitless number, length, percentage, or normal keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/line-height}
 *
 * @example
 * ```typescript
 * const lineHeight: LineHeight = {
 *   kind: "line-height",
 *   value: 1.5
 * };
 * // CSS: line-height: 1.5;
 * ```
 *
 * @public
 */
export const lineHeightSchema = z.object({
	kind: z.literal("line-height"),
	value: z.union([z.number(), lengthPercentageSchema, z.literal("normal")], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <number> | <length-percentage> | normal" }
				: { message: "Invalid line-height value" },
	}),
});

export type LineHeight = z.infer<typeof lineHeightSchema>;

/**
 * CSS text-align property IR.
 *
 * The text-align property sets the horizontal alignment of the inline-level content
 * inside a block element or table-cell box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-align}
 *
 * @example
 * ```typescript
 * const textAlign: TextAlign = {
 *   kind: "text-align",
 *   value: "center"
 * };
 * // CSS: text-align: center;
 * ```
 *
 * @public
 */
export const textAlignSchema = z.object({
	kind: z.literal("text-align"),
	value: z.enum(["left", "right", "center", "justify", "start", "end"], {
		error: () => ({ message: "Expected left | right | center | justify | start | end" }),
	}),
});

export type TextAlign = z.infer<typeof textAlignSchema>;

/**
 * CSS font-style property IR.
 *
 * The font-style property sets whether a font should be styled with a normal, italic,
 * or oblique face from its font-family.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style}
 *
 * @example
 * ```typescript
 * const fontStyle: FontStyle = {
 *   kind: "font-style",
 *   value: "italic"
 * };
 * // CSS: font-style: italic;
 * ```
 *
 * @public
 */
export const fontStyleSchema = z.object({
	kind: z.literal("font-style"),
	value: z.enum(["normal", "italic", "oblique"], {
		error: () => ({ message: "Expected normal | italic | oblique" }),
	}),
});

export type FontStyle = z.infer<typeof fontStyleSchema>;

/**
 * CSS letter-spacing property IR.
 *
 * The letter-spacing property sets the horizontal spacing behavior between text characters.
 * Accepts length values or the normal keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing}
 *
 * @example
 * ```typescript
 * const letterSpacing: LetterSpacing = {
 *   kind: "letter-spacing",
 *   value: { value: 2, unit: "px" }
 * };
 * // CSS: letter-spacing: 2px;
 * ```
 *
 * @public
 */
export const letterSpacingSchema = z.object({
	kind: z.literal("letter-spacing"),
	value: z.union([lengthPercentageSchema, z.literal("normal")], {
		error: (issue) =>
			issue.code === "invalid_union"
				? { message: "Expected <length-percentage> | normal" }
				: { message: "Invalid letter-spacing value" },
	}),
});

export type LetterSpacing = z.infer<typeof letterSpacingSchema>;

/**
 * CSS text-transform property IR.
 *
 * The text-transform property specifies how to capitalize an element's text.
 * Accepts keyword values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform}
 *
 * @example
 * ```typescript
 * const textTransform: TextTransform = {
 *   kind: "text-transform",
 *   value: "uppercase"
 * };
 * // CSS: text-transform: uppercase;
 * ```
 *
 * @public
 */
export const textTransformSchema = z.object({
	kind: z.literal("text-transform"),
	value: z.enum(["none", "capitalize", "uppercase", "lowercase", "full-width", "full-size-kana"], {
		error: () => ({
			message: "Expected none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		}),
	}),
});

export type TextTransform = z.infer<typeof textTransformSchema>;

/**
 * CSS vertical-align property IR.
 *
 * The vertical-align property sets vertical alignment of an inline, inline-block or table-cell box.
 * Accepts keyword values, length, or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align}
 *
 * @example
 * ```typescript
 * const verticalAlign: VerticalAlign = {
 *   kind: "vertical-align",
 *   value: "middle"
 * };
 * // CSS: vertical-align: middle;
 * ```
 *
 * @public
 */
export const verticalAlignSchema = z.object({
	kind: z.literal("vertical-align"),
	value: z.union(
		[
			lengthPercentageSchema,
			z.enum(["baseline", "sub", "super", "text-top", "text-bottom", "middle", "top", "bottom"]),
		],
		{
			error: (issue) =>
				issue.code === "invalid_union"
					? {
							message:
								"Expected <length-percentage> | baseline | sub | super | text-top | text-bottom | middle | top | bottom",
						}
					: { message: "Invalid vertical-align value" },
		},
	),
});

export type VerticalAlign = z.infer<typeof verticalAlignSchema>;

/**
 * CSS word-break property IR.
 *
 * The word-break property sets whether line breaks appear wherever the text would otherwise overflow.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/word-break}
 *
 * @example
 * ```typescript
 * const wordBreak: WordBreak = {
 *   kind: "word-break",
 *   value: "break-all"
 * };
 * // CSS: word-break: break-all;
 * ```
 *
 * @public
 */
export const wordBreakSchema = z.object({
	kind: z.literal("word-break"),
	value: z.enum(["normal", "break-all", "keep-all", "break-word"], {
		error: () => ({ message: "Expected normal | break-all | keep-all | break-word" }),
	}),
});

export type WordBreak = z.infer<typeof wordBreakSchema>;

/**
 * CSS overflow-wrap property IR.
 *
 * The overflow-wrap property applies to inline elements, setting whether the browser should
 * insert line breaks within an otherwise unbreakable string to prevent text from overflowing.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap}
 *
 * @example
 * ```typescript
 * const overflowWrap: OverflowWrap = {
 *   kind: "overflow-wrap",
 *   value: "break-word"
 * };
 * // CSS: overflow-wrap: break-word;
 * ```
 *
 * @public
 */
export const overflowWrapSchema = z.object({
	kind: z.literal("overflow-wrap"),
	value: z.enum(["normal", "break-word", "anywhere"], {
		error: () => ({ message: "Expected normal | break-word | anywhere" }),
	}),
});

export type OverflowWrap = z.infer<typeof overflowWrapSchema>;


=== File: src/core/types/url.test.ts ===
// b_path:: src/core/types/url.test.ts

import { describe, expect, it } from "vitest";
import { type Url, urlSchema } from "./url";

describe("urlSchema", () => {
	it("validates fragment identifier", () => {
		const result = urlSchema.safeParse({ kind: "url", value: "#clip-shape" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.kind).toBe("url");
			expect(result.data.value).toBe("#clip-shape");
		}
	});

	it("validates file path", () => {
		const result = urlSchema.safeParse({ kind: "url", value: "shapes.svg#clip" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.value).toBe("shapes.svg#clip");
		}
	});

	it("validates absolute URL", () => {
		const result = urlSchema.safeParse({ kind: "url", value: "https://example.com/image.png" });
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data.value).toBe("https://example.com/image.png");
		}
	});

	it("validates data URL", () => {
		const result = urlSchema.safeParse({ kind: "url", value: "data:image/svg+xml,..." });
		expect(result.success).toBe(true);
	});

	it("rejects missing kind", () => {
		const result = urlSchema.safeParse({ value: "#test" });
		expect(result.success).toBe(false);
	});

	it("rejects wrong kind", () => {
		const result = urlSchema.safeParse({ kind: "invalid", value: "#test" });
		expect(result.success).toBe(false);
	});

	it("rejects missing value", () => {
		const result = urlSchema.safeParse({ kind: "url" });
		expect(result.success).toBe(false);
	});

	it("rejects non-string value", () => {
		const result = urlSchema.safeParse({ kind: "url", value: 123 });
		expect(result.success).toBe(false);
	});
});

describe("Url type", () => {
	it("accepts valid URL", () => {
		const url: Url = { kind: "url", value: "#clip" };
		expect(url.kind).toBe("url");
		expect(url.value).toBe("#clip");
	});
});


=== File: src/core/types/url.ts ===
// b_path:: src/core/types/url.ts

import { z } from "zod";

/**
 * CSS url() function value.
 *
 * Represents a URL reference to an external resource or SVG element.
 * Can be an absolute URL, relative URL, data URL, or hash reference.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/url_function}
 *
 * @example
 * ```typescript
 * import type { Url } from "@/core/types/url";
 *
 * // Fragment identifier (SVG reference)
 * const url1: Url = { kind: "url", value: "#clip-shape" };
 *
 * // File path
 * const url2: Url = { kind: "url", value: "shapes.svg#clip" };
 *
 * // Absolute URL
 * const url3: Url = { kind: "url", value: "https://example.com/image.png" };
 *
 * // Data URL
 * const url4: Url = { kind: "url", value: "data:image/svg+xml,..." };
 * ```
 *
 * @public
 */
export const urlSchema = z.object({
	kind: z.literal("url"),
	value: z.string(),
});

/**
 * TypeScript type for CSS url() function.
 * @public
 */
export type Url = z.infer<typeof urlSchema>;


=== File: src/core/types/visual.ts ===
// b_path:: src/core/types/visual.ts
import { z } from "zod";
import { blendModeKeywordsSchema } from "../keywords/blend-mode-keywords";

/**
 * CSS background-blend-mode property IR.
 *
 * The background-blend-mode property defines how an element's background images
 * should blend with each other and with the background color.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode}
 *
 * @example
 * ```typescript
 * const bgBlend: BackgroundBlendMode = {
 *   kind: "background-blend-mode",
 *   mode: "multiply"
 * };
 * // CSS: background-blend-mode: multiply;
 * ```
 *
 * @public
 */
export const backgroundBlendModeSchema = z.object({
	kind: z.literal("background-blend-mode"),
	mode: blendModeKeywordsSchema,
});

/**
 * TypeScript type for background-blend-mode property.
 *
 * @public
 */
export type BackgroundBlendMode = z.infer<typeof backgroundBlendModeSchema>;

/**
 * CSS mix-blend-mode property IR.
 *
 * The mix-blend-mode property defines how an element's content should blend
 * with its backdrop (the content of the element's parent and the element's background).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode}
 *
 * @example
 * ```typescript
 * const mixBlend: MixBlendMode = {
 *   kind: "mix-blend-mode",
 *   mode: "screen"
 * };
 * // CSS: mix-blend-mode: screen;
 * ```
 *
 * @public
 */
export const mixBlendModeSchema = z.object({
	kind: z.literal("mix-blend-mode"),
	mode: blendModeKeywordsSchema,
});

/**
 * TypeScript type for mix-blend-mode property.
 *
 * @public
 */
export type MixBlendMode = z.infer<typeof mixBlendModeSchema>;


=== File: src/core/units/angle.test.ts ===
// b_path:: src/core/units/angle.test.ts
import { describe, expect, it } from "vitest";
import { ANGLE_UNITS, angleUnitSchema } from "./angle";

describe("angle units", () => {
	it("exports angle units array", () => {
		expect(ANGLE_UNITS).toEqual(["deg", "grad", "rad", "turn"]);
	});

	it("validates 'deg' unit", () => {
		const result = angleUnitSchema.safeParse("deg");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("deg");
		}
	});

	it("validates 'grad' unit", () => {
		const result = angleUnitSchema.safeParse("grad");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("grad");
		}
	});

	it("validates 'rad' unit", () => {
		const result = angleUnitSchema.safeParse("rad");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("rad");
		}
	});

	it("validates 'turn' unit", () => {
		const result = angleUnitSchema.safeParse("turn");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("turn");
		}
	});

	it("rejects invalid unit", () => {
		const result = angleUnitSchema.safeParse("degree");
		expect(result.success).toBe(false);
	});

	it("rejects empty string", () => {
		const result = angleUnitSchema.safeParse("");
		expect(result.success).toBe(false);
	});
});


=== File: src/core/units/angle.ts ===
// b_path:: src/core/units/angle.ts
import { z } from "zod";

export const angleUnitSchema = z
	.union(
		[
			z.literal("deg").describe("degrees - one full circle is 360deg"),
			z.literal("grad").describe("gradians - one full circle is 400grad"),
			z.literal("rad").describe("radians - one full circle is 2π radians (≈6.2832rad)"),
			z.literal("turn").describe("turns - one full circle is 1turn"),
		],
		{
			error: (issue) =>
				issue.code === "invalid_union"
					? 'Invalid angle unit. Expected "deg", "grad", "rad", or "turn".'
					: "Invalid input",
		},
	)
	.describe(
		"Angle units specify rotation or direction." +
			"Used in transforms, gradients, and other CSS properties requiring angular measurements.",
	);

export const ANGLE_UNITS = angleUnitSchema.options.map((option) => option.value);

export type AngleUnit = z.infer<typeof angleUnitSchema>;

export const angleUnitOptions = angleUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type AngleUnitOptions = typeof angleUnitOptions;


=== File: src/core/units/frequency.test.ts ===
// b_path:: src/core/units/frequency.test.ts
import { describe, expect, it } from "vitest";
import { FREQUENCY_UNITS, frequencyUnitSchema } from "./frequency";

describe("frequency units", () => {
	it("exports frequency units array", () => {
		expect(FREQUENCY_UNITS).toEqual(["Hz", "kHz"]);
	});

	it("validates 'Hz' unit", () => {
		const result = frequencyUnitSchema.safeParse("Hz");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("Hz");
		}
	});

	it("validates 'kHz' unit", () => {
		const result = frequencyUnitSchema.safeParse("kHz");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("kHz");
		}
	});

	it("rejects invalid unit", () => {
		const result = frequencyUnitSchema.safeParse("MHz");
		expect(result.success).toBe(false);
	});

	it("rejects empty string", () => {
		const result = frequencyUnitSchema.safeParse("");
		expect(result.success).toBe(false);
	});

	it("is case-sensitive", () => {
		const result = frequencyUnitSchema.safeParse("hz");
		expect(result.success).toBe(false);
	});
});


=== File: src/core/units/frequency.ts ===
// b_path:: src/core/units/frequency.ts
import { z } from "zod";

export const frequencyUnitSchema = z
	.union(
		[
			z.literal("Hz").describe("hertz - number of occurrences per second (canonical unit)"),
			z.literal("kHz").describe("kilohertz - 1000 hertz"),
		],
		{
			error: (issue) =>
				issue.code === "invalid_union" ? 'Invalid frequency unit. Expected "Hz" or "kHz".' : "Invalid input",
		},
	)
	.describe(
		"Frequency units specify the number of occurrences per second." +
			"Used for sound pitches and other frequency-based CSS properties.",
	);

export const FREQUENCY_UNITS = frequencyUnitSchema.options.map((option) => option.value);

export type FrequencyUnit = z.infer<typeof frequencyUnitSchema>;

export const frequencyUnitOptions = frequencyUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type FrequencyUnitOptions = typeof frequencyUnitOptions;


=== File: src/core/units/index.ts ===
// b_path:: src/core/units/index.ts

export * from "./angle";
export * from "./frequency";
export * from "./length.absolute";
export * from "./length.font";
export * from "./length.viewport";
export * from "./percentage";
export * from "./time";


=== File: src/core/units/length.absolute.ts ===
// b_path:: src/core/units/length.absolute.ts
import { z } from "zod";

/**
 * CSS absolute length unit identifiers.
 *
 * Absolute length units specify a length using physical units.
 * These units are fixed and do not scale relative to other elements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#absolute_length_units}
 *
 * @example
 * ```typescript
 * import { absoluteLengthUnitSchema } from "@/core/units/length.absolute";
 *
 * const unit = absoluteLengthUnitSchema.parse("px"); // "px"
 * ```
 *
 * @public
 */
export const absoluteLengthUnitSchema = z
	.union(
		[
			z.literal("px").describe("pixels - 1/96th of 1 inch"),
			z.literal("pt").describe("points - 1/72nd of 1 inch"),
			z.literal("cm").describe("centimeters"),
			z.literal("mm").describe("millimeters"),
			z.literal("Q").describe("quarter-millimeters - 1/40th of 1 centimeter"),
			z.literal("in").describe("inches - 2.54 centimeters"),
			z.literal("pc").describe("picas - 12 points"),
		],
		{
			error: (issue) =>
				issue.code === "invalid_union"
					? 'Invalid absolute length unit. Expected "px", "pt", "cm", "mm", "Q", "in", or "pc".'
					: "Invalid input",
		},
	)
	.describe(
		"Absolute length units specify a length using physical units. " +
			"These units are fixed and do not scale relative to other elements.",
	);

/**
 * Array of all absolute length unit values.
 *
 * @example
 * ```typescript
 * import { ABSOLUTE_LENGTH_UNITS } from "@/core/units/length.absolute";
 *
 * console.log(ABSOLUTE_LENGTH_UNITS); // ["px", "pt", "cm", "mm", "Q", "in", "pc"]
 * ```
 *
 * @public
 */
export const ABSOLUTE_LENGTH_UNITS = absoluteLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for absolute length units.
 *
 * @public
 */
export type AbsoluteLengthUnit = z.infer<typeof absoluteLengthUnitSchema>;

/**
 * Metadata for absolute length unit options.
 *
 * Provides value and description for each absolute length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { absoluteLengthUnitOptions } from "@/core/units/length.absolute";
 *
 * absoluteLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const absoluteLengthUnitOptions = absoluteLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for absolute length unit options metadata.
 *
 * @public
 */
export type AbsoluteLengthUnitOptions = typeof absoluteLengthUnitOptions;


=== File: src/core/units/length.font.ts ===
// b_path:: src/core/units/length.font.ts
import { z } from "zod";

/**
 * CSS font-relative length unit identifiers.
 *
 * Font-relative length units specify a length relative to font metrics.
 * These units allow measurements based on typography and text characteristics.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#font-relative_lengths}
 *
 * @example
 * ```typescript
 * import { fontLengthUnitSchema } from "@/core/units/length.font";
 *
 * const unit = fontLengthUnitSchema.parse("em"); // "em"
 * ```
 *
 * @public
 */
export const fontLengthUnitSchema = z
	.union(
		[
			z.literal("em").describe("font size of the element"),
			z.literal("ex").describe("x-height of the element's font"),
			z.literal("cap").describe("cap height of capital letters"),
			z.literal("ch").describe("typical character advance of a narrow glyph"),
			z.literal("ic").describe("typical character advance of a fullwidth glyph"),
			z.literal("rem").describe("font size of the root element"),
			z.literal("rex").describe("x-height of the root element's font"),
			z.literal("rcap").describe("cap height of the root element's font"),
			z.literal("rch").describe("typical character advance of a narrow glyph in root element"),
			z.literal("ric").describe("typical character advance of a fullwidth glyph in root element"),
			z.literal("lh").describe("line height of the element"),
			z.literal("rlh").describe("line height of the root element"),
		],
		{
			error: (issue) =>
				issue.code === "invalid_union"
					? 'Invalid font-relative length unit. Expected "em", "ex", "cap", "ch", "ic", "rem", "rex", "rcap", "rch", "ric", "lh", or "rlh".'
					: "Invalid input",
		},
	)
	.describe(
		"Font-relative length units specify a length relative to font metrics. " +
			"These units allow measurements based on typography and text characteristics.",
	);

/**
 * Array of all font-relative length unit values.
 *
 * @example
 * ```typescript
 * import { FONT_LENGTH_UNITS } from "@/core/units/length.font";
 *
 * console.log(FONT_LENGTH_UNITS); // ["em", "ex", "cap", ...]
 * ```
 *
 * @public
 */
export const FONT_LENGTH_UNITS = fontLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-relative length units.
 *
 * @public
 */
export type FontLengthUnit = z.infer<typeof fontLengthUnitSchema>;

/**
 * Metadata for font-relative length unit options.
 *
 * Provides value and description for each font-relative length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { fontLengthUnitOptions } from "@/core/units/length.font";
 *
 * fontLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const fontLengthUnitOptions = fontLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-relative length unit options metadata.
 *
 * @public
 */
export type FontLengthUnitOptions = typeof fontLengthUnitOptions;


=== File: src/core/units/length.viewport.ts ===
// b_path:: src/core/units/length.viewport.ts
import { z } from "zod";

/**
 * CSS viewport-percentage length unit identifiers.
 *
 * Viewport-percentage length units are relative to the size of the initial containing block.
 * They provide different sizing strategies for responsive design across various viewport states.
 *
 * Includes default (large), small, large (explicit), and dynamic viewport units.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#viewport-percentage_lengths}
 *
 * @example
 * ```typescript
 * import { viewportLengthUnitSchema } from "@/core/units/length.viewport";
 *
 * const unit = viewportLengthUnitSchema.parse("vw"); // "vw"
 * ```
 *
 * @public
 */
export const viewportLengthUnitSchema = z
	.union(
		[
			// Default/Large viewport units
			z
				.literal("vw")
				.describe("1% of the width of the large viewport size"),
			z.literal("vh").describe("1% of the height of the large viewport size"),
			z.literal("vi").describe("1% of the large viewport size in the inline axis"),
			z.literal("vb").describe("1% of the large viewport size in the block axis"),
			z.literal("vmin").describe("smaller of vw or vh"),
			z.literal("vmax").describe("larger of vw or vh"),

			// Small viewport units
			z
				.literal("svw")
				.describe("1% of the width of the small viewport size"),
			z.literal("svh").describe("1% of the height of the small viewport size"),
			z.literal("svi").describe("1% of the small viewport size in the inline axis"),
			z.literal("svb").describe("1% of the small viewport size in the block axis"),
			z.literal("svmin").describe("smaller of svw or svh"),
			z.literal("svmax").describe("larger of svw or svh"),

			// Large viewport units (explicit)
			z
				.literal("lvw")
				.describe("1% of the width of the large viewport size"),
			z.literal("lvh").describe("1% of the height of the large viewport size"),
			z.literal("lvi").describe("1% of the large viewport size in the inline axis"),
			z.literal("lvb").describe("1% of the large viewport size in the block axis"),
			z.literal("lvmin").describe("smaller of lvw or lvh"),
			z.literal("lvmax").describe("larger of lvw or lvh"),

			// Dynamic viewport units
			z
				.literal("dvw")
				.describe("1% of the width of the dynamic viewport size"),
			z.literal("dvh").describe("1% of the height of the dynamic viewport size"),
			z.literal("dvi").describe("1% of the dynamic viewport size in the inline axis"),
			z.literal("dvb").describe("1% of the dynamic viewport size in the block axis"),
			z.literal("dvmin").describe("smaller of dvw or dvh"),
			z.literal("dvmax").describe("larger of dvw or dvh"),
		],
		{
			error: (issue) =>
				issue.code === "invalid_union"
					? "Invalid viewport length unit. Expected standard (vw/vh/vi/vb/vmin/vmax), small (sv*), large (lv*), or dynamic (dv*) viewport units."
					: "Invalid input",
		},
	)
	.describe(
		"Viewport-percentage length units are relative to the size of the initial containing block. " +
			"They provide different sizing strategies for responsive design across various viewport states.",
	);

/**
 * Array of all viewport-percentage length unit values.
 *
 * @example
 * ```typescript
 * import { VIEWPORT_LENGTH_UNITS } from "@/core/units/length.viewport";
 *
 * console.log(VIEWPORT_LENGTH_UNITS); // ["vw", "vh", "vi", ...]
 * ```
 *
 * @public
 */
export const VIEWPORT_LENGTH_UNITS = viewportLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for viewport-percentage length units.
 *
 * @public
 */
export type ViewportLengthUnit = z.infer<typeof viewportLengthUnitSchema>;

/**
 * Metadata for viewport-percentage length unit options.
 *
 * Provides value and description for each viewport-percentage length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { viewportLengthUnitOptions } from "@/core/units/length.viewport";
 *
 * viewportLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const viewportLengthUnitOptions = viewportLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for viewport-percentage length unit options metadata.
 *
 * @public
 */
export type ViewportLengthUnitOptions = typeof viewportLengthUnitOptions;


=== File: src/core/units/percentage.ts ===
// b_path:: src/core/units/percentage.ts
import { z } from "zod";

/**
 * CSS percentage unit identifier.
 *
 * The percentage unit `%` represents a fraction of some reference value.
 * The reference value depends on the property using the percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/percentage}
 *
 * @example
 * ```typescript
 * import { percentageUnitSchema } from "@/core/units/percentage";
 *
 * const unit = percentageUnitSchema.parse("%"); // "%"
 * ```
 *
 * @public
 */
export const percentageUnitSchema = z
	.literal("%")
	.describe("percentage sign - represents a fraction of some reference value");

/**
 * CSS `<percentage>` dimension.
 *
 * A percentage consists of a number followed by the percentage sign (%).
 * May be preceded by + or - sign, with no space between symbol and number.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/percentage}
 *
 * @example
 * ```typescript
 * import { percentageSchema, type Percentage } from "@/core/units/percentage";
 *
 * const size: Percentage = { value: 50, unit: "%" };
 * const opacity: Percentage = { value: 75, unit: "%" };
 *
 * // Validate
 * percentageSchema.parse({ value: 100, unit: "%" }); // Valid
 * ```
 *
 * @public
 */
export const percentageSchema = z
	.object({
		value: z.number().describe("numeric value of the percentage"),
		unit: percentageUnitSchema,
	})
	.describe(
		"Percentage data type consists of a number followed by the percentage sign (%). " +
			"May be preceded by + or - sign, with no space between symbol and number.",
	);

/**
 * Constant for the percentage unit value.
 *
 * @example
 * ```typescript
 * import { PERCENTAGE_UNIT } from "@/core/units/percentage";
 *
 * console.log(PERCENTAGE_UNIT); // "%"
 * ```
 *
 * @public
 */
export const PERCENTAGE_UNIT = percentageUnitSchema.value;

/**
 * TypeScript type for percentage unit.
 *
 * @public
 */
export type PercentageUnit = z.infer<typeof percentageUnitSchema>;

/**
 * TypeScript type for percentage dimension.
 *
 * @public
 */
export type Percentage = z.infer<typeof percentageSchema>;

/**
 * Metadata for percentage unit option.
 *
 * Provides value and description for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { percentageUnitOptions } from "@/core/units/percentage";
 *
 * percentageUnitOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const percentageUnitOptions = [
	{
		value: percentageUnitSchema.value,
		description: percentageUnitSchema.description,
	},
];

/**
 * Type for percentage unit options metadata.
 *
 * @public
 */
export type PercentageUnitOptions = typeof percentageUnitOptions;


=== File: src/core/units/time.test.ts ===
// b_path:: src/core/units/time.test.ts
import { describe, expect, it } from "vitest";
import { TIME_UNITS, timeUnitSchema } from "./time";

describe("time units", () => {
	it("exports time units array", () => {
		expect(TIME_UNITS).toEqual(["s", "ms"]);
	});

	it("validates 's' unit", () => {
		const result = timeUnitSchema.safeParse("s");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("s");
		}
	});

	it("validates 'ms' unit", () => {
		const result = timeUnitSchema.safeParse("ms");
		expect(result.success).toBe(true);
		if (result.success) {
			expect(result.data).toBe("ms");
		}
	});

	it("rejects invalid unit", () => {
		const result = timeUnitSchema.safeParse("sec");
		expect(result.success).toBe(false);
	});

	it("rejects empty string", () => {
		const result = timeUnitSchema.safeParse("");
		expect(result.success).toBe(false);
	});
});


=== File: src/core/units/time.ts ===
// b_path:: src/core/units/time.ts
import { z } from "zod";

export const timeUnitSchema = z
	.union(
		[
			z.literal("s").describe("seconds - canonical time unit"),
			z.literal("ms").describe("milliseconds - 1000 milliseconds in a second"),
		],
		{
			error: (issue) => (issue.code === "invalid_union" ? 'Invalid unit. Expected "s" or "ms".' : "Invalid input"),
		},
	)
	.describe(
		"Time units specify duration or delay." + "Used in animations, transitions, and other time-based CSS properties.",
	);

export const TIME_UNITS = timeUnitSchema.options.map((option) => option.value);

export type TimeUnit = z.infer<typeof timeUnitSchema>;

export const timeUnitOptions = timeUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type TimeUnitOptions = typeof timeUnitOptions;


=== File: src/generate/animation/animation.test.ts ===
// b_path:: src/generate/animation/animation.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./animation";

describe("animation generator (dispatcher)", () => {
	test("should dispatch animation-delay", () => {
		const result = generate({
			kind: "animation-delay",
			delays: [{ value: 500, unit: "ms" }],
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("500ms");
	});

	test("should dispatch animation-direction", () => {
		const result = generate({
			kind: "animation-direction",
			directions: ["normal"],
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("normal");
	});

	test("should dispatch animation-duration", () => {
		const result = generate({
			kind: "animation-duration",
			durations: [{ type: "time", value: 2, unit: "s" }],
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("2s");
	});

	test("should dispatch animation-fill-mode", () => {
		const result = generate({
			kind: "animation-fill-mode",
			modes: ["forwards"],
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("forwards");
	});

	test("should dispatch animation-iteration-count", () => {
		const result = generate({
			kind: "animation-iteration-count",
			counts: [{ type: "infinite" }],
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("infinite");
	});

	test("should dispatch animation-name", () => {
		const result = generate({
			kind: "animation-name",
			names: [{ type: "identifier", value: "fadeIn" }],
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("fadeIn");
	});

	test("should dispatch animation-play-state", () => {
		const result = generate({
			kind: "animation-play-state",
			states: ["paused"],
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("paused");
	});

	test("should dispatch animation-timing-function", () => {
		const result = generate({
			kind: "animation-timing-function",
			functions: ["ease-in-out"],
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("ease-in-out");
	});

	test("should error on missing kind", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate({} as any);
		expect(result.ok).toBe(false);
		if (!result.ok) expect(result.issues?.[0]?.message).toContain("missing 'kind' field");
	});

	test("should error on invalid kind", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate({ kind: "animation-invalid" } as any);
		expect(result.ok).toBe(false);
		if (!result.ok) expect(result.issues?.[0]?.message).toContain("Unknown animation kind");
	});
});


=== File: src/generate/animation/animation.ts ===
// b_path:: src/generate/animation/animation.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types/animation";
import * as Delay from "./delay";
import * as Direction from "./direction";
import * as Duration from "./duration";
import * as FillMode from "./fill-mode";
import * as IterationCount from "./iteration-count";
import * as Name from "./name";
import * as PlayState from "./play-state";
import * as TimingFunction from "./timing-function";

/**
 * Animation property type union.
 *
 * @public
 */
export type Animation =
	| Type.AnimationDelay
	| Type.AnimationDirection
	| Type.AnimationDuration
	| Type.AnimationFillMode
	| Type.AnimationIterationCount
	| Type.AnimationName
	| Type.AnimationPlayState
	| Type.AnimationTimingFunction;

/**
 * Generate CSS from animation property IR with auto-detection.
 *
 * Automatically detects animation property type from IR.kind and generates appropriate CSS.
 * Supports all animation longhand properties.
 *
 * @param animation - Animation property IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Animation duration:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Animation.generate({
 *   kind: "animation-duration",
 *   durations: [{ type: "time", value: 1, unit: "s" }]
 * });
 * // → { ok: true, value: "1s", issues: [] }
 * ```
 *
 * @example
 * Animation delay:
 * ```typescript
 * const result = Generate.Animation.generate({
 *   kind: "animation-delay",
 *   delays: [{ value: 500, unit: "ms" }]
 * });
 * // → { ok: true, value: "500ms", issues: [] }
 * ```
 *
 * @example
 * Animation timing function:
 * ```typescript
 * const result = Generate.Animation.generate({
 *   kind: "animation-timing-function",
 *   functions: [{ type: "keyword", value: "ease-in-out" }]
 * });
 * // → { ok: true, value: "ease-in-out", issues: [] }
 * ```
 *
 * @example
 * Animation iteration count:
 * ```typescript
 * const result = Generate.Animation.generate({
 *   kind: "animation-iteration-count",
 *   counts: [{ type: "infinite" }]
 * });
 * // → { ok: true, value: "infinite", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Animation.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid animation IR: missing 'kind' field" }] }
 * ```
 *
 * @public
 */
export function generate(animation: Animation): GenerateResult {
	// Validate IR has 'kind' field
	if (!animation || typeof animation !== "object" || !("kind" in animation)) {
		return generateErr("missing-required-field", "Invalid animation IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (animation.kind) {
		case "animation-delay":
			return Delay.generate(animation);

		case "animation-direction":
			return Direction.generate(animation);

		case "animation-duration":
			return Duration.generate(animation);

		case "animation-fill-mode":
			return FillMode.generate(animation);

		case "animation-iteration-count":
			return IterationCount.generate(animation);

		case "animation-name":
			return Name.generate(animation);

		case "animation-play-state":
			return PlayState.generate(animation);

		case "animation-timing-function":
			return TimingFunction.generate(animation);

		default:
			return generateErr("unsupported-kind", `Unknown animation kind: ${(animation as { kind?: string }).kind}`, {
				suggestion:
					"Expected one of: animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, or animation-timing-function. Check that animation IR is valid.",
			});
	}
}


=== File: src/generate/animation/delay.failure.test.ts ===
// b_path:: src/generate/animation/delay.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/delay.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-delay
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/animation/delay";

describe("generate/animation/delay - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-unit", () => {
		it("should reject invalid unit px", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-delay",
				delays: [
					{
						value: 1,
						unit: "px",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('delays[0].unit: Invalid unit. Expected "s" or "ms".');
		});

		it("should reject invalid unit em", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-delay",
				delays: [
					{
						value: 1,
						unit: "em",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('delays[0].unit: Invalid unit. Expected "s" or "ms".');
		});
	});

	describe("invalid-value-type", () => {
		it("should reject string value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-delay",
				delays: [
					{
						value: "oops",
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("delays[0].value: Invalid input: expected number, received string");
		});

		it("should reject null value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-delay",
				delays: [
					{
						value: null,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("delays[0].value: Invalid input: expected number, received null");
		});
	});

	describe("invalid-missing", () => {
		it("should reject missing value field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-delay",
				delays: [
					{
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("delays[0].value: Invalid input: expected number, received undefined");
		});

		it("should reject missing unit field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-delay",
				delays: [
					{
						value: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('delays[0].unit: Invalid unit. Expected "s" or "ms".');
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty delays array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-delay",
				delays: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("delays: Too small: expected array to have >=1 items");
		});
	});
});


=== File: src/generate/animation/delay.test.ts ===
// b_path:: src/generate/animation/delay.test.ts
// Auto-generated from scripts/generate-test-generator/configs/animation/delay.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-delay
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/animation/delay";
import * as Parser from "@/parse/animation/delay";

describe("generate/animation/delay - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate single delay in seconds", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate single delay in milliseconds", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-edge", () => {
		it("should generate zero delay", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 0,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-negative", () => {
		it("should generate negative delay", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: -1,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("-1s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate negative delay in milliseconds", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: -500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("-500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-decimal", () => {
		it("should generate decimal seconds", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 0.5,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.5s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate decimal seconds with integer part", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 1.5,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1.5s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate decimal milliseconds", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 0.25,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.25ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-large", () => {
		it("should generate very large delay", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 10000,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("10000s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-list", () => {
		it("should generate multiple delays", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
					{
						value: 500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s, 500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple time values", () => {
			const input: Type.AnimationDelay = {
				kind: "animation-delay",
				delays: [
					{
						value: 0,
						unit: "s",
					},
					{
						value: 1,
						unit: "s",
					},
					{
						value: 2,
						unit: "s",
					},
					{
						value: 3,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0s, 1s, 2s, 3s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/animation/delay.ts ===
// b_path:: src/generate/animation/delay.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { animationDelaySchema } from "@/core/types/animation";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS animation-delay property value from IR.
 *
 * Converts AnimationDelay IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationDelay IR object
 * @returns CSS animation-delay value string
 *
 * @example
 * Single delay:
 * ```typescript
 * const css = toCss({ kind: "animation-delay", delays: [{ value: 1, unit: "s" }] });
 * // "1s"
 * ```
 *
 * @example
 * Multiple delays:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-delay",
 *   delays: [
 *     { value: 1, unit: "s" },
 *     { value: 500, unit: "ms" },
 *     { value: 2, unit: "s" }
 *   ]
 * });
 * // "1s, 500ms, 2s"
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay | MDN: animation-delay}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-delay | W3C Spec}
 */
export function generate(ir: Type.AnimationDelay): GenerateResult {
	// Validate IR with Zod schema
	const validation = animationDelaySchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(ir.delays.map((time) => `${time.value}${time.unit}`).join(", "));
}


=== File: src/generate/animation/direction.failure.test.ts ===
// b_path:: src/generate/animation/direction.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/direction.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-direction
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/animation/direction";

describe("generate/animation/direction - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind literal", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				directions: ["normal"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "animation-direction"');
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid direction keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-direction",
				directions: ["invalid"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'directions[0]: Invalid option: expected one of "normal"|"reverse"|"alternate"|"alternate-reverse"',
			);
		});

		it("should reject fill-mode keyword instead of direction", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-direction",
				directions: ["forwards"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'directions[0]: Invalid option: expected one of "normal"|"reverse"|"alternate"|"alternate-reverse"',
			);
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty directions array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-direction",
				directions: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("directions: Too small: expected array to have >=1 items");
		});
	});

	describe("invalid-type", () => {
		it("should reject string instead of array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-direction",
				directions: "normal",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("directions: Invalid input: expected array, received string");
		});

		it("should reject number instead of string", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-direction",
				directions: [123],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'directions[0]: Invalid option: expected one of "normal"|"reverse"|"alternate"|"alternate-reverse"',
			);
		});
	});
});


=== File: src/generate/animation/direction.test.ts ===
// b_path:: src/generate/animation/direction.test.ts
// Auto-generated from scripts/generate-test-generator/configs/animation/direction.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-direction
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/animation/direction";
import * as Parser from "@/parse/animation/direction";

describe("generate/animation/direction - valid cases", () => {
	describe("valid-single", () => {
		it("should generate normal direction", () => {
			const input: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["normal"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("normal");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate reverse direction", () => {
			const input: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["reverse"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("reverse");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate alternate direction", () => {
			const input: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["alternate"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("alternate");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate alternate-reverse direction", () => {
			const input: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["alternate-reverse"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("alternate-reverse");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-multiple", () => {
		it("should generate two directions", () => {
			const input: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["normal", "reverse"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("normal, reverse");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate all four direction keywords", () => {
			const input: Type.AnimationDirection = {
				kind: "animation-direction",
				directions: ["normal", "reverse", "alternate", "alternate-reverse"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("normal, reverse, alternate, alternate-reverse");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/animation/direction.ts ===
// b_path:: src/generate/animation/direction.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { animationDirectionSchema } from "@/core/types/animation";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS animation-direction property value from IR.
 *
 * Converts AnimationDirection IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationDirection IR object
 * @returns CSS animation-direction value string
 *
 * @example
 * Single direction:
 * ```typescript
 * const css = toCss({ kind: "animation-direction", directions: ["normal"] });
 * // "normal"
 * ```
 *
 * @example
 * Multiple directions:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-direction",
 *   directions: ["normal", "reverse", "alternate"]
 * });
 * // "normal, reverse, alternate"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction | MDN: animation-direction}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-direction | W3C Spec}
 */
export function generate(ir: Type.AnimationDirection): GenerateResult {
	// Validate IR with Zod schema
	const validation = animationDirectionSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(ir.directions.join(", "));
}


=== File: src/generate/animation/duration.failure.test.ts ===
// b_path:: src/generate/animation/duration.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/duration.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-duration
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/animation/duration";

describe("generate/animation/duration - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-unit", () => {
		it("should reject invalid unit px", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "px",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('durations[0].unit: Invalid unit. Expected "s" or "ms".');
		});

		it("should reject invalid unit em", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "em",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('durations[0].unit: Invalid unit. Expected "s" or "ms".');
		});
	});

	describe("invalid-negative", () => {
		it("should reject negative value in seconds", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: -1,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("durations[0].value: Time value must be non-negative");
		});

		it("should reject negative value in milliseconds", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: -500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("durations[0].value: Time value must be non-negative");
		});
	});

	describe("invalid-value-type", () => {
		it("should reject string value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: "oops",
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("durations[0].value: Invalid input: expected number, received string");
		});

		it("should reject null value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: null,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("durations[0].value: Invalid input: expected number, received null");
		});
	});

	describe("invalid-type", () => {
		it("should reject invalid duration type", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				durations: [
					{
						type: "invalid",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid IR structure");
		});
	});
});


=== File: src/generate/animation/duration.test.ts ===
// b_path:: src/generate/animation/duration.test.ts
// Auto-generated from scripts/generate-test-generator/configs/animation/duration.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-duration
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/animation/duration";
import * as Parser from "@/parse/animation/duration";

describe("generate/animation/duration - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate single time value in seconds", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate single time value in milliseconds", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-keyword", () => {
		it("should generate auto keyword", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "auto",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("auto");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-edge", () => {
		it("should generate zero duration", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 0,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate zero duration in ms", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 0,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-decimal", () => {
		it("should generate decimal values", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 0.5,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.5s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate decimal seconds", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 2.5,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("2.5s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate decimal milliseconds", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 100.5,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("100.5ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-large", () => {
		it("should generate large values", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 3600,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("3600s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-list", () => {
		it("should generate multiple durations", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "s",
					},
					{
						type: "auto",
					},
					{
						type: "time",
						value: 500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s, auto, 500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple time values", () => {
			const input: Type.AnimationDuration = {
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "s",
					},
					{
						type: "time",
						value: 2,
						unit: "s",
					},
					{
						type: "time",
						value: 3,
						unit: "s",
					},
					{
						type: "time",
						value: 4,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s, 2s, 3s, 4s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/animation/duration.ts ===
// b_path:: src/generate/animation/duration.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { animationDurationSchema } from "@/core/types/animation";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS animation-duration property value from IR.
 *
 * Converts AnimationDuration IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationDuration IR object
 * @returns CSS animation-duration value string
 *
 * @example
 * Time duration:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-duration",
 *   durations: [{ type: "time", value: 1, unit: "s" }]
 * });
 * // "1s"
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-duration",
 *   durations: [{ type: "auto" }]
 * });
 * // "auto"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration | MDN: animation-duration}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-duration | W3C Spec}
 */
export function generate(ir: Type.AnimationDuration): GenerateResult {
	// Validate IR with Zod schema
	const validation = animationDurationSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array

		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	const values = ir.durations
		.map((duration) => {
			if (duration.type === "auto") {
				return "auto";
			}
			return `${duration.value}${duration.unit}`;
		})
		.join(", ");
	return generateOk(values);
}


=== File: src/generate/animation/fill-mode.failure.test.ts ===
// b_path:: src/generate/animation/fill-mode.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/fill-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-fill-mode
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/animation/fill-mode";

describe("generate/animation/fill-mode - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind literal", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-direction",
				modes: ["none"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "animation-fill-mode"');
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid fill mode keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-fill-mode",
				modes: ["invalid"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'modes[0]: Invalid option: expected one of "none"|"forwards"|"backwards"|"both"',
			);
		});

		it("should reject direction keyword instead of fill-mode", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-fill-mode",
				modes: ["normal"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'modes[0]: Invalid option: expected one of "none"|"forwards"|"backwards"|"both"',
			);
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty modes array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-fill-mode",
				modes: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("modes: Too small: expected array to have >=1 items");
		});
	});

	describe("invalid-type", () => {
		it("should reject string instead of array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-fill-mode",
				modes: "none",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("modes: Invalid input: expected array, received string");
		});

		it("should reject boolean instead of string", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-fill-mode",
				modes: [true],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'modes[0]: Invalid option: expected one of "none"|"forwards"|"backwards"|"both"',
			);
		});
	});
});


=== File: src/generate/animation/fill-mode.test.ts ===
// b_path:: src/generate/animation/fill-mode.test.ts
// Auto-generated from scripts/generate-test-generator/configs/animation/fill-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-fill-mode
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/animation/fill-mode";
import * as Parser from "@/parse/animation/fill-mode";

describe("generate/animation/fill-mode - valid cases", () => {
	describe("valid-single", () => {
		it("should generate none fill mode", () => {
			const input: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["none"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate forwards fill mode", () => {
			const input: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["forwards"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("forwards");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate backwards fill mode", () => {
			const input: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["backwards"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("backwards");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate both fill mode", () => {
			const input: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["both"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("both");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-multiple", () => {
		it("should generate two fill modes", () => {
			const input: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["none", "forwards"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none, forwards");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate all four fill mode keywords", () => {
			const input: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["none", "forwards", "backwards", "both"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none, forwards, backwards, both");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate repeated keywords", () => {
			const input: Type.AnimationFillMode = {
				kind: "animation-fill-mode",
				modes: ["forwards", "forwards", "backwards"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("forwards, forwards, backwards");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/animation/fill-mode.ts ===
// b_path:: src/generate/animation/fill-mode.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { animationFillModeSchema } from "@/core/types/animation";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS animation-fill-mode property value from IR.
 *
 * Converts AnimationFillMode IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationFillMode IR object
 * @returns CSS animation-fill-mode value string
 *
 * @example
 * Single fill mode:
 * ```typescript
 * const css = toCss({ kind: "animation-fill-mode", modes: ["forwards"] });
 * // "forwards"
 * ```
 *
 * @example
 * Multiple fill modes:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-fill-mode",
 *   modes: ["none", "forwards", "both"]
 * });
 * // "none, forwards, both"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode | MDN: animation-fill-mode}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-fill-mode | W3C Spec}
 */
export function generate(ir: Type.AnimationFillMode): GenerateResult {
	// Validate IR with Zod schema
	const validation = animationFillModeSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(ir.modes.join(", "));
}


=== File: src/generate/animation/index.ts ===
// b_path:: src/generate/animation/index.ts

export { generate } from "./animation";

export * as Delay from "./delay";
export * as Direction from "./direction";
export * as Duration from "./duration";
export * as FillMode from "./fill-mode";
export * as IterationCount from "./iteration-count";
export * as Name from "./name";
export * as PlayState from "./play-state";
export * as TimingFunction from "./timing-function";


=== File: src/generate/animation/iteration-count.failure.test.ts ===
// b_path:: src/generate/animation/iteration-count.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/iteration-count.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-iteration-count
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/animation/iteration-count";

describe("generate/animation/iteration-count - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-negative", () => {
		it("should reject negative iteration count", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: -1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("counts[0].value: Too small: expected number to be >=0");
		});

		it("should reject negative decimal iteration count", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: -5.5,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("counts[0].value: Too small: expected number to be >=0");
		});
	});

	describe("invalid-type", () => {
		it("should reject invalid type keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "invalid",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'counts[0]: Invalid iteration count. Expected { type: "infinite" } or { type: "number", value: <non-negative number> }.',
			);
		});

		it("should reject string value instead of number", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: "three",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'counts[0]: Invalid iteration count. Expected { type: "infinite" } or { type: "number", value: <non-negative number> }.',
			);
		});
	});

	describe("invalid-missing", () => {
		it("should reject missing value field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'counts[0]: Invalid iteration count. Expected { type: "infinite" } or { type: "number", value: <non-negative number> }.',
			);
		});

		it("should reject missing type field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-iteration-count",
				counts: [
					{
						value: 5,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'counts[0]: Invalid iteration count. Expected { type: "infinite" } or { type: "number", value: <non-negative number> }.',
			);
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty counts array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-iteration-count",
				counts: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("counts: Too small: expected array to have >=1 items");
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind literal", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				counts: [
					{
						type: "infinite",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "animation-iteration-count"');
		});
	});
});


=== File: src/generate/animation/iteration-count.test.ts ===
// b_path:: src/generate/animation/iteration-count.test.ts
// Auto-generated from scripts/generate-test-generator/configs/animation/iteration-count.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-iteration-count
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/animation/iteration-count";
import * as Parser from "@/parse/animation/iteration-count";

describe("generate/animation/iteration-count - valid cases", () => {
	describe("valid-keyword", () => {
		it("should generate infinite keyword", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "infinite",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("infinite");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-number", () => {
		it("should generate single iteration", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple iterations", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 3,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("3");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate zero iterations", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 0,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-decimal", () => {
		it("should generate decimal iterations", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 2.5,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("2.5");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate half iteration", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 0.5,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.5");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-large", () => {
		it("should generate very large count", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 1000,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1000");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-list", () => {
		it("should generate mixed number and infinite", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 1,
					},
					{
						type: "infinite",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1, infinite");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple mixed values", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 2,
					},
					{
						type: "number",
						value: 3,
					},
					{
						type: "infinite",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("2, 3, infinite");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple infinite keywords", () => {
			const input: Type.AnimationIterationCount = {
				kind: "animation-iteration-count",
				counts: [
					{
						type: "infinite",
					},
					{
						type: "infinite",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("infinite, infinite");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/animation/iteration-count.ts ===
// b_path:: src/generate/animation/iteration-count.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { animationIterationCountSchema } from "@/core/types/animation";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS animation-iteration-count property value from IR.
 *
 * Converts AnimationIterationCount IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationIterationCount IR object
 * @returns CSS animation-iteration-count value string
 *
 * @example
 * Number count:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-iteration-count",
 *   counts: [{ type: "number", value: 3 }]
 * });
 * // "3"
 * ```
 *
 * @example
 * Infinite keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-iteration-count",
 *   counts: [{ type: "infinite" }]
 * });
 * // "infinite"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count | MDN: animation-iteration-count}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-iteration-count | W3C Spec}
 */
export function generate(ir: Type.AnimationIterationCount): GenerateResult {
	// Validate IR with Zod schema
	const validation = animationIterationCountSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	const values = ir.counts
		.map((count) => {
			if (count.type === "infinite") {
				return "infinite";
			}
			return String(count.value);
		})
		.join(", ");
	return generateOk(values);
}


=== File: src/generate/animation/name.failure.test.ts ===
// b_path:: src/generate/animation/name.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/name.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-name
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/animation/name";

describe("generate/animation/name - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind literal", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-duration",
				names: [
					{
						type: "none",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "animation-name"');
		});
	});

	describe("invalid-type", () => {
		it("should reject invalid type keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-name",
				names: [
					{
						type: "invalid",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'names[0]: Invalid animation name. Expected { type: "none" } or { type: "identifier", value: <string> }.',
			);
		});

		it("should reject missing value for identifier", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'names[0]: Invalid animation name. Expected { type: "none" } or { type: "identifier", value: <string> }.',
			);
		});

		it("should reject number value instead of string", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: 123,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'names[0]: Invalid animation name. Expected { type: "none" } or { type: "identifier", value: <string> }.',
			);
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty names array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-name",
				names: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("names: Too small: expected array to have >=1 items");
		});
	});

	describe("invalid-structure", () => {
		it("should reject string instead of array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-name",
				names: "slideIn",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("names: Invalid input: expected array, received string");
		});

		it("should reject missing type field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-name",
				names: [
					{
						value: "slideIn",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'names[0]: Invalid animation name. Expected { type: "none" } or { type: "identifier", value: <string> }.',
			);
		});
	});
});


=== File: src/generate/animation/name.test.ts ===
// b_path:: src/generate/animation/name.test.ts
// Auto-generated from scripts/generate-test-generator/configs/animation/name.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-name
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/animation/name";
import * as Parser from "@/parse/animation/name";

describe("generate/animation/name - valid cases", () => {
	describe("valid-none", () => {
		it("should generate none keyword", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "none",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-identifier", () => {
		it("should generate simple identifier", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "slideIn",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("slideIn");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate camelCase identifier", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "fadeOut",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("fadeOut");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate hyphenated identifier", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "slide-in",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("slide-in");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate underscore identifier", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "bounce_effect",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("bounce_effect");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate identifier with numbers", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "animation123",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("animation123");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-multiple", () => {
		it("should generate two identifiers", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "slideIn",
					},
					{
						type: "identifier",
						value: "fadeOut",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("slideIn, fadeOut");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate mixed identifiers and none", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "bounce",
					},
					{
						type: "none",
					},
					{
						type: "identifier",
						value: "spin",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("bounce, none, spin");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple none keywords", () => {
			const input: Type.AnimationName = {
				kind: "animation-name",
				names: [
					{
						type: "none",
					},
					{
						type: "none",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none, none");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/animation/name.ts ===
// b_path:: src/generate/animation/name.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { animationNameSchema } from "@/core/types/animation";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS animation-name property value from IR.
 *
 * Converts AnimationName IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationName IR object
 * @returns CSS animation-name value string
 *
 * @example
 * Identifier name:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-name",
 *   names: [{ type: "identifier", value: "slideIn" }]
 * });
 * // "slideIn"
 * ```
 *
 * @example
 * None keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-name",
 *   names: [{ type: "none" }]
 * });
 * // "none"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name | MDN: animation-name}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-name | W3C Spec}
 */
export function generate(ir: Type.AnimationName): GenerateResult {
	// Validate IR with Zod schema
	const validation = animationNameSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	const values = ir.names
		.map((name) => {
			if (name.type === "none") {
				return "none";
			}
			return name.value;
		})
		.join(", ");
	return generateOk(values);
}


=== File: src/generate/animation/play-state.failure.test.ts ===
// b_path:: src/generate/animation/play-state.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/play-state.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-play-state
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/animation/play-state";

describe("generate/animation/play-state - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind literal", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-direction",
				states: ["running"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "animation-play-state"');
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid play state keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-play-state",
				states: ["invalid"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('states[0]: Invalid option: expected one of "running"|"paused"');
		});

		it("should reject non-existent play state", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-play-state",
				states: ["stopped"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('states[0]: Invalid option: expected one of "running"|"paused"');
		});

		it("should reject direction keyword instead of play-state", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-play-state",
				states: ["normal"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('states[0]: Invalid option: expected one of "running"|"paused"');
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty states array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-play-state",
				states: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("states: Too small: expected array to have >=1 items");
		});
	});

	describe("invalid-type", () => {
		it("should reject string instead of array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-play-state",
				states: "running",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("states: Invalid input: expected array, received string");
		});

		it("should reject number instead of string", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-play-state",
				states: [1],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('states[0]: Invalid option: expected one of "running"|"paused"');
		});
	});
});


=== File: src/generate/animation/play-state.test.ts ===
// b_path:: src/generate/animation/play-state.test.ts
// Auto-generated from scripts/generate-test-generator/configs/animation/play-state.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-play-state
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/animation/play-state";
import * as Parser from "@/parse/animation/play-state";

describe("generate/animation/play-state - valid cases", () => {
	describe("valid-single", () => {
		it("should generate running play state", () => {
			const input: Type.AnimationPlayState = {
				kind: "animation-play-state",
				states: ["running"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("running");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate paused play state", () => {
			const input: Type.AnimationPlayState = {
				kind: "animation-play-state",
				states: ["paused"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("paused");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-multiple", () => {
		it("should generate two play states", () => {
			const input: Type.AnimationPlayState = {
				kind: "animation-play-state",
				states: ["running", "paused"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("running, paused");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate repeated play states", () => {
			const input: Type.AnimationPlayState = {
				kind: "animation-play-state",
				states: ["paused", "running", "running"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("paused, running, running");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple animations with different states", () => {
			const input: Type.AnimationPlayState = {
				kind: "animation-play-state",
				states: ["running", "running", "running", "paused"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("running, running, running, paused");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/animation/play-state.ts ===
// b_path:: src/generate/animation/play-state.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { animationPlayStateSchema } from "@/core/types/animation";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS animation-play-state property value from IR.
 *
 * Converts AnimationPlayState IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationPlayState IR object
 * @returns CSS animation-play-state value string
 *
 * @example
 * Single play state:
 * ```typescript
 * const css = toCss({ kind: "animation-play-state", states: ["running"] });
 * // "running"
 * ```
 *
 * @example
 * Multiple play states:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-play-state",
 *   states: ["running", "paused"]
 * });
 * // "running, paused"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state | MDN: animation-play-state}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-play-state | W3C Spec}
 */
export function generate(ir: Type.AnimationPlayState): GenerateResult {
	// Validate IR with Zod schema
	const validation = animationPlayStateSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(ir.states.join(", "));
}


=== File: src/generate/animation/timing-function.failure.test.ts ===
// b_path:: src/generate/animation/timing-function.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/timing-function.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-timing-function
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/animation/timing-function";

describe("generate/animation/timing-function - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-timing-function",
				functions: ["invalid-keyword"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject invalid function type", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "unknown",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});
	});

	describe("invalid-cubic-bezier", () => {
		it("should reject cubic-bezier missing x2/y2", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0,
						y1: 0,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});

		it("should reject cubic-bezier with string value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: "0",
						y1: 0,
						x2: 1,
						y2: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});
	});

	describe("invalid-steps", () => {
		it("should reject steps missing steps count", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});

		it("should reject steps with zero count", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 0,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("functions[0].steps: Too small: expected number to be >0");
		});

		it("should reject steps with negative count", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: -1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("functions[0].steps: Too small: expected number to be >0");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty functions array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "animation-timing-function",
				functions: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("functions: Too small: expected array to have >=1 items");
		});
	});
});


=== File: src/generate/animation/timing-function.test.ts ===
// b_path:: src/generate/animation/timing-function.test.ts
// Auto-generated from scripts/generate-test-generator/configs/animation/timing-function.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-timing-function
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/animation/timing-function";
import * as Parser from "@/parse/animation/timing-function";

describe("generate/animation/timing-function - valid cases", () => {
	describe("valid-keyword", () => {
		it("should generate ease keyword", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["ease"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate linear keyword", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["linear"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("linear");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate ease-in keyword", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["ease-in"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease-in");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate ease-out keyword", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["ease-out"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease-out");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate ease-in-out keyword", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["ease-in-out"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease-in-out");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate step-start keyword", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["step-start"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("step-start");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate step-end keyword", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["step-end"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("step-end");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-cubic-bezier", () => {
		it("should generate cubic-bezier function", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0.42,
						y1: 0,
						x2: 1,
						y2: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("cubic-bezier(0.42, 0, 1, 1)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate cubic-bezier with zero values", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0,
						y1: 0,
						x2: 1,
						y2: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("cubic-bezier(0, 0, 1, 1)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-steps", () => {
		it("should generate steps without position", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 4,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("steps(4)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate steps with start position", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 10,
						position: "start",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("steps(10, start)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate steps with end position", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 5,
						position: "end",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("steps(5, end)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-linear", () => {
		it("should generate linear function simple", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "linear",
						stops: [
							{
								output: 0,
							},
							{
								output: 1,
							},
						],
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("linear(0, 1)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate linear function with input positions", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [
					{
						type: "linear",
						stops: [
							{
								output: 0,
								input: 0,
							},
							{
								output: 0.5,
								input: 0.5,
							},
							{
								output: 1,
								input: 1,
							},
						],
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("linear(0 0%, 0.5 50%, 1 100%)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-list", () => {
		it("should generate multiple keyword functions", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: ["ease", "linear", "ease-out"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease, linear, ease-out");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate mixed function types", () => {
			const input: Type.AnimationTimingFunction = {
				kind: "animation-timing-function",
				functions: [
					"ease",
					{
						type: "cubic-bezier",
						x1: 0.1,
						y1: 0.7,
						x2: 1,
						y2: 0.1,
					},
					{
						type: "steps",
						steps: 4,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease, cubic-bezier(0.1, 0.7, 1, 0.1), steps(4)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/animation/timing-function.ts ===
// b_path:: src/generate/animation/timing-function.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { animationTimingFunctionSchema } from "@/core/types/animation";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS easing function string from IR.
 *
 * @param func - EasingFunction IR
 * @returns CSS easing function string
 *
 * @internal
 */
function easingFunctionToCss(func: Type.EasingFunction): string {
	// Keyword
	if (typeof func === "string") {
		return func;
	}

	// cubic-bezier()
	if (func.type === "cubic-bezier") {
		return `cubic-bezier(${func.x1}, ${func.y1}, ${func.x2}, ${func.y2})`;
	}

	// steps()
	if (func.type === "steps") {
		if (func.position !== undefined) {
			return `steps(${func.steps}, ${func.position})`;
		}
		return `steps(${func.steps})`;
	}

	// linear()
	if (func.type === "linear") {
		const stops = func.stops
			.map((stop) => {
				if (stop.input !== undefined) {
					return `${stop.output} ${stop.input * 100}%`;
				}
				return String(stop.output);
			})
			.join(", ");
		return `linear(${stops})`;
	}

	return "";
}

/**
 * Generate CSS animation-timing-function property value from IR.
 *
 * Converts AnimationTimingFunction IR to CSS string representation.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param ir - AnimationTimingFunction IR object
 * @returns CSS animation-timing-function value string
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-timing-function",
 *   functions: ["ease-in"]
 * });
 * // "ease-in"
 * ```
 *
 * @example
 * Cubic bezier:
 * ```typescript
 * const css = toCss({
 *   kind: "animation-timing-function",
 *   functions: [{ type: "cubic-bezier", x1: 0.1, y1: 0.7, x2: 1.0, y2: 0.1 }]
 * });
 * // "cubic-bezier(0.1, 0.7, 1.0, 0.1)"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function | MDN: animation-timing-function}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-timing-function | W3C Spec}
 */
export function generate(ir: Type.AnimationTimingFunction): GenerateResult {
	// Validate IR with Zod schema
	const validation = animationTimingFunctionSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(ir.functions.map(easingFunctionToCss).join(", "));
}


=== File: src/generate/background/attachment.test.ts ===
// b_path:: src/generate/background/attachment.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./attachment";

describe("background-attachment generator", () => {
	test("should generate 'scroll'", () => {
		const result = generate("scroll");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("scroll");
	});

	test("should generate 'fixed'", () => {
		const result = generate("fixed");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("fixed");
	});

	test("should generate 'local'", () => {
		const result = generate("local");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("local");
	});
});


=== File: src/generate/background/attachment.ts ===
// b_path:: src/generate/background/attachment.ts
import type * as Keyword from "@/core/keywords";
import { type GenerateResult, generateErr, generateOk } from "@/core/result";

/**
 * Generate CSS background-attachment string from keyword.
 *
 * @param keyword - BackgroundAttachmentKeyword value
 * @returns CSS background-attachment string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Attachment.generate("fixed");
 * console.log(css); // "fixed"
 * ```
 */
export function generate(keyword: Keyword.BackgroundAttachmentKeyword): GenerateResult {
	if (keyword === undefined || keyword === null) {
		return generateErr("invalid-ir", "Keyword must not be null or undefined");
	}
	if (typeof keyword !== "string") {
		return generateErr("invalid-ir", `Expected string keyword, got ${typeof keyword}`);
	}
	return generateOk(keyword);
}


=== File: src/generate/background/clip.test.ts ===
// b_path:: src/generate/background/clip.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./clip";

describe("background-clip generator", () => {
	test("should generate 'border-box'", () => {
		const result = generate("border-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("border-box");
	});

	test("should generate 'padding-box'", () => {
		const result = generate("padding-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("padding-box");
	});

	test("should generate 'content-box'", () => {
		const result = generate("content-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("content-box");
	});

	test("should generate 'text'", () => {
		const result = generate("text");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("text");
	});
});


=== File: src/generate/background/clip.ts ===
// b_path:: src/generate/background/clip.ts
import type * as Keyword from "@/core/keywords";
import { type GenerateResult, generateErr, generateOk } from "@/core/result";

/**
 * Generate CSS background-clip string from keyword.
 *
 * @param keyword - BackgroundClipKeyword value
 * @returns CSS background-clip string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Clip.generate("padding-box");
 * console.log(css); // "padding-box"
 * ```
 */
export function generate(keyword: Keyword.BackgroundClipKeyword): GenerateResult {
	if (keyword === undefined || keyword === null) {
		return generateErr("invalid-ir", "Keyword must not be null or undefined");
	}
	if (typeof keyword !== "string") {
		return generateErr("invalid-ir", `Expected string keyword, got ${typeof keyword}`);
	}
	return generateOk(keyword);
}


=== File: src/generate/background/index.ts ===
// b_path:: src/generate/background/index.ts

export * as Attachment from "./attachment";
export * as Clip from "./clip";
export * as Origin from "./origin";
export * as PositionX from "./position-x";
export * as PositionY from "./position-y";
export * as Repeat from "./repeat";
export * as Size from "./size";


=== File: src/generate/background/origin.test.ts ===
// b_path:: src/generate/background/origin.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./origin";

describe("background-origin generator", () => {
	test("should generate 'border-box'", () => {
		const result = generate("border-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("border-box");
	});

	test("should generate 'padding-box'", () => {
		const result = generate("padding-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("padding-box");
	});

	test("should generate 'content-box'", () => {
		const result = generate("content-box");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("content-box");
	});
});


=== File: src/generate/background/origin.ts ===
// b_path:: src/generate/background/origin.ts
import type * as Keyword from "@/core/keywords";
import { type GenerateResult, generateErr, generateOk } from "@/core/result";

/**
 * Generate CSS background-origin string from keyword.
 *
 * @param keyword - VisualBoxKeyword value
 * @returns CSS background-origin string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Origin.generate("content-box");
 * console.log(css); // "content-box"
 * ```
 */
export function generate(keyword: Keyword.VisualBoxKeyword): GenerateResult {
	if (keyword === undefined || keyword === null) {
		return generateErr("invalid-ir", "Keyword must not be null or undefined");
	}
	if (typeof keyword !== "string") {
		return generateErr("invalid-ir", `Expected string keyword, got ${typeof keyword}`);
	}
	return generateOk(keyword);
}


=== File: src/generate/background/position-x.test.ts ===
// b_path:: src/generate/background/position-x.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./position-x";

describe("background-position-x generator", () => {
	test("should generate 'left' keyword", () => {
		const result = generate("left");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("left");
	});

	test("should generate 'center' keyword", () => {
		const result = generate("center");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("center");
	});

	test("should generate 'right' keyword", () => {
		const result = generate("right");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("right");
	});

	test("should generate percentage", () => {
		const result = generate({ value: 25, unit: "%" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("25%");
	});

	test("should generate length in px", () => {
		const result = generate({ value: 10, unit: "px" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("10px");
	});
});


=== File: src/generate/background/position-x.ts ===
// b_path:: src/generate/background/position-x.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { PositionValue } from "@/core/types";

/**
 * Generate CSS background-position-x string from value.
 *
 * @param value - PositionValue (keyword or length-percentage)
 * @returns CSS background-position-x string
 *
 * @public
 *
 * @example
 * Keyword:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.PositionX.generate("center");
 * console.log(css); // "center"
 * ```
 *
 * @example
 * Percentage:
 * ```typescript
 * const css = Generate.Background.PositionX.generate({ value: 25, unit: "%" });
 * console.log(css); // "25%"
 * ```
 *
 * @example
 * Length:
 * ```typescript
 * const css = Generate.Background.PositionX.generate({ value: 10, unit: "px" });
 * console.log(css); // "10px"
 * ```
 */
export function generate(value: PositionValue): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "PositionValue must not be null or undefined");
	}
	if (typeof value === "string") {
		return generateOk(value);
	}
	if (typeof value !== "object") {
		return generateErr("invalid-ir", `Expected string or object, got ${typeof value}`);
	}
	if (!("value" in value) || !("unit" in value)) {
		return generateErr("missing-required-field", "Length-percentage must have 'value' and 'unit' fields");
	}
	return generateOk(`${value.value}${value.unit}`);
}


=== File: src/generate/background/position-y.test.ts ===
// b_path:: src/generate/background/position-y.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./position-y";

describe("background-position-y generator", () => {
	test("should generate 'top' keyword", () => {
		const result = generate("top");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("top");
	});

	test("should generate 'center' keyword", () => {
		const result = generate("center");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("center");
	});

	test("should generate 'bottom' keyword", () => {
		const result = generate("bottom");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("bottom");
	});

	test("should generate percentage", () => {
		const result = generate({ value: 50, unit: "%" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("50%");
	});

	test("should generate length in px", () => {
		const result = generate({ value: 20, unit: "px" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("20px");
	});
});


=== File: src/generate/background/position-y.ts ===
// b_path:: src/generate/background/position-y.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { PositionValue } from "@/core/types";

/**
 * Generate CSS background-position-y string from value.
 *
 * @param value - PositionValue (keyword or length-percentage)
 * @returns CSS background-position-y string
 *
 * @public
 *
 * @example
 * Keyword:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.PositionY.generate("top");
 * console.log(css); // "top"
 * ```
 *
 * @example
 * Percentage:
 * ```typescript
 * const css = Generate.Background.PositionY.generate({ value: 50, unit: "%" });
 * console.log(css); // "50%"
 * ```
 *
 * @example
 * Length:
 * ```typescript
 * const css = Generate.Background.PositionY.generate({ value: 20, unit: "px" });
 * console.log(css); // "20px"
 * ```
 */
export function generate(value: PositionValue): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "PositionValue must not be null or undefined");
	}
	if (typeof value === "string") {
		return generateOk(value);
	}
	if (typeof value !== "object") {
		return generateErr("invalid-ir", `Expected string or object, got ${typeof value}`);
	}
	if (!("value" in value) || !("unit" in value)) {
		return generateErr("missing-required-field", "Length-percentage must have 'value' and 'unit' fields");
	}
	return generateOk(`${value.value}${value.unit}`);
}


=== File: src/generate/background/repeat.test.ts ===
// b_path:: src/generate/background/repeat.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./repeat";

describe("background-repeat generator", () => {
	test("should generate 'repeat'", () => {
		const result = generate("repeat");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("repeat");
	});

	test("should generate 'repeat-x'", () => {
		const result = generate("repeat-x");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("repeat-x");
	});

	test("should generate 'repeat-y'", () => {
		const result = generate("repeat-y");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("repeat-y");
	});

	test("should generate 'no-repeat'", () => {
		const result = generate("no-repeat");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("no-repeat");
	});

	test("should generate 'space'", () => {
		const result = generate("space");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("space");
	});

	test("should generate 'round'", () => {
		const result = generate("round");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("round");
	});
});


=== File: src/generate/background/repeat.ts ===
// b_path:: src/generate/background/repeat.ts
import type * as Keyword from "@/core/keywords";
import { type GenerateResult, generateErr, generateOk } from "@/core/result";

/**
 * Generate CSS background-repeat string from keyword.
 *
 * @param keyword - RepeatKeyword value
 * @returns CSS background-repeat string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Repeat.generate("repeat-x");
 * console.log(css); // "repeat-x"
 * ```
 */
export function generate(keyword: Keyword.RepeatKeyword): GenerateResult {
	if (keyword === undefined || keyword === null) {
		return generateErr("invalid-ir", "Keyword must not be null or undefined");
	}
	if (typeof keyword !== "string") {
		return generateErr("invalid-ir", `Expected string keyword, got ${typeof keyword}`);
	}
	return generateOk(keyword);
}


=== File: src/generate/background/size.test.ts ===
// b_path:: src/generate/background/size.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./size";

describe("background-size generator", () => {
	test("should generate 'cover' keyword", () => {
		const result = generate("cover");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("cover");
	});

	test("should generate 'contain' keyword", () => {
		const result = generate("contain");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("contain");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate("auto");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});

	test("should generate length in px", () => {
		const result = generate({ value: 100, unit: "px" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("100px");
	});

	test("should generate percentage", () => {
		const result = generate({ value: 50, unit: "%" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("50%");
	});
});


=== File: src/generate/background/size.ts ===
// b_path:: src/generate/background/size.ts
import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { BackgroundSizeValue } from "../../parse/background/size";

/**
 * Generate CSS background-size string from value.
 *
 * @param value - BackgroundSizeValue (keyword, auto, or length-percentage)
 * @returns CSS background-size string
 *
 * @public
 *
 * @example
 * Keyword:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Background.Size.generate("cover");
 * console.log(css); // "cover"
 * ```
 *
 * @example
 * Length value:
 * ```typescript
 * const css = Generate.Background.Size.generate({ value: 100, unit: "px" });
 * console.log(css); // "100px"
 * ```
 */
export function generate(value: BackgroundSizeValue): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "BackgroundSizeValue must not be null or undefined");
	}
	if (typeof value === "string") {
		return generateOk(value);
	}
	if (typeof value !== "object") {
		return generateErr("invalid-ir", `Expected string or object, got ${typeof value}`);
	}
	if (!("value" in value) || !("unit" in value)) {
		return generateErr("missing-required-field", "Length-percentage must have 'value' and 'unit' fields");
	}
	return generateOk(`${value.value}${value.unit}`);
}


=== File: src/generate/border/border.test.ts ===
// b_path:: src/generate/border/border.test.ts

import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types/border";
import { generate } from "./border";

describe("Generate.Border.generate", () => {
	describe("border-width", () => {
		it("generates border-width with length", () => {
			const ir: Type.BorderWidthValue = {
				kind: "border-width",
				width: { value: 2, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px");
			expect(result.issues).toEqual([]);
		});

		it("generates border-width with keyword", () => {
			const ir: Type.BorderWidthValue = {
				kind: "border-width",
				width: "medium",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("medium");
		});

		it("generates border-width with thin", () => {
			const ir: Type.BorderWidthValue = {
				kind: "border-width",
				width: "thin",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("thin");
		});

		it("generates border-width with thick", () => {
			const ir: Type.BorderWidthValue = {
				kind: "border-width",
				width: "thick",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("thick");
		});
	});

	describe("border-style", () => {
		it("generates border-style solid", () => {
			const ir: Type.BorderStyleValue = {
				kind: "border-style",
				style: "solid",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("solid");
			expect(result.issues).toEqual([]);
		});

		it("generates border-style dashed", () => {
			const ir: Type.BorderStyleValue = {
				kind: "border-style",
				style: "dashed",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("dashed");
		});

		it("generates border-style dotted", () => {
			const ir: Type.BorderStyleValue = {
				kind: "border-style",
				style: "dotted",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("dotted");
		});

		it("generates border-style none", () => {
			const ir: Type.BorderStyleValue = {
				kind: "border-style",
				style: "none",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("none");
		});
	});

	describe("border-color", () => {
		it("generates border-color with keyword", () => {
			const ir: Type.BorderColorValue = {
				kind: "border-color",
				color: "red",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("red");
			expect(result.issues).toEqual([]);
		});

		it("generates border-color with transparent", () => {
			const ir: Type.BorderColorValue = {
				kind: "border-color",
				color: "transparent",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("transparent");
		});

		it("generates border-color with currentColor", () => {
			const ir: Type.BorderColorValue = {
				kind: "border-color",
				color: "currentColor",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("currentColor");
		});
	});

	describe("border-radius", () => {
		it("generates border-radius with px", () => {
			const ir: Type.BorderRadiusValue = {
				kind: "border-radius",
				radius: { value: 4, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("4px");
			expect(result.issues).toEqual([]);
		});

		it("generates border-radius with percentage", () => {
			const ir: Type.BorderRadiusValue = {
				kind: "border-radius",
				radius: { value: 50, unit: "%" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("50%");
		});

		it("generates border-radius with em", () => {
			const ir: Type.BorderRadiusValue = {
				kind: "border-radius",
				radius: { value: 0.5, unit: "em" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("0.5em");
		});
	});

	describe("error handling", () => {
		it("returns error for null IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(null as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Invalid border IR: missing 'kind' field");
		});

		it("returns error for undefined IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(undefined as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
		});

		it("returns error for IR without kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({} as any);

			expect(result.ok).toBe(false);
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		});

		it("returns error for unknown kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({ kind: "unknown" } as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Unknown border kind: unknown");
			expect(result.issues[0]?.suggestion).toContain("border-width");
			expect(result.issues[0]?.suggestion).toContain("border-style");
			expect(result.issues[0]?.suggestion).toContain("border-color");
			expect(result.issues[0]?.suggestion).toContain("border-radius");
		});
	});
});


=== File: src/generate/border/border.ts ===
// b_path:: src/generate/border/border.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types/border";
import * as Color from "./color";
import * as Radius from "./radius";
import * as Style from "./style";
import * as Width from "./width";

/**
 * Generate CSS from border property IR with auto-detection.
 *
 * Automatically detects border property type from IR.kind and generates appropriate CSS.
 * Supports border-width, border-style, border-color, and border-radius.
 *
 * @param border - Border property IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Border width:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Border.generate({
 *   kind: "border-width",
 *   width: { value: 2, unit: "px" }
 * });
 * // → { ok: true, value: "2px", issues: [] }
 * ```
 *
 * @example
 * Border style:
 * ```typescript
 * const result = Generate.Border.generate({
 *   kind: "border-style",
 *   style: "solid"
 * });
 * // → { ok: true, value: "solid", issues: [] }
 * ```
 *
 * @example
 * Border color:
 * ```typescript
 * const result = Generate.Border.generate({
 *   kind: "border-color",
 *   color: "red"
 * });
 * // → { ok: true, value: "red", issues: [] }
 * ```
 *
 * @example
 * Border radius:
 * ```typescript
 * const result = Generate.Border.generate({
 *   kind: "border-radius",
 *   radius: { value: 4, unit: "px" }
 * });
 * // → { ok: true, value: "4px", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Border.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid border IR: missing 'kind' field" }] }
 *
 * const result2 = Generate.Border.generate({ kind: "unknown" });
 * // → { ok: false, issues: [{ severity: "error", message: "Unknown border kind: unknown" }] }
 * ```
 *
 * @public
 */
export function generate(
	border: Type.BorderWidthValue | Type.BorderStyleValue | Type.BorderColorValue | Type.BorderRadiusValue,
): GenerateResult {
	// Validate IR has 'kind' field
	if (!border || typeof border !== "object" || !("kind" in border)) {
		return generateErr("missing-required-field", "Invalid border IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (border.kind) {
		case "border-width":
			return Width.generate(border);

		case "border-style":
			return Style.generate(border);

		case "border-color":
			return Color.generate(border);

		case "border-radius":
			return Radius.generate(border);

		default:
			return generateErr("unsupported-kind", `Unknown border kind: ${(border as { kind?: string }).kind}`, {
				suggestion:
					"Expected 'border-width', 'border-style', 'border-color', or 'border-radius'. Check that border IR is valid.",
			});
	}
}


=== File: src/generate/border/color.test.ts ===
// b_path:: src/generate/border/color.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./color";

describe("border-color generator", () => {
	test("should generate named color", () => {
		const result = generate({ kind: "border-color", color: "red" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("red");
	});

	test("should generate 'transparent'", () => {
		const result = generate({ kind: "border-color", color: "transparent" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("transparent");
	});

	test("should generate 'currentColor'", () => {
		const result = generate({ kind: "border-color", color: "currentColor" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("currentColor");
	});
});


=== File: src/generate/border/color.ts ===
// b_path:: src/generate/border/color.ts
import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS border-color property value from IR.
 *
 * Converts BorderColorValue IR to CSS string representation.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param ir - BorderColorValue IR object
 * @returns GenerateResult containing CSS border-color value string
 *
 * @example
 * ```typescript
 * const result = generate({ kind: "border-color", color: "red" });
 * // { ok: true, value: "red", issues: [] }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color | MDN: border-color}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-color | W3C Spec}
 */
export function generate(ir: Type.BorderColorValue): GenerateResult {
	return generateOk(ir.color);
}


=== File: src/generate/border/index.ts ===
// b_path:: src/generate/border/index.ts

export { generate } from "./border";
export * as Color from "./color";
export * as Radius from "./radius";
export * as Style from "./style";
export * as Width from "./width";


=== File: src/generate/border/radius.test.ts ===
// b_path:: src/generate/border/radius.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./radius";

describe("border-radius generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "border-radius", radius: { value: 5, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("5px");
	});

	test("should generate length in rem", () => {
		const result = generate({ kind: "border-radius", radius: { value: 0.5, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0.5rem");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "border-radius", radius: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("50%");
	});
});


=== File: src/generate/border/radius.ts ===
// b_path:: src/generate/border/radius.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS border-radius property value from IR.
 *
 * Converts BorderRadiusValue IR to CSS string representation.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param ir - BorderRadiusValue IR object
 * @returns CSS border-radius value string
 *
 * @example
 * Length:
 * ```typescript
 * const css = toCss({ kind: "border-radius", radius: { value: 5, unit: "px" } });
 * // "5px"
 * ```
 *
 * @example
 * Percentage:
 * ```typescript
 * const css = toCss({ kind: "border-radius", radius: { value: 50, unit: "%" } });
 * // "50%"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius | MDN: border-radius}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-radius | W3C Spec}
 */
export function generate(ir: Type.BorderRadiusValue): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(`${ir.radius.value}${ir.radius.unit}`);
}


=== File: src/generate/border/style.test.ts ===
// b_path:: src/generate/border/style.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./style";

describe("border-style generator", () => {
	test("should generate 'none'", () => {
		const result = generate({ kind: "border-style", style: "none" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("none");
	});

	test("should generate 'solid'", () => {
		const result = generate({ kind: "border-style", style: "solid" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("solid");
	});

	test("should generate 'dashed'", () => {
		const result = generate({ kind: "border-style", style: "dashed" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("dashed");
	});

	test("should generate 'dotted'", () => {
		const result = generate({ kind: "border-style", style: "dotted" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("dotted");
	});

	test("should generate 'double'", () => {
		const result = generate({ kind: "border-style", style: "double" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("double");
	});

	test("should generate 'groove'", () => {
		const result = generate({ kind: "border-style", style: "groove" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("groove");
	});
});


=== File: src/generate/border/style.ts ===
// b_path:: src/generate/border/style.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS border-style property value from IR.
 *
 * Converts BorderStyleValue IR to CSS string representation.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param ir - BorderStyleValue IR object
 * @returns CSS border-style value string
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "border-style", style: "solid" });
 * // "solid"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style | MDN: border-style}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-style | W3C Spec}
 */
export function generate(ir: Type.BorderStyleValue): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(ir.style);
}


=== File: src/generate/border/width.test.ts ===
// b_path:: src/generate/border/width.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./width";

describe("border-width generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "border-width", width: { value: 1, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1px");
	});

	test("should generate length in em", () => {
		const result = generate({ kind: "border-width", width: { value: 0.1, unit: "em" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0.1em");
	});

	test("should generate 'thin' keyword", () => {
		const result = generate({ kind: "border-width", width: "thin" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("thin");
	});

	test("should generate 'medium' keyword", () => {
		const result = generate({ kind: "border-width", width: "medium" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("medium");
	});

	test("should generate 'thick' keyword", () => {
		const result = generate({ kind: "border-width", width: "thick" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("thick");
	});
});


=== File: src/generate/border/width.ts ===
// b_path:: src/generate/border/width.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS border-width property value from IR.
 *
 * Converts BorderWidthValue IR to CSS string representation.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param ir - BorderWidthValue IR object
 * @returns CSS border-width value string
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({ kind: "border-width", width: "medium" });
 * // "medium"
 * ```
 *
 * @example
 * Length:
 * ```typescript
 * const css = toCss({ kind: "border-width", width: { value: 1, unit: "px" } });
 * // "1px"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width | MDN: border-width}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-width | W3C Spec}
 */
export function generate(ir: Type.BorderWidthValue): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof ir.width === "string") {
		return generateOk(ir.width);
	}
	return generateOk(`${ir.width.value}${ir.width.unit}`);
}


=== File: src/generate/clip-path/circle.test.ts ===
// b_path:: src/generate/clip-path/circle.test.ts
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./circle";

describe("generate circle()", () => {
	it("generates minimal circle", () => {
		const circle: Type.ClipPathCircle = { kind: "clip-path-circle" };
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle()");
		}
	});

	it("generates circle with radius", () => {
		const circle: Type.ClipPathCircle = {
			kind: "clip-path-circle",
			radius: { value: 50, unit: "px" },
		};
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(50px)");
		}
	});

	it("generates circle with percentage radius", () => {
		const circle: Type.ClipPathCircle = {
			kind: "clip-path-circle",
			radius: { value: 50, unit: "%" },
		};
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(50%)");
		}
	});

	it("generates circle with keyword radius", () => {
		const circle: Type.ClipPathCircle = {
			kind: "clip-path-circle",
			radius: "closest-side",
		};
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(closest-side)");
		}
	});

	it("generates circle with farthest-side radius", () => {
		const circle: Type.ClipPathCircle = {
			kind: "clip-path-circle",
			radius: "farthest-side",
		};
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(farthest-side)");
		}
	});

	it("generates circle with position", () => {
		const circle: Type.ClipPathCircle = {
			kind: "clip-path-circle",
			radius: { value: 50, unit: "px" },
			position: { horizontal: "center", vertical: "center" },
		};
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(50px at center center)");
		}
	});

	it("generates circle with custom position", () => {
		const circle: Type.ClipPathCircle = {
			kind: "clip-path-circle",
			radius: { value: 40, unit: "%" },
			position: {
				horizontal: { value: 30, unit: "%" },
				vertical: { value: 70, unit: "%" },
			},
		};
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(40% at 30% 70%)");
		}
	});

	it("generates circle with only position (no radius)", () => {
		const circle: Type.ClipPathCircle = {
			kind: "clip-path-circle",
			position: { horizontal: "left", vertical: "top" },
		};
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(at left top)");
		}
	});

	it("generates circle with position using length values", () => {
		const circle: Type.ClipPathCircle = {
			kind: "clip-path-circle",
			radius: { value: 100, unit: "px" },
			position: {
				horizontal: { value: 20, unit: "px" },
				vertical: { value: 50, unit: "px" },
			},
		};
		const result = generate(circle);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("circle(100px at 20px 50px)");
		}
	});

	it("returns error for null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("returns error for undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/clip-path/circle.ts ===
// b_path:: src/generate/clip-path/circle.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Generate from "@/generate";
import * as GenerateUtils from "@/utils/generate";

/**
 * Convert circle() IR to CSS string.
 *
 * Generates optimized CSS for circle() shape function.
 * Omits defaults (no radius = closest-side, no position = center).
 *
 * @param value - ClipPathCircle IR
 * @returns CSS string
 *
 * @example
 * ```typescript
 * toCss({ kind: "clip-path-circle" });
 * // "circle()"
 *
 * toCss({ kind: "clip-path-circle", radius: { value: 50, unit: "px" } });
 * // "circle(50px)"
 *
 * toCss({
 *   kind: "clip-path-circle",
 *   radius: { value: 50, unit: "px" },
 *   position: { horizontal: "center", vertical: "center" }
 * });
 * // "circle(50px at center)"
 * ```
 *
 * @public
 */
export function generate(value: Type.ClipPathCircle): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const parts: string[] = ["circle("];

	// Add radius if present
	if (value.radius !== undefined) {
		if (typeof value.radius === "string") {
			parts.push(value.radius);
		} else {
			parts.push(GenerateUtils.lengthPercentageToCss(value.radius));
		}
	}

	// Add position if present
	if (value.position !== undefined) {
		if (parts.length > 1) {
			parts.push(" ");
		}
		parts.push("at ");
		const posResult = Generate.Position.Utils.generate(value.position);
		if (!posResult.ok) return posResult;
		parts.push(posResult.value);
	}

	parts.push(")");
	return generateOk(parts.join(""));
}


=== File: src/generate/clip-path/clip-path.ts ===
// b_path:: src/generate/clip-path/clip-path.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types";
import * as Circle from "./circle";
import * as Ellipse from "./ellipse";
import * as GeometryBox from "./geometry-box";
import * as Inset from "./inset";
import * as None from "./none";
import * as Path from "./path";
import * as Polygon from "./polygon";
import * as Rect from "./rect";
import * as Url from "./url";
import * as Xywh from "./xywh";

/**
 * Generate CSS from clip-path IR with auto-detection.
 *
 * Automatically detects clip-path shape from IR.kind and generates appropriate CSS.
 * Supports all clip-path shapes and keywords.
 *
 * @param clipPath - ClipPath IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate({ kind: "clip-path-circle", radius: { value: 50, unit: "%" } })
 * // → { ok: true, value: "circle(50%)", issues: [] }
 *
 * generate({ kind: "clip-path-none" })
 * // → { ok: true, value: "none", issues: [] }
 *
 * generate({ kind: "url", value: "#clip-shape" })
 * // → { ok: true, value: "url(#clip-shape)", issues: [] }
 * ```
 *
 * @public
 */
export function generate(clipPath: Type.ClipPathValue): GenerateResult {
	// Validate IR has 'kind' field
	if (!clipPath || typeof clipPath !== "object" || !("kind" in clipPath)) {
		return generateErr("missing-required-field", "Invalid clip-path IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (clipPath.kind) {
		case "clip-path-none":
			return None.generate(clipPath);

		case "clip-path-geometry-box":
			return GeometryBox.generate(clipPath);

		case "clip-path-inset":
			return Inset.generate(clipPath);

		case "clip-path-circle":
			return Circle.generate(clipPath);

		case "clip-path-ellipse":
			return Ellipse.generate(clipPath);

		case "clip-path-polygon":
			return Polygon.generate(clipPath);

		case "clip-path-rect":
			return Rect.generate(clipPath);

		case "clip-path-xywh":
			return Xywh.generate(clipPath);

		case "clip-path-path":
			return Path.generate(clipPath);

		case "url":
			return Url.generate(clipPath);

		default:
			return generateErr("unsupported-kind", `Unknown clip-path kind: ${(clipPath as { kind?: string }).kind}`, {
				suggestion: "Check that clip-path IR is valid",
			});
	}
}


=== File: src/generate/clip-path/ellipse.test.ts ===
// b_path:: src/generate/clip-path/ellipse.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./ellipse";

describe("generate ellipse clip-path", () => {
	it("generates basic ellipse", () => {
		const result = generate({ kind: "clip-path-ellipse" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ellipse()");
		}
	});

	it("generates ellipse with radiusX", () => {
		const result = generate({
			kind: "clip-path-ellipse",
			radiusX: { value: 50, unit: "px" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ellipse(50px)");
		}
	});

	it("generates ellipse with both radii", () => {
		const result = generate({
			kind: "clip-path-ellipse",
			radiusX: { value: 50, unit: "px" },
			radiusY: { value: 100, unit: "px" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ellipse(50px 100px)");
		}
	});

	it("generates ellipse with keyword radii", () => {
		const result = generate({
			kind: "clip-path-ellipse",
			radiusX: "closest-side",
			radiusY: "farthest-side",
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ellipse(closest-side farthest-side)");
		}
	});

	it("generates ellipse with percentage radii", () => {
		const result = generate({
			kind: "clip-path-ellipse",
			radiusX: { value: 50, unit: "%" },
			radiusY: { value: 75, unit: "%" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ellipse(50% 75%)");
		}
	});

	it("generates ellipse with position", () => {
		const result = generate({
			kind: "clip-path-ellipse",
			radiusX: { value: 50, unit: "px" },
			position: { horizontal: "center", vertical: "center" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ellipse(50px at center center)");
		}
	});

	it("rejects null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("rejects undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/clip-path/ellipse.ts ===
// b_path:: src/generate/clip-path/ellipse.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Generate from "@/generate";
import * as GenerateUtils from "@/utils/generate";

/**
 * Convert ellipse() IR to CSS string.
 *
 * Generates optimized CSS for ellipse() shape function.
 * Omits defaults (no radii = closest-side, no position = center).
 *
 * @param value - ClipPathEllipse IR
 * @returns CSS string
 *
 * @example
 * ```typescript
 * toCss({ kind: "clip-path-ellipse" });
 * // "ellipse()"
 *
 * toCss({ kind: "clip-path-ellipse", radiusX: { value: 50, unit: "px" } });
 * // "ellipse(50px)"
 *
 * toCss({
 *   kind: "clip-path-ellipse",
 *   radiusX: { value: 50, unit: "px" },
 *   radiusY: { value: 100, unit: "px" }
 * });
 * // "ellipse(50px 100px)"
 * ```
 *
 * @public
 */
export function generate(value: Type.ClipPathEllipse): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const parts: string[] = ["ellipse("];

	// Add radiusX if present
	if (value.radiusX !== undefined) {
		if (typeof value.radiusX === "string") {
			parts.push(value.radiusX);
		} else {
			parts.push(GenerateUtils.lengthPercentageToCss(value.radiusX));
		}
	}

	// Add radiusY if present
	if (value.radiusY !== undefined) {
		if (parts.length > 1) {
			parts.push(" ");
		}
		if (typeof value.radiusY === "string") {
			parts.push(value.radiusY);
		} else {
			parts.push(GenerateUtils.lengthPercentageToCss(value.radiusY));
		}
	}

	// Add position if present
	if (value.position !== undefined) {
		if (parts.length > 1) {
			parts.push(" ");
		}
		parts.push("at ");
		const posResult = Generate.Position.Utils.generate(value.position);
		if (!posResult.ok) return posResult;
		parts.push(posResult.value);
	}

	parts.push(")");
	return generateOk(parts.join(""));
}


=== File: src/generate/clip-path/geometry-box.test.ts ===
// b_path:: src/generate/clip-path/geometry-box.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./geometry-box";

describe("generate clip-path geometry-box", () => {
	it("generates 'content-box'", () => {
		const result = generate({ kind: "clip-path-geometry-box", value: "content-box" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("content-box");
		}
	});

	it("generates 'padding-box'", () => {
		const result = generate({ kind: "clip-path-geometry-box", value: "padding-box" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("padding-box");
		}
	});

	it("generates 'border-box'", () => {
		const result = generate({ kind: "clip-path-geometry-box", value: "border-box" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("border-box");
		}
	});

	it("generates 'margin-box'", () => {
		const result = generate({ kind: "clip-path-geometry-box", value: "margin-box" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("margin-box");
		}
	});

	it("generates 'fill-box'", () => {
		const result = generate({ kind: "clip-path-geometry-box", value: "fill-box" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("fill-box");
		}
	});

	it("generates 'stroke-box'", () => {
		const result = generate({ kind: "clip-path-geometry-box", value: "stroke-box" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("stroke-box");
		}
	});

	it("generates 'view-box'", () => {
		const result = generate({ kind: "clip-path-geometry-box", value: "view-box" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("view-box");
		}
	});

	it("rejects null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});

	it("rejects undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});
});


=== File: src/generate/clip-path/geometry-box.ts ===
// b_path:: src/generate/clip-path/geometry-box.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { ClipPathGeometryBox } from "@/core/types/clip-path";

/**
 * Generate CSS geometry-box keyword for clip-path property.
 *
 * Converts ClipPathGeometryBox IR to CSS keyword string.
 *
 * @param value - ClipPathGeometryBox IR value
 * @returns CSS string like "content-box" or "fill-box"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path#geometry-box}
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.ClipPath.GeometryBox.generate({
 *   kind: "clip-path-geometry-box",
 *   value: "padding-box"
 * });
 * // "padding-box"
 * ```
 *
 * @public
 */
export function generate(value: ClipPathGeometryBox): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(value.value);
}


=== File: src/generate/clip-path/index.ts ===
// b_path:: src/generate/clip-path/index.ts

export * as Circle from "./circle";
export * as ClipPath from "./clip-path";
export { generate } from "./clip-path";
export * as Ellipse from "./ellipse";
export * as GeometryBox from "./geometry-box";
export * as Inset from "./inset";
export * as None from "./none";
export * as Path from "./path";
export * as Polygon from "./polygon";
export * as Rect from "./rect";
export * as Url from "./url";
export * as Xywh from "./xywh";


=== File: src/generate/clip-path/inset.test.ts ===
// b_path:: src/generate/clip-path/inset.test.ts
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./inset";

describe("generate inset()", () => {
	it("generates inset with all equal values (optimized to 1 value)", () => {
		const inset: Type.ClipPathInset = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "px" },
			right: { value: 10, unit: "px" },
			bottom: { value: 10, unit: "px" },
			left: { value: 10, unit: "px" },
		};
		const result = generate(inset);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10px)");
		}
	});

	it("generates inset with vertical/horizontal pairs (optimized to 2 values)", () => {
		const inset: Type.ClipPathInset = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "px" },
			right: { value: 20, unit: "px" },
			bottom: { value: 10, unit: "px" },
			left: { value: 20, unit: "px" },
		};
		const result = generate(inset);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10px 20px)");
		}
	});

	it("generates inset with left/right same (optimized to 3 values)", () => {
		const inset: Type.ClipPathInset = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "px" },
			right: { value: 20, unit: "px" },
			bottom: { value: 30, unit: "px" },
			left: { value: 20, unit: "px" },
		};
		const result = generate(inset);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10px 20px 30px)");
		}
	});

	it("generates inset with all different values (4 values)", () => {
		const inset: Type.ClipPathInset = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "px" },
			right: { value: 20, unit: "px" },
			bottom: { value: 30, unit: "px" },
			left: { value: 40, unit: "px" },
		};
		const result = generate(inset);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10px 20px 30px 40px)");
		}
	});

	it("generates inset with percentage values", () => {
		const inset: Type.ClipPathInset = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "%" },
			right: { value: 20, unit: "%" },
			bottom: { value: 30, unit: "%" },
			left: { value: 40, unit: "%" },
		};
		const result = generate(inset);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10% 20% 30% 40%)");
		}
	});

	it("generates inset with mixed units", () => {
		const inset: Type.ClipPathInset = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "px" },
			right: { value: 5, unit: "%" },
			bottom: { value: 2, unit: "em" },
			left: { value: 1, unit: "rem" },
		};
		const result = generate(inset);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10px 5% 2em 1rem)");
		}
	});

	it("generates inset with border-radius", () => {
		const inset: Type.ClipPathInset = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "px" },
			right: { value: 10, unit: "px" },
			bottom: { value: 10, unit: "px" },
			left: { value: 10, unit: "px" },
			borderRadius: {
				topLeft: { value: 5, unit: "px" },
				topRight: { value: 5, unit: "px" },
				bottomRight: { value: 5, unit: "px" },
				bottomLeft: { value: 5, unit: "px" },
			},
		};
		const result = generate(inset);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10px round 5px)");
		}
	});

	it("generates inset with complex border-radius", () => {
		const inset: Type.ClipPathInset = {
			kind: "clip-path-inset",
			top: { value: 10, unit: "px" },
			right: { value: 20, unit: "px" },
			bottom: { value: 10, unit: "px" },
			left: { value: 20, unit: "px" },
			borderRadius: {
				topLeft: { value: 5, unit: "px" },
				topRight: { value: 10, unit: "px" },
				bottomRight: { value: 15, unit: "px" },
				bottomLeft: { value: 20, unit: "px" },
			},
		};
		const result = generate(inset);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset(10px 20px round 5px 10px 15px 20px)");
		}
	});

	it("returns error for null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("returns error for undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/clip-path/inset.ts ===
// b_path:: src/generate/clip-path/inset.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as GenerateUtils from "@/utils/generate";

/**
 * Generate CSS for inset() function.
 *
 * Optimizes TRBL values to shortest form:
 * - 4 equal values → 1 value
 * - top/bottom same, left/right same → 2 values
 * - etc.
 *
 * @param value - ClipPathInset IR
 * @returns CSS inset() function string
 *
 * @example
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-inset",
 *   top: { value: 10, unit: "px" },
 *   right: { value: 10, unit: "px" },
 *   bottom: { value: 10, unit: "px" },
 *   left: { value: 10, unit: "px" }
 * });
 * // "inset(10px)"
 * ```
 *
 * @public
 */
export function generate(value: Type.ClipPathInset): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	// Generate TRBL CSS (optimized to shortest form)
	const trblCss = generateTRBL({
		top: value.top,
		right: value.right,
		bottom: value.bottom,
		left: value.left,
	});

	// Generate optional border-radius
	let radiusCss = "";
	if (value.borderRadius) {
		radiusCss = ` round ${GenerateUtils.borderRadiusToCss(value.borderRadius)}`;
	}

	return generateOk(`inset(${trblCss}${radiusCss})`);
}

/**
 * Generate TRBL CSS in shortest form.
 *
 * @internal
 */
function generateTRBL(trbl: {
	top: Type.LengthPercentage;
	right: Type.LengthPercentage;
	bottom: Type.LengthPercentage;
	left: Type.LengthPercentage;
}): string {
	const top = GenerateUtils.lengthPercentageToCss(trbl.top);
	const right = GenerateUtils.lengthPercentageToCss(trbl.right);
	const bottom = GenerateUtils.lengthPercentageToCss(trbl.bottom);
	const left = GenerateUtils.lengthPercentageToCss(trbl.left);

	// Check for optimization opportunities
	if (top === right && right === bottom && bottom === left) {
		// All equal: 1 value
		return top;
	}

	if (top === bottom && right === left) {
		// Vertical same, horizontal same: 2 values
		return `${top} ${right}`;
	}

	if (right === left) {
		// Left/right same: 3 values
		return `${top} ${right} ${bottom}`;
	}

	// All different: 4 values
	return `${top} ${right} ${bottom} ${left}`;
}


=== File: src/generate/clip-path/none.test.ts ===
// b_path:: src/generate/clip-path/none.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./none";

describe("generate clip-path none", () => {
	it("generates 'none' keyword", () => {
		const result = generate({ kind: "clip-path-none" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("none");
		}
	});

	it("rejects null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});

	it("rejects undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});
});


=== File: src/generate/clip-path/none.ts ===
// b_path:: src/generate/clip-path/none.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { ClipPathNone } from "@/core/types/clip-path";

/**
 * Generate CSS none keyword for clip-path property.
 *
 * Converts ClipPathNone IR to CSS "none" keyword.
 *
 * @param _value - ClipPathNone IR value (unused)
 * @returns CSS string "none"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.ClipPath.None.generate({ kind: "clip-path-none" });
 * // "none"
 * ```
 *
 * @public
 */
export function generate(_value: ClipPathNone): GenerateResult {
	if (_value === undefined || _value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk("none");
}


=== File: src/generate/clip-path/path.test.ts ===
// b_path:: src/generate/clip-path/path.test.ts

import { describe, expect, it } from "vitest";
import { generate } from "./path";

describe("generate path", () => {
	it("generates simple path", () => {
		const result = generate({
			kind: "clip-path-path",
			pathData: "M 10,10 L 90,10 L 50,90 Z",
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("path('M 10,10 L 90,10 L 50,90 Z')");
		}
	});

	it("generates path with fill-rule", () => {
		const result = generate({
			kind: "clip-path-path",
			fillRule: "evenodd",
			pathData: "M 10,10 L 90,10 Z",
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("path(evenodd, 'M 10,10 L 90,10 Z')");
		}
	});

	it("generates path with nonzero fill-rule", () => {
		const result = generate({
			kind: "clip-path-path",
			fillRule: "nonzero",
			pathData: "M 0,0 L 100,100",
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("path(nonzero, 'M 0,0 L 100,100')");
		}
	});

	it("escapes single quotes in path data", () => {
		const result = generate({
			kind: "clip-path-path",
			pathData: "M 0,0 L 10,'10'",
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("path('M 0,0 L 10,\\'10\\'')");
		}
	});

	it("handles complex path data", () => {
		const result = generate({
			kind: "clip-path-path",
			pathData: "M 0,0 C 10,20 30,40 50,50 Z",
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("M 0,0 C 10,20 30,40 50,50 Z");
		}
	});

	it("handles null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("handles undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/clip-path/path.ts ===
// b_path:: src/generate/clip-path/path.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS for path() function.
 *
 * Outputs the path data string, optionally prefixed with fill-rule.
 *
 * @param value - ClipPathPath IR
 * @returns CSS path() function string
 *
 * @example
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-path",
 *   pathData: "M 10,10 L 90,10 L 50,90 Z"
 * });
 * // "path('M 10,10 L 90,10 L 50,90 Z')"
 * ```
 *
 * @example
 * With fill-rule:
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-path",
 *   fillRule: "evenodd",
 *   pathData: "M 10,10 L 90,10 Z"
 * });
 * // "path(evenodd, 'M 10,10 L 90,10 Z')"
 * ```
 *
 * @public
 */
export function generate(value: Type.ClipPathPath): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const pathDataEscaped = value.pathData.replace(/'/g, "\\'");

	if (value.fillRule) {
		return generateOk(`path(${value.fillRule}, '${pathDataEscaped}')`);
	}

	return generateOk(`path('${pathDataEscaped}')`);
}


=== File: src/generate/clip-path/polygon.test.ts ===
// b_path:: src/generate/clip-path/polygon.test.ts

import { describe, expect, it } from "vitest";
import { generate } from "./polygon";

describe("generate polygon", () => {
	it("generates simple triangle", () => {
		const result = generate({
			kind: "clip-path-polygon",
			points: [
				{ x: { value: 50, unit: "%" }, y: { value: 0, unit: "%" } },
				{ x: { value: 100, unit: "%" }, y: { value: 50, unit: "%" } },
				{ x: { value: 50, unit: "%" }, y: { value: 100, unit: "%" } },
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("polygon(50% 0%, 100% 50%, 50% 100%)");
		}
	});

	it("generates polygon with fill-rule", () => {
		const result = generate({
			kind: "clip-path-polygon",
			fillRule: "nonzero",
			points: [
				{ x: { value: 50, unit: "%" }, y: { value: 0, unit: "%" } },
				{ x: { value: 100, unit: "%" }, y: { value: 100, unit: "%" } },
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("polygon(nonzero, 50% 0%, 100% 100%)");
		}
	});

	it("generates polygon with evenodd fill-rule", () => {
		const result = generate({
			kind: "clip-path-polygon",
			fillRule: "evenodd",
			points: [
				{ x: { value: 0, unit: "%" }, y: { value: 0, unit: "%" } },
				{ x: { value: 100, unit: "%" }, y: { value: 0, unit: "%" } },
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("evenodd");
		}
	});

	it("generates polygon with px units", () => {
		const result = generate({
			kind: "clip-path-polygon",
			points: [
				{ x: { value: 10, unit: "px" }, y: { value: 20, unit: "px" } },
				{ x: { value: 30, unit: "px" }, y: { value: 40, unit: "px" } },
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("polygon(10px 20px, 30px 40px)");
		}
	});

	it("handles null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("handles undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/clip-path/polygon.ts ===
// b_path:: src/generate/clip-path/polygon.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as GenerateUtils from "@/utils/generate";

/**
 * Generate CSS polygon() function from ClipPathPolygon IR.
 *
 * Syntax: polygon( <fill-rule>? , <shape-arg># )
 *
 * @param polygon - ClipPathPolygon IR
 * @returns CSS string
 *
 * @example
 * toCss({ kind: "clip-path-polygon", points: [{x: {value:50, unit:"%"}, y: {value:0, unit:"%"}}, ...] });
 * // "polygon(50% 0%, 100% 50%, 50% 100%)"
 *
 * toCss({ kind: "clip-path-polygon", fillRule: "nonzero", points: [...] });
 * // "polygon(nonzero, 50% 0%, 100% 50%, 50% 100%)"
 *
 * @public
 */
export function generate(polygon: Type.ClipPathPolygon): GenerateResult {
	if (polygon === undefined || polygon === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const parts: string[] = ["polygon("];

	// Add fill-rule if present
	if (polygon.fillRule) {
		parts.push(polygon.fillRule, ", ");
	}

	// Add points
	const pointStrings = polygon.points.map((point) => {
		const x = GenerateUtils.lengthPercentageToCss(point.x);
		const y = GenerateUtils.lengthPercentageToCss(point.y);
		return `${x} ${y}`;
	});

	parts.push(pointStrings.join(", "));
	parts.push(")");

	return generateOk(parts.join(""));
}


=== File: src/generate/clip-path/rect.test.ts ===
// b_path:: src/generate/clip-path/rect.test.ts

import { describe, expect, it } from "vitest";
import { generate } from "./rect";

describe("generate rect", () => {
	it("generates rect with all pixel values", () => {
		const result = generate({
			kind: "clip-path-rect",
			top: { value: 10, unit: "px" },
			right: { value: 90, unit: "px" },
			bottom: { value: 80, unit: "px" },
			left: { value: 20, unit: "px" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rect(10px 90px 80px 20px)");
		}
	});

	it("generates rect with auto values", () => {
		const result = generate({
			kind: "clip-path-rect",
			top: { value: 10, unit: "px" },
			right: "auto",
			bottom: { value: 20, unit: "px" },
			left: "auto",
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rect(10px auto 20px auto)");
		}
	});

	it("generates rect with all auto", () => {
		const result = generate({
			kind: "clip-path-rect",
			top: "auto",
			right: "auto",
			bottom: "auto",
			left: "auto",
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rect(auto auto auto auto)");
		}
	});

	it("generates rect with percentages", () => {
		const result = generate({
			kind: "clip-path-rect",
			top: { value: 10, unit: "%" },
			right: { value: 90, unit: "%" },
			bottom: { value: 80, unit: "%" },
			left: { value: 20, unit: "%" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rect(10% 90% 80% 20%)");
		}
	});

	it("generates rect with border-radius", () => {
		const result = generate({
			kind: "clip-path-rect",
			top: { value: 0, unit: "px" },
			right: { value: 100, unit: "px" },
			bottom: { value: 100, unit: "px" },
			left: { value: 0, unit: "px" },
			borderRadius: {
				topLeft: { value: 10, unit: "px" },
				topRight: { value: 10, unit: "px" },
				bottomRight: { value: 10, unit: "px" },
				bottomLeft: { value: 10, unit: "px" },
			},
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("round");
		}
	});

	it("handles null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("handles undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/clip-path/rect.ts ===
// b_path:: src/generate/clip-path/rect.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as GenerateUtils from "@/utils/generate";

/**
 * Generate CSS for rect() function.
 *
 * Always outputs all 4 values for clarity (top right bottom left).
 * Does not optimize to shorter forms.
 *
 * @param value - ClipPathRect IR
 * @returns CSS rect() function string
 *
 * @example
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-rect",
 *   top: { value: 10, unit: "px" },
 *   right: "auto",
 *   bottom: { value: 20, unit: "px" },
 *   left: "auto"
 * });
 * // "rect(10px auto 20px auto)"
 * ```
 *
 * @public
 */
export function generate(value: Type.ClipPathRect): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	// Generate TRBL CSS (always 4 values)
	const top = value.top === "auto" ? "auto" : GenerateUtils.lengthPercentageToCss(value.top);
	const right = value.right === "auto" ? "auto" : GenerateUtils.lengthPercentageToCss(value.right);
	const bottom = value.bottom === "auto" ? "auto" : GenerateUtils.lengthPercentageToCss(value.bottom);
	const left = value.left === "auto" ? "auto" : GenerateUtils.lengthPercentageToCss(value.left);

	const trblCss = `${top} ${right} ${bottom} ${left}`;

	// Generate optional border-radius
	let radiusCss = "";
	if (value.borderRadius) {
		radiusCss = ` round ${GenerateUtils.borderRadiusToCss(value.borderRadius)}`;
	}

	return generateOk(`rect(${trblCss}${radiusCss})`);
}


=== File: src/generate/clip-path/url.test.ts ===
// b_path:: src/generate/clip-path/url.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./url";

describe("generate clip-path url", () => {
	it("generates url with fragment", () => {
		const result = generate({ kind: "url", value: "#clip-shape" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("url(#clip-shape)");
		}
	});

	it("generates url with file and fragment", () => {
		const result = generate({ kind: "url", value: "shapes.svg#clip" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("url(shapes.svg#clip)");
		}
	});

	it("generates url with path", () => {
		const result = generate({ kind: "url", value: "/path/to/shapes.svg#myClip" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("url(/path/to/shapes.svg#myClip)");
		}
	});

	it("rejects null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});

	it("rejects undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});
});


=== File: src/generate/clip-path/url.ts ===
// b_path:: src/generate/clip-path/url.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Url } from "@/core/types/url";
import { urlToCss } from "@/utils/generate/url";

/**
 * Generate CSS url() for clip-path property.
 *
 * Converts Url IR to CSS url() function string.
 *
 * @param value - Url IR value
 * @returns CSS string like "url(#clip-shape)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.ClipPath.Url.generate({
 *   kind: "url",
 *   value: "#clip-shape"
 * });
 * // "url(#clip-shape)"
 * ```
 *
 * @public
 */
export function generate(value: Url): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(urlToCss(value));
}


=== File: src/generate/clip-path/xywh.test.ts ===
// b_path:: src/generate/clip-path/xywh.test.ts

import { describe, expect, it } from "vitest";
import { generate } from "./xywh";

describe("generate xywh", () => {
	it("generates simple xywh", () => {
		const result = generate({
			kind: "clip-path-xywh",
			x: { value: 10, unit: "px" },
			y: { value: 20, unit: "px" },
			width: { value: 100, unit: "px" },
			height: { value: 50, unit: "px" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("xywh(10px 20px 100px 50px)");
		}
	});

	it("generates xywh with percentages", () => {
		const result = generate({
			kind: "clip-path-xywh",
			x: { value: 10, unit: "%" },
			y: { value: 20, unit: "%" },
			width: { value: 50, unit: "%" },
			height: { value: 30, unit: "%" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("xywh(10% 20% 50% 30%)");
		}
	});

	it("generates xywh with border-radius", () => {
		const result = generate({
			kind: "clip-path-xywh",
			x: { value: 0, unit: "px" },
			y: { value: 0, unit: "px" },
			width: { value: 100, unit: "px" },
			height: { value: 100, unit: "px" },
			borderRadius: {
				topLeft: { value: 10, unit: "px" },
				topRight: { value: 10, unit: "px" },
				bottomRight: { value: 10, unit: "px" },
				bottomLeft: { value: 10, unit: "px" },
			},
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("round");
		}
	});

	it("generates xywh with zero values", () => {
		const result = generate({
			kind: "clip-path-xywh",
			x: { value: 0, unit: "px" },
			y: { value: 0, unit: "px" },
			width: { value: 0, unit: "px" },
			height: { value: 0, unit: "px" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("xywh(0px 0px 0px 0px)");
		}
	});

	it("handles null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("handles undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/clip-path/xywh.ts ===
// b_path:: src/generate/clip-path/xywh.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as GenerateUtils from "@/utils/generate";

/**
 * Generate CSS for xywh() function.
 *
 * Always outputs all 4 values (x, y, width, height).
 *
 * @param value - ClipPathXywh IR
 * @returns CSS xywh() function string
 *
 * @example
 * ```typescript
 * const css = toCss({
 *   kind: "clip-path-xywh",
 *   x: { value: 10, unit: "px" },
 *   y: { value: 20, unit: "px" },
 *   width: { value: 100, unit: "px" },
 *   height: { value: 50, unit: "px" }
 * });
 * // "xywh(10px 20px 100px 50px)"
 * ```
 *
 * @public
 */
export function generate(value: Type.ClipPathXywh): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const x = GenerateUtils.lengthPercentageToCss(value.x);
	const y = GenerateUtils.lengthPercentageToCss(value.y);
	const width = GenerateUtils.lengthPercentageToCss(value.width);
	const height = GenerateUtils.lengthPercentageToCss(value.height);

	const xywhCss = `${x} ${y} ${width} ${height}`;

	// Generate optional border-radius
	let radiusCss = "";
	if (value.borderRadius) {
		radiusCss = ` round ${GenerateUtils.borderRadiusToCss(value.borderRadius)}`;
	}

	return generateOk(`xywh(${xywhCss}${radiusCss})`);
}


=== File: src/generate/color/color-function.test.ts ===
// b_path:: src/generate/color/color-function.test.ts
import { describe, expect, test } from "vitest";
import * as Parse from "../../parse/color/color-function";
import * as Generate from "./color-function";

describe("generate() - color() function generator", () => {
	describe("Basic Generation", () => {
		test("srgb color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 0.5 0.2 0.8)" });
		});

		test("srgb-linear color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb-linear",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb-linear 0.5 0.2 0.8)" });
		});

		test("display-p3 color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "display-p3",
				channels: [0.928, 0.322, 0.203],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(display-p3 0.928 0.322 0.203)" });
		});

		test("a98-rgb color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "a98-rgb",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(a98-rgb 0.5 0.2 0.8)" });
		});

		test("prophoto-rgb color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "prophoto-rgb",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(prophoto-rgb 0.5 0.2 0.8)" });
		});

		test("rec2020 color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "rec2020",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(rec2020 0.5 0.2 0.8)" });
		});

		test("xyz color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "xyz",
				channels: [0.3, 0.4, 0.5],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(xyz 0.3 0.4 0.5)" });
		});

		test("xyz-d50 color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "xyz-d50",
				channels: [0.3, 0.4, 0.5],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(xyz-d50 0.3 0.4 0.5)" });
		});

		test("xyz-d65 color space", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "xyz-d65",
				channels: [0.3, 0.4, 0.5],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(xyz-d65 0.3 0.4 0.5)" });
		});
	});

	describe("Alpha Generation", () => {
		test("color with alpha", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
				alpha: 0.5,
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 0.5 0.2 0.8 / 0.5)" });
		});

		test("color without alpha", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 0.5 0.2 0.8)" });
		});

		test("alpha 0", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
				alpha: 0,
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 0.5 0.2 0.8 / 0)" });
		});

		test("alpha 1", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.2, 0.8],
				alpha: 1,
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 0.5 0.2 0.8 / 1)" });
		});
	});

	describe("Precision and Rounding", () => {
		test("rounds trailing zeros", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.5, 0.20000000000001, 0.8],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 0.5 0.2 0.8)" });
		});

		test("preserves necessary precision", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [0.123456, 0.789012, 0.345678],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 0.123456 0.789012 0.345678)" });
		});

		test("handles zero values", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [0, 0, 0],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 0 0 0)" });
		});

		test("handles one values", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "srgb",
				channels: [1, 1, 1],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(srgb 1 1 1)" });
		});

		test("handles negative values", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "xyz",
				channels: [-0.1, 0.5, -0.2],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(xyz -0.1 0.5 -0.2)" });
		});

		test("handles values over 1", () => {
			const css = Generate.generate({
				kind: "color",
				colorSpace: "xyz",
				channels: [1.5, 2.0, 1.8],
			});
			expect(css).toEqual({ ok: true, issues: [], value: "color(xyz 1.5 2 1.8)" });
		});
	});

	describe("Round-Trip", () => {
		test("parse and generate srgb", () => {
			const original = "color(srgb 0.5 0.2 0.8)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (generated.ok) expect(generated.value).toBe(original);

				const reparsed = generated.ok ? Parse.parse(generated.value) : { ok: false as const };
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		test("parse and generate display-p3 with alpha", () => {
			const original = "color(display-p3 0.928 0.322 0.203 / 0.8)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (generated.ok) expect(generated.value).toBe(original);

				const reparsed = generated.ok ? Parse.parse(generated.value) : { ok: false as const };
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		test("parse and generate xyz-d50", () => {
			const original = "color(xyz-d50 0.3 0.4 0.5)";
			const parsed = Parse.parse(original);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (generated.ok) expect(generated.value).toBe(original);

				const reparsed = generated.ok ? Parse.parse(generated.value) : { ok: false as const };
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/generate/color/color-function.ts ===
// b_path:: src/generate/color/color-function.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Convert color() IR to CSS string.
 *
 * @param value - ColorFunction IR
 * @returns CSS color() function string
 *
 * @example
 * ```typescript
 * toCss({
 *   kind: "color",
 *   colorSpace: "display-p3",
 *   channels: [0.928, 0.322, 0.203],
 *   alpha: 0.8
 * });
 * // "color(display-p3 0.928 0.322 0.203 / 0.8)"
 * ```
 *
 * @public
 */
export function generate(value: Type.ColorFunction): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "ColorFunction must not be null or undefined");
	}
	if (typeof value !== "object") {
		return generateErr("invalid-ir", `Expected ColorFunction object, got ${typeof value}`);
	}
	if (!("colorSpace" in value) || !("channels" in value)) {
		return generateErr("missing-required-field", "ColorFunction must have 'colorSpace' and 'channels' fields");
	}

	const parts: string[] = ["color(", value.colorSpace];

	// Add channels
	for (const channel of value.channels) {
		parts.push(" ");
		parts.push(channel.toFixed(6).replace(/\.?0+$/, "") || "0");
	}

	// Add alpha if present
	if (value.alpha !== undefined) {
		parts.push(" / ");
		parts.push(value.alpha.toFixed(6).replace(/\.?0+$/, "") || "0");
	}

	parts.push(")");
	return generateOk(parts.join(""));
}


=== File: src/generate/color/color.test.ts ===
// b_path:: src/generate/color/color.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./color";

describe("Color.generate()", () => {
	test("generates hex color", () => {
		const color: Type.Color = { kind: "hex", value: "#FF0000" };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("#FF0000");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates named color", () => {
		const color: Type.Color = { kind: "named", name: "red" };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("red");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates rgb color", () => {
		const color: Type.Color = { kind: "rgb", r: 255, g: 0, b: 0 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rgb(255 0 0)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates rgb color with alpha", () => {
		const color: Type.Color = { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rgb(255 0 0 / 0.5)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates hsl color", () => {
		const color: Type.Color = { kind: "hsl", h: 120, s: 100, l: 50 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("hsl(120 100% 50%)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates hwb color", () => {
		const color: Type.Color = { kind: "hwb", h: 120, w: 20, b: 30 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("hwb(120 20% 30%)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates lab color", () => {
		const color: Type.Color = { kind: "lab", l: 50, a: -20, b: 30 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("lab(50 -20 30)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates lch color", () => {
		const color: Type.Color = { kind: "lch", l: 50, c: 50, h: 180 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("lch(50 50 180)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates oklab color", () => {
		const color: Type.Color = { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("oklab(0.5 -0.2 0.3)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates oklch color", () => {
		const color: Type.Color = { kind: "oklch", l: 0.5, c: 0.2, h: 180 };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("oklch(0.5 0.2 180)");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates system color", () => {
		const color: Type.Color = { kind: "system", keyword: "ButtonText" };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("ButtonText");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates special color", () => {
		const color: Type.Color = { kind: "special", keyword: "transparent" };
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("transparent");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates color() function", () => {
		const color: Type.Color = {
			kind: "color",
			colorSpace: "display-p3",
			channels: [0.928, 0.322, 0.203],
		};
		const result = generate(color);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("color(display-p3 0.928 0.322 0.203)");
			expect(result.issues).toEqual([]);
		}
	});

	test("returns error for invalid IR (missing kind)", () => {
		const color = {} as Type.Color;
		const result = generate(color);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});

	test("returns error for unknown kind", () => {
		const color = { kind: "unknown" } as unknown as Type.Color;
		const result = generate(color);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("Unknown color kind");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});
});


=== File: src/generate/color/color.ts ===
// b_path:: src/generate/color/color.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types";
import * as ColorFunction from "./color-function";
import * as Hex from "./hex";
import * as Hsl from "./hsl";
import * as Hwb from "./hwb";
import * as Lab from "./lab";
import * as Lch from "./lch";
import * as Named from "./named";
import * as Oklab from "./oklab";
import * as Oklch from "./oklch";
import * as Rgb from "./rgb";
import * as Special from "./special";
import * as System from "./system";

/**
 * Generate CSS from color IR with auto-detection.
 *
 * Automatically detects color format from IR.kind and generates appropriate CSS.
 * Supports all 12 CSS color formats.
 *
 * @param color - Color IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate({ kind: "hex", value: "#FF0000" })
 * // → { ok: true, value: "#FF0000", issues: [] }
 *
 * generate({ kind: "rgb", r: 255, g: 0, b: 0 })
 * // → { ok: true, value: "rgb(255 0 0)", issues: [] }
 *
 * generate({ kind: "hsl", h: 120, s: 100, l: 50 })
 * // → { ok: true, value: "hsl(120 100% 50%)", issues: [] }
 * ```
 *
 * @public
 */
export function generate(color: Type.Color): GenerateResult {
	// Validate IR has 'kind' field
	if (!color || typeof color !== "object" || !("kind" in color)) {
		return generateErr("missing-required-field", "Invalid color IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (color.kind) {
		case "hex":
			return Hex.generate(color);

		case "named":
			return Named.generate(color);

		case "rgb":
			return Rgb.generate(color);

		case "hsl":
			return Hsl.generate(color);

		case "hwb":
			return Hwb.generate(color);

		case "lab":
			return Lab.generate(color);

		case "lch":
			return Lch.generate(color);

		case "oklab":
			return Oklab.generate(color);

		case "oklch":
			return Oklch.generate(color);

		case "system":
			return System.generate(color);

		case "special":
			return Special.generate(color);

		case "color":
			return ColorFunction.generate(color);

		default:
			return generateErr("unsupported-kind", `Unknown color kind: ${(color as { kind?: string }).kind}`, {
				suggestion: "Check that color IR is valid",
			});
	}
}


=== File: src/generate/color/hex.test.ts ===
// b_path:: src/generate/color/hex.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./hex";

describe("hex color generator", () => {
	test("should generate 6-digit hex color", () => {
		const result = generate({ kind: "hex", value: "#FF5733" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("#FF5733");
	});

	test("should generate 8-digit hex color with alpha", () => {
		const result = generate({ kind: "hex", value: "#FF573380" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("#FF573380");
	});

	test("should generate 3-digit shorthand hex", () => {
		const result = generate({ kind: "hex", value: "#F00" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("#F00");
	});

	test("should generate black color", () => {
		const result = generate({ kind: "hex", value: "#000000" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("#000000");
	});
});


=== File: src/generate/color/hex.ts ===
// b_path:: src/generate/color/hex.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { HexColor } from "@/core/types/color";

/**
 * Generate CSS from a hex color value.
 *
 * Converts a HexColor IR back to its CSS string representation.
 * Output is always uppercase #RRGGBB or #RRGGBBAA format.
 *
 * @param color - The hex color to convert
 * @returns CSS hex color string
 *
 * @example
 * ```typescript
 * import { generate } from "@/generate/color/hex";
 *
 * const css1 = generate({ kind: "hex", value: "#FF5733" });
 * // => { ok: true, value: "#FF5733" }
 *
 * const css2 = generate({ kind: "hex", value: "#FF573380" });
 * // => { ok: true, value: "#FF573380" }
 * ```
 *
 * @public
 */
export function generate(color: HexColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "HexColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected HexColor object, got ${typeof color}`);
	}
	if (!("value" in color)) {
		return generateErr("missing-required-field", "HexColor must have 'value' field");
	}
	return generateOk(color.value);
}


=== File: src/generate/color/hsl.test.ts ===
// b_path:: src/generate/color/hsl.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./hsl";

describe("hsl color generator", () => {
	test("should generate opaque HSL color", () => {
		const result = generate({ kind: "hsl", h: 120, s: 100, l: 50 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hsl(120 100% 50%)");
	});

	test("should generate HSL with alpha", () => {
		const result = generate({ kind: "hsl", h: 240, s: 75, l: 60, alpha: 0.8 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hsl(240 75% 60% / 0.8)");
	});

	test("should omit alpha when fully opaque", () => {
		const result = generate({ kind: "hsl", h: 0, s: 100, l: 50, alpha: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hsl(0 100% 50%)");
	});

	test("should handle zero saturation", () => {
		const result = generate({ kind: "hsl", h: 0, s: 0, l: 50 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hsl(0 0% 50%)");
	});
});


=== File: src/generate/color/hsl.ts ===
// b_path:: src/generate/color/hsl.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { HSLColor } from "@/core/types/color";

/**
 * Generate CSS from an HSL color value.
 *
 * Converts an HSLColor IR back to its CSS string representation.
 * Uses modern space-separated syntax without units on percentages.
 *
 * @param color - The HSL color to convert
 * @returns CSS HSL color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/hsl";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "hsl", h: 120, s: 100, l: 50 });
 * // => "hsl(120 100% 50%)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "hsl", h: 120, s: 100, l: 50, alpha: 0.5 });
 * // => "hsl(120 100% 50% / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "hsl", h: 120, s: 100, l: 50, alpha: 1 });
 * // => "hsl(120 100% 50%)"
 * ```
 *
 * @public
 */
export function generate(color: HSLColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "HSLColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected HSLColor object, got ${typeof color}`);
	}
	if (!("h" in color) || !("s" in color) || !("l" in color)) {
		return generateErr("missing-required-field", "HSLColor must have 'h', 's', 'l' fields");
	}

	const { h, s, l, alpha } = color;

	// Format HSL values (hue as number, saturation and lightness with %)
	const hslPart = `${h} ${s}% ${l}%`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return generateOk(`hsl(${hslPart} / ${alpha})`);
	}

	return generateOk(`hsl(${hslPart})`);
}


=== File: src/generate/color/hwb.test.ts ===
// b_path:: src/generate/color/hwb.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./hwb";

describe("hwb color generator", () => {
	test("should generate opaque HWB color", () => {
		const result = generate({ kind: "hwb", h: 120, w: 20, b: 30 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hwb(120 20% 30%)");
	});

	test("should generate HWB with alpha", () => {
		const result = generate({ kind: "hwb", h: 180, w: 10, b: 15, alpha: 0.5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hwb(180 10% 15% / 0.5)");
	});

	test("should omit alpha when fully opaque", () => {
		const result = generate({ kind: "hwb", h: 240, w: 0, b: 0, alpha: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hwb(240 0% 0%)");
	});

	test("should handle zero whiteness and blackness", () => {
		const result = generate({ kind: "hwb", h: 60, w: 0, b: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hwb(60 0% 0%)");
	});
});


=== File: src/generate/color/hwb.ts ===
// b_path:: src/generate/color/hwb.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { HWBColor } from "@/core/types/color";

/**
 * Generate CSS string from HWB color object.
 *
 * Always outputs modern space-separated syntax:
 * - `hwb(120 20% 30%)` - without alpha
 * - `hwb(120 20% 30% / 0.5)` - with alpha
 *
 * @param color - The HWB color object
 * @returns CSS HWB color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/hwb";
 *
 * // Basic HWB
 * toCss({ kind: "hwb", h: 120, w: 20, b: 30 });
 * // => "hwb(120 20% 30%)"
 *
 * // With alpha
 * toCss({ kind: "hwb", h: 120, w: 20, b: 30, alpha: 0.5 });
 * // => "hwb(120 20% 30% / 0.5)"
 * ```
 *
 * @public
 */
export function generate(color: HWBColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "HWBColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected HWBColor object, got ${typeof color}`);
	}
	if (!("h" in color) || !("w" in color) || !("b" in color)) {
		return generateErr("missing-required-field", "HWBColor must have 'h', 'w', 'b' fields");
	}

	const { h, w, b, alpha } = color;

	// Format: hwb(H W% B%)
	let result = `hwb(${h} ${w}% ${b}%`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha !== 1) {
		result += ` / ${alpha}`;
	}

	result += ")";
	return generateOk(result);
}


=== File: src/generate/color/index.ts ===
// b_path:: src/generate/color/index.ts

export { generate } from "./color";

export * as ColorFunction from "./color-function";
export * as Hex from "./hex";
export * as Hsl from "./hsl";
export * as Hwb from "./hwb";
export * as Lab from "./lab";
export * as Lch from "./lch";
export * as Named from "./named";
export * as Oklab from "./oklab";
export * as Oklch from "./oklch";
export * as Rgb from "./rgb";
export * as Special from "./special";
export * as System from "./system";


=== File: src/generate/color/lab.test.ts ===
// b_path:: src/generate/color/lab.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./lab";

describe("lab color generator", () => {
	test("should generate opaque LAB color", () => {
		const result = generate({ kind: "lab", l: 50, a: -20, b: 30 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lab(50 -20 30)");
	});

	test("should generate LAB with alpha", () => {
		const result = generate({ kind: "lab", l: 75, a: 15, b: -10, alpha: 0.6 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lab(75 15 -10 / 0.6)");
	});

	test("should omit alpha when fully opaque", () => {
		const result = generate({ kind: "lab", l: 100, a: 0, b: 0, alpha: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lab(100 0 0)");
	});

	test("should handle negative values", () => {
		const result = generate({ kind: "lab", l: 25, a: -50, b: -40 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lab(25 -50 -40)");
	});
});


=== File: src/generate/color/lab.ts ===
// b_path:: src/generate/color/lab.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { LABColor } from "@/core/types/color";

/**
 * Generate CSS from a LAB color value.
 *
 * Converts a LABColor IR back to its CSS string representation.
 * Uses modern space-separated syntax.
 *
 * @param color - The LAB color to convert
 * @returns CSS LAB color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/lab";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "lab", l: 50, a: -20, b: 30 });
 * // => "lab(50 -20 30)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "lab", l: 50, a: -20, b: 30, alpha: 0.5 });
 * // => "lab(50 -20 30 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "lab", l: 50, a: -20, b: 30, alpha: 1 });
 * // => "lab(50 -20 30)"
 * ```
 *
 * @public
 */
export function generate(color: LABColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "LABColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected LABColor object, got ${typeof color}`);
	}
	if (!("l" in color) || !("a" in color) || !("b" in color)) {
		return generateErr("missing-required-field", "LABColor must have 'l', 'a', 'b' fields");
	}

	const { l, a, b, alpha } = color;

	// Format LAB values (lightness, a, b as numbers)
	const labPart = `${l} ${a} ${b}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return generateOk(`lab(${labPart} / ${alpha})`);
	}

	return generateOk(`lab(${labPart})`);
}


=== File: src/generate/color/lch.test.ts ===
// b_path:: src/generate/color/lch.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./lch";

describe("lch color generator", () => {
	test("should generate opaque LCH color", () => {
		const result = generate({ kind: "lch", l: 50, c: 50, h: 180 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lch(50 50 180)");
	});

	test("should generate LCH with alpha", () => {
		const result = generate({ kind: "lch", l: 75, c: 30, h: 120, alpha: 0.7 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lch(75 30 120 / 0.7)");
	});

	test("should omit alpha when fully opaque", () => {
		const result = generate({ kind: "lch", l: 100, c: 0, h: 0, alpha: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lch(100 0 0)");
	});

	test("should handle various hue values", () => {
		const result = generate({ kind: "lch", l: 60, c: 40, h: 270 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lch(60 40 270)");
	});
});


=== File: src/generate/color/lch.ts ===
// b_path:: src/generate/color/lch.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { LCHColor } from "@/core/types/color";

/**
 * Generate CSS from a LCH color value.
 *
 * Converts a LCHColor IR back to its CSS string representation.
 * Uses modern space-separated syntax without units.
 *
 * @param color - The LCH color to convert
 * @returns CSS LCH color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/lch";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "lch", l: 50, c: 50, h: 180 });
 * // => "lch(50 50 180)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "lch", l: 50, c: 50, h: 180, alpha: 0.5 });
 * // => "lch(50 50 180 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "lch", l: 50, c: 50, h: 180, alpha: 1 });
 * // => "lch(50 50 180)"
 * ```
 *
 * @public
 */
export function generate(color: LCHColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "LCHColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected LCHColor object, got ${typeof color}`);
	}
	if (!("l" in color) || !("c" in color) || !("h" in color)) {
		return generateErr("missing-required-field", "LCHColor must have 'l', 'c', 'h' fields");
	}

	const { l, c, h, alpha } = color;

	// Format LCH values (lightness, chroma, hue as numbers)
	const lchPart = `${l} ${c} ${h}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return generateOk(`lch(${lchPart} / ${alpha})`);
	}

	return generateOk(`lch(${lchPart})`);
}


=== File: src/generate/color/named.test.ts ===
// b_path:: src/generate/color/named.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./named";

describe("named color generator", () => {
	test("should generate basic named color", () => {
		const result = generate({ kind: "named", name: "red" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("red");
	});

	test("should generate compound named color", () => {
		const result = generate({ kind: "named", name: "cornflowerblue" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("cornflowerblue");
	});

	test("should generate 'white' color", () => {
		const result = generate({ kind: "named", name: "white" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("white");
	});

	test("should generate 'black' color", () => {
		const result = generate({ kind: "named", name: "black" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("black");
	});
});


=== File: src/generate/color/named.ts ===
// b_path:: src/generate/color/named.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { NamedColor } from "@/core/types/color";

/**
 * Generate CSS from a named color value.
 *
 * Converts a NamedColor IR back to its CSS string representation.
 * Output is always lowercase color name.
 *
 * @param color - The named color to convert
 * @returns CSS color name string
 *
 * @example
 * ```typescript
 * import { generate } from "@/generate/color/named";
 *
 * const css1 = generate({ kind: "named", name: "red" });
 * // => { ok: true, value: "red" }
 *
 * const css2 = generate({ kind: "named", name: "cornflowerblue" });
 * // => { ok: true, value: "cornflowerblue" }
 * ```
 *
 * @public
 */
export function generate(color: NamedColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "NamedColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected NamedColor object, got ${typeof color}`);
	}
	if (!("name" in color)) {
		return generateErr("missing-required-field", "NamedColor must have 'name' field");
	}
	return generateOk(color.name);
}


=== File: src/generate/color/oklab.test.ts ===
// b_path:: src/generate/color/oklab.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./oklab";

describe("oklab color generator", () => {
	test("should generate opaque OKLab color", () => {
		const result = generate({ kind: "oklab", l: 0.5, a: -0.2, b: 0.3 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("oklab(0.5 -0.2 0.3)");
	});

	test("should generate OKLab with alpha", () => {
		const result = generate({ kind: "oklab", l: 0.75, a: 0.1, b: -0.05, alpha: 0.9 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("oklab(0.75 0.1 -0.05 / 0.9)");
	});

	test("should omit alpha when fully opaque", () => {
		const result = generate({ kind: "oklab", l: 1, a: 0, b: 0, alpha: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("oklab(1 0 0)");
	});

	test("should handle negative a and b values", () => {
		const result = generate({ kind: "oklab", l: 0.3, a: -0.15, b: -0.25 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("oklab(0.3 -0.15 -0.25)");
	});
});


=== File: src/generate/color/oklab.ts ===
// b_path:: src/generate/color/oklab.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { OKLabColor } from "@/core/types/color";

/**
 * Generate CSS from an OKLab color value.
 *
 * Converts an OKLabColor IR back to its CSS string representation.
 * Uses modern space-separated syntax.
 *
 * @param color - The OKLab color to convert
 * @returns CSS OKLab color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/oklab";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "oklab", l: 0.5, a: -0.2, b: 0.3 });
 * // => "oklab(0.5 -0.2 0.3)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "oklab", l: 0.5, a: -0.2, b: 0.3, alpha: 0.5 });
 * // => "oklab(0.5 -0.2 0.3 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "oklab", l: 0.5, a: -0.2, b: 0.3, alpha: 1 });
 * // => "oklab(0.5 -0.2 0.3)"
 * ```
 *
 * @public
 */
export function generate(color: OKLabColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "OKLabColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected OKLabColor object, got ${typeof color}`);
	}
	if (!("l" in color) || !("a" in color) || !("b" in color)) {
		return generateErr("missing-required-field", "OKLabColor must have 'l', 'a', 'b' fields");
	}

	const { l, a, b, alpha } = color;

	// Format OKLab values (lightness, a, b as numbers)
	const oklabPart = `${l} ${a} ${b}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return generateOk(`oklab(${oklabPart} / ${alpha})`);
	}

	return generateOk(`oklab(${oklabPart})`);
}


=== File: src/generate/color/oklch.test.ts ===
// b_path:: src/generate/color/oklch.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./oklch";

describe("oklch color generator", () => {
	test("should generate opaque OKLCH color", () => {
		const result = generate({ kind: "oklch", l: 0.5, c: 0.2, h: 180 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("oklch(0.5 0.2 180)");
	});

	test("should generate OKLCH with alpha", () => {
		const result = generate({ kind: "oklch", l: 0.8, c: 0.15, h: 90, alpha: 0.85 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("oklch(0.8 0.15 90 / 0.85)");
	});

	test("should omit alpha when fully opaque", () => {
		const result = generate({ kind: "oklch", l: 1, c: 0, h: 0, alpha: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("oklch(1 0 0)");
	});

	test("should handle various hue values", () => {
		const result = generate({ kind: "oklch", l: 0.6, c: 0.25, h: 300 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("oklch(0.6 0.25 300)");
	});
});


=== File: src/generate/color/oklch.ts ===
// b_path:: src/generate/color/oklch.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { OKLCHColor } from "@/core/types/color";

/**
 * Generate CSS from an OKLCH color value.
 *
 * Converts an OKLCHColor IR back to its CSS string representation.
 * Uses modern space-separated syntax. Hue is output as a unitless number (degrees implied).
 *
 * @param color - The OKLCH color to convert
 * @returns CSS OKLCH color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/oklch";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "oklch", l: 0.5, c: 0.2, h: 180 });
 * // => "oklch(0.5 0.2 180)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "oklch", l: 0.5, c: 0.2, h: 180, alpha: 0.5 });
 * // => "oklch(0.5 0.2 180 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "oklch", l: 0.5, c: 0.2, h: 180, alpha: 1 });
 * // => "oklch(0.5 0.2 180)"
 * ```
 *
 * @public
 */
export function generate(color: OKLCHColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "OKLCHColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected OKLCHColor object, got ${typeof color}`);
	}
	if (!("l" in color) || !("c" in color) || !("h" in color)) {
		return generateErr("missing-required-field", "OKLCHColor must have 'l', 'c', 'h' fields");
	}

	const { l, c, h, alpha } = color;

	// Format OKLCH values (lightness, chroma, hue as numbers)
	// Hue is output as unitless (degrees implied)
	const oklchPart = `${l} ${c} ${h}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return generateOk(`oklch(${oklchPart} / ${alpha})`);
	}

	return generateOk(`oklch(${oklchPart})`);
}


=== File: src/generate/color/rgb.test.ts ===
// b_path:: src/generate/color/rgb.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./rgb";

describe("rgb color generator", () => {
	test("should generate opaque RGB color", () => {
		const result = generate({ kind: "rgb", r: 255, g: 0, b: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("rgb(255 0 0)");
	});

	test("should generate RGB with alpha", () => {
		const result = generate({ kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("rgb(255 0 0 / 0.5)");
	});

	test("should omit alpha when fully opaque", () => {
		const result = generate({ kind: "rgb", r: 0, g: 128, b: 255, alpha: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("rgb(0 128 255)");
	});

	test("should round RGB values", () => {
		const result = generate({ kind: "rgb", r: 255.7, g: 127.3, b: 63.9 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("rgb(256 127 64)");
	});
});


=== File: src/generate/color/rgb.ts ===
// b_path:: src/generate/color/rgb.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { RGBColor } from "@/core/types/color";

/**
 * Generate CSS from an RGB color value.
 *
 * Converts an RGBColor IR back to its CSS string representation.
 * Uses modern space-separated syntax with slash for alpha.
 *
 * @param color - The RGB color to convert
 * @returns CSS RGB color string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/rgb";
 *
 * // Opaque color
 * const css1 = toCss({ kind: "rgb", r: 255, g: 0, b: 0 });
 * // => "rgb(255 0 0)"
 *
 * // With alpha
 * const css2 = toCss({ kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 });
 * // => "rgb(255 0 0 / 0.5)"
 *
 * // Full opacity (alpha = 1)
 * const css3 = toCss({ kind: "rgb", r: 255, g: 0, b: 0, alpha: 1 });
 * // => "rgb(255 0 0)"
 * ```
 *
 * @public
 */
export function generate(color: RGBColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "RGBColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected RGBColor object, got ${typeof color}`);
	}
	if (!("r" in color) || !("g" in color) || !("b" in color)) {
		return generateErr("missing-required-field", "RGBColor must have 'r', 'g', 'b' fields");
	}

	const { r, g, b, alpha } = color;

	// Format RGB values (integers)
	const rgbPart = `${Math.round(r)} ${Math.round(g)} ${Math.round(b)}`;

	// Add alpha if present and not fully opaque
	if (alpha !== undefined && alpha < 1) {
		return generateOk(`rgb(${rgbPart} / ${alpha})`);
	}

	return generateOk(`rgb(${rgbPart})`);
}


=== File: src/generate/color/special.test.ts ===
// b_path:: src/generate/color/special.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./special";

describe("special color generator", () => {
	test("should generate 'transparent' keyword", () => {
		const result = generate({ kind: "special", keyword: "transparent" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("transparent");
	});

	test("should generate 'currentcolor' keyword", () => {
		const result = generate({ kind: "special", keyword: "currentcolor" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("currentcolor");
	});
});


=== File: src/generate/color/special.ts ===
// b_path:: src/generate/color/special.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { SpecialColor } from "@/core/types/color";

/**
 * Generate CSS from a special color value.
 *
 * Converts a SpecialColor IR back to its CSS string representation.
 * Special color keywords are output in lowercase.
 *
 * @param color - The special color to convert
 * @returns CSS special color keyword string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/special";
 *
 * const css1 = toCss({ kind: "special", keyword: "transparent" });
 * // => "transparent"
 *
 * const css2 = toCss({ kind: "special", keyword: "currentcolor" });
 * // => "currentcolor"
 * ```
 *
 * @public
 */
export function generate(color: SpecialColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "SpecialColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected SpecialColor object, got ${typeof color}`);
	}
	if (!("keyword" in color)) {
		return generateErr("missing-required-field", "SpecialColor must have 'keyword' field");
	}
	return generateOk(color.keyword);
}


=== File: src/generate/color/system.test.ts ===
// b_path:: src/generate/color/system.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./system";

describe("system color generator", () => {
	test("should generate 'ButtonText' system color", () => {
		const result = generate({ kind: "system", keyword: "ButtonText" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("ButtonText");
	});

	test("should generate 'Canvas' system color", () => {
		const result = generate({ kind: "system", keyword: "Canvas" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("Canvas");
	});

	test("should generate 'LinkText' system color", () => {
		const result = generate({ kind: "system", keyword: "LinkText" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("LinkText");
	});
});


=== File: src/generate/color/system.ts ===
// b_path:: src/generate/color/system.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { SystemColor } from "@/core/types/color";

/**
 * Generate CSS from a system color value.
 *
 * Converts a SystemColor IR back to its CSS string representation.
 * System color keywords are output as-is with their original casing.
 *
 * @param color - The system color to convert
 * @returns CSS system color keyword string
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/color/system";
 *
 * const css1 = toCss({ kind: "system", keyword: "ButtonText" });
 * // => "ButtonText"
 *
 * const css2 = toCss({ kind: "system", keyword: "Canvas" });
 * // => "Canvas"
 * ```
 *
 * @public
 */
export function generate(color: SystemColor): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "SystemColor must not be null or undefined");
	}
	if (typeof color !== "object") {
		return generateErr("invalid-ir", `Expected SystemColor object, got ${typeof color}`);
	}
	if (!("keyword" in color)) {
		return generateErr("missing-required-field", "SystemColor must have 'keyword' field");
	}
	return generateOk(color.keyword);
}


=== File: src/generate/filter/blur.test.ts ===
// b_path:: src/generate/filter/blur.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./blur";

describe("blur generator", () => {
	test("should generate blur with px", () => {
		const result = generate({ kind: "blur", radius: { value: 5, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("blur(5px)");
	});

	test("should generate blur with rem", () => {
		const result = generate({ kind: "blur", radius: { value: 0.5, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("blur(0.5rem)");
	});

	test("should generate blur with em", () => {
		const result = generate({ kind: "blur", radius: { value: 1, unit: "em" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("blur(1em)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/blur.ts ===
// b_path:: src/generate/filter/blur.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { BlurFilter } from "@/core/types/filter";

/**
 * Generate CSS blur() filter function from IR.
 *
 * Outputs blur radius with its unit (px, em, rem, etc.).
 * Preserves the original unit from the IR.
 *
 * @param filter - BlurFilter IR
 * @returns CSS string like "blur(5px)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/blur";
 *
 * const css = toCss({ kind: "blur", radius: { value: 5, unit: "px" } });
 * // "blur(5px)"
 * ```
 *
 * @public
 */
export function generate(filter: BlurFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { radius } = filter;
	return generateOk(`blur(${radius.value}${radius.unit})`);
}


=== File: src/generate/filter/brightness.test.ts ===
// b_path:: src/generate/filter/brightness.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./brightness";

describe("brightness generator", () => {
	test("should generate brightness 0 (black)", () => {
		const result = generate({ kind: "brightness", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("brightness(0)");
	});

	test("should generate brightness 1 (normal)", () => {
		const result = generate({ kind: "brightness", value: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("brightness(1)");
	});

	test("should generate brightness 1.5 (brighter)", () => {
		const result = generate({ kind: "brightness", value: 1.5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("brightness(1.5)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/brightness.ts ===
// b_path:: src/generate/filter/brightness.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { BrightnessFilter } from "@/core/types/filter";

/**
 * Generate CSS brightness() filter function from IR.
 *
 * Outputs brightness value as a number (not percentage).
 * 1 = 100% brightness (no change), 0 = completely black.
 *
 * @param filter - BrightnessFilter IR
 * @returns CSS string like "brightness(1.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/brightness";
 *
 * const css = toCss({ kind: "brightness", value: 1.5 });
 * // "brightness(1.5)"
 * ```
 *
 * @public
 */
export function generate(filter: BrightnessFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { value } = filter;
	return generateOk(`brightness(${value})`);
}


=== File: src/generate/filter/contrast.test.ts ===
// b_path:: src/generate/filter/contrast.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./contrast";

describe("contrast generator", () => {
	test("should generate contrast 0", () => {
		const result = generate({ kind: "contrast", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("contrast(0)");
	});

	test("should generate contrast 1 (normal)", () => {
		const result = generate({ kind: "contrast", value: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("contrast(1)");
	});

	test("should generate contrast 2 (high)", () => {
		const result = generate({ kind: "contrast", value: 2 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("contrast(2)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/contrast.ts ===
// b_path:: src/generate/filter/contrast.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { ContrastFilter } from "@/core/types/filter";

/**
 * Generate CSS contrast() filter function from IR.
 *
 * Outputs contrast value as a number (not percentage).
 * 1 = 100% contrast (no change), 0 = completely black.
 *
 * @param filter - ContrastFilter IR
 * @returns CSS string like "contrast(1.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/contrast";
 *
 * const css = toCss({ kind: "contrast", value: 1.5 });
 * // "contrast(1.5)"
 * ```
 *
 * @public
 */
export function generate(filter: ContrastFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { value } = filter;
	return generateOk(`contrast(${value})`);
}


=== File: src/generate/filter/drop-shadow.test.ts ===
// b_path:: src/generate/filter/drop-shadow.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./drop-shadow";

describe("drop-shadow generator", () => {
	test("should generate drop-shadow with named color", () => {
		const result = generate({
			kind: "drop-shadow",
			offsetX: { value: 2, unit: "px" },
			offsetY: { value: 4, unit: "px" },
			blurRadius: { value: 6, unit: "px" },
			color: { kind: "named", name: "black" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("drop-shadow(2px 4px 6px black)");
	});

	test("should generate drop-shadow with rgb", () => {
		const result = generate({
			kind: "drop-shadow",
			offsetX: { value: 1, unit: "px" },
			offsetY: { value: 1, unit: "px" },
			blurRadius: { value: 2, unit: "px" },
			color: { kind: "rgb", r: 0, g: 0, b: 0, alpha: 0.5 },
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("drop-shadow(1px 1px 2px rgb(0 0 0 / 0.5))");
	});

	test("should generate drop-shadow with only color", () => {
		const result = generate({
			kind: "drop-shadow",
			offsetX: { value: 3, unit: "px" },
			offsetY: { value: 3, unit: "px" },
			color: { kind: "named", name: "gray" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("drop-shadow(3px 3px gray)");
	});

	test("should generate drop-shadow with minimal params", () => {
		const result = generate({
			kind: "drop-shadow",
			offsetX: { value: 1, unit: "px" },
			offsetY: { value: 2, unit: "px" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("drop-shadow(1px 2px)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/drop-shadow.ts ===
// b_path:: src/generate/filter/drop-shadow.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { DropShadowFilter } from "@/core/types/filter";
import { generateColor } from "@/utils/generate/color";

/**
 * Generate CSS drop-shadow() filter function from IR.
 *
 * Outputs drop-shadow with offset-x, offset-y, and optional blur-radius and color.
 * Preserves the original units from the IR.
 * Optional parameters are only included if present in the IR.
 *
 * @param filter - DropShadowFilter IR
 * @returns CSS string like "drop-shadow(2px 2px)" or "drop-shadow(2px 2px 4px black)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/drop-shadow";
 *
 * // Basic drop shadow
 * const css1 = toCss({
 *   kind: "drop-shadow",
 *   offsetX: { value: 2, unit: "px" },
 *   offsetY: { value: 2, unit: "px" }
 * });
 * // "drop-shadow(2px 2px)"
 *
 * // With blur radius
 * const css2 = toCss({
 *   kind: "drop-shadow",
 *   offsetX: { value: 2, unit: "px" },
 *   offsetY: { value: 2, unit: "px" },
 *   blurRadius: { value: 4, unit: "px" }
 * });
 * // "drop-shadow(2px 2px 4px)"
 *
 * // With color
 * const css3 = toCss({
 *   kind: "drop-shadow",
 *   offsetX: { value: 2, unit: "px" },
 *   offsetY: { value: 2, unit: "px" },
 *   blurRadius: { value: 4, unit: "px" },
 *   color: { kind: "named", name: "black" }
 * });
 * // "drop-shadow(2px 2px 4px black)"
 * ```
 *
 * @public
 */
export function generate(filter: DropShadowFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { offsetX, offsetY, blurRadius, color } = filter;

	// Start with required offset values
	let css = `drop-shadow(${offsetX.value}${offsetX.unit} ${offsetY.value}${offsetY.unit}`;

	// Add optional blur radius
	if (blurRadius !== undefined) {
		css += ` ${blurRadius.value}${blurRadius.unit}`;
	}

	// Add optional color
	if (color !== undefined) {
		css += ` ${generateColor(color)}`;
	}

	// Close function
	css += ")";

	return generateOk(css);
}


=== File: src/generate/filter/filter.test.ts ===
// b_path:: src/generate/filter/filter.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./filter";

describe("Filter.generate()", () => {
	test("generates blur", () => {
		const filter: Type.FilterFunction = { kind: "blur", radius: { value: 5, unit: "px" } };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("blur(5px)");
		}
	});

	test("generates brightness", () => {
		const filter: Type.FilterFunction = { kind: "brightness", value: 150 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("brightness(150)");
		}
	});

	test("generates contrast", () => {
		const filter: Type.FilterFunction = { kind: "contrast", value: 75 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("contrast(75)");
		}
	});

	test("generates grayscale", () => {
		const filter: Type.FilterFunction = { kind: "grayscale", value: 100 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("grayscale(100)");
		}
	});

	test("generates hue-rotate", () => {
		const filter: Type.FilterFunction = { kind: "hue-rotate", angle: { value: 90, unit: "deg" } };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("hue-rotate(90deg)");
		}
	});

	test("generates invert", () => {
		const filter: Type.FilterFunction = { kind: "invert", value: 50 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("invert(50)");
		}
	});

	test("generates opacity", () => {
		const filter: Type.FilterFunction = { kind: "opacity", value: 75 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("opacity(75)");
		}
	});

	test("generates saturate", () => {
		const filter: Type.FilterFunction = { kind: "saturate", value: 200 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("saturate(200)");
		}
	});

	test("generates sepia", () => {
		const filter: Type.FilterFunction = { kind: "sepia", value: 80 };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("sepia(80)");
		}
	});

	test("generates url", () => {
		const filter: Type.FilterFunction = { kind: "url", url: "#filter-id" };
		const result = generate(filter);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("url(#filter-id)");
		}
	});

	test("returns error for missing kind", () => {
		const filter = {} as Type.FilterFunction;
		const result = generate(filter);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		}
	});
});


=== File: src/generate/filter/filter.ts ===
// b_path:: src/generate/filter/filter.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types";
import * as Blur from "./blur";
import * as Brightness from "./brightness";
import * as Contrast from "./contrast";
import * as DropShadow from "./drop-shadow";
import * as Grayscale from "./grayscale";
import * as HueRotate from "./hue-rotate";
import * as Invert from "./invert";
import * as Opacity from "./opacity";
import * as Saturate from "./saturate";
import * as Sepia from "./sepia";
import * as Url from "./url";

/**
 * Generate CSS from filter IR with auto-detection.
 *
 * @param filter - Filter IR
 * @returns GenerateResult with CSS string or error
 *
 * @public
 */
export function generate(filter: Type.FilterFunction): GenerateResult {
	if (!filter || typeof filter !== "object" || !("kind" in filter)) {
		return generateErr("missing-required-field", "Invalid filter IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	switch (filter.kind) {
		case "blur":
			return Blur.generate(filter);
		case "brightness":
			return Brightness.generate(filter);
		case "contrast":
			return Contrast.generate(filter);
		case "drop-shadow":
			return DropShadow.generate(filter);
		case "grayscale":
			return Grayscale.generate(filter);
		case "hue-rotate":
			return HueRotate.generate(filter);
		case "invert":
			return Invert.generate(filter);
		case "opacity":
			return Opacity.generate(filter);
		case "saturate":
			return Saturate.generate(filter);
		case "sepia":
			return Sepia.generate(filter);
		case "url":
			return Url.generate(filter);
		default:
			return generateErr("unsupported-kind", `Unknown filter kind: ${(filter as { kind?: string }).kind}`, {
				suggestion: "Check that filter IR is valid",
			});
	}
}


=== File: src/generate/filter/grayscale.test.ts ===
// b_path:: src/generate/filter/grayscale.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./grayscale";

describe("grayscale generator", () => {
	test("should generate grayscale 0 (no effect)", () => {
		const result = generate({ kind: "grayscale", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("grayscale(0)");
	});

	test("should generate grayscale 0.5", () => {
		const result = generate({ kind: "grayscale", value: 0.5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("grayscale(0.5)");
	});

	test("should generate grayscale 1 (full grayscale)", () => {
		const result = generate({ kind: "grayscale", value: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("grayscale(1)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/grayscale.ts ===
// b_path:: src/generate/filter/grayscale.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { GrayscaleFilter } from "@/core/types/filter";

/**
 * Generate CSS grayscale() filter function from IR.
 *
 * Outputs grayscale value as a number (not percentage).
 * 0 = no grayscale, 1 = 100% grayscale.
 *
 * @param filter - GrayscaleFilter IR
 * @returns CSS string like "grayscale(0.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/grayscale";
 *
 * const css = toCss({ kind: "grayscale", value: 0.5 });
 * // "grayscale(0.5)"
 * ```
 *
 * @public
 */
export function generate(filter: GrayscaleFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { value } = filter;
	return generateOk(`grayscale(${value})`);
}


=== File: src/generate/filter/hue-rotate.test.ts ===
// b_path:: src/generate/filter/hue-rotate.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./hue-rotate";

describe("hue-rotate generator", () => {
	test("should generate hue-rotate with deg", () => {
		const result = generate({ kind: "hue-rotate", angle: { value: 90, unit: "deg" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hue-rotate(90deg)");
	});

	test("should generate hue-rotate with rad", () => {
		const result = generate({ kind: "hue-rotate", angle: { value: 1.57, unit: "rad" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hue-rotate(1.57rad)");
	});

	test("should generate hue-rotate with turn", () => {
		const result = generate({ kind: "hue-rotate", angle: { value: 0.5, unit: "turn" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hue-rotate(0.5turn)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/hue-rotate.ts ===
// b_path:: src/generate/filter/hue-rotate.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { HueRotateFilter } from "@/core/types/filter";

/**
 * Generate CSS hue-rotate() filter function from IR.
 *
 * Outputs hue rotation angle with its unit (deg, grad, rad, turn).
 * Preserves the original unit from the IR.
 *
 * @param filter - HueRotateFilter IR
 * @returns CSS string like "hue-rotate(90deg)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/hue-rotate";
 *
 * const css = toCss({ kind: "hue-rotate", angle: { value: 90, unit: "deg" } });
 * // "hue-rotate(90deg)"
 * ```
 *
 * @public
 */
export function generate(filter: HueRotateFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { angle } = filter;
	return generateOk(`hue-rotate(${angle.value}${angle.unit})`);
}


=== File: src/generate/filter/index.ts ===
// b_path:: src/generate/filter/index.ts

export * as Blur from "./blur";
export * as Brightness from "./brightness";
export * as Contrast from "./contrast";
export * as DropShadow from "./drop-shadow";
export * as Filter from "./filter";
export { generate } from "./filter";
export * as Grayscale from "./grayscale";
export * as HueRotate from "./hue-rotate";
export * as Invert from "./invert";
export * as Opacity from "./opacity";
export * as Saturate from "./saturate";
export * as Sepia from "./sepia";
export * as Url from "./url";


=== File: src/generate/filter/invert.test.ts ===
// b_path:: src/generate/filter/invert.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./invert";

describe("invert generator", () => {
	test("should generate invert 0 (no effect)", () => {
		const result = generate({ kind: "invert", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("invert(0)");
	});

	test("should generate invert 0.5", () => {
		const result = generate({ kind: "invert", value: 0.5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("invert(0.5)");
	});

	test("should generate invert 1 (full invert)", () => {
		const result = generate({ kind: "invert", value: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("invert(1)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/invert.ts ===
// b_path:: src/generate/filter/invert.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { InvertFilter } from "@/core/types/filter";

/**
 * Generate CSS invert() filter function from IR.
 *
 * Outputs invert value as a number (not percentage).
 * 0 = no invert, 1 = 100% invert.
 *
 * @param filter - InvertFilter IR
 * @returns CSS string like "invert(0.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/invert";
 *
 * const css = toCss({ kind: "invert", value: 0.5 });
 * // "invert(0.5)"
 * ```
 *
 * @public
 */
export function generate(filter: InvertFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { value } = filter;
	return generateOk(`invert(${value})`);
}


=== File: src/generate/filter/opacity.test.ts ===
// b_path:: src/generate/filter/opacity.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./opacity";

describe("opacity filter generator", () => {
	test("should generate opacity 0 (transparent)", () => {
		const result = generate({ kind: "opacity", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("opacity(0)");
	});

	test("should generate opacity 0.5", () => {
		const result = generate({ kind: "opacity", value: 0.5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("opacity(0.5)");
	});

	test("should generate opacity 1 (opaque)", () => {
		const result = generate({ kind: "opacity", value: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("opacity(1)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/opacity.ts ===
// b_path:: src/generate/filter/opacity.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { OpacityFilter } from "@/core/types/filter";

/**
 * Generate CSS opacity() filter function from IR.
 *
 * Outputs opacity value as a number (not percentage).
 * 0 = no opacity, 1 = 100% opacity.
 *
 * @param filter - OpacityFilter IR
 * @returns CSS string like "opacity(0.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/opacity}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/opacity";
 *
 * const css = toCss({ kind: "opacity", value: 0.5 });
 * // "opacity(0.5)"
 * ```
 *
 * @public
 */
export function generate(filter: OpacityFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { value } = filter;
	return generateOk(`opacity(${value})`);
}


=== File: src/generate/filter/saturate.test.ts ===
// b_path:: src/generate/filter/saturate.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./saturate";

describe("saturate generator", () => {
	test("should generate saturate 0 (desaturated)", () => {
		const result = generate({ kind: "saturate", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("saturate(0)");
	});

	test("should generate saturate 1 (normal)", () => {
		const result = generate({ kind: "saturate", value: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("saturate(1)");
	});

	test("should generate saturate 2 (high)", () => {
		const result = generate({ kind: "saturate", value: 2 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("saturate(2)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/saturate.ts ===
// b_path:: src/generate/filter/saturate.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { SaturateFilter } from "@/core/types/filter";

/**
 * Generate CSS saturate() filter function from IR.
 *
 * Outputs saturate value as a number (not percentage).
 * 1 = 100% saturate (no change), 0 = completely black.
 *
 * @param filter - SaturateFilter IR
 * @returns CSS string like "saturate(1.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/saturate";
 *
 * const css = toCss({ kind: "saturate", value: 1.5 });
 * // "saturate(1.5)"
 * ```
 *
 * @public
 */
export function generate(filter: SaturateFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { value } = filter;
	return generateOk(`saturate(${value})`);
}


=== File: src/generate/filter/sepia.test.ts ===
// b_path:: src/generate/filter/sepia.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./sepia";

describe("sepia generator", () => {
	test("should generate sepia 0 (no effect)", () => {
		const result = generate({ kind: "sepia", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("sepia(0)");
	});

	test("should generate sepia 0.5", () => {
		const result = generate({ kind: "sepia", value: 0.5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("sepia(0.5)");
	});

	test("should generate sepia 1 (full sepia)", () => {
		const result = generate({ kind: "sepia", value: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("sepia(1)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/sepia.ts ===
// b_path:: src/generate/filter/sepia.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { SepiaFilter } from "@/core/types/filter";

/**
 * Generate CSS sepia() filter function from IR.
 *
 * Outputs sepia value as a number (not percentage).
 * 0 = no sepia, 1 = 100% sepia.
 *
 * @param filter - SepiaFilter IR
 * @returns CSS string like "sepia(0.5)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/sepia";
 *
 * const css = toCss({ kind: "sepia", value: 0.5 });
 * // "sepia(0.5)"
 * ```
 *
 * @public
 */
export function generate(filter: SepiaFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { value } = filter;
	return generateOk(`sepia(${value})`);
}


=== File: src/generate/filter/url.test.ts ===
// b_path:: src/generate/filter/url.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./url";

describe("url filter generator", () => {
	test("should generate url with fragment", () => {
		const result = generate({ kind: "url", url: "#filter-id" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("url(#filter-id)");
	});

	test("should generate url with svg path", () => {
		const result = generate({ kind: "url", url: "filters.svg#blur" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("url(filters.svg#blur)");
	});

	test("should generate url with full path", () => {
		const result = generate({ kind: "url", url: "/assets/filters.svg#shadow" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("url(/assets/filters.svg#shadow)");
	});

	test("should error on null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/filter/url.ts ===
// b_path:: src/generate/filter/url.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { UrlFilter } from "@/core/types/filter";

/**
 * Generate CSS url() filter function from IR.
 *
 * Outputs URL as-is without quotes for simple URLs and fragments.
 *
 * @param filter - UrlFilter IR
 * @returns CSS string like "url(#filter-id)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/url}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/filter/url";
 *
 * const css = toCss({ kind: "url", url: "#filter-id" });
 * // "url(#filter-id)"
 *
 * const css2 = toCss({ kind: "url", url: "path/to/filter.svg" });
 * // "url(path/to/filter.svg)"
 * ```
 *
 * @public
 */
export function generate(filter: UrlFilter): GenerateResult {
	if (filter === undefined || filter === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { url } = filter;
	return generateOk(`url(${url})`);
}


=== File: src/generate/flexbox/align-content.failure.test.ts ===
// b_path:: src/generate/flexbox/align-content.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/align-content.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/flexbox/align-content";

describe("generate/flexbox/align-content - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/flexbox/align-content.test.ts ===
// b_path:: src/generate/flexbox/align-content.test.ts
// Auto-generated from scripts/generate-test-generator/configs/flexbox/align-content.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/flexbox/align-content";
import * as Parser from "@/parse/flexbox/align-content";

describe("generate/flexbox/align-content - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate flex-start keyword", () => {
			const input: Type.AlignContent = {
				kind: "align-content",
				value: "flex-start",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("flex-start");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate center keyword", () => {
			const input: Type.AlignContent = {
				kind: "align-content",
				value: "center",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("center");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate space-between keyword", () => {
			const input: Type.AlignContent = {
				kind: "align-content",
				value: "space-between",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("space-between");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/flexbox/align-content.ts ===
// b_path:: src/generate/flexbox/align-content.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { AlignContent } from "@/core/types";

export function generate(ir: AlignContent): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(ir.value);
}


=== File: src/generate/flexbox/align-items.failure.test.ts ===
// b_path:: src/generate/flexbox/align-items.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/align-items.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/flexbox/align-items";

describe("generate/flexbox/align-items - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/flexbox/align-items.test.ts ===
// b_path:: src/generate/flexbox/align-items.test.ts
// Auto-generated from scripts/generate-test-generator/configs/flexbox/align-items.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/flexbox/align-items";
import * as Parser from "@/parse/flexbox/align-items";

describe("generate/flexbox/align-items - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate flex-start keyword", () => {
			const input: Type.AlignItems = {
				kind: "align-items",
				value: "flex-start",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("flex-start");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate center keyword", () => {
			const input: Type.AlignItems = {
				kind: "align-items",
				value: "center",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("center");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate stretch keyword", () => {
			const input: Type.AlignItems = {
				kind: "align-items",
				value: "stretch",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("stretch");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/flexbox/align-items.ts ===
// b_path:: src/generate/flexbox/align-items.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { AlignItems } from "@/core/types";

export function generate(ir: AlignItems): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(ir.value);
}


=== File: src/generate/flexbox/align-self.failure.test.ts ===
// b_path:: src/generate/flexbox/align-self.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/align-self.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/flexbox/align-self";

describe("generate/flexbox/align-self - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/flexbox/align-self.test.ts ===
// b_path:: src/generate/flexbox/align-self.test.ts
// Auto-generated from scripts/generate-test-generator/configs/flexbox/align-self.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/flexbox/align-self";
import * as Parser from "@/parse/flexbox/align-self";

describe("generate/flexbox/align-self - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate auto keyword", () => {
			const input: Type.AlignSelf = {
				kind: "align-self",
				value: "auto",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("auto");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate flex-start keyword", () => {
			const input: Type.AlignSelf = {
				kind: "align-self",
				value: "flex-start",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("flex-start");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate center keyword", () => {
			const input: Type.AlignSelf = {
				kind: "align-self",
				value: "center",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("center");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/flexbox/align-self.ts ===
// b_path:: src/generate/flexbox/align-self.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { AlignSelf } from "@/core/types";

export function generate(ir: AlignSelf): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(ir.value);
}


=== File: src/generate/flexbox/flex-basis.test.ts ===
// b_path:: src/generate/flexbox/flex-basis.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./flex-basis";

describe("flex-basis generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "flex-basis", value: { value: 200, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("200px");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "flex-basis", value: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("50%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "flex-basis", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});

	test("should generate 'content' keyword", () => {
		const result = generate({ kind: "flex-basis", value: "content" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("content");
	});
});


=== File: src/generate/flexbox/flex-basis.ts ===
// b_path:: src/generate/flexbox/flex-basis.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FlexBasis } from "@/core/types";
import * as GenUtils from "@/utils/generate";

export function generate(ir: FlexBasis): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof ir.value === "string") {
		return generateOk(ir.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(ir.value));
}


=== File: src/generate/flexbox/flex-direction.failure.test.ts ===
// b_path:: src/generate/flexbox/flex-direction.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/flex-direction.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/flexbox/flex-direction";

describe("generate/flexbox/flex-direction - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/flexbox/flex-direction.test.ts ===
// b_path:: src/generate/flexbox/flex-direction.test.ts
// Auto-generated from scripts/generate-test-generator/configs/flexbox/flex-direction.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/flexbox/flex-direction";
import * as Parser from "@/parse/flexbox/flex-direction";

describe("generate/flexbox/flex-direction - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate row keyword", () => {
			const input: Type.FlexDirection = {
				kind: "flex-direction",
				value: "row",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("row");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate row-reverse keyword", () => {
			const input: Type.FlexDirection = {
				kind: "flex-direction",
				value: "row-reverse",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("row-reverse");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate column keyword", () => {
			const input: Type.FlexDirection = {
				kind: "flex-direction",
				value: "column",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("column");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate column-reverse keyword", () => {
			const input: Type.FlexDirection = {
				kind: "flex-direction",
				value: "column-reverse",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("column-reverse");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/flexbox/flex-direction.ts ===
// b_path:: src/generate/flexbox/flex-direction.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FlexDirection } from "@/core/types";

export function generate(ir: FlexDirection): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(ir.value);
}


=== File: src/generate/flexbox/flex-grow.test.ts ===
// b_path:: src/generate/flexbox/flex-grow.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./flex-grow.js";

describe("generate/flexbox/flex-grow", () => {
	it("generates number 0", () => {
		const result = generate({ kind: "flex-grow", value: 0 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0");
	});

	it("generates number 1", () => {
		const result = generate({ kind: "flex-grow", value: 1 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("1");
	});

	it("generates number 2", () => {
		const result = generate({ kind: "flex-grow", value: 2 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("2");
	});

	it("generates fractional number", () => {
		const result = generate({ kind: "flex-grow", value: 0.5 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0.5");
	});
});


=== File: src/generate/flexbox/flex-grow.ts ===
// b_path:: src/generate/flexbox/flex-grow.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FlexGrow } from "@/core/types";

export function generate(ir: FlexGrow): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(String(ir.value));
}


=== File: src/generate/flexbox/flex-shrink.test.ts ===
// b_path:: src/generate/flexbox/flex-shrink.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./flex-shrink.js";

describe("generate/flexbox/flex-shrink", () => {
	it("generates number 0", () => {
		const result = generate({ kind: "flex-shrink", value: 0 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0");
	});

	it("generates number 1", () => {
		const result = generate({ kind: "flex-shrink", value: 1 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("1");
	});

	it("generates number 2", () => {
		const result = generate({ kind: "flex-shrink", value: 2 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("2");
	});

	it("generates fractional number", () => {
		const result = generate({ kind: "flex-shrink", value: 0.5 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0.5");
	});
});


=== File: src/generate/flexbox/flex-shrink.ts ===
// b_path:: src/generate/flexbox/flex-shrink.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FlexShrink } from "@/core/types";

export function generate(ir: FlexShrink): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(String(ir.value));
}


=== File: src/generate/flexbox/flex-wrap.failure.test.ts ===
// b_path:: src/generate/flexbox/flex-wrap.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/flex-wrap.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/flexbox/flex-wrap";

describe("generate/flexbox/flex-wrap - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/flexbox/flex-wrap.test.ts ===
// b_path:: src/generate/flexbox/flex-wrap.test.ts
// Auto-generated from scripts/generate-test-generator/configs/flexbox/flex-wrap.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/flexbox/flex-wrap";
import * as Parser from "@/parse/flexbox/flex-wrap";

describe("generate/flexbox/flex-wrap - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate nowrap keyword", () => {
			const input: Type.FlexWrap = {
				kind: "flex-wrap",
				value: "nowrap",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("nowrap");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate wrap keyword", () => {
			const input: Type.FlexWrap = {
				kind: "flex-wrap",
				value: "wrap",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("wrap");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate wrap-reverse keyword", () => {
			const input: Type.FlexWrap = {
				kind: "flex-wrap",
				value: "wrap-reverse",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("wrap-reverse");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/flexbox/flex-wrap.ts ===
// b_path:: src/generate/flexbox/flex-wrap.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FlexWrap } from "@/core/types";

export function generate(ir: FlexWrap): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(ir.value);
}


=== File: src/generate/flexbox/gap.test.ts ===
// b_path:: src/generate/flexbox/gap.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./gap.js";

describe("generate/flexbox/gap", () => {
	it("generates pixel value", () => {
		const result = generate({ kind: "gap", value: { value: 16, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("16px");
	});

	it("generates rem value", () => {
		const result = generate({ kind: "gap", value: { value: 1, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("1rem");
	});

	it("generates percentage", () => {
		const result = generate({ kind: "gap", value: { value: 10, unit: "%" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("10%");
	});

	it("generates normal keyword", () => {
		const result = generate({ kind: "gap", value: "normal" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("normal");
	});
});


=== File: src/generate/flexbox/gap.ts ===
// b_path:: src/generate/flexbox/gap.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Gap } from "@/core/types";
import * as GenUtils from "@/utils/generate";

export function generate(ir: Gap): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof ir.value === "string") {
		return generateOk(ir.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(ir.value));
}


=== File: src/generate/flexbox/index.ts ===
// b_path:: src/generate/flexbox/index.ts

export * as AlignContent from "./align-content";
export * as AlignItems from "./align-items";
export * as AlignSelf from "./align-self";
export * as FlexBasis from "./flex-basis";
export * as FlexDirection from "./flex-direction";
export * as FlexGrow from "./flex-grow";
export * as FlexShrink from "./flex-shrink";
export * as FlexWrap from "./flex-wrap";
export * as Gap from "./gap";
export * as JustifyContent from "./justify-content";
export * as Order from "./order";


=== File: src/generate/flexbox/justify-content.failure.test.ts ===
// b_path:: src/generate/flexbox/justify-content.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/justify-content.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/flexbox/justify-content";

describe("generate/flexbox/justify-content - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/flexbox/justify-content.test.ts ===
// b_path:: src/generate/flexbox/justify-content.test.ts
// Auto-generated from scripts/generate-test-generator/configs/flexbox/justify-content.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/flexbox/justify-content";
import * as Parser from "@/parse/flexbox/justify-content";

describe("generate/flexbox/justify-content - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate flex-start keyword", () => {
			const input: Type.JustifyContent = {
				kind: "justify-content",
				value: "flex-start",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("flex-start");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate center keyword", () => {
			const input: Type.JustifyContent = {
				kind: "justify-content",
				value: "center",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("center");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate space-between keyword", () => {
			const input: Type.JustifyContent = {
				kind: "justify-content",
				value: "space-between",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("space-between");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/flexbox/justify-content.ts ===
// b_path:: src/generate/flexbox/justify-content.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { JustifyContent } from "@/core/types";

export function generate(ir: JustifyContent): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(ir.value);
}


=== File: src/generate/flexbox/order.test.ts ===
// b_path:: src/generate/flexbox/order.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./order.js";

describe("generate/flexbox/order", () => {
	it("generates number 0", () => {
		const result = generate({ kind: "order", value: 0 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0");
	});

	it("generates positive number", () => {
		const result = generate({ kind: "order", value: 1 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("1");
	});

	it("generates negative number", () => {
		const result = generate({ kind: "order", value: -1 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("-1");
	});

	it("generates large number", () => {
		const result = generate({ kind: "order", value: 999 });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("999");
	});
});


=== File: src/generate/flexbox/order.ts ===
// b_path:: src/generate/flexbox/order.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Order } from "@/core/types";

export function generate(ir: Order): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(String(ir.value));
}


=== File: src/generate/gradient/color-stop.test.ts ===
// b_path:: src/generate/gradient/color-stop.test.ts

import { describe, expect, it } from "vitest";
import { generate } from "./color-stop";

describe("generate color-stop", () => {
	it("generates color without position", () => {
		const result = generate({
			color: { kind: "named", name: "red" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("red");
		}
	});

	it("generates color with position", () => {
		const result = generate({
			color: { kind: "named", name: "blue" },
			position: { value: 50, unit: "%" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("blue 50%");
		}
	});

	it("generates rgb color with position", () => {
		const result = generate({
			color: { kind: "rgb", r: 255, g: 0, b: 0 },
			position: { value: 100, unit: "px" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rgb(255 0 0) 100px");
		}
	});

	it("generates rgba color with alpha", () => {
		const result = generate({
			color: { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rgb(255 0 0 / 0.5)");
		}
	});

	it("generates color at 0%", () => {
		const result = generate({
			color: { kind: "named", name: "black" },
			position: { value: 0, unit: "%" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("black 0%");
		}
	});

	it("generates color at 100%", () => {
		const result = generate({
			color: { kind: "named", name: "white" },
			position: { value: 100, unit: "%" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("white 100%");
		}
	});

	it("handles null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("handles undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/gradient/color-stop.ts ===
// b_path:: src/generate/gradient/color-stop.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { generateColor } from "@/utils/generate/color";

/**
 * Generate CSS color stop string from IR.
 *
 * Converts color stop IR into a valid CSS color stop string.
 *
 * @param ir - ColorStop IR object
 * @returns CSS color stop string
 *
 * @public
 *
 * @example
 * ```typescript
 * import * as Gradient from "@/ast/generate/gradient";
 *
 * const css1 = Gradient.ColorStop.generate({
 *   color: { kind: "named", name: "red" }
 * });
 * // Returns: "red"
 *
 * const css2 = Gradient.ColorStop.generate({
 *   color: { kind: "named", name: "blue" },
 *   position: { value: 50, unit: "%" }
 * });
 * // Returns: "blue 50%"
 *
 * const css3 = Gradient.ColorStop.generate({
 *   color: { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 },
 *   position: { value: 100, unit: "px" }
 * });
 * // Returns: "rgb(255 0 0 / 0.5) 100px"
 * ```
 */
export function generate(ir: Type.ColorStop): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const colorStr = generateColor(ir.color);

	if (ir.position) {
		const { value, unit } = ir.position;
		return generateOk(`${colorStr} ${value}${unit}`);
	}

	return generateOk(colorStr);
}


=== File: src/generate/gradient/conic.test.ts ===
// b_path:: src/generate/gradient/conic.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./conic";

describe("generate() for conic gradient", () => {
	test("generates basic conic gradient", () => {
		const ir: Type.ConicGradient = {
			kind: "conic",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("conic-gradient");
			expect(result.value).toContain("red");
		}
	});

	test("generates conic gradient with from angle", () => {
		const ir: Type.ConicGradient = {
			kind: "conic",
			fromAngle: { value: 45, unit: "deg" },
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("from 45deg");
		}
	});

	test("generates conic gradient with position only (no from angle)", () => {
		const ir: Type.ConicGradient = {
			kind: "conic",
			position: {
				horizontal: "center",
				vertical: "center",
			},
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Lines 158-159: position without from angle
			expect(result.value).toContain("at center center");
			expect(result.value).not.toContain("from");
		}
	});

	test("generates conic gradient with from angle and position", () => {
		const ir: Type.ConicGradient = {
			kind: "conic",
			fromAngle: { value: 90, unit: "deg" },
			position: {
				horizontal: { value: 75, unit: "%" },
				vertical: { value: 25, unit: "%" },
			},
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Lines 160-161: from angle with position
			expect(result.value).toContain("from 90deg at 75% 25%");
		}
	});

	test("generates conic gradient with colorSpace (no from/position)", () => {
		const ir: Type.ConicGradient = {
			kind: "conic",
			colorSpace: "oklch",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Lines 164-165: colorSpace as standalone part
			expect(result.value).toContain("in oklch");
		}
	});

	test("generates conic gradient with colorSpace (with from/position)", () => {
		const ir: Type.ConicGradient = {
			kind: "conic",
			fromAngle: { value: 0, unit: "deg" },
			colorSpace: "hsl",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Lines 162: colorSpace appended to existing parts
			expect(result.value).toContain("from 0deg in hsl");
		}
	});

	test("generates repeating conic gradient", () => {
		const ir: Type.ConicGradient = {
			kind: "conic",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: true,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("repeating-conic-gradient");
		}
	});

	test("generates conic gradient with color stops at specific angles", () => {
		const ir: Type.ConicGradient = {
			kind: "conic",
			colorStops: [
				{ color: { kind: "named", name: "red" }, position: { value: 0, unit: "deg" } },
				{ color: { kind: "named", name: "blue" }, position: { value: 180, unit: "deg" } },
			],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("red 0deg");
			expect(result.value).toContain("blue 180deg");
		}
	});
});


=== File: src/generate/gradient/conic.ts ===
// b_path:: src/generate/gradient/conic.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as ColorStop from "./color-stop";

/**
 * Generate CSS position string from Position2D IR.
 *
 * @param position - Position2D IR object
 * @returns CSS position string (e.g., "center", "left top", "50% 50%")
 *
 * @internal
 */
function positionToCss(position: Type.Position2D): string {
	const h =
		typeof position.horizontal === "string"
			? position.horizontal
			: `${position.horizontal.value}${position.horizontal.unit}`;
	const v =
		typeof position.vertical === "string" ? position.vertical : `${position.vertical.value}${position.vertical.unit}`;
	return `${h} ${v}`;
}

/**
 * Generate a CSS conic gradient string from intermediate representation (IR).
 *
 * Converts a ConicGradient IR object into a valid CSS `conic-gradient()` or
 * `repeating-conic-gradient()` function string. Handles all gradient components:
 * starting angle, position, color interpolation, and color stops.
 *
 * The generated CSS string is spec-compliant and can be used directly in CSS
 * properties like `background-image`, `background`, or `mask-image`.
 *
 * This function performs the inverse operation of `Parse.Gradient.Conic.parse()`,
 * enabling bidirectional transformation between CSS and IR.
 *
 * @param ir - ConicGradient IR object to convert to CSS
 * @returns CSS conic gradient function string
 *
 * @public
 *
 * @example
 * Simple gradient:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Conic.generate({
 *   kind: "conic",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(red, blue)"
 * ```
 *
 * @example
 * With starting angle:
 * ```typescript
 * const css = Generate.Gradient.Conic.generate({
 *   kind: "conic",
 *   fromAngle: { value: 45, unit: "deg" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(from 45deg, red, blue)"
 * ```
 *
 * @example
 * At specific position:
 * ```typescript
 * const css = Generate.Gradient.Conic.generate({
 *   kind: "conic",
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(at left top, red, blue)"
 * ```
 *
 * @example
 * With both angle and position:
 * ```typescript
 * const css = Generate.Gradient.Conic.generate({
 *   kind: "conic",
 *   fromAngle: { value: 90, unit: "deg" },
 *   position: { horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } },
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "blue", position: { value: 180, unit: "deg" } }
 *   ],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(from 90deg at 50% 50%, red 0deg, blue 180deg)"
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const css = Generate.Gradient.Conic.generate({
 *   kind: "conic",
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "blue", position: { value: 180, unit: "deg" } }
 *   ],
 *   repeating: false
 * });
 * console.log(css); // "conic-gradient(in oklch, red 0deg, blue 180deg)"
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const css = Generate.Gradient.Conic.generate({
 *   kind: "conic",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "blue", position: { value: 45, unit: "deg" } }
 *   ],
 *   repeating: true
 * });
 * console.log(css); // "repeating-conic-gradient(red 0deg, blue 45deg)"
 * ```
 *
 * @example
 * Round-trip transformation (parse → generate):
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "conic-gradient(from 45deg, red, blue)";
 * const parsed = Parse.Gradient.Conic.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Gradient.Conic.generate(parsed.value);
 *   console.log(generated === original); // true - perfect round-trip!
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient | MDN: conic-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-4/#conic-gradients | W3C Spec: Conic Gradients}
 */
export function generate(ir: Type.ConicGradient): GenerateResult {
	const parts: string[] = [];
	const angleAndPos: string[] = [];

	// Build from angle and position part
	if (ir.fromAngle) {
		angleAndPos.push(`from ${ir.fromAngle.value}${ir.fromAngle.unit}`);
	}

	if (ir.position) {
		angleAndPos.push(`at ${positionToCss(ir.position)}`);
	}

	// Combine angle/position with color space
	const angleAndPosStr = angleAndPos.join(" ");
	if (ir.colorSpace) {
		if (angleAndPosStr) {
			parts.push(`${angleAndPosStr} in ${ir.colorSpace}`);
		} else {
			parts.push(`in ${ir.colorSpace}`);
		}
	} else if (angleAndPosStr) {
		parts.push(angleAndPosStr);
	}

	// Add color stops
	for (const stop of ir.colorStops) {
		const result = ColorStop.generate(stop);
		if (!result.ok) return result;
		parts.push(result.value);
	}

	// Generate function
	const functionName = ir.repeating ? "repeating-conic-gradient" : "conic-gradient";
	return generateOk(`${functionName}(${parts.join(", ")})`);
}


=== File: src/generate/gradient/gradient.test.ts ===
// b_path:: src/generate/gradient/gradient.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./gradient";

describe("Gradient.generate()", () => {
	test("generates linear gradient", () => {
		const gradient: Type.Gradient = {
			kind: "linear",
			direction: { kind: "to-side", value: "bottom" },
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(gradient);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("linear-gradient");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates radial gradient", () => {
		const gradient: Type.Gradient = {
			kind: "radial",
			shape: "circle",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(gradient);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("radial-gradient");
			expect(result.issues).toEqual([]);
		}
	});

	test("generates conic gradient", () => {
		const gradient: Type.Gradient = {
			kind: "conic",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(gradient);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("conic-gradient");
			expect(result.issues).toEqual([]);
		}
	});

	test("returns error for invalid IR (missing kind)", () => {
		const gradient = {} as Type.Gradient;
		const result = generate(gradient);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});

	test("returns error for unknown kind", () => {
		const gradient = { kind: "unknown" } as unknown as Type.Gradient;
		const result = generate(gradient);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toContain("Unknown gradient kind");
			expect(result.issues[0]?.suggestion).toBeDefined();
		}
	});
});


=== File: src/generate/gradient/gradient.ts ===
// b_path:: src/generate/gradient/gradient.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types";
import * as Conic from "./conic";
import * as Linear from "./linear";
import * as Radial from "./radial";

/**
 * Generate CSS from gradient IR with auto-detection.
 *
 * Automatically detects gradient type from IR.kind and generates appropriate CSS.
 * Supports linear, radial, and conic gradients.
 *
 * @param gradient - Gradient IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate({ kind: "linear", ... })
 * // → { ok: true, value: "linear-gradient(...)", issues: [] }
 *
 * generate({ kind: "radial", ... })
 * // → { ok: true, value: "radial-gradient(...)", issues: [] }
 * ```
 *
 * @public
 */
export function generate(gradient: Type.Gradient): GenerateResult {
	// Validate IR has 'kind' field
	if (!gradient || typeof gradient !== "object" || !("kind" in gradient)) {
		return generateErr("missing-required-field", "Invalid gradient IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (gradient.kind) {
		case "linear":
			return Linear.generate(gradient);

		case "radial":
			return Radial.generate(gradient);

		case "conic":
			return Conic.generate(gradient);

		default:
			return generateErr("unsupported-kind", `Unknown gradient kind: ${(gradient as { kind?: string }).kind}`, {
				suggestion: "Check that gradient IR is valid",
			});
	}
}


=== File: src/generate/gradient/index.ts ===
// b_path:: src/generate/gradient/index.ts

/**
 * CSS gradient generators - convert gradient IR to CSS strings.
 *
 * @module Generate.Gradient
 * @public
 */

/**
 * Generate color stop CSS strings.
 *
 * @see {@link ColorStop.toCss}
 */
export * as ColorStop from "./color-stop";
/**
 * Generate conic and repeating-conic gradient CSS strings.
 *
 * @see {@link Conic.toCss}
 */
export * as Conic from "./conic";
/**
 * Generate CSS from gradient IR with auto-detection.
 *
 * @see {@link generate}
 */
export { generate } from "./gradient";

/**
 * Generate linear and repeating-linear gradient CSS strings.
 *
 * @see {@link Linear.toCss}
 */
export * as Linear from "./linear";
/**
 * Generate radial and repeating-radial gradient CSS strings.
 *
 * @see {@link Radial.toCss}
 */
export * as Radial from "./radial";


=== File: src/generate/gradient/linear.ts ===
// b_path:: src/generate/gradient/linear.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as ColorStop from "./color-stop";

/**
 * Generate CSS direction string from GradientDirection IR.
 *
 * @param direction - GradientDirection IR object
 * @returns CSS direction string (e.g., "45deg", "to right", "to top left")
 *
 * @internal
 */
function directionToCss(direction: Type.GradientDirection): GenerateResult {
	if (direction.kind === "angle") {
		return generateOk(`${direction.value.value}${direction.value.unit}`);
	}

	if (direction.kind === "to-side") {
		return generateOk(`to ${direction.value}`);
	}

	// to-corner
	return generateOk(`to ${direction.value}`);
}

/**
 * Generate a CSS linear gradient string from intermediate representation (IR).
 *
 * Converts a LinearGradient IR object into a valid CSS `linear-gradient()` or
 * `repeating-linear-gradient()` function string. Handles all gradient components:
 * direction, color interpolation, and color stops.
 *
 * The generated CSS string is spec-compliant and can be used directly in CSS
 * properties like `background-image`, `background`, or `mask-image`.
 *
 * This function performs the inverse operation of `Parse.Gradient.Linear.parse()`,
 * enabling bidirectional transformation between CSS and IR.
 *
 * @param ir - LinearGradient IR object to convert to CSS
 * @returns CSS linear gradient function string
 *
 * @public
 *
 * @example
 * Simple gradient:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Linear.generate({
 *   kind: "linear",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(red, blue)"
 * ```
 *
 * @example
 * With angle direction:
 * ```typescript
 * const css = Generate.Gradient.Linear.generate({
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(45deg, red, blue)"
 * ```
 *
 * @example
 * With side direction:
 * ```typescript
 * const css = Generate.Gradient.Linear.generate({
 *   kind: "linear",
 *   direction: { kind: "to-side", value: "right" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(to right, red, blue)"
 * ```
 *
 * @example
 * With corner direction:
 * ```typescript
 * const css = Generate.Gradient.Linear.generate({
 *   kind: "linear",
 *   direction: { kind: "to-corner", value: "top right" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(to top right, red, blue)"
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const css = Generate.Gradient.Linear.generate({
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 90, unit: "deg" } },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * });
 * console.log(css); // "linear-gradient(90deg in oklch, red 0%, blue 100%)"
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const css = Generate.Gradient.Linear.generate({
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "px" } },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * });
 * console.log(css); // "repeating-linear-gradient(45deg, red 0px, blue 20px)"
 * ```
 *
 * @example
 * Round-trip transformation (parse → generate):
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "linear-gradient(to right, red, blue)";
 * const parsed = Parse.Gradient.Linear.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Gradient.Linear.generate(parsed.value);
 *   console.log(generated === original); // true - perfect round-trip!
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient | MDN: linear-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients | W3C Spec: Linear Gradients}
 */
export function generate(ir: Type.LinearGradient): GenerateResult {
	const parts: string[] = [];

	// Add direction if present
	if (ir.direction) {
		const dirStr = directionToCss(ir.direction);
		if (ir.colorSpace) {
			// Direction and color space together
			parts.push(`${dirStr} in ${ir.colorSpace}`);
		} else {
			const _result = dirStr;
			if (!_result.ok) return _result;
			parts.push(_result.value);
		}
	} else if (ir.colorSpace) {
		// Just color space
		parts.push(`in ${ir.colorSpace}`);
	}

	// Add color stops
	for (const stop of ir.colorStops) {
		const result = ColorStop.generate(stop);
		if (!result.ok) return result;
		parts.push(result.value);
	}

	// Generate function
	const functionName = ir.repeating ? "repeating-linear-gradient" : "linear-gradient";
	return generateOk(`${functionName}(${parts.join(", ")})`);
}


=== File: src/generate/gradient/radial.test.ts ===
// b_path:: src/generate/gradient/radial.test.ts

import { describe, expect, test } from "vitest";
import type * as Type from "@/core/types";
import { generate } from "./radial";

describe("generate() for radial gradient", () => {
	test("generates basic radial gradient with shape only", () => {
		const ir: Type.RadialGradient = {
			kind: "radial",
			shape: "circle",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("circle");
			expect(result.value).toContain("red");
		}
	});

	test("generates radial gradient with position only (no shape/size)", () => {
		const ir: Type.RadialGradient = {
			kind: "radial",
			position: {
				horizontal: "left",
				vertical: "top",
			},
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Lines 182-183: position without shape/size
			expect(result.value).toContain("at left top");
			expect(result.value).not.toContain("circle");
			expect(result.value).not.toContain("ellipse");
		}
	});

	test("generates radial gradient with shape, size and position", () => {
		const ir: Type.RadialGradient = {
			kind: "radial",
			shape: "circle",
			size: { kind: "keyword", value: "closest-side" },
			position: {
				horizontal: { value: 50, unit: "%" },
				vertical: { value: 50, unit: "%" },
			},
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Lines 180-181: shape+size with position
			expect(result.value).toContain("circle closest-side at 50% 50%");
		}
	});

	test("generates radial gradient with colorSpace (with existing parts)", () => {
		const ir: Type.RadialGradient = {
			kind: "radial",
			shape: "circle",
			colorSpace: "srgb",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Lines 191-193: colorSpace appended to existing parts
			expect(result.value).toContain("circle in srgb");
		}
	});

	test("generates radial gradient with colorSpace only (no shape/size/position)", () => {
		const ir: Type.RadialGradient = {
			kind: "radial",
			colorSpace: "display-p3",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Lines 195-196: colorSpace as standalone part
			expect(result.value).toContain("in display-p3");
		}
	});

	test("generates repeating radial gradient", () => {
		const ir: Type.RadialGradient = {
			kind: "radial",
			shape: "ellipse",
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: true,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("repeating-radial-gradient");
		}
	});

	test("handles explicit ellipse size", () => {
		const ir: Type.RadialGradient = {
			kind: "radial",
			size: {
				kind: "ellipse-explicit",
				radiusX: { value: 100, unit: "px" },
				radiusY: { value: 50, unit: "px" },
			},
			colorStops: [{ color: { kind: "named", name: "red" } }, { color: { kind: "named", name: "blue" } }],
			repeating: false,
		};
		const result = generate(ir);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("100px 50px");
		}
	});
});


=== File: src/generate/gradient/radial.ts ===
// b_path:: src/generate/gradient/radial.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as ColorStop from "./color-stop";

/**
 * Generate CSS position string from Position2D IR.
 *
 * @param position - Position2D IR object
 * @returns CSS position string (e.g., "center", "left top", "50% 50%")
 *
 * @internal
 */
function positionToCss(position: Type.Position2D): string {
	const h =
		typeof position.horizontal === "string"
			? position.horizontal
			: `${position.horizontal.value}${position.horizontal.unit}`;
	const v =
		typeof position.vertical === "string" ? position.vertical : `${position.vertical.value}${position.vertical.unit}`;
	return `${h} ${v}`;
}

/**
 * Generate CSS radial gradient size string from IR.
 *
 * @param size - RadialGradientSize IR object
 * @returns CSS size string
 *
 * @internal
 */
function sizeToCss(size: Type.RadialGradientSize): string {
	if (size.kind === "keyword") {
		return size.value;
	}

	if (size.kind === "circle-explicit") {
		return `${size.radius.value}${size.radius.unit}`;
	}

	// ellipse-explicit
	return `${size.radiusX.value}${size.radiusX.unit} ${size.radiusY.value}${size.radiusY.unit}`;
}

/**
 * Generate a CSS radial gradient string from intermediate representation (IR).
 *
 * Converts a RadialGradient IR object into a valid CSS `radial-gradient()` or
 * `repeating-radial-gradient()` function string. Handles all gradient components:
 * shape, size, position, color interpolation, and color stops.
 *
 * The generated CSS string is spec-compliant and can be used directly in CSS
 * properties like `background-image`, `background`, or `mask-image`.
 *
 * This function performs the inverse operation of `Parse.Gradient.Radial.parse()`,
 * enabling bidirectional transformation between CSS and IR.
 *
 * @param ir - RadialGradient IR object to convert to CSS
 * @returns CSS radial gradient function string
 *
 * @public
 *
 * @example
 * Simple gradient:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Radial.generate({
 *   kind: "radial",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(red, blue)"
 * ```
 *
 * @example
 * Circle with keyword size:
 * ```typescript
 * const css = Generate.Gradient.Radial.generate({
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "keyword", value: "closest-side" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(circle closest-side, red, blue)"
 * ```
 *
 * @example
 * Positioned gradient:
 * ```typescript
 * const css = Generate.Gradient.Radial.generate({
 *   kind: "radial",
 *   shape: "ellipse",
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(ellipse at left top, red, blue)"
 * ```
 *
 * @example
 * With explicit size:
 * ```typescript
 * const css = Generate.Gradient.Radial.generate({
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "circle-explicit", radius: { value: 100, unit: "px" } },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(circle 100px, red, blue)"
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const css = Generate.Gradient.Radial.generate({
 *   kind: "radial",
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * });
 * console.log(css); // "radial-gradient(in oklch, red 0%, blue 100%)"
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const css = Generate.Gradient.Radial.generate({
 *   kind: "radial",
 *   shape: "circle",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "px" } },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * });
 * console.log(css); // "repeating-radial-gradient(circle, red 0px, blue 20px)"
 * ```
 *
 * @example
 * Round-trip transformation (parse → generate):
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "radial-gradient(circle closest-side, red, blue)";
 * const parsed = Parse.Gradient.Radial.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Gradient.Radial.generate(parsed.value);
 *   console.log(generated === original); // true - perfect round-trip!
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient | MDN: radial-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients | W3C Spec: Radial Gradients}
 */
export function generate(ir: Type.RadialGradient): GenerateResult {
	const parts: string[] = [];
	const shapeAndSize: string[] = [];

	// Build shape and size part
	if (ir.shape) {
		shapeAndSize.push(ir.shape);
	}

	if (ir.size) {
		shapeAndSize.push(sizeToCss(ir.size));
	}

	// Combine shape/size with position
	const shapeAndSizeStr = shapeAndSize.join(" ");
	if (ir.position) {
		const posStr = positionToCss(ir.position);
		if (shapeAndSizeStr) {
			parts.push(`${shapeAndSizeStr} at ${posStr}`);
		} else {
			parts.push(`at ${posStr}`);
		}
	} else if (shapeAndSizeStr) {
		parts.push(shapeAndSizeStr);
	}

	// Add color interpolation if present
	if (ir.colorSpace) {
		if (parts.length > 0) {
			// Append to last part without comma
			parts[parts.length - 1] = `${parts[parts.length - 1]} in ${ir.colorSpace}`;
		} else {
			parts.push(`in ${ir.colorSpace}`);
		}
	}

	// Add color stops
	for (const stop of ir.colorStops) {
		const result = ColorStop.generate(stop);
		if (!result.ok) return result;
		parts.push(result.value);
	}

	// Generate function
	const functionName = ir.repeating ? "repeating-radial-gradient" : "radial-gradient";
	return generateOk(`${functionName}(${parts.join(", ")})`);
}


=== File: src/generate/index.ts ===
// b_path:: src/generate/index.ts

/**
 * CSS value generators - convert structured IR to CSS strings.
 *
 * All generators return CSS strings directly (no Result type needed since
 * generation cannot fail). Convert intermediate representation (IR) objects
 * into spec-compliant CSS that can be used in stylesheets.
 *
 * @module Generate
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Radial.generate({
 *   kind: "radial",
 *   shape: "circle",
 *   colorStops: [
 *     { color: { kind: "named", name: "red" } },
 *     { color: { kind: "named", name: "blue" } }
 *   ],
 *   repeating: false
 * });
 *
 * console.log(css); // "radial-gradient(circle, red, blue)"
 * ```
 */

/**
 * Animation generators (delay, duration, iteration-count, direction, fill-mode, play-state, name, timing-function).
 *
 * @see {@link Animation.Delay.toCss}
 */
export * as Animation from "./animation";
/**
 * Background generators (attachment, clip, origin, repeat, size).
 *
 * @see {@link Background.Attachment.toCss}
 */
export * as Background from "./background";
/**
 * Border generators (width, style, color, radius).
 *
 * @see {@link Border.Width.toCss}
 */
export * as Border from "./border";
/**
 * Clip-path generators (url, none).
 *
 * @see {@link ClipPath.Url.toCss}
 */
export * as ClipPath from "./clip-path";
/**
 * Color generators (hex, named, RGB, HSL, HWB, LAB, LCH, OKLab, OKLCH, system, special).
 *
 * @see {@link Color.Hex.toCss}
 */
export * as Color from "./color";
/**
 * Filter generators (blur, brightness, contrast, drop-shadow, grayscale, hue-rotate, invert, opacity, saturate, sepia, url).
 *
 * @see {@link Filter.Blur.toCss}
 */
export * as Filter from "./filter";
/**
 * Gradient generators (radial, linear, conic).
 *
 * @see {@link Gradient.Radial.toCss}
 */
export * as Gradient from "./gradient";
/**
 * Interaction generators (pointer-events).
 *
 * @see {@link Interaction.PointerEvents.toCss}
 */
export * as Interaction from "./interaction";
/**
 * Layout generators (display, visibility, opacity).
 *
 * @see {@link Layout.Display.toCss}
 */
export * as Layout from "./layout";
/**
 * Outline generators (width, style, color, offset).
 *
 * @see {@link Outline.Width.toCss}
 */
export * as Outline from "./outline";
/**
 * Position generators (background-position, object-position, transform-origin, etc.).
 *
 * @see {@link Position.toCss}
 */
export * as Position from "./position";
/**
 * Shadow generators (box-shadow, text-shadow).
 *
 * @see {@link Shadow.BoxShadow.toCss}
 */
export * as Shadow from "./shadow";
/**
 * Text decoration generators (color, line, style, thickness).
 *
 * @see {@link Text.Color.toCss}
 */
export * as Text from "./text";
/**
 * Transform generators (translate, rotate, scale, skew, matrix, etc.).
 *
 * @see {@link Transform.Utils.toCss}
 */
export * as Transform from "./transform";
/**
 * Transition generators (delay, duration, timing-function, property).
 *
 * @see {@link Transition.Delay.toCss}
 */
export * as Transition from "./transition";


=== File: src/generate/interaction/index.ts ===
// b_path:: src/generate/interaction/index.ts

export * as PointerEvents from "./pointer-events";
export * as UserSelect from "./user-select";


=== File: src/generate/interaction/pointer-events.test.ts ===
// b_path:: src/generate/interaction/pointer-events.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./pointer-events";

describe("pointer-events generator", () => {
	test("should generate 'none'", () => {
		const result = generate({ kind: "pointer-events", value: "none" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("none");
	});

	test("should generate 'auto'", () => {
		const result = generate({ kind: "pointer-events", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});

	test("should generate 'visiblePainted'", () => {
		const result = generate({ kind: "pointer-events", value: "visiblePainted" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("visiblePainted");
	});

	test("should generate 'visibleFill'", () => {
		const result = generate({ kind: "pointer-events", value: "visibleFill" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("visibleFill");
	});
});


=== File: src/generate/interaction/pointer-events.ts ===
// b_path:: src/generate/interaction/pointer-events.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { PointerEvents } from "@/core/types";

/**
 * Generate CSS pointer-events property from IR.
 *
 * Outputs keyword value.
 *
 * @param pointerEvents - PointerEvents IR
 * @returns CSS string like "none", "auto", or "visiblePainted"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/interaction/pointer-events";
 *
 * const css = toCss({ kind: "pointer-events", value: "none" });
 * // "none"
 * ```
 *
 * @public
 */
export function generate(pointerEvents: PointerEvents): GenerateResult {
	if (pointerEvents === undefined || pointerEvents === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(pointerEvents.value);
}


=== File: src/generate/interaction/user-select.test.ts ===
// b_path:: src/generate/interaction/user-select.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./user-select";

describe("user-select generator", () => {
	test("should generate 'none'", () => {
		const result = generate({ kind: "user-select", value: "none" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("none");
	});

	test("should generate 'auto'", () => {
		const result = generate({ kind: "user-select", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});

	test("should generate 'text'", () => {
		const result = generate({ kind: "user-select", value: "text" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("text");
	});

	test("should generate 'all'", () => {
		const result = generate({ kind: "user-select", value: "all" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("all");
	});
});


=== File: src/generate/interaction/user-select.ts ===
// b_path:: src/generate/interaction/user-select.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { UserSelect } from "@/core/types";

/**
 * Generate CSS user-select property from IR.
 *
 * Outputs keyword value.
 *
 * @param userSelect - UserSelect IR
 * @returns CSS string like "none", "auto", or "text"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/user-select}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/interaction/user-select";
 *
 * const css = toCss({ kind: "user-select", value: "none" });
 * // "none"
 * ```
 *
 * @public
 */
export function generate(userSelect: UserSelect): GenerateResult {
	if (userSelect === undefined || userSelect === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(userSelect.value);
}


=== File: src/generate/layout/bottom.test.ts ===
// b_path:: src/generate/layout/bottom.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./bottom.js";

describe("generate/layout/bottom", () => {
	it("generates pixel value", () => {
		const result = generate({ kind: "bottom", value: { value: 10, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("10px");
	});

	it("generates percentage", () => {
		const result = generate({ kind: "bottom", value: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("50%");
	});

	it("generates rem value", () => {
		const result = generate({ kind: "bottom", value: { value: 2, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("2rem");
	});

	it("generates auto", () => {
		const result = generate({ kind: "bottom", value: "auto" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("auto");
	});

	it("generates zero", () => {
		const result = generate({ kind: "bottom", value: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0px");
	});
});


=== File: src/generate/layout/bottom.ts ===
// b_path:: src/generate/layout/bottom.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Bottom } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS bottom property from IR.
 *
 * Outputs length-percentage value or "auto" keyword.
 *
 * @param bottom - Bottom IR
 * @returns CSS string like "10px", "50%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/bottom}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/bottom";
 *
 * const css = toCss({ kind: "bottom", value: { value: 10, unit: "px" } });
 * // "10px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "bottom", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function generate(bottom: Bottom): GenerateResult {
	if (bottom === undefined || bottom === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (bottom.value === "auto") {
		return generateOk("auto");
	}
	return generateOk(GenUtils.lengthPercentageToCss(bottom.value));
}


=== File: src/generate/layout/box-sizing.failure.test.ts ===
// b_path:: src/generate/layout/box-sizing.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/box-sizing.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/layout/box-sizing";

describe("generate/layout/box-sizing - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "box-sizing",
				value: "padding-box",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Expected content-box | border-box");
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "display",
				value: "content-box",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "box-sizing"');
		});
	});
});


=== File: src/generate/layout/box-sizing.test.ts ===
// b_path:: src/generate/layout/box-sizing.test.ts
// Auto-generated from scripts/generate-test-generator/configs/layout/box-sizing.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/layout/box-sizing";
import * as Parser from "@/parse/layout/box-sizing";

describe("generate/layout/box-sizing - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate content-box keyword", () => {
			const input: Type.BoxSizing = {
				kind: "box-sizing",
				value: "content-box",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("content-box");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate border-box keyword", () => {
			const input: Type.BoxSizing = {
				kind: "box-sizing",
				value: "border-box",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("border-box");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/layout/box-sizing.ts ===
// b_path:: src/generate/layout/box-sizing.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { BoxSizing } from "@/core/types";
import { boxSizingSchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS box-sizing property from IR.
 *
 * Outputs box-sizing keyword.
 *
 * @param boxSizing - BoxSizing IR
 * @returns CSS string like "border-box" or "content-box"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/box-sizing";
 *
 * const css = toCss({ kind: "box-sizing", value: "border-box" });
 * // "border-box"
 * ```
 *
 * @public
 */
export function generate(boxSizing: BoxSizing): GenerateResult {
	// Validate IR with Zod schema
	const validation = boxSizingSchema.safeParse(boxSizing);

	if (!validation.success) {
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	return generateOk(boxSizing.value);
}


=== File: src/generate/layout/clear.failure.test.ts ===
// b_path:: src/generate/layout/clear.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/clear.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/layout/clear";

describe("generate/layout/clear - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "clear",
				value: "center",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"value: Expected left | right | both | none | inline-start | inline-end",
			);
		});
	});
});


=== File: src/generate/layout/clear.test.ts ===
// b_path:: src/generate/layout/clear.test.ts
// Auto-generated from scripts/generate-test-generator/configs/layout/clear.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/layout/clear";
import * as Parser from "@/parse/layout/clear";

describe("generate/layout/clear - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate none keyword", () => {
			const input: Type.Clear = {
				kind: "clear",
				value: "none",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate left keyword", () => {
			const input: Type.Clear = {
				kind: "clear",
				value: "left",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("left");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate right keyword", () => {
			const input: Type.Clear = {
				kind: "clear",
				value: "right",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("right");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate both keyword", () => {
			const input: Type.Clear = {
				kind: "clear",
				value: "both",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("both");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/layout/clear.ts ===
// b_path:: src/generate/layout/clear.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { Clear } from "@/core/types";
import { clearSchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate/validation";

/**
 * Generate CSS clear value.
 *
 * @param clear - Clear IR value
 * @returns CSS clear string
 *
 * @example
 * toCss({ kind: "clear", value: "both" })  // "both"
 * toCss({ kind: "clear", value: "left" })  // "left"
 */
export function generate(clear: Clear): GenerateResult {
	// Validate IR with Zod schema
	const validation = clearSchema.safeParse(clear);

	if (!validation.success) {
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	return generateOk(clear.value);
}


=== File: src/generate/layout/cursor.failure.test.ts ===
// b_path:: src/generate/layout/cursor.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/cursor.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/layout/cursor";

describe("generate/layout/cursor - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "cursor",
				value: "hand",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"value: Expected auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | grab | grabbing | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out",
			);
		});
	});
});


=== File: src/generate/layout/cursor.test.ts ===
// b_path:: src/generate/layout/cursor.test.ts
// Auto-generated from scripts/generate-test-generator/configs/layout/cursor.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/layout/cursor";
import * as Parser from "@/parse/layout/cursor";

describe("generate/layout/cursor - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate auto keyword", () => {
			const input: Type.Cursor = {
				kind: "cursor",
				value: "auto",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("auto");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate pointer keyword", () => {
			const input: Type.Cursor = {
				kind: "cursor",
				value: "pointer",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("pointer");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate text keyword", () => {
			const input: Type.Cursor = {
				kind: "cursor",
				value: "text",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("text");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate move keyword", () => {
			const input: Type.Cursor = {
				kind: "cursor",
				value: "move",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("move");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-action", () => {
		it("should generate not-allowed keyword", () => {
			const input: Type.Cursor = {
				kind: "cursor",
				value: "not-allowed",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("not-allowed");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/layout/cursor.ts ===
// b_path:: src/generate/layout/cursor.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { Cursor } from "@/core/types";
import { cursorSchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS cursor property from IR.
 *
 * Outputs cursor keyword value.
 *
 * @param cursor - Cursor IR
 * @returns CSS string like "pointer" or "text"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/cursor";
 *
 * const css = toCss({ kind: "cursor", value: "pointer" });
 * // "pointer"
 * ```
 *
 * @public
 */
export function generate(cursor: Cursor): GenerateResult {
	// Validate IR with Zod schema
	const validation = cursorSchema.safeParse(cursor);

	if (!validation.success) {
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	return generateOk(cursor.value);
}


=== File: src/generate/layout/display.failure.test.ts ===
// b_path:: src/generate/layout/display.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/display.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/display
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/layout/display";

describe("generate/layout/display - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "display",
				value: "visible",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"value: Expected contents | none | flow | flow-root | table | flex | grid | ruby | table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container | inline-block | inline-table | inline-flex | inline-grid | block | inline | run-in | list-item",
			);
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "visibility",
				value: "block",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "display"');
		});
	});
});


=== File: src/generate/layout/display.test.ts ===
// b_path:: src/generate/layout/display.test.ts
// Auto-generated from scripts/generate-test-generator/configs/layout/display.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/display
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/layout/display";
import * as Parser from "@/parse/layout/display";

describe("generate/layout/display - valid cases", () => {
	describe("valid-outside", () => {
		it("should generate block keyword", () => {
			const input: Type.Display = {
				kind: "display",
				value: "block",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("block");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate inline keyword", () => {
			const input: Type.Display = {
				kind: "display",
				value: "inline",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("inline");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-box", () => {
		it("should generate none keyword", () => {
			const input: Type.Display = {
				kind: "display",
				value: "none",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-inside", () => {
		it("should generate flex keyword", () => {
			const input: Type.Display = {
				kind: "display",
				value: "flex",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("flex");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate grid keyword", () => {
			const input: Type.Display = {
				kind: "display",
				value: "grid",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("grid");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-legacy", () => {
		it("should generate inline-block keyword", () => {
			const input: Type.Display = {
				kind: "display",
				value: "inline-block",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("inline-block");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/layout/display.ts ===
// b_path:: src/generate/layout/display.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { Display } from "@/core/types";
import { displaySchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS display property from IR.
 *
 * Outputs display keyword value.
 *
 * @param display - Display IR
 * @returns CSS string like "flex" or "none"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/display";
 *
 * const css = toCss({ kind: "display", value: "flex" });
 * // "flex"
 * ```
 *
 * @public
 */
export function generate(display: Display): GenerateResult {
	// Validate IR with Zod schema
	const validation = displaySchema.safeParse(display);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(display.value);
}


=== File: src/generate/layout/float.failure.test.ts ===
// b_path:: src/generate/layout/float.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/float.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/layout/float";

describe("generate/layout/float - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "float",
				value: "center",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Expected left | right | none | inline-start | inline-end");
		});
	});
});


=== File: src/generate/layout/float.test.ts ===
// b_path:: src/generate/layout/float.test.ts
// Auto-generated from scripts/generate-test-generator/configs/layout/float.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/layout/float";
import * as Parser from "@/parse/layout/float";

describe("generate/layout/float - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate none keyword", () => {
			const input: Type.Float = {
				kind: "float",
				value: "none",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate left keyword", () => {
			const input: Type.Float = {
				kind: "float",
				value: "left",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("left");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate right keyword", () => {
			const input: Type.Float = {
				kind: "float",
				value: "right",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("right");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/layout/float.ts ===
// b_path:: src/generate/layout/float.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { Float } from "@/core/types";
import { floatSchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate/validation";

/**
 * Generate CSS float value.
 *
 * @param float - Float IR value
 * @returns CSS float string
 *
 * @example
 * toCss({ kind: "float", value: "left" })  // "left"
 * toCss({ kind: "float", value: "right" }) // "right"
 */
export function generate(float: Float): GenerateResult {
	// Validate IR with Zod schema
	const validation = floatSchema.safeParse(float);

	if (!validation.success) {
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	return generateOk(float.value);
}


=== File: src/generate/layout/height.test.ts ===
// b_path:: src/generate/layout/height.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./height";

describe("height generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "height", value: { value: 300, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("300px");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "height", value: { value: 100, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("100%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "height", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});

	test("should generate 'min-content' keyword", () => {
		const result = generate({ kind: "height", value: "min-content" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("min-content");
	});
});


=== File: src/generate/layout/height.ts ===
// b_path:: src/generate/layout/height.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Height } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS height property from IR.
 *
 * Outputs length-percentage value, auto keyword, or intrinsic sizing keyword.
 *
 * @param height - Height IR
 * @returns CSS string like "100px", "50%", "auto", or "max-content"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/height}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/height";
 *
 * const css = toCss({ kind: "height", value: { value: 100, unit: "px" } });
 * // "100px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "height", value: "auto" });
 * // "auto"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "height", value: "max-content" });
 * // "max-content"
 * ```
 *
 * @public
 */
export function generate(height: Height): GenerateResult {
	if (height === undefined || height === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof height.value === "string") {
		return generateOk(height.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(height.value));
}


=== File: src/generate/layout/index.ts ===
// b_path:: src/generate/layout/index.ts

export * as Bottom from "./bottom";
export * as BoxSizing from "./box-sizing";
export * as Clear from "./clear";
export * as Cursor from "./cursor";
export * as Display from "./display";
export * as Float from "./float";
export * as Height from "./height";
export * as Left from "./left";
export * as MarginBottom from "./margin-bottom";
export * as MarginLeft from "./margin-left";
export * as MarginRight from "./margin-right";
export * as MarginTop from "./margin-top";
export * as MaxHeight from "./max-height";
export * as MaxWidth from "./max-width";
export * as MinHeight from "./min-height";
export * as MinWidth from "./min-width";
export * as Overflow from "./overflow.generate";
export * as OverflowX from "./overflow-x";
export * as OverflowY from "./overflow-y";
export * as PaddingBottom from "./padding-bottom";
export * as PaddingLeft from "./padding-left";
export * as PaddingRight from "./padding-right";
export * as PaddingTop from "./padding-top";
export * as Position from "./position";
export * as Right from "./right";
export * as Top from "./top";
export * as Width from "./width";
export * as ZIndex from "./z-index";


=== File: src/generate/layout/left.test.ts ===
// b_path:: src/generate/layout/left.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./left.js";

describe("generate/layout/left", () => {
	it("generates pixel value", () => {
		const result = generate({ kind: "left", value: { value: 10, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("10px");
	});

	it("generates percentage", () => {
		const result = generate({ kind: "left", value: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("50%");
	});

	it("generates rem value", () => {
		const result = generate({ kind: "left", value: { value: 2, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("2rem");
	});

	it("generates auto", () => {
		const result = generate({ kind: "left", value: "auto" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("auto");
	});

	it("generates zero", () => {
		const result = generate({ kind: "left", value: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0px");
	});
});


=== File: src/generate/layout/left.ts ===
// b_path:: src/generate/layout/left.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Left } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS left property from IR.
 *
 * Outputs length-percentage value or "auto" keyword.
 *
 * @param left - Left IR
 * @returns CSS string like "10px", "50%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/left}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/left";
 *
 * const css = toCss({ kind: "left", value: { value: 10, unit: "px" } });
 * // "10px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "left", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function generate(left: Left): GenerateResult {
	if (left === undefined || left === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (left.value === "auto") {
		return generateOk("auto");
	}
	return generateOk(GenUtils.lengthPercentageToCss(left.value));
}


=== File: src/generate/layout/margin-bottom.test.ts ===
// b_path:: src/generate/layout/margin-bottom.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./margin-bottom";

describe("margin-bottom generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "margin-bottom", value: { value: 20, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("20px");
	});

	test("should generate length in rem", () => {
		const result = generate({ kind: "margin-bottom", value: { value: 3, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("3rem");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "margin-bottom", value: { value: 8, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("8%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "margin-bottom", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});
});


=== File: src/generate/layout/margin-bottom.ts ===
// b_path:: src/generate/layout/margin-bottom.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { MarginBottom } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS margin-bottom property from IR.
 *
 * @param marginBottom - MarginBottom IR
 * @returns CSS string like "10px", "5%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-bottom}
 *
 * @public
 */
export function generate(marginBottom: MarginBottom): GenerateResult {
	if (marginBottom === undefined || marginBottom === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof marginBottom.value === "string") {
		return generateOk(marginBottom.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(marginBottom.value));
}


=== File: src/generate/layout/margin-left.test.ts ===
// b_path:: src/generate/layout/margin-left.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./margin-left";

describe("margin-left generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "margin-left", value: { value: 25, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("25px");
	});

	test("should generate length in vw", () => {
		const result = generate({ kind: "margin-left", value: { value: 5, unit: "vw" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("5vw");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "margin-left", value: { value: 12, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("12%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "margin-left", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});
});


=== File: src/generate/layout/margin-left.ts ===
// b_path:: src/generate/layout/margin-left.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { MarginLeft } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS margin-left property from IR.
 *
 * @param marginLeft - MarginLeft IR
 * @returns CSS string like "10px", "5%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-left}
 *
 * @public
 */
export function generate(marginLeft: MarginLeft): GenerateResult {
	if (marginLeft === undefined || marginLeft === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof marginLeft.value === "string") {
		return generateOk(marginLeft.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(marginLeft.value));
}


=== File: src/generate/layout/margin-right.test.ts ===
// b_path:: src/generate/layout/margin-right.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./margin-right";

describe("margin-right generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "margin-right", value: { value: 15, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("15px");
	});

	test("should generate length in em", () => {
		const result = generate({ kind: "margin-right", value: { value: 1.5, unit: "em" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1.5em");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "margin-right", value: { value: 10, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("10%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "margin-right", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});
});


=== File: src/generate/layout/margin-right.ts ===
// b_path:: src/generate/layout/margin-right.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { MarginRight } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS margin-right property from IR.
 *
 * @param marginRight - MarginRight IR
 * @returns CSS string like "10px", "5%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-right}
 *
 * @public
 */
export function generate(marginRight: MarginRight): GenerateResult {
	if (marginRight === undefined || marginRight === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof marginRight.value === "string") {
		return generateOk(marginRight.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(marginRight.value));
}


=== File: src/generate/layout/margin-top.test.ts ===
// b_path:: src/generate/layout/margin-top.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./margin-top";

describe("margin-top generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "margin-top", value: { value: 10, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("10px");
	});

	test("should generate length in rem", () => {
		const result = generate({ kind: "margin-top", value: { value: 2, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("2rem");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "margin-top", value: { value: 5, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("5%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "margin-top", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});
});


=== File: src/generate/layout/margin-top.ts ===
// b_path:: src/generate/layout/margin-top.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { MarginTop } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS margin-top property from IR.
 *
 * @param marginTop - MarginTop IR
 * @returns CSS string like "10px", "5%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-top}
 *
 * @public
 */
export function generate(marginTop: MarginTop): GenerateResult {
	if (marginTop === undefined || marginTop === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof marginTop.value === "string") {
		return generateOk(marginTop.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(marginTop.value));
}


=== File: src/generate/layout/max-height.test.ts ===
// b_path:: src/generate/layout/max-height.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./max-height";

describe("max-height generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "max-height", value: { value: 600, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("600px");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "max-height", value: { value: 80, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("80%");
	});

	test("should generate 'none' keyword", () => {
		const result = generate({ kind: "max-height", value: "none" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("none");
	});
});


=== File: src/generate/layout/max-height.ts ===
// b_path:: src/generate/layout/max-height.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { MaxHeight } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS max-height property from IR.
 *
 * @param maxHeight - MaxHeight IR
 * @returns CSS string like "100px", "50%", "none", or "max-content"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/max-height}
 *
 * @public
 */
export function generate(maxHeight: MaxHeight): GenerateResult {
	if (maxHeight === undefined || maxHeight === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof maxHeight.value === "string") {
		return generateOk(maxHeight.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(maxHeight.value));
}


=== File: src/generate/layout/max-width.test.ts ===
// b_path:: src/generate/layout/max-width.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./max-width";

describe("max-width generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "max-width", value: { value: 1200, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1200px");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "max-width", value: { value: 90, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("90%");
	});

	test("should generate 'none' keyword", () => {
		const result = generate({ kind: "max-width", value: "none" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("none");
	});
});


=== File: src/generate/layout/max-width.ts ===
// b_path:: src/generate/layout/max-width.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { MaxWidth } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS max-width property from IR.
 *
 * @param maxWidth - MaxWidth IR
 * @returns CSS string like "200px", "50%", "none", or "max-content"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/max-width}
 *
 * @public
 */
export function generate(maxWidth: MaxWidth): GenerateResult {
	if (maxWidth === undefined || maxWidth === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof maxWidth.value === "string") {
		return generateOk(maxWidth.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(maxWidth.value));
}


=== File: src/generate/layout/min-height.test.ts ===
// b_path:: src/generate/layout/min-height.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./min-height";

describe("min-height generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "min-height", value: { value: 150, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("150px");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "min-height", value: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("50%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "min-height", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});
});


=== File: src/generate/layout/min-height.ts ===
// b_path:: src/generate/layout/min-height.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { MinHeight } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS min-height property from IR.
 *
 * @param minHeight - MinHeight IR
 * @returns CSS string like "100px", "50%", "auto", or "min-content"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/min-height}
 *
 * @public
 */
export function generate(minHeight: MinHeight): GenerateResult {
	if (minHeight === undefined || minHeight === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof minHeight.value === "string") {
		return generateOk(minHeight.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(minHeight.value));
}


=== File: src/generate/layout/min-width.test.ts ===
// b_path:: src/generate/layout/min-width.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./min-width";

describe("min-width generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "min-width", value: { value: 100, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("100px");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "min-width", value: { value: 30, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("30%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "min-width", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});
});


=== File: src/generate/layout/min-width.ts ===
// b_path:: src/generate/layout/min-width.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { MinWidth } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS min-width property from IR.
 *
 * @param minWidth - MinWidth IR
 * @returns CSS string like "200px", "50%", "auto", or "min-content"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/min-width}
 *
 * @public
 */
export function generate(minWidth: MinWidth): GenerateResult {
	if (minWidth === undefined || minWidth === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof minWidth.value === "string") {
		return generateOk(minWidth.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(minWidth.value));
}


=== File: src/generate/layout/overflow-x.failure.test.ts ===
// b_path:: src/generate/layout/overflow-x.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/overflow-x.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/layout/overflow-x";

describe("generate/layout/overflow-x - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});
	});
});


=== File: src/generate/layout/overflow-x.test.ts ===
// b_path:: src/generate/layout/overflow-x.test.ts
// Auto-generated from scripts/generate-test-generator/configs/layout/overflow-x.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/layout/overflow-x";
import * as Parser from "@/parse/layout/overflow-x";

describe("generate/layout/overflow-x - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate visible keyword", () => {
			const input: Type.OverflowX = {
				kind: "overflow-x",
				value: "visible",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("visible");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate hidden keyword", () => {
			const input: Type.OverflowX = {
				kind: "overflow-x",
				value: "hidden",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("hidden");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate scroll keyword", () => {
			const input: Type.OverflowX = {
				kind: "overflow-x",
				value: "scroll",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("scroll");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate auto keyword", () => {
			const input: Type.OverflowX = {
				kind: "overflow-x",
				value: "auto",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("auto");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/layout/overflow-x.ts ===
// b_path:: src/generate/layout/overflow-x.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { OverflowX } from "@/core/types";
import { overflowXSchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS overflow-x property from IR.
 *
 * Outputs overflow-x keyword value.
 *
 * @param overflowX - OverflowX IR
 * @returns CSS string like "hidden" or "scroll"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/overflow-x";
 *
 * const css = toCss({ kind: "overflow-x", value: "hidden" });
 * // "hidden"
 * ```
 *
 * @public
 */
export function generate(overflowX: OverflowX): GenerateResult {
	// Validate IR with Zod schema
	const validation = overflowXSchema.safeParse(overflowX);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(overflowX.value);
}


=== File: src/generate/layout/overflow-y.failure.test.ts ===
// b_path:: src/generate/layout/overflow-y.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/overflow-y.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/layout/overflow-y";

describe("generate/layout/overflow-y - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});
	});
});


=== File: src/generate/layout/overflow-y.test.ts ===
// b_path:: src/generate/layout/overflow-y.test.ts
// Auto-generated from scripts/generate-test-generator/configs/layout/overflow-y.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/layout/overflow-y";
import * as Parser from "@/parse/layout/overflow-y";

describe("generate/layout/overflow-y - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate visible keyword", () => {
			const input: Type.OverflowY = {
				kind: "overflow-y",
				value: "visible",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("visible");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate hidden keyword", () => {
			const input: Type.OverflowY = {
				kind: "overflow-y",
				value: "hidden",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("hidden");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate scroll keyword", () => {
			const input: Type.OverflowY = {
				kind: "overflow-y",
				value: "scroll",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("scroll");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate auto keyword", () => {
			const input: Type.OverflowY = {
				kind: "overflow-y",
				value: "auto",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("auto");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/layout/overflow-y.ts ===
// b_path:: src/generate/layout/overflow-y.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { OverflowY } from "@/core/types";
import { overflowYSchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS overflow-y property from IR.
 *
 * Outputs overflow-y keyword value.
 *
 * @param overflowY - OverflowY IR
 * @returns CSS string like "auto" or "scroll"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/overflow-y";
 *
 * const css = toCss({ kind: "overflow-y", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function generate(overflowY: OverflowY): GenerateResult {
	// Validate IR with Zod schema
	const validation = overflowYSchema.safeParse(overflowY);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(overflowY.value);
}


=== File: src/generate/layout/overflow.generate.test.ts ===
// b_path:: src/generate/layout/overflow.generate.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./overflow.generate";

describe("generate overflow", () => {
	it("generates 'visible'", () => {
		const result = generate("visible");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("visible");
		}
	});

	it("generates 'hidden'", () => {
		const result = generate("hidden");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("hidden");
		}
	});

	it("generates 'scroll'", () => {
		const result = generate("scroll");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("scroll");
		}
	});

	it("generates 'auto'", () => {
		const result = generate("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("auto");
		}
	});

	it("rejects null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});

	it("rejects undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});

	it("rejects non-string", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(123 as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});
});


=== File: src/generate/layout/overflow.generate.ts ===
// b_path:: src/generate/layout/overflow.generate.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Overflow } from "../../parse/layout/overflow";

/**
 * Generate CSS overflow value.
 *
 * @param overflow - Overflow IR value
 * @returns CSS overflow string
 *
 * @example
 * toCss("auto")   // "auto"
 * toCss("hidden") // "hidden"
 */
export function generate(overflow: Overflow): GenerateResult {
	if (overflow === undefined || overflow === null) {
		return generateErr("invalid-ir", "Overflow must not be null or undefined");
	}
	if (typeof overflow !== "string") {
		return generateErr("invalid-ir", `Expected string, got ${typeof overflow}`);
	}
	return generateOk(overflow);
}


=== File: src/generate/layout/overflow.test.ts ===
// b_path:: src/generate/layout/overflow.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./overflow.generate";

describe("overflow generator", () => {
	test("should generate 'visible'", () => {
		const result = generate("visible");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("visible");
	});

	test("should generate 'hidden'", () => {
		const result = generate("hidden");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("hidden");
	});

	test("should generate 'scroll'", () => {
		const result = generate("scroll");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("scroll");
	});

	test("should generate 'auto'", () => {
		const result = generate("auto");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});
});


=== File: src/generate/layout/padding-bottom.test.ts ===
// b_path:: src/generate/layout/padding-bottom.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./padding-bottom";

describe("padding-bottom generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "padding-bottom", value: { value: 16, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("16px");
	});

	test("should generate length in rem", () => {
		const result = generate({ kind: "padding-bottom", value: { value: 1.5, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1.5rem");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "padding-bottom", value: { value: 10, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("10%");
	});
});


=== File: src/generate/layout/padding-bottom.ts ===
// b_path:: src/generate/layout/padding-bottom.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { PaddingBottom } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS padding-bottom property from IR.
 *
 * @param paddingBottom - PaddingBottom IR
 * @returns CSS string like "10px" or "5%"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-bottom}
 *
 * @public
 */
export function generate(paddingBottom: PaddingBottom): GenerateResult {
	if (paddingBottom === undefined || paddingBottom === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(GenUtils.lengthPercentageToCss(paddingBottom.value));
}


=== File: src/generate/layout/padding-left.test.ts ===
// b_path:: src/generate/layout/padding-left.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./padding-left";

describe("padding-left generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "padding-left", value: { value: 14, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("14px");
	});

	test("should generate length in vw", () => {
		const result = generate({ kind: "padding-left", value: { value: 3, unit: "vw" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("3vw");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "padding-left", value: { value: 25, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("25%");
	});
});


=== File: src/generate/layout/padding-left.ts ===
// b_path:: src/generate/layout/padding-left.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { PaddingLeft } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS padding-left property from IR.
 *
 * @param paddingLeft - PaddingLeft IR
 * @returns CSS string like "10px" or "5%"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-left}
 *
 * @public
 */
export function generate(paddingLeft: PaddingLeft): GenerateResult {
	if (paddingLeft === undefined || paddingLeft === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(GenUtils.lengthPercentageToCss(paddingLeft.value));
}


=== File: src/generate/layout/padding-right.test.ts ===
// b_path:: src/generate/layout/padding-right.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./padding-right";

describe("padding-right generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "padding-right", value: { value: 12, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("12px");
	});

	test("should generate length in em", () => {
		const result = generate({ kind: "padding-right", value: { value: 2, unit: "em" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("2em");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "padding-right", value: { value: 20, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("20%");
	});
});


=== File: src/generate/layout/padding-right.ts ===
// b_path:: src/generate/layout/padding-right.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { PaddingRight } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS padding-right property from IR.
 *
 * @param paddingRight - PaddingRight IR
 * @returns CSS string like "10px" or "5%"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-right}
 *
 * @public
 */
export function generate(paddingRight: PaddingRight): GenerateResult {
	if (paddingRight === undefined || paddingRight === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(GenUtils.lengthPercentageToCss(paddingRight.value));
}


=== File: src/generate/layout/padding-top.test.ts ===
// b_path:: src/generate/layout/padding-top.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./padding-top";

describe("padding-top generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "padding-top", value: { value: 8, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("8px");
	});

	test("should generate length in rem", () => {
		const result = generate({ kind: "padding-top", value: { value: 1, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1rem");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "padding-top", value: { value: 15, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("15%");
	});
});


=== File: src/generate/layout/padding-top.ts ===
// b_path:: src/generate/layout/padding-top.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { PaddingTop } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS padding-top property from IR.
 *
 * @param paddingTop - PaddingTop IR
 * @returns CSS string like "10px" or "5%"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-top}
 *
 * @public
 */
export function generate(paddingTop: PaddingTop): GenerateResult {
	if (paddingTop === undefined || paddingTop === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(GenUtils.lengthPercentageToCss(paddingTop.value));
}


=== File: src/generate/layout/position.failure.test.ts ===
// b_path:: src/generate/layout/position.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/position.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/position
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/layout/position";

describe("generate/layout/position - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});
	});
});


=== File: src/generate/layout/position.test.ts ===
// b_path:: src/generate/layout/position.test.ts
// Auto-generated from scripts/generate-test-generator/configs/layout/position.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/position
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/layout/position";
import * as Parser from "@/parse/layout/position";

describe("generate/layout/position - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate static keyword", () => {
			const input: Type.PositionProperty = {
				kind: "position",
				value: "static",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("static");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate relative keyword", () => {
			const input: Type.PositionProperty = {
				kind: "position",
				value: "relative",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("relative");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate absolute keyword", () => {
			const input: Type.PositionProperty = {
				kind: "position",
				value: "absolute",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("absolute");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate fixed keyword", () => {
			const input: Type.PositionProperty = {
				kind: "position",
				value: "fixed",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("fixed");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate sticky keyword", () => {
			const input: Type.PositionProperty = {
				kind: "position",
				value: "sticky",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("sticky");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/layout/position.ts ===
// b_path:: src/generate/layout/position.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { PositionProperty } from "@/core/types";
import { positionPropertySchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS position property from IR.
 *
 * Outputs position keyword value.
 *
 * @param position - PositionProperty IR
 * @returns CSS string like "absolute" or "sticky"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/position";
 *
 * const css = toCss({ kind: "position-property", value: "absolute" });
 * // "absolute"
 * ```
 *
 * @public
 */
export function generate(position: PositionProperty): GenerateResult {
	// Validate IR with Zod schema
	const validation = positionPropertySchema.safeParse(position);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(position.value);
}


=== File: src/generate/layout/right.test.ts ===
// b_path:: src/generate/layout/right.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./right.js";

describe("generate/layout/right", () => {
	it("generates pixel value", () => {
		const result = generate({ kind: "right", value: { value: 10, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("10px");
	});

	it("generates percentage", () => {
		const result = generate({ kind: "right", value: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("50%");
	});

	it("generates rem value", () => {
		const result = generate({ kind: "right", value: { value: 2, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("2rem");
	});

	it("generates auto", () => {
		const result = generate({ kind: "right", value: "auto" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("auto");
	});

	it("generates zero", () => {
		const result = generate({ kind: "right", value: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0px");
	});
});


=== File: src/generate/layout/right.ts ===
// b_path:: src/generate/layout/right.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Right } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS right property from IR.
 *
 * Outputs length-percentage value or "auto" keyword.
 *
 * @param right - Right IR
 * @returns CSS string like "10px", "50%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/right}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/right";
 *
 * const css = toCss({ kind: "right", value: { value: 10, unit: "px" } });
 * // "10px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "right", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function generate(right: Right): GenerateResult {
	if (right === undefined || right === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (right.value === "auto") {
		return generateOk("auto");
	}
	return generateOk(GenUtils.lengthPercentageToCss(right.value));
}


=== File: src/generate/layout/top.test.ts ===
// b_path:: src/generate/layout/top.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./top.js";

describe("generate/layout/top", () => {
	it("generates pixel value", () => {
		const result = generate({ kind: "top", value: { value: 10, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("10px");
	});

	it("generates percentage", () => {
		const result = generate({ kind: "top", value: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("50%");
	});

	it("generates rem value", () => {
		const result = generate({ kind: "top", value: { value: 2, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("2rem");
	});

	it("generates auto", () => {
		const result = generate({ kind: "top", value: "auto" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("auto");
	});

	it("generates zero", () => {
		const result = generate({ kind: "top", value: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0px");
	});
});


=== File: src/generate/layout/top.ts ===
// b_path:: src/generate/layout/top.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Top } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS top property from IR.
 *
 * Outputs length-percentage value or "auto" keyword.
 *
 * @param top - Top IR
 * @returns CSS string like "10px", "50%", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/top}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/top";
 *
 * const css = toCss({ kind: "top", value: { value: 10, unit: "px" } });
 * // "10px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "top", value: "auto" });
 * // "auto"
 * ```
 *
 * @public
 */
export function generate(top: Top): GenerateResult {
	if (top === undefined || top === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (top.value === "auto") {
		return generateOk("auto");
	}
	return generateOk(GenUtils.lengthPercentageToCss(top.value));
}


=== File: src/generate/layout/width.test.ts ===
// b_path:: src/generate/layout/width.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./width";

describe("width generator", () => {
	test("should generate length in px", () => {
		const result = generate({ kind: "width", value: { value: 200, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("200px");
	});

	test("should generate percentage", () => {
		const result = generate({ kind: "width", value: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("50%");
	});

	test("should generate 'auto' keyword", () => {
		const result = generate({ kind: "width", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});

	test("should generate 'min-content' keyword", () => {
		const result = generate({ kind: "width", value: "min-content" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("min-content");
	});

	test("should generate 'max-content' keyword", () => {
		const result = generate({ kind: "width", value: "max-content" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("max-content");
	});
});


=== File: src/generate/layout/width.ts ===
// b_path:: src/generate/layout/width.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { Width } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS width property from IR.
 *
 * Outputs length-percentage value, auto keyword, or intrinsic sizing keyword.
 *
 * @param width - Width IR
 * @returns CSS string like "200px", "50%", "auto", or "min-content"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/width";
 *
 * const css = toCss({ kind: "width", value: { value: 200, unit: "px" } });
 * // "200px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "width", value: "auto" });
 * // "auto"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "width", value: "min-content" });
 * // "min-content"
 * ```
 *
 * @public
 */
export function generate(width: Width): GenerateResult {
	if (width === undefined || width === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof width.value === "string") {
		return generateOk(width.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(width.value));
}


=== File: src/generate/layout/z-index.test.ts ===
// b_path:: src/generate/layout/z-index.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./z-index";

describe("z-index generator", () => {
	test("should generate positive integer", () => {
		const result = generate({ kind: "z-index", value: 10 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("10");
	});

	test("should generate zero", () => {
		const result = generate({ kind: "z-index", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0");
	});

	test("should generate negative integer", () => {
		const result = generate({ kind: "z-index", value: -5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("-5");
	});

	test("should generate 'auto'", () => {
		const result = generate({ kind: "z-index", value: "auto" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});
});


=== File: src/generate/layout/z-index.ts ===
// b_path:: src/generate/layout/z-index.ts
import { type GenerateResult, generateOk } from "@/core/result";
import type { ZIndex } from "@/core/types";

/**
 * Generate CSS z-index property from IR.
 *
 * Outputs integer value or "auto" keyword.
 *
 * @param zIndex - ZIndex IR
 * @returns GenerateResult containing CSS string like "10", "-5", or "auto"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/z-index}
 *
 * @example
 * ```typescript
 * import { generate } from "@/generate/layout/z-index";
 *
 * const result = generate({ kind: "z-index", value: 10 });
 * // { ok: true, value: "10", issues: [] }
 * ```
 *
 * @example
 * ```typescript
 * const result = generate({ kind: "z-index", value: "auto" });
 * // { ok: true, value: "auto", issues: [] }
 * ```
 *
 * @public
 */
export function generate(zIndex: ZIndex): GenerateResult {
	return generateOk(String(zIndex.value));
}


=== File: src/generate/outline/color.test.ts ===
// b_path:: src/generate/outline/color.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./color.js";

describe("generate/outline/color", () => {
	it("generates hex color", () => {
		const result = generate({ kind: "outline-color", color: "#ff0000" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("#ff0000");
	});

	it("generates named color", () => {
		const result = generate({ kind: "outline-color", color: "blue" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("blue");
	});

	it("generates rgb", () => {
		const result = generate({ kind: "outline-color", color: "rgb(255, 0, 0)" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("rgb(255, 0, 0)");
	});

	it("generates rgba", () => {
		const result = generate({ kind: "outline-color", color: "rgba(255, 0, 0, 0.5)" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("rgba(255, 0, 0, 0.5)");
	});
});


=== File: src/generate/outline/color.ts ===
// b_path:: src/generate/outline/color.ts
import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS outline-color property value from IR.
 *
 * Converts OutlineColorValue IR to CSS string representation.
 *
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param ir - OutlineColorValue IR object
 * @returns GenerateResult containing CSS outline-color value string
 *
 * @example
 * ```typescript
 * const result = generate({ kind: "outline-color", color: "red" });
 * // { ok: true, value: "red", issues: [] }
 * ```
 *
 * @example
 * Invert (outline-specific):
 * ```typescript
 * const result = generate({ kind: "outline-color", color: "invert" });
 * // { ok: true, value: "invert", issues: [] }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color | MDN: outline-color}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-color | W3C Spec}
 */
export function generate(ir: Type.OutlineColorValue): GenerateResult {
	return generateOk(ir.color);
}


=== File: src/generate/outline/index.ts ===
// b_path:: src/generate/outline/index.ts

export * as Color from "./color";
export * as Offset from "./offset";
export * as Outline from "./outline";
export { generate } from "./outline";
export * as Style from "./style";
export * as Width from "./width";


=== File: src/generate/outline/offset.test.ts ===
// b_path:: src/generate/outline/offset.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./offset.js";

describe("generate/outline/offset", () => {
	it("generates pixel value", () => {
		const result = generate({ kind: "outline-offset", offset: { value: 4, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("4px");
	});

	it("generates rem value", () => {
		const result = generate({ kind: "outline-offset", offset: { value: 0.5, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0.5rem");
	});

	it("generates negative value", () => {
		const result = generate({ kind: "outline-offset", offset: { value: -2, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("-2px");
	});

	it("generates zero", () => {
		const result = generate({ kind: "outline-offset", offset: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0px");
	});
});


=== File: src/generate/outline/offset.ts ===
// b_path:: src/generate/outline/offset.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS outline-offset property value from IR.
 *
 * Converts OutlineOffsetValue IR to CSS string representation.
 *
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param ir - OutlineOffsetValue IR object
 * @returns CSS outline-offset value string
 *
 * @example
 * Positive offset:
 * ```typescript
 * const css = toCss({ kind: "outline-offset", offset: { value: 5, unit: "px" } });
 * // "5px"
 * ```
 *
 * @example
 * Negative offset:
 * ```typescript
 * const css = toCss({ kind: "outline-offset", offset: { value: -2, unit: "px" } });
 * // "-2px"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset | MDN: outline-offset}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-offset | W3C Spec}
 */
export function generate(ir: Type.OutlineOffsetValue): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(`${ir.offset.value}${ir.offset.unit}`);
}


=== File: src/generate/outline/outline.test.ts ===
// b_path:: src/generate/outline/outline.test.ts

import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types/outline";
import { generate } from "./outline";

describe("Generate.Outline.generate", () => {
	describe("outline-width", () => {
		it("generates outline-width with length", () => {
			const ir: Type.OutlineWidthValue = {
				kind: "outline-width",
				width: { value: 2, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("2px");
			expect(result.issues).toEqual([]);
		});

		it("generates outline-width with keyword", () => {
			const ir: Type.OutlineWidthValue = {
				kind: "outline-width",
				width: "medium",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("medium");
		});

		it("generates outline-width with thin", () => {
			const ir: Type.OutlineWidthValue = {
				kind: "outline-width",
				width: "thin",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("thin");
		});

		it("generates outline-width with thick", () => {
			const ir: Type.OutlineWidthValue = {
				kind: "outline-width",
				width: "thick",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("thick");
		});
	});

	describe("outline-style", () => {
		it("generates outline-style solid", () => {
			const ir: Type.OutlineStyleValue = {
				kind: "outline-style",
				style: "solid",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("solid");
			expect(result.issues).toEqual([]);
		});

		it("generates outline-style dashed", () => {
			const ir: Type.OutlineStyleValue = {
				kind: "outline-style",
				style: "dashed",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("dashed");
		});

		it("generates outline-style auto", () => {
			const ir: Type.OutlineStyleValue = {
				kind: "outline-style",
				style: "auto",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("auto");
		});

		it("generates outline-style none", () => {
			const ir: Type.OutlineStyleValue = {
				kind: "outline-style",
				style: "none",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("none");
		});
	});

	describe("outline-color", () => {
		it("generates outline-color with keyword", () => {
			const ir: Type.OutlineColorValue = {
				kind: "outline-color",
				color: "red",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("red");
			expect(result.issues).toEqual([]);
		});

		it("generates outline-color with invert", () => {
			const ir: Type.OutlineColorValue = {
				kind: "outline-color",
				color: "invert",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("invert");
		});

		it("generates outline-color with transparent", () => {
			const ir: Type.OutlineColorValue = {
				kind: "outline-color",
				color: "transparent",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("transparent");
		});

		it("generates outline-color with currentColor", () => {
			const ir: Type.OutlineColorValue = {
				kind: "outline-color",
				color: "currentColor",
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("currentColor");
		});
	});

	describe("outline-offset", () => {
		it("generates outline-offset with positive value", () => {
			const ir: Type.OutlineOffsetValue = {
				kind: "outline-offset",
				offset: { value: 4, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("4px");
			expect(result.issues).toEqual([]);
		});

		it("generates outline-offset with negative value", () => {
			const ir: Type.OutlineOffsetValue = {
				kind: "outline-offset",
				offset: { value: -2, unit: "px" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("-2px");
		});

		it("generates outline-offset with em units", () => {
			const ir: Type.OutlineOffsetValue = {
				kind: "outline-offset",
				offset: { value: 0.5, unit: "em" },
			};

			const result = generate(ir);

			expect(result.ok).toBe(true);
			expect(result.value).toBe("0.5em");
		});
	});

	describe("error handling", () => {
		it("returns error for null IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(null as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Invalid outline IR: missing 'kind' field");
		});

		it("returns error for undefined IR", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate(undefined as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
		});

		it("returns error for IR without kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({} as any);

			expect(result.ok).toBe(false);
			expect(result.issues[0]?.message).toContain("missing 'kind' field");
		});

		it("returns error for unknown kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const result = generate({ kind: "unknown" } as any);

			expect(result.ok).toBe(false);
			expect(result.issues).toHaveLength(1);
			expect(result.issues[0]?.severity).toBe("error");
			expect(result.issues[0]?.message).toBe("Unknown outline kind: unknown");
			expect(result.issues[0]?.suggestion).toContain("outline-width");
			expect(result.issues[0]?.suggestion).toContain("outline-style");
			expect(result.issues[0]?.suggestion).toContain("outline-color");
			expect(result.issues[0]?.suggestion).toContain("outline-offset");
		});
	});
});


=== File: src/generate/outline/outline.ts ===
// b_path:: src/generate/outline/outline.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types/outline";
import * as Color from "./color";
import * as Offset from "./offset";
import * as Style from "./style";
import * as Width from "./width";

/**
 * Generate CSS from outline property IR with auto-detection.
 *
 * Automatically detects outline property type from IR.kind and generates appropriate CSS.
 * Supports outline-width, outline-style, outline-color, and outline-offset.
 *
 * @param outline - Outline property IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Outline width:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Outline.generate({
 *   kind: "outline-width",
 *   width: { value: 2, unit: "px" }
 * });
 * // → { ok: true, value: "2px", issues: [] }
 * ```
 *
 * @example
 * Outline style:
 * ```typescript
 * const result = Generate.Outline.generate({
 *   kind: "outline-style",
 *   style: "dashed"
 * });
 * // → { ok: true, value: "dashed", issues: [] }
 * ```
 *
 * @example
 * Outline color:
 * ```typescript
 * const result = Generate.Outline.generate({
 *   kind: "outline-color",
 *   color: "red"
 * });
 * // → { ok: true, value: "red", issues: [] }
 * ```
 *
 * @example
 * Outline offset:
 * ```typescript
 * const result = Generate.Outline.generate({
 *   kind: "outline-offset",
 *   offset: { value: 4, unit: "px" }
 * });
 * // → { ok: true, value: "4px", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Outline.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid outline IR: missing 'kind' field" }] }
 *
 * const result2 = Generate.Outline.generate({ kind: "unknown" });
 * // → { ok: false, issues: [{ severity: "error", message: "Unknown outline kind: unknown" }] }
 * ```
 *
 * @public
 */
export function generate(
	outline: Type.OutlineWidthValue | Type.OutlineStyleValue | Type.OutlineColorValue | Type.OutlineOffsetValue,
): GenerateResult {
	// Validate IR has 'kind' field
	if (!outline || typeof outline !== "object" || !("kind" in outline)) {
		return generateErr("missing-required-field", "Invalid outline IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (outline.kind) {
		case "outline-width":
			return Width.generate(outline);

		case "outline-style":
			return Style.generate(outline);

		case "outline-color":
			return Color.generate(outline);

		case "outline-offset":
			return Offset.generate(outline);

		default:
			return generateErr("unsupported-kind", `Unknown outline kind: ${(outline as { kind?: string }).kind}`, {
				suggestion:
					"Expected 'outline-width', 'outline-style', 'outline-color', or 'outline-offset'. Check that outline IR is valid.",
			});
	}
}


=== File: src/generate/outline/style.test.ts ===
// b_path:: src/generate/outline/style.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./style.js";

describe("generate/outline/style", () => {
	it("generates none", () => {
		const result = generate({ kind: "outline-style", style: "none" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("none");
	});

	it("generates solid", () => {
		const result = generate({ kind: "outline-style", style: "solid" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("solid");
	});

	it("generates dashed", () => {
		const result = generate({ kind: "outline-style", style: "dashed" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("dashed");
	});

	it("generates dotted", () => {
		const result = generate({ kind: "outline-style", style: "dotted" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("dotted");
	});

	it("generates double", () => {
		const result = generate({ kind: "outline-style", style: "double" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("double");
	});
});


=== File: src/generate/outline/style.ts ===
// b_path:: src/generate/outline/style.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS outline-style property value from IR.
 *
 * Converts OutlineStyleValue IR to CSS string representation.
 *
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param ir - OutlineStyleValue IR object
 * @returns CSS outline-style value string
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "outline-style", style: "solid" });
 * // "solid"
 * ```
 *
 * @example
 * Auto (outline-specific):
 * ```typescript
 * const css = toCss({ kind: "outline-style", style: "auto" });
 * // "auto"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style | MDN: outline-style}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-style | W3C Spec}
 */
export function generate(ir: Type.OutlineStyleValue): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(ir.style);
}


=== File: src/generate/outline/width.test.ts ===
// b_path:: src/generate/outline/width.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./width.js";

describe("generate/outline/width", () => {
	it("generates pixel value", () => {
		const result = generate({ kind: "outline-width", width: { value: 2, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("2px");
	});

	it("generates thin", () => {
		const result = generate({ kind: "outline-width", width: "thin" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("thin");
	});

	it("generates medium", () => {
		const result = generate({ kind: "outline-width", width: "medium" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("medium");
	});

	it("generates thick", () => {
		const result = generate({ kind: "outline-width", width: "thick" });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("thick");
	});

	it("generates zero", () => {
		const result = generate({ kind: "outline-width", width: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (!result.ok) return;
		expect(result.value).toBe("0px");
	});
});


=== File: src/generate/outline/width.ts ===
// b_path:: src/generate/outline/width.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS outline-width property value from IR.
 *
 * Converts OutlineWidthValue IR to CSS string representation.
 *
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param ir - OutlineWidthValue IR object
 * @returns CSS outline-width value string
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({ kind: "outline-width", width: "medium" });
 * // "medium"
 * ```
 *
 * @example
 * Length:
 * ```typescript
 * const css = toCss({ kind: "outline-width", width: { value: 1, unit: "px" } });
 * // "1px"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-width | MDN: outline-width}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-width | W3C Spec}
 */
export function generate(ir: Type.OutlineWidthValue): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof ir.width === "string") {
		return generateOk(ir.width);
	}
	return generateOk(`${ir.width.value}${ir.width.unit}`);
}


=== File: src/generate/position/index.ts ===
// b_path:: src/generate/position/index.ts

export * as Position from "./position";
export * as Utils from "./utils";


=== File: src/generate/position/position.test.ts ===
// b_path:: src/generate/position/position.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./position";

describe("generate position", () => {
	it("generates center center", () => {
		const result = generate({ horizontal: "center", vertical: "center" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("center center");
		}
	});

	it("generates left top", () => {
		const result = generate({ horizontal: "left", vertical: "top" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("left top");
		}
	});

	it("generates right bottom", () => {
		const result = generate({ horizontal: "right", vertical: "bottom" });
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("right bottom");
		}
	});

	it("generates with percentage", () => {
		const result = generate({
			horizontal: { value: 50, unit: "%" },
			vertical: { value: 50, unit: "%" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("50% 50%");
		}
	});

	it("generates with length", () => {
		const result = generate({
			horizontal: { value: 10, unit: "px" },
			vertical: { value: 20, unit: "px" },
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("10px 20px");
		}
	});

	it("rejects null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});

	it("rejects undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});

	it("rejects non-object", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate("not-an-object" as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/position/position.ts ===
// b_path:: src/generate/position/position.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Utils from "./utils";

/**
 * Generate CSS from Position2D IR.
 *
 * Wraps the existing position generator with GenerateResult for consistent API.
 *
 * @param position - Position2D IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate({ horizontal: "center", vertical: "center" })
 * // → { ok: true, value: "center center", issues: [] }
 * ```
 *
 * @public
 */
export function generate(position: Type.Position2D): GenerateResult {
	if (!position || typeof position !== "object") {
		return generateErr("invalid-ir", "Invalid position IR", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	try {
		const css = Utils.generate(position);
		if (!css.ok) return css;
		return generateOk(css.value);
	} catch (error) {
		return generateErr("invalid-ir", `Failed to generate position: ${error}`, {
			suggestion: "Check that position IR is valid",
		});
	}
}


=== File: src/generate/position/utils.ts ===
// b_path:: src/generate/position/utils.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import * as Type from "@/core/types";
import { positionValueToCss } from "@/utils/generate/values";

/**
 * Generate CSS 2D position string from Position2D IR.
 *
 * Converts a Position2D IR object into a valid CSS position string.
 * Handles both keyword and length/percentage values.
 *
 * @param ir - Position2D IR object to convert to CSS
 * @returns CSS position string
 *
 * @public
 *
 * @example
 * Keyword position:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Position.generate({
 *   horizontal: "center",
 *   vertical: "center"
 * });
 * console.log(css); // "center center"
 * ```
 *
 * @example
 * Mixed position:
 * ```typescript
 * const css = Generate.Position.generate({
 *   horizontal: "left",
 *   vertical: { value: 50, unit: "%" }
 * });
 * console.log(css); // "left 50%"
 * ```
 *
 * @example
 * Length/percentage position:
 * ```typescript
 * const css = Generate.Position.generate({
 *   horizontal: { value: 100, unit: "px" },
 *   vertical: { value: 50, unit: "%" }
 * });
 * console.log(css); // "100px 50%"
 * ```
 */
export function generate(ir: Type.Position2D): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const h = positionValueToCss(ir.horizontal);
	const v = positionValueToCss(ir.vertical);
	return generateOk(`${h} ${v}`);
}

/**
 * Generate CSS 3D position string from Position3D IR.
 *
 * @param ir - Position3D IR object to convert to CSS
 * @returns CSS 3D position string
 *
 * @public
 */
export function to3DCss(ir: Type.Position3D): GenerateResult {
	const x = positionValueToCss(ir.x);
	const y = positionValueToCss(ir.y);
	const z = `${ir.z.value}${ir.z.unit}`;
	return generateOk(`${x} ${y} ${z}`);
}

/**
 * Generate CSS position list string from PositionList IR.
 *
 * @param ir - PositionList IR object to convert to CSS
 * @returns CSS position list string
 *
 * @public
 */
export function toListCss(ir: Type.PositionList): GenerateResult {
	const positionResults = ir.map(generate);
	const positionStrings = positionResults.map((result) => {
		if (!result.ok) return "";
		return result.value;
	});
	return generateOk(positionStrings.join(", "));
}

/**
 * Generate CSS position string from common position preset.
 *
 * @param preset - Common position preset name
 * @returns CSS position string
 *
 * @public
 */
export function fromCommonPosition(preset: keyof Type.CommonPositions): GenerateResult {
	const position = Type.COMMON_POSITIONS[preset];
	return generate(position);
}


=== File: src/generate/shadow/box-shadow.test.ts ===
// b_path:: src/generate/shadow/box-shadow.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./box-shadow";

describe("generateBoxShadow", () => {
	it("generates basic shadow with offsets only", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("2px 2px");
		}
	});

	it("generates shadow with blur radius", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("2px 2px 4px");
		}
	});

	it("generates shadow with blur and spread", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
					spreadRadius: { value: 2, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("2px 2px 4px 2px");
		}
	});

	it("generates shadow with color", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					color: { kind: "named", name: "black" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("2px 2px black");
		}
	});

	it("generates inset shadow", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					inset: true,
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
					blurRadius: { value: 10, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset 0px 0px 10px");
		}
	});

	it("generates complete shadow with all properties", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					inset: true,
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
					spreadRadius: { value: 1, unit: "px" },
					color: { kind: "hex", value: "#000000" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("inset 2px 2px 4px 1px #000000");
		}
	});

	it("generates multiple shadows", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					color: { kind: "named", name: "black" },
				},
				{
					inset: true,
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
					blurRadius: { value: 10, unit: "px" },
					color: { kind: "named", name: "white" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("2px 2px black, inset 0px 0px 10px white");
		}
	});

	it("preserves different length units", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "em" },
					offsetY: { value: 1, unit: "rem" },
					blurRadius: { value: 2, unit: "vh" },
					spreadRadius: { value: 0.5, unit: "vw" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("1em 1rem 2vh 0.5vw");
		}
	});

	it("handles negative offsets", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: -2, unit: "px" },
					offsetY: { value: -2, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("-2px -2px");
		}
	});

	it("handles zero values", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
					blurRadius: { value: 0, unit: "px" },
					spreadRadius: { value: 0, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("0px 0px 0px 0px");
		}
	});

	it("generates shadow with rgba color", () => {
		const result = generate({
			kind: "box-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
					color: { kind: "rgb", r: 0, g: 0, b: 0, alpha: 0.5 },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("2px 2px 4px rgb(0 0 0 / 0.5)");
		}
	});

	it("rejects null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues[0]?.code).toBe("invalid-ir");
		}
	});

	it("rejects undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues[0]?.code).toBe("invalid-ir");
		}
	});
});


=== File: src/generate/shadow/box-shadow.ts ===
// b_path:: src/generate/shadow/box-shadow.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { BoxShadow } from "@/core/types/shadow";
import { generateColor } from "@/utils/generate/color";

/**
 * Generate CSS box-shadow property value from IR.
 *
 * Outputs box-shadow with required offsets and optional inset, blur, spread, and color.
 * Preserves the original units from the IR.
 * Supports multiple comma-separated shadow layers.
 *
 * @param shadow - BoxShadow IR
 * @returns CSS string like "2px 2px" or "inset 0 0 10px 2px rgba(0,0,0,0.5), 2px 2px 4px black"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/shadow/box-shadow";
 *
 * // Basic shadow
 * const css1 = toCss({
 *   kind: "box-shadow",
 *   shadows: [{
 *     offsetX: { value: 2, unit: "px" },
 *     offsetY: { value: 2, unit: "px" }
 *   }]
 * });
 * // "2px 2px"
 *
 * // With blur and spread
 * const css2 = toCss({
 *   kind: "box-shadow",
 *   shadows: [{
 *     offsetX: { value: 2, unit: "px" },
 *     offsetY: { value: 2, unit: "px" },
 *     blurRadius: { value: 4, unit: "px" },
 *     spreadRadius: { value: 2, unit: "px" }
 *   }]
 * });
 * // "2px 2px 4px 2px"
 *
 * // Inset shadow with color
 * const css3 = toCss({
 *   kind: "box-shadow",
 *   shadows: [{
 *     inset: true,
 *     offsetX: { value: 0, unit: "px" },
 *     offsetY: { value: 0, unit: "px" },
 *     blurRadius: { value: 10, unit: "px" },
 *     color: { kind: "named", name: "black" }
 *   }]
 * });
 * // "inset 0px 0px 10px black"
 *
 * // Multiple shadows
 * const css4 = toCss({
 *   kind: "box-shadow",
 *   shadows: [
 *     {
 *       offsetX: { value: 2, unit: "px" },
 *       offsetY: { value: 2, unit: "px" },
 *       color: { kind: "named", name: "black" }
 *     },
 *     {
 *       inset: true,
 *       offsetX: { value: 0, unit: "px" },
 *       offsetY: { value: 0, unit: "px" },
 *       blurRadius: { value: 10, unit: "px" },
 *       color: { kind: "named", name: "white" }
 *     }
 *   ]
 * });
 * // "2px 2px black, inset 0px 0px 10px white"
 * ```
 *
 * @public
 */
export function generate(shadow: BoxShadow): GenerateResult {
	if (shadow === undefined || shadow === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const layers = shadow.shadows.map((layer) => {
		const { inset, offsetX, offsetY, blurRadius, spreadRadius, color } = layer;

		const parts: string[] = [];

		// Add inset keyword if present
		if (inset) {
			parts.push("inset");
		}

		// Add required offset values
		parts.push(`${offsetX.value}${offsetX.unit}`);
		parts.push(`${offsetY.value}${offsetY.unit}`);

		// Add optional blur radius
		if (blurRadius !== undefined) {
			parts.push(`${blurRadius.value}${blurRadius.unit}`);
		}

		// Add optional spread radius
		if (spreadRadius !== undefined) {
			parts.push(`${spreadRadius.value}${spreadRadius.unit}`);
		}

		// Add optional color
		if (color !== undefined) {
			parts.push(generateColor(color));
		}

		return parts.join(" ");
	});

	return generateOk(layers.join(", "));
}


=== File: src/generate/shadow/index.ts ===
// b_path:: src/generate/shadow/index.ts
export * as BoxShadow from "./box-shadow";
export { generate } from "./shadow";
export * as TextShadow from "./text-shadow";


=== File: src/generate/shadow/shadow.test.ts ===
// b_path:: src/generate/shadow/shadow.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./shadow";

describe("generateShadow (dispatcher)", () => {
	describe("box-shadow", () => {
		it("dispatches box-shadow to BoxShadow.generate", () => {
			const result = generate({
				kind: "box-shadow",
				shadows: [
					{
						offsetX: { value: 2, unit: "px" },
						offsetY: { value: 2, unit: "px" },
						blurRadius: { value: 4, unit: "px" },
						color: { kind: "named", name: "black" },
					},
				],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("2px 2px 4px black");
			}
		});

		it("handles inset box-shadow", () => {
			const result = generate({
				kind: "box-shadow",
				shadows: [
					{
						inset: true,
						offsetX: { value: 0, unit: "px" },
						offsetY: { value: 0, unit: "px" },
						blurRadius: { value: 10, unit: "px" },
						color: { kind: "named", name: "white" },
					},
				],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("inset 0px 0px 10px white");
			}
		});

		it("handles multiple box-shadows", () => {
			const result = generate({
				kind: "box-shadow",
				shadows: [
					{
						offsetX: { value: 2, unit: "px" },
						offsetY: { value: 2, unit: "px" },
						color: { kind: "named", name: "black" },
					},
					{
						inset: true,
						offsetX: { value: 0, unit: "px" },
						offsetY: { value: 0, unit: "px" },
						blurRadius: { value: 10, unit: "px" },
						color: { kind: "named", name: "white" },
					},
				],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("2px 2px black, inset 0px 0px 10px white");
			}
		});
	});

	describe("text-shadow", () => {
		it("dispatches text-shadow to TextShadow.generate", () => {
			const result = generate({
				kind: "text-shadow",
				shadows: [
					{
						offsetX: { value: 1, unit: "px" },
						offsetY: { value: 1, unit: "px" },
						blurRadius: { value: 2, unit: "px" },
						color: { kind: "named", name: "gray" },
					},
				],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("1px 1px 2px gray");
			}
		});

		it("handles multiple text-shadows", () => {
			const result = generate({
				kind: "text-shadow",
				shadows: [
					{
						offsetX: { value: 1, unit: "px" },
						offsetY: { value: 1, unit: "px" },
						color: { kind: "named", name: "black" },
					},
					{
						offsetX: { value: -1, unit: "px" },
						offsetY: { value: -1, unit: "px" },
						color: { kind: "named", name: "white" },
					},
				],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("1px 1px black, -1px -1px white");
			}
		});
	});

	describe("error handling", () => {
		it("rejects null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			const result = generate(null as any);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.code).toBe("missing-required-field");
				expect(result.issues[0]?.message).toContain("missing 'kind' field");
			}
		});

		it("rejects undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			const result = generate(undefined as any);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.code).toBe("missing-required-field");
			}
		});

		it("rejects object without kind field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			const result = generate({} as any);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.code).toBe("missing-required-field");
			}
		});

		it("rejects unknown shadow kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			const result = generate({ kind: "unknown-shadow" } as any);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.code).toBe("unsupported-kind");
				expect(result.issues[0]?.message).toContain("unknown-shadow");
			}
		});
	});
});


=== File: src/generate/shadow/shadow.ts ===
// b_path:: src/generate/shadow/shadow.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types/shadow";
import * as BoxShadow from "./box-shadow";
import * as TextShadow from "./text-shadow";

/**
 * Generate CSS from shadow IR with auto-detection.
 *
 * Automatically detects shadow type from IR.kind and generates appropriate CSS.
 * Supports both box-shadow and text-shadow formats.
 *
 * @param shadow - Shadow IR (BoxShadow or TextShadow)
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Box shadow:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Shadow.generate({
 *   kind: "box-shadow",
 *   shadows: [{
 *     offsetX: { value: 2, unit: "px" },
 *     offsetY: { value: 2, unit: "px" },
 *     blurRadius: { value: 4, unit: "px" },
 *     color: { kind: "named", name: "black" }
 *   }]
 * });
 * // → { ok: true, value: "2px 2px 4px black", issues: [] }
 * ```
 *
 * @example
 * Text shadow:
 * ```typescript
 * const result = Generate.Shadow.generate({
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" },
 *     blurRadius: { value: 2, unit: "px" },
 *     color: { kind: "named", name: "gray" }
 *   }]
 * });
 * // → { ok: true, value: "1px 1px 2px gray", issues: [] }
 * ```
 *
 * @example
 * Multiple shadows:
 * ```typescript
 * const result = Generate.Shadow.generate({
 *   kind: "box-shadow",
 *   shadows: [
 *     {
 *       offsetX: { value: 2, unit: "px" },
 *       offsetY: { value: 2, unit: "px" },
 *       color: { kind: "named", name: "black" }
 *     },
 *     {
 *       inset: true,
 *       offsetX: { value: 0, unit: "px" },
 *       offsetY: { value: 0, unit: "px" },
 *       blurRadius: { value: 10, unit: "px" },
 *       color: { kind: "named", name: "white" }
 *     }
 *   ]
 * });
 * // → { ok: true, value: "2px 2px black, inset 0px 0px 10px white", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Shadow.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid shadow IR: missing 'kind' field" }] }
 *
 * const result2 = Generate.Shadow.generate({ kind: "unknown" });
 * // → { ok: false, issues: [{ severity: "error", message: "Unknown shadow kind: unknown" }] }
 * ```
 *
 * @public
 */
export function generate(shadow: Type.BoxShadow | Type.TextShadow): GenerateResult {
	// Validate IR has 'kind' field
	if (!shadow || typeof shadow !== "object" || !("kind" in shadow)) {
		return generateErr("missing-required-field", "Invalid shadow IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (shadow.kind) {
		case "box-shadow":
			return BoxShadow.generate(shadow);

		case "text-shadow":
			return TextShadow.generate(shadow);

		default:
			return generateErr("unsupported-kind", `Unknown shadow kind: ${(shadow as { kind?: string }).kind}`, {
				suggestion: "Expected 'box-shadow' or 'text-shadow'. Check that shadow IR is valid.",
			});
	}
}


=== File: src/generate/shadow/text-shadow.test.ts ===
// b_path:: src/generate/shadow/text-shadow.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./text-shadow";

describe("generateTextShadow", () => {
	it("generates basic shadow with offsets only", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("1px 1px");
		}
	});

	it("generates shadow with blur radius", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					blurRadius: { value: 2, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("1px 1px 2px");
		}
	});

	it("generates shadow with color", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					color: { kind: "named", name: "gray" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("1px 1px gray");
		}
	});

	it("generates complete shadow with all properties", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					blurRadius: { value: 2, unit: "px" },
					color: { kind: "named", name: "black" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("1px 1px 2px black");
		}
	});

	it("generates multiple shadows", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					blurRadius: { value: 2, unit: "px" },
					color: { kind: "named", name: "black" },
				},
				{
					offsetX: { value: -1, unit: "px" },
					offsetY: { value: -1, unit: "px" },
					blurRadius: { value: 2, unit: "px" },
					color: { kind: "named", name: "white" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("1px 1px 2px black, -1px -1px 2px white");
		}
	});

	it("preserves different length units", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 0.5, unit: "em" },
					offsetY: { value: 0.5, unit: "rem" },
					blurRadius: { value: 1, unit: "vh" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("0.5em 0.5rem 1vh");
		}
	});

	it("handles negative offsets", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: -1, unit: "px" },
					offsetY: { value: -1, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("-1px -1px");
		}
	});

	it("handles zero values", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
					blurRadius: { value: 0, unit: "px" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("0px 0px 0px");
		}
	});

	it("generates shadow with hex color", () => {
		const result = generate({
			kind: "text-shadow",
			shadows: [
				{
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					color: { kind: "hex", value: "#333333" },
				},
			],
		});
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("2px 2px #333333");
		}
	});

	it("rejects null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
		const result = generate(null as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues[0]?.code).toBe("invalid-ir");
		}
	});

	it("rejects undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues[0]?.code).toBe("invalid-ir");
		}
	});
});


=== File: src/generate/shadow/text-shadow.ts ===
// b_path:: src/generate/shadow/text-shadow.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { TextShadow } from "@/core/types/shadow";
import { generateColor } from "@/utils/generate/color";

/**
 * Generate CSS text-shadow property value from IR.
 *
 * Outputs text-shadow with required offsets and optional blur and color.
 * Preserves the original units from the IR.
 * Supports multiple comma-separated shadow layers.
 *
 * @param shadow - TextShadow IR
 * @returns CSS string like "1px 1px" or "1px 1px 2px gray, -1px -1px 2px white"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/shadow/text-shadow";
 *
 * // Basic shadow
 * const css1 = toCss({
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" }
 *   }]
 * });
 * // "1px 1px"
 *
 * // With blur radius
 * const css2 = toCss({
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" },
 *     blurRadius: { value: 2, unit: "px" }
 *   }]
 * });
 * // "1px 1px 2px"
 *
 * // With color
 * const css3 = toCss({
 *   kind: "text-shadow",
 *   shadows: [{
 *     offsetX: { value: 1, unit: "px" },
 *     offsetY: { value: 1, unit: "px" },
 *     blurRadius: { value: 2, unit: "px" },
 *     color: { kind: "named", name: "gray" }
 *   }]
 * });
 * // "1px 1px 2px gray"
 *
 * // Multiple shadows
 * const css4 = toCss({
 *   kind: "text-shadow",
 *   shadows: [
 *     {
 *       offsetX: { value: 1, unit: "px" },
 *       offsetY: { value: 1, unit: "px" },
 *       blurRadius: { value: 2, unit: "px" },
 *       color: { kind: "named", name: "black" }
 *     },
 *     {
 *       offsetX: { value: -1, unit: "px" },
 *       offsetY: { value: -1, unit: "px" },
 *       blurRadius: { value: 2, unit: "px" },
 *       color: { kind: "named", name: "white" }
 *     }
 *   ]
 * });
 * // "1px 1px 2px black, -1px -1px 2px white"
 * ```
 *
 * @public
 */
export function generate(shadow: TextShadow): GenerateResult {
	if (shadow === undefined || shadow === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const layers = shadow.shadows.map((layer) => {
		const { offsetX, offsetY, blurRadius, color } = layer;

		const parts: string[] = [];

		// Add required offset values
		parts.push(`${offsetX.value}${offsetX.unit}`);
		parts.push(`${offsetY.value}${offsetY.unit}`);

		// Add optional blur radius
		if (blurRadius !== undefined) {
			parts.push(`${blurRadius.value}${blurRadius.unit}`);
		}

		// Add optional color
		if (color !== undefined) {
			parts.push(generateColor(color));
		}

		return parts.join(" ");
	});

	return generateOk(layers.join(", "));
}


=== File: src/generate/text/color.test.ts ===
// b_path:: src/generate/text/color.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./color";

describe("text-decoration-color generator", () => {
	test("should generate RGB color", () => {
		const result = generate({ kind: "rgb", r: 255, g: 0, b: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("rgb(255 0 0)");
	});

	test("should generate hex color", () => {
		const result = generate({ kind: "hex", value: "#ff0000" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("#ff0000");
	});

	test("should generate named color", () => {
		const result = generate({ kind: "named", name: "red" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("red");
	});

	test("should generate currentColor", () => {
		const result = generate({ kind: "special", keyword: "currentcolor" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("currentcolor");
	});

	test("should error on null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	test("should error on undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/text/color.ts ===
// b_path:: src/generate/text/color.ts
import type { GenerateResult } from "@/core/result";
import { generateErr } from "@/core/result";
import type { Color } from "@/core/types/color";
import * as ColorGenerators from "../color";

/**
 * Generate CSS text-decoration-color string from Color IR.
 *
 * @param color - Color IR object
 * @returns CSS text-decoration-color string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Text.Color.generate({ kind: "named", name: "red" });
 * if (result.ok) console.log(result.value); // "red"
 * ```
 */
export function generate(color: Color): GenerateResult {
	if (color === undefined || color === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	switch (color.kind) {
		case "hex":
			return ColorGenerators.Hex.generate(color);
		case "named":
			return ColorGenerators.Named.generate(color);
		case "rgb":
			return ColorGenerators.Rgb.generate(color);
		case "hsl":
			return ColorGenerators.Hsl.generate(color);
		case "hwb":
			return ColorGenerators.Hwb.generate(color);
		case "lab":
			return ColorGenerators.Lab.generate(color);
		case "lch":
			return ColorGenerators.Lch.generate(color);
		case "oklab":
			return ColorGenerators.Oklab.generate(color);
		case "oklch":
			return ColorGenerators.Oklch.generate(color);
		case "system":
			return ColorGenerators.System.generate(color);
		case "special":
			return ColorGenerators.Special.generate(color);
		case "color":
			return ColorGenerators.ColorFunction.generate(color);
	}
}


=== File: src/generate/text/index.ts ===
// b_path:: src/generate/text/index.ts
export * as Color from "./color";
export * as Line from "./line";
export * as Style from "./style";
export * as Thickness from "./thickness";


=== File: src/generate/text/line.test.ts ===
// b_path:: src/generate/text/line.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./line";

describe("text-decoration-line generator", () => {
	test("should generate 'none'", () => {
		const result = generate("none");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("none");
	});

	test("should generate 'underline'", () => {
		const result = generate("underline");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("underline");
	});

	test("should generate 'overline'", () => {
		const result = generate("overline");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("overline");
	});

	test("should generate 'line-through'", () => {
		const result = generate("line-through");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("line-through");
	});

	test("should error on null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	test("should error on undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});

	test("should error on non-string", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(123 as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/text/line.ts ===
// b_path:: src/generate/text/line.ts
import type * as Keyword from "@/core/keywords";
import { type GenerateResult, generateErr, generateOk } from "@/core/result";

/**
 * Generate CSS text-decoration-line string from keyword.
 *
 * @param keyword - TextDecorationLineKeyword value
 * @returns CSS text-decoration-line string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Text.Line.generate("underline");
 * console.log(css); // "underline"
 * ```
 */
export function generate(keyword: Keyword.TextDecorationLineKeyword): GenerateResult {
	if (keyword === undefined || keyword === null) {
		return generateErr("invalid-ir", "Keyword.TextDecorationLineKeyword must not be null or undefined");
	}
	if (typeof keyword !== "string") {
		return generateErr("invalid-ir", `Expected string, got ${typeof keyword}`);
	}
	return generateOk(keyword);
}


=== File: src/generate/text/style.test.ts ===
// b_path:: src/generate/text/style.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./style";

describe("text-decoration-style generator", () => {
	test("should generate 'solid'", () => {
		const result = generate("solid");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("solid");
	});

	test("should generate 'double'", () => {
		const result = generate("double");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("double");
	});

	test("should generate 'dotted'", () => {
		const result = generate("dotted");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("dotted");
	});

	test("should generate 'dashed'", () => {
		const result = generate("dashed");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("dashed");
	});

	test("should generate 'wavy'", () => {
		const result = generate("wavy");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("wavy");
	});

	test("should error on null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	test("should error on undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});

	test("should error on non-string", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(123 as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/text/style.ts ===
// b_path:: src/generate/text/style.ts
import type * as Keyword from "@/core/keywords";
import { type GenerateResult, generateErr, generateOk } from "@/core/result";

/**
 * Generate CSS text-decoration-style string from keyword.
 *
 * @param keyword - TextDecorationStyleKeyword value
 * @returns CSS text-decoration-style string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Text.Style.generate("wavy");
 * console.log(css); // "wavy"
 * ```
 */
export function generate(keyword: Keyword.TextDecorationStyleKeyword): GenerateResult {
	if (keyword === undefined || keyword === null) {
		return generateErr("invalid-ir", "Keyword.TextDecorationStyleKeyword must not be null or undefined");
	}
	if (typeof keyword !== "string") {
		return generateErr("invalid-ir", `Expected string, got ${typeof keyword}`);
	}
	return generateOk(keyword);
}


=== File: src/generate/text/thickness.test.ts ===
// b_path:: src/generate/text/thickness.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./thickness";

describe("text-decoration-thickness generator", () => {
	test("should generate 'auto'", () => {
		const result = generate("auto");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("auto");
	});

	test("should generate 'from-font'", () => {
		const result = generate("from-font");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("from-font");
	});

	test("should generate length value", () => {
		const result = generate({ value: 2, unit: "px" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("2px");
	});

	test("should generate percentage value", () => {
		const result = generate({ value: 10, unit: "%" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("10%");
	});

	test("should error on null", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	test("should error on undefined", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/text/thickness.ts ===
// b_path:: src/generate/text/thickness.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { TextDecorationThicknessValue } from "../../parse/text/thickness";

/**
 * Generate CSS text-decoration-thickness string from value.
 *
 * @param value - TextDecorationThicknessValue (keyword or length-percentage)
 * @returns CSS text-decoration-thickness string
 *
 * @public
 *
 * @example
 * Keyword:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Text.Thickness.generate("auto");
 * console.log(css); // "auto"
 * ```
 *
 * @example
 * Length value:
 * ```typescript
 * const css = Generate.Text.Thickness.generate({ value: 2, unit: "px" });
 * console.log(css); // "2px"
 * ```
 */
export function generate(value: TextDecorationThicknessValue): GenerateResult {
	if (value === undefined || value === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof value === "string") {
		return generateOk(value);
	}
	return generateOk(`${value.value}${value.unit}`);
}


=== File: src/generate/transform/index.ts ===
// b_path:: src/generate/transform/index.ts

export * as Origin from "./origin";
export { generate } from "./transform";
export * as Utils from "./utils";


=== File: src/generate/transform/origin.ts ===
// b_path:: src/generate/transform/origin.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types";
import * as Position from "../position/utils";

/**
 * Generate CSS transform-origin string from Position2D or Position3D IR.
 *
 * Converts a Position2D or Position3D IR object into a valid CSS transform-origin string.
 * Handles both 2D (x y) and 3D (x y z) positions.
 *
 * @param ir - Position2D or Position3D IR object
 * @returns CSS transform-origin string
 *
 * @public
 *
 * @example
 * 2D keyword position:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Transform.Origin.generate({
 *   horizontal: "center",
 *   vertical: "top"
 * });
 * console.log(css); // "center top"
 * ```
 *
 * @example
 * 2D with values:
 * ```typescript
 * const css = Generate.Transform.Origin.generate({
 *   horizontal: { value: 50, unit: "%" },
 *   vertical: { value: 100, unit: "px" }
 * });
 * console.log(css); // "50% 100px"
 * ```
 *
 * @example
 * 3D position:
 * ```typescript
 * const css = Generate.Transform.Origin.generate({
 *   x: "left",
 *   y: "top",
 *   z: { value: 10, unit: "px" }
 * });
 * console.log(css); // "left top 10px"
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin | MDN: transform-origin}
 */
export function generate(ir: Type.Position2D | Type.Position3D): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	// Check if it's a 3D position (has x, y, z)
	if ("x" in ir && "y" in ir && "z" in ir) {
		return Position.to3DCss(ir);
	}

	// 2D position
	return Position.generate(ir);
}

/**
 * Generate CSS perspective-origin string from Position2D IR.
 *
 * Converts a Position2D IR object into a valid CSS perspective-origin string.
 * Only supports 2D positions.
 *
 * @param ir - Position2D IR object
 * @returns CSS perspective-origin string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Transform.PerspectiveOrigin.generate({
 *   horizontal: { value: 50, unit: "%" },
 *   vertical: { value: 50, unit: "%" }
 * });
 * console.log(css); // "50% 50%"
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/perspective-origin | MDN: perspective-origin}
 */
export function toCssPerspectiveOrigin(ir: Type.Position2D): GenerateResult {
	return Position.generate(ir);
}


=== File: src/generate/transform/transform.test.ts ===
// b_path:: src/generate/transform/transform.test.ts

import { describe, expect, it } from "vitest";
import { generate } from "./transform";

describe("generate transform", () => {
	it("generates single translateX", () => {
		const result = generate([{ kind: "translateX", x: { value: 100, unit: "px" } }]);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("translateX(100px)");
		}
	});

	it("generates single rotate", () => {
		const result = generate([{ kind: "rotate", angle: { value: 45, unit: "deg" } }]);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("rotate(45deg)");
		}
	});

	it("generates multiple transforms", () => {
		const result = generate([
			{ kind: "translateX", x: { value: 100, unit: "px" } },
			{ kind: "rotate", angle: { value: 45, unit: "deg" } },
		]);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("translateX(100px) rotate(45deg)");
		}
	});

	it("generates scale", () => {
		const result = generate([{ kind: "scale", x: 2, y: 2 }]);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toContain("scale");
		}
	});

	it("rejects empty array", () => {
		const result = generate([]);
		expect(result.ok).toBe(false);
	});

	it("rejects null input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(null as any);
		expect(result.ok).toBe(false);
	});

	it("rejects undefined input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate(undefined as any);
		expect(result.ok).toBe(false);
	});

	it("rejects non-array input", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const result = generate("not an array" as any);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/transform/transform.ts ===
// b_path:: src/generate/transform/transform.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as Utils from "./utils";

/**
 * Generate CSS from Transform IR.
 *
 * Wraps the existing transform generator with GenerateResult for consistent API.
 *
 * @param transform - Transform IR (array of transform functions)
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * ```typescript
 * generate([
 *   { kind: "translateX", x: { value: 100, unit: "px" } },
 *   { kind: "rotate", angle: { value: 45, unit: "deg" } }
 * ])
 * // → { ok: true, value: "translateX(100px) rotate(45deg)", issues: [] }
 * ```
 *
 * @public
 */
export function generate(transform: Type.Transform): GenerateResult {
	if (!transform || !Array.isArray(transform)) {
		return generateErr("invalid-ir", "Invalid transform IR: must be an array", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	if (transform.length === 0) {
		return generateErr("invalid-ir", "Transform array cannot be empty", {
			suggestion: "Provide at least one transform function",
		});
	}

	try {
		const css = Utils.generate(transform);
		if (!css.ok) return css;
		return generateOk(css.value);
	} catch (error) {
		return generateErr("invalid-ir", `Failed to generate transform: ${error}`, {
			suggestion: "Check that transform IR is valid",
		});
	}
}


=== File: src/generate/transform/utils.ts ===
// b_path:: src/generate/transform/utils.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Generate CSS length/percentage string from IR value.
 *
 * @param value - LengthPercentage IR object
 * @returns CSS length/percentage string
 *
 * @internal
 */
function lengthPercentageToCss(value: Type.LengthPercentage): string {
	return `${value.value}${value.unit}`;
}

/**
 * Generate CSS length string from IR value.
 *
 * @param value - Length IR object
 * @returns CSS length string
 *
 * @internal
 */
function lengthToCss(value: Type.Length): string {
	return `${value.value}${value.unit}`;
}

/**
 * Generate CSS angle string from IR value.
 *
 * @param value - Angle IR object
 * @returns CSS angle string
 *
 * @internal
 */
function angleToCss(value: Type.Angle): string {
	return `${value.value}${value.unit}`;
}

/**
 * Generate CSS transform function string from TransformFunction IR.
 *
 * Converts a single TransformFunction IR object into a valid CSS transform function string.
 *
 * @param ir - TransformFunction IR object to convert to CSS
 * @returns CSS transform function string
 *
 * @public
 *
 * @example
 * Translation:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Transform.toFunctionCss({
 *   kind: "translate",
 *   x: { value: 100, unit: "px" },
 *   y: { value: 50, unit: "px" }
 * });
 * console.log(css); // "translate(100px, 50px)"
 * ```
 *
 * @example
 * Rotation:
 * ```typescript
 * const css = Generate.Transform.toFunctionCss({
 *   kind: "rotate",
 *   angle: { value: 45, unit: "deg" }
 * });
 * console.log(css); // "rotate(45deg)"
 * ```
 *
 * @example
 * Scale:
 * ```typescript
 * const css = Generate.Transform.toFunctionCss({
 *   kind: "scale",
 *   x: 1.5,
 *   y: 2
 * });
 * console.log(css); // "scale(1.5, 2)"
 * ```
 */
export function toFunctionCss(ir: Type.TransformFunction): GenerateResult {
	switch (ir.kind) {
		case "translate":
			if (ir.y) {
				return generateOk(`translate(${lengthPercentageToCss(ir.x)}, ${lengthPercentageToCss(ir.y)})`);
			}
			return generateOk(`translate(${lengthPercentageToCss(ir.x)})`);

		case "translateX":
			return generateOk(`translateX(${lengthPercentageToCss(ir.x)})`);

		case "translateY":
			return generateOk(`translateY(${lengthPercentageToCss(ir.y)})`);

		case "translateZ":
			return generateOk(`translateZ(${lengthToCss(ir.z)})`);

		case "translate3d":
			return generateOk(
				`translate3d(${lengthPercentageToCss(ir.x)}, ${lengthPercentageToCss(ir.y)}, ${lengthToCss(ir.z)})`,
			);

		case "rotate":
			return generateOk(`rotate(${angleToCss(ir.angle)})`);

		case "rotateX":
			return generateOk(`rotateX(${angleToCss(ir.angle)})`);

		case "rotateY":
			return generateOk(`rotateY(${angleToCss(ir.angle)})`);

		case "rotateZ":
			return generateOk(`rotateZ(${angleToCss(ir.angle)})`);

		case "rotate3d":
			return generateOk(`rotate3d(${ir.x}, ${ir.y}, ${ir.z}, ${angleToCss(ir.angle)})`);

		case "scale":
			if (ir.y) {
				return generateOk(`scale(${ir.x}, ${ir.y})`);
			}
			return generateOk(`scale(${ir.x})`);

		case "scaleX":
			return generateOk(`scaleX(${ir.x})`);

		case "scaleY":
			return generateOk(`scaleY(${ir.y})`);

		case "scaleZ":
			return generateOk(`scaleZ(${ir.z})`);

		case "scale3d":
			return generateOk(`scale3d(${ir.x}, ${ir.y}, ${ir.z})`);

		case "skew":
			if (ir.y) {
				return generateOk(`skew(${angleToCss(ir.x)}, ${angleToCss(ir.y)})`);
			}
			return generateOk(`skew(${angleToCss(ir.x)})`);

		case "skewX":
			return generateOk(`skewX(${angleToCss(ir.x)})`);

		case "skewY":
			return generateOk(`skewY(${angleToCss(ir.y)})`);

		case "matrix":
			return generateOk(`matrix(${ir.a}, ${ir.b}, ${ir.c}, ${ir.d}, ${ir.e.value}, ${ir.f.value})`);

		case "matrix3d":
			return generateOk(`matrix3d(${ir.values.join(", ")})`);

		case "perspective":
			return generateOk(`perspective(${lengthToCss(ir.depth)})`);

		default: {
			// Exhaustive check - TypeScript will ensure all cases are handled
			const _exhaustiveCheck: never = ir;
			throw new Error(`Unknown transform function kind: ${(_exhaustiveCheck as { kind: string }).kind}`);
		}
	}
}

/**
 * Generate a CSS transform string from intermediate representation (IR).
 *
 * Converts a Transform IR object (array of transform functions) into a valid CSS
 * transform property value string. Multiple transform functions are space-separated.
 *
 * The generated CSS string is spec-compliant and can be used directly in CSS
 * properties like `transform`, `transform-origin`, etc.
 *
 * This function performs the inverse operation of `Parse.Transform.parse()`,
 * enabling bidirectional transformation between CSS and IR.
 *
 * @param ir - Transform IR object to convert to CSS
 * @returns CSS transform property value string
 *
 * @public
 *
 * @example
 * Simple translation:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Transform.generate([{
 *   kind: "translateX",
 *   x: { value: 100, unit: "px" }
 * }]);
 * console.log(css); // "translateX(100px)"
 * ```
 *
 * @example
 * Multiple transforms:
 * ```typescript
 * const css = Generate.Transform.generate([
 *   { kind: "translate", x: { value: 100, unit: "px" }, y: { value: 50, unit: "px" } },
 *   { kind: "rotate", angle: { value: 45, unit: "deg" } },
 *   { kind: "scale", x: 1.5, y: 1.5 }
 * ]);
 * console.log(css); // "translate(100px, 50px) rotate(45deg) scale(1.5, 1.5)"
 * ```
 *
 * @example
 * 3D transforms:
 * ```typescript
 * const css = Generate.Transform.generate([
 *   { kind: "translate3d", x: { value: 10, unit: "px" }, y: { value: 20, unit: "px" }, z: { value: 30, unit: "px" } },
 *   { kind: "rotateY", angle: { value: 45, unit: "deg" } }
 * ]);
 * console.log(css); // "translate3d(10px, 20px, 30px) rotateY(45deg)"
 * ```
 *
 * @example
 * Matrix transform:
 * ```typescript
 * const css = Generate.Transform.generate([{
 *   kind: "matrix",
 *   a: 1, b: 0.5, c: -0.5, d: 1,
 *   e: { value: 10, unit: "px" },
 *   f: { value: 20, unit: "px" }
 * }]);
 * console.log(css); // "matrix(1, 0.5, -0.5, 1, 10, 20)"
 * ```
 *
 * @example
 * Round-trip transformation (parse → generate):
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "translateX(100px) rotate(45deg) scale(1.5)";
 * const parsed = Parse.Transform.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Transform.generate(parsed.value);
 *   console.log(generated === original); // true - perfect round-trip!
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform | MDN: transform}
 * @see {@link https://www.w3.org/TR/css-transforms-1/ | W3C Spec: CSS Transforms Level 1}
 * @see {@link https://www.w3.org/TR/css-transforms-2/ | W3C Spec: CSS Transforms Level 2}
 */
export function generate(ir: Type.Transform): GenerateResult {
	if (ir === undefined || ir === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (ir.length === 0) {
		return generateOk("");
	}

	const functionResults = ir.map(toFunctionCss);
	const functionStrings = functionResults.map((result) => {
		if (!result.ok) return "";
		return result.value;
	});
	return generateOk(functionStrings.join(" "));
}


=== File: src/generate/transition/delay.failure.test.ts ===
// b_path:: src/generate/transition/delay.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/delay.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-delay-property
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/transition/delay";

describe("generate/transition/delay - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-unit", () => {
		it("should reject invalid unit px", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-delay",
				delays: [
					{
						value: 1,
						unit: "px",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('delays[0].unit: Invalid unit. Expected "s" or "ms".');
		});

		it("should reject invalid unit em", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-delay",
				delays: [
					{
						value: 1,
						unit: "em",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('delays[0].unit: Invalid unit. Expected "s" or "ms".');
		});
	});

	describe("invalid-value-type", () => {
		it("should reject string value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-delay",
				delays: [
					{
						value: "oops",
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("delays[0].value: Invalid input: expected number, received string");
		});

		it("should reject null value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-delay",
				delays: [
					{
						value: null,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("delays[0].value: Invalid input: expected number, received null");
		});
	});

	describe("invalid-missing", () => {
		it("should reject missing value field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-delay",
				delays: [
					{
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("delays[0].value: Invalid input: expected number, received undefined");
		});

		it("should reject missing unit field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-delay",
				delays: [
					{
						value: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('delays[0].unit: Invalid unit. Expected "s" or "ms".');
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty delays array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-delay",
				delays: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("delays: Too small: expected array to have >=1 items");
		});
	});
});


=== File: src/generate/transition/delay.test.ts ===
// b_path:: src/generate/transition/delay.test.ts
// Auto-generated from scripts/generate-test-generator/configs/transition/delay.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-delay-property
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/transition/delay";
import * as Parser from "@/parse/transition/delay";

describe("generate/transition/delay - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate single delay in seconds", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate single delay in milliseconds", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-edge", () => {
		it("should generate zero delay", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 0,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-negative", () => {
		it("should generate negative delay", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: -1,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("-1s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate negative delay in milliseconds", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: -500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("-500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-decimal", () => {
		it("should generate decimal seconds", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 0.5,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.5s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate decimal seconds with integer part", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 1.5,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1.5s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate decimal milliseconds", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 0.25,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.25ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-large", () => {
		it("should generate very large delay", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 10000,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("10000s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-list", () => {
		it("should generate multiple delays", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
					{
						value: 500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s, 500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple time values", () => {
			const input: Type.TransitionDelay = {
				kind: "transition-delay",
				delays: [
					{
						value: 0,
						unit: "s",
					},
					{
						value: 1,
						unit: "s",
					},
					{
						value: 2,
						unit: "s",
					},
					{
						value: 3,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0s, 1s, 2s, 3s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/transition/delay.ts ===
// b_path:: src/generate/transition/delay.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { transitionDelaySchema } from "@/core/types/transition";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS transition-delay property value from IR.
 *
 * Converts TransitionDelay IR to CSS string representation.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param ir - TransitionDelay IR object
 * @returns CSS transition-delay value string
 *
 * @example
 * Single delay:
 * ```typescript
 * const css = toCss({ kind: "transition-delay", delays: [{ value: 1, unit: "s" }] });
 * // "1s"
 * ```
 *
 * @example
 * Multiple delays:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-delay",
 *   delays: [
 *     { value: 1, unit: "s" },
 *     { value: 500, unit: "ms" },
 *     { value: 2, unit: "s" }
 *   ]
 * });
 * // "1s, 500ms, 2s"
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay | MDN: transition-delay}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-delay-property | W3C Spec}
 */
export function generate(ir: Type.TransitionDelay): GenerateResult {
	// Validate IR with Zod schema
	const validation = transitionDelaySchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(ir.delays.map((time) => `${time.value}${time.unit}`).join(", "));
}


=== File: src/generate/transition/duration.failure.test.ts ===
// b_path:: src/generate/transition/duration.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/duration.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-duration-property
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/transition/duration";

describe("generate/transition/duration - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-unit", () => {
		it("should reject invalid unit px", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-duration",
				durations: [
					{
						value: 1,
						unit: "px",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('durations[0].unit: Invalid unit. Expected "s" or "ms".');
		});

		it("should reject invalid unit em", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-duration",
				durations: [
					{
						value: 1,
						unit: "em",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('durations[0].unit: Invalid unit. Expected "s" or "ms".');
		});
	});

	describe("invalid-negative", () => {
		it("should reject negative value in seconds", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-duration",
				durations: [
					{
						value: -1,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("durations[0].value: Time value must be non-negative");
		});

		it("should reject negative value in milliseconds", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-duration",
				durations: [
					{
						value: -500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("durations[0].value: Time value must be non-negative");
		});
	});

	describe("invalid-value-type", () => {
		it("should reject string value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-duration",
				durations: [
					{
						value: "oops",
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("durations[0].value: Invalid input: expected number, received string");
		});

		it("should reject null value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-duration",
				durations: [
					{
						value: null,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("durations[0].value: Invalid input: expected number, received null");
		});
	});
});


=== File: src/generate/transition/duration.test.ts ===
// b_path:: src/generate/transition/duration.test.ts
// Auto-generated from scripts/generate-test-generator/configs/transition/duration.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-duration-property
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/transition/duration";
import * as Parser from "@/parse/transition/duration";

describe("generate/transition/duration - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate single time value in seconds", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 1,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate single time value in milliseconds", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 500,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("500ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-edge", () => {
		it("should generate zero duration", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 0,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate zero duration in ms", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 0,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-decimal", () => {
		it("should generate decimal values", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 0.5,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.5s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate decimal seconds", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 2.5,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("2.5s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate decimal milliseconds", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 100.5,
						unit: "ms",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("100.5ms");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-large", () => {
		it("should generate large values", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 3600,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("3600s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-list", () => {
		it("should generate multiple time values", () => {
			const input: Type.TransitionDuration = {
				kind: "transition-duration",
				durations: [
					{
						value: 1,
						unit: "s",
					},
					{
						value: 2,
						unit: "s",
					},
					{
						value: 3,
						unit: "s",
					},
					{
						value: 4,
						unit: "s",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1s, 2s, 3s, 4s");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/transition/duration.ts ===
// b_path:: src/generate/transition/duration.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { transitionDurationSchema } from "@/core/types/transition";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS transition-duration property value from IR.
 *
 * Converts TransitionDuration IR to CSS string representation.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param ir - TransitionDuration IR object
 * @returns CSS transition-duration value string
 *
 * @example
 * Time duration:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-duration",
 *   durations: [{ value: 1, unit: "s" }]
 * });
 * // "1s"
 * ```
 *
 * @example
 * Multiple durations:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-duration",
 *   durations: [
 *     { value: 1, unit: "s" },
 *     { value: 500, unit: "ms" }
 *   ]
 * });
 * // "1s, 500ms"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration | MDN: transition-duration}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-duration-property | W3C Spec}
 */
export function generate(ir: Type.TransitionDuration): GenerateResult {
	// Validate IR with Zod schema
	const validation = transitionDurationSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(ir.durations.map((duration) => `${duration.value}${duration.unit}`).join(", "));
}


=== File: src/generate/transition/index.ts ===
// b_path:: src/generate/transition/index.ts

export * as Delay from "./delay";
export * as Duration from "./duration";
export * as Property from "./property";
export * as TimingFunction from "./timing-function";
export { generate } from "./transition";


=== File: src/generate/transition/property.failure.test.ts ===
// b_path:: src/generate/transition/property.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/property.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-property-property
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/transition/property";

describe("generate/transition/property - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty properties array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-property",
				properties: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("properties: Too small: expected array to have >=1 items");
		});
	});

	describe("invalid-type", () => {
		it("should reject invalid property type", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-property",
				properties: [
					{
						type: "invalid",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'properties[0]: Invalid transition property. Expected { type: "none" }, { type: "all" }, or { type: "identifier", value: <string> }.',
			);
		});
	});

	describe("invalid-missing", () => {
		it("should reject identifier without value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				'properties[0]: Invalid transition property. Expected { type: "none" }, { type: "all" }, or { type: "identifier", value: <string> }.',
			);
		});
	});
});


=== File: src/generate/transition/property.test.ts ===
// b_path:: src/generate/transition/property.test.ts
// Auto-generated from scripts/generate-test-generator/configs/transition/property.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-property-property
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/transition/property";
import * as Parser from "@/parse/transition/property";

describe("generate/transition/property - valid cases", () => {
	describe("valid-keyword", () => {
		it("should generate none keyword", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "none",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate all keyword", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "all",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("all");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-basic", () => {
		it("should generate single property", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "opacity",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("opacity");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate transform property", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "transform",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("transform");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate hyphenated property", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "background-color",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("background-color");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-list", () => {
		it("should generate multiple properties", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "opacity",
					},
					{
						type: "identifier",
						value: "transform",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("opacity, transform");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate three properties", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "width",
					},
					{
						type: "identifier",
						value: "height",
					},
					{
						type: "identifier",
						value: "opacity",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("width, height, opacity");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-custom", () => {
		it("should generate custom property", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "--custom-property",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("--custom-property");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiple custom properties", () => {
			const input: Type.TransitionProperty = {
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "--my-color",
					},
					{
						type: "identifier",
						value: "--my-size",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("--my-color, --my-size");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/transition/property.ts ===
// b_path:: src/generate/transition/property.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { transitionPropertySchema } from "@/core/types/transition";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS transition-property property value from IR.
 *
 * Converts TransitionProperty IR to CSS string representation.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param ir - TransitionProperty IR object
 * @returns CSS transition-property value string
 *
 * @example
 * Single property:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-property",
 *   properties: [{ type: "identifier", value: "opacity" }]
 * });
 * // "opacity"
 * ```
 *
 * @example
 * Multiple properties:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-property",
 *   properties: [
 *     { type: "identifier", value: "opacity" },
 *     { type: "identifier", value: "transform" }
 *   ]
 * });
 * // "opacity, transform"
 * ```
 *
 * @example
 * Keywords:
 * ```typescript
 * const css = toCss({ kind: "transition-property", properties: [{ type: "all" }] });
 * // "all"
 *
 * const css2 = toCss({ kind: "transition-property", properties: [{ type: "none" }] });
 * // "none"
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property | MDN: transition-property}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-property-property | W3C Spec}
 */
export function generate(ir: Type.TransitionProperty): GenerateResult {
	// Validate IR with Zod schema
	const validation = transitionPropertySchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	const parts = ir.properties.map((prop) => {
		if (prop.type === "none") return "none";
		if (prop.type === "all") return "all";
		return prop.value; // identifier
	});

	return generateOk(parts.join(", "));
}


=== File: src/generate/transition/timing-function.failure.test.ts ===
// b_path:: src/generate/transition/timing-function.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/timing-function.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/transition/timing-function";

describe("generate/transition/timing-function - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-timing-function",
				functions: ["invalid-keyword"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject invalid function type", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "unknown",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});
	});

	describe("invalid-cubic-bezier", () => {
		it("should reject cubic-bezier missing x2/y2", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0,
						y1: 0,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});

		it("should reject cubic-bezier with string value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: "0",
						y1: 0,
						x2: 1,
						y2: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});
	});

	describe("invalid-steps", () => {
		it("should reject steps missing steps count", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"functions[0]: Invalid easing function. Expected a keyword (ease, linear, etc.), cubic-bezier(), steps(), or linear().",
			);
		});

		it("should reject steps with zero count", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 0,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("functions[0].steps: Too small: expected number to be >0");
		});

		it("should reject steps with negative count", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: -1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("functions[0].steps: Too small: expected number to be >0");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty functions array", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "transition-timing-function",
				functions: [],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("functions: Too small: expected array to have >=1 items");
		});
	});
});


=== File: src/generate/transition/timing-function.test.ts ===
// b_path:: src/generate/transition/timing-function.test.ts
// Auto-generated from scripts/generate-test-generator/configs/transition/timing-function.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/transition/timing-function";
import * as Parser from "@/parse/transition/timing-function";

describe("generate/transition/timing-function - valid cases", () => {
	describe("valid-keyword", () => {
		it("should generate ease keyword", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["ease"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate linear keyword", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["linear"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("linear");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate ease-in keyword", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["ease-in"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease-in");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate ease-out keyword", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["ease-out"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease-out");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate ease-in-out keyword", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["ease-in-out"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease-in-out");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate step-start keyword", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["step-start"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("step-start");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate step-end keyword", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["step-end"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("step-end");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-cubic-bezier", () => {
		it("should generate cubic-bezier function", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0.42,
						y1: 0,
						x2: 1,
						y2: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("cubic-bezier(0.42, 0, 1, 1)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate cubic-bezier with zero values", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0,
						y1: 0,
						x2: 1,
						y2: 1,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("cubic-bezier(0, 0, 1, 1)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-steps", () => {
		it("should generate steps without position", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 4,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("steps(4)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate steps with start position", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 10,
						position: "start",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("steps(10, start)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate steps with end position", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 5,
						position: "end",
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("steps(5, end)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-linear", () => {
		it("should generate linear function simple", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "linear",
						stops: [
							{
								output: 0,
							},
							{
								output: 1,
							},
						],
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("linear(0, 1)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate linear function with input positions", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: [
					{
						type: "linear",
						stops: [
							{
								output: 0,
								input: 0,
							},
							{
								output: 0.5,
								input: 0.5,
							},
							{
								output: 1,
								input: 1,
							},
						],
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("linear(0 0%, 0.5 50%, 1 100%)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-list", () => {
		it("should generate multiple keyword functions", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: ["ease", "linear", "ease-out"],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease, linear, ease-out");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate mixed function types", () => {
			const input: Type.TransitionTimingFunction = {
				kind: "transition-timing-function",
				functions: [
					"ease",
					{
						type: "cubic-bezier",
						x1: 0.1,
						y1: 0.7,
						x2: 1,
						y2: 0.1,
					},
					{
						type: "steps",
						steps: 4,
					},
				],
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("ease, cubic-bezier(0.1, 0.7, 1, 0.1), steps(4)");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/transition/timing-function.ts ===
// b_path:: src/generate/transition/timing-function.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type * as Type from "@/core/types";
import { transitionTimingFunctionSchema } from "@/core/types/transition";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS easing function string from IR.
 *
 * @param func - EasingFunction IR
 * @returns CSS easing function string
 *
 * @internal
 */
function easingFunctionToCss(func: Type.EasingFunction): string {
	// Keyword
	if (typeof func === "string") {
		return func;
	}

	// cubic-bezier()
	if (func.type === "cubic-bezier") {
		return `cubic-bezier(${func.x1}, ${func.y1}, ${func.x2}, ${func.y2})`;
	}

	// steps()
	if (func.type === "steps") {
		if (func.position !== undefined) {
			return `steps(${func.steps}, ${func.position})`;
		}
		return `steps(${func.steps})`;
	}

	// linear()
	if (func.type === "linear") {
		const stops = func.stops
			.map((stop) => {
				if (stop.input !== undefined) {
					return `${stop.output} ${stop.input * 100}%`;
				}
				return String(stop.output);
			})
			.join(", ");
		return `linear(${stops})`;
	}

	return "";
}

/**
 * Generate CSS transition-timing-function property value from IR.
 *
 * Converts TransitionTimingFunction IR to CSS string representation.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param ir - TransitionTimingFunction IR object
 * @returns CSS transition-timing-function value string
 *
 * @example
 * Keyword:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-timing-function",
 *   functions: ["ease-in"]
 * });
 * // "ease-in"
 * ```
 *
 * @example
 * Cubic bezier:
 * ```typescript
 * const css = toCss({
 *   kind: "transition-timing-function",
 *   functions: [{ type: "cubic-bezier", x1: 0.1, y1: 0.7, x2: 1.0, y2: 0.1 }]
 * });
 * // "cubic-bezier(0.1, 0.7, 1, 0.1)"
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function | MDN: transition-timing-function}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property | W3C Spec}
 */
export function generate(ir: Type.TransitionTimingFunction): GenerateResult {
	// Validate IR with Zod schema
	const validation = transitionTimingFunctionSchema.safeParse(ir);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(ir.functions.map(easingFunctionToCss).join(", "));
}


=== File: src/generate/transition/transition.test.ts ===
// b_path:: src/generate/transition/transition.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./transition";

describe("generateTransition (dispatcher)", () => {
	describe("transition-duration", () => {
		it("dispatches transition-duration in seconds", () => {
			const result = generate({
				kind: "transition-duration",
				durations: [{ value: 1, unit: "s" }],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("1s");
			}
		});

		it("dispatches transition-duration in milliseconds", () => {
			const result = generate({
				kind: "transition-duration",
				durations: [{ value: 500, unit: "ms" }],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("500ms");
			}
		});
	});

	describe("transition-delay", () => {
		it("dispatches transition-delay in seconds", () => {
			const result = generate({
				kind: "transition-delay",
				delays: [{ value: 0.5, unit: "s" }],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("0.5s");
			}
		});

		it("dispatches transition-delay in milliseconds", () => {
			const result = generate({
				kind: "transition-delay",
				delays: [{ value: 200, unit: "ms" }],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("200ms");
			}
		});
	});

	describe("transition-timing-function", () => {
		it("dispatches keyword timing function", () => {
			const result = generate({
				kind: "transition-timing-function",
				functions: ["ease-in-out"],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("ease-in-out");
			}
		});

		it("dispatches cubic-bezier timing function", () => {
			const result = generate({
				kind: "transition-timing-function",
				functions: [{ type: "cubic-bezier", x1: 0.1, y1: 0.7, x2: 1.0, y2: 0.1 }],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("cubic-bezier(0.1, 0.7, 1, 0.1)");
			}
		});
	});

	describe("transition-property", () => {
		it("dispatches transition-property", () => {
			const result = generate({
				kind: "transition-property",
				properties: [{ type: "identifier", value: "opacity" }],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("opacity");
			}
		});

		it("dispatches all keyword", () => {
			const result = generate({
				kind: "transition-property",
				properties: [{ type: "all" }],
			});
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("all");
			}
		});
	});

	describe("error handling", () => {
		it("rejects null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			const result = generate(null as any);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.code).toBe("missing-required-field");
				expect(result.issues[0]?.message).toContain("missing 'kind' field");
			}
		});

		it("rejects undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			const result = generate(undefined as any);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.code).toBe("missing-required-field");
			}
		});

		it("rejects object without kind field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			const result = generate({} as any);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.code).toBe("missing-required-field");
			}
		});

		it("rejects unknown transition kind", () => {
			// biome-ignore lint/suspicious/noExplicitAny: testing invalid input
			const result = generate({ kind: "unknown-transition" } as any);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.code).toBe("unsupported-kind");
				expect(result.issues[0]?.message).toContain("unknown-transition");
			}
		});
	});
});


=== File: src/generate/transition/transition.ts ===
// b_path:: src/generate/transition/transition.ts

import { type GenerateResult, generateErr } from "@/core/result";
import type * as Type from "@/core/types/transition";
import * as Delay from "./delay";
import * as Duration from "./duration";
import * as Property from "./property";
import * as TimingFunction from "./timing-function";

/**
 * Generate CSS from transition IR with auto-detection.
 *
 * Automatically detects transition property type from IR.kind and generates appropriate CSS.
 * Supports transition-delay, transition-duration, transition-property, and transition-timing-function.
 *
 * @param transition - Transition IR
 * @returns GenerateResult with CSS string or error
 *
 * @example
 * Duration:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const result = Generate.Transition.generate({
 *   kind: "transition-duration",
 *   value: 1,
 *   unit: "s"
 * });
 * // → { ok: true, value: "1s", issues: [] }
 * ```
 *
 * @example
 * Delay:
 * ```typescript
 * const result = Generate.Transition.generate({
 *   kind: "transition-delay",
 *   value: 500,
 *   unit: "ms"
 * });
 * // → { ok: true, value: "500ms", issues: [] }
 * ```
 *
 * @example
 * Timing function:
 * ```typescript
 * const result = Generate.Transition.generate({
 *   kind: "transition-timing-function",
 *   function: "ease-in-out"
 * });
 * // → { ok: true, value: "ease-in-out", issues: [] }
 * ```
 *
 * @example
 * Property:
 * ```typescript
 * const result = Generate.Transition.generate({
 *   kind: "transition-property",
 *   property: "opacity"
 * });
 * // → { ok: true, value: "opacity", issues: [] }
 * ```
 *
 * @example
 * Invalid IR:
 * ```typescript
 * const result = Generate.Transition.generate(null);
 * // → { ok: false, issues: [{ severity: "error", message: "Invalid transition IR: missing 'kind' field" }] }
 * ```
 *
 * @public
 */
export function generate(
	transition: Type.TransitionDelay | Type.TransitionDuration | Type.TransitionProperty | Type.TransitionTimingFunction,
): GenerateResult {
	// Validate IR has 'kind' field
	if (!transition || typeof transition !== "object" || !("kind" in transition)) {
		return generateErr("missing-required-field", "Invalid transition IR: missing 'kind' field", {
			suggestion: "Ensure IR was parsed correctly",
		});
	}

	// Dispatch based on kind
	switch (transition.kind) {
		case "transition-duration":
			return Duration.generate(transition);

		case "transition-delay":
			return Delay.generate(transition);

		case "transition-timing-function":
			return TimingFunction.generate(transition);

		case "transition-property":
			return Property.generate(transition);

		default:
			return generateErr("unsupported-kind", `Unknown transition kind: ${(transition as { kind?: string }).kind}`, {
				suggestion:
					"Expected 'transition-duration', 'transition-delay', 'transition-timing-function', or 'transition-property'",
			});
	}
}


=== File: src/generate/typography/font-family.test.ts ===
// b_path:: src/generate/typography/font-family.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./font-family";

describe("font-family generator", () => {
	it("should generate single font family", () => {
		let result = generate({ kind: "font-family", families: ["Arial"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("Arial");

		result = generate({ kind: "font-family", families: ["serif"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("serif");
	});

	it("should generate multiple font families", () => {
		let result = generate({ kind: "font-family", families: ["Arial", "sans-serif"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("Arial, sans-serif");

		result = generate({ kind: "font-family", families: ["Georgia", "serif"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("Georgia, serif");
	});

	it("should quote families with spaces", () => {
		let result = generate({ kind: "font-family", families: ["Times New Roman", "serif"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe('"Times New Roman", serif');

		result = generate({ kind: "font-family", families: ["Courier New", "monospace"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe('"Courier New", monospace');
	});

	it("should handle mixed quoted and unquoted families", () => {
		const result = generate({ kind: "font-family", families: ["Open Sans", "Arial", "sans-serif"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe('"Open Sans", Arial, sans-serif');
	});

	it("should handle generic font families", () => {
		let result = generate({ kind: "font-family", families: ["sans-serif"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("sans-serif");

		result = generate({ kind: "font-family", families: ["serif"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("serif");

		result = generate({ kind: "font-family", families: ["monospace"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("monospace");

		result = generate({ kind: "font-family", families: ["cursive"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("cursive");

		result = generate({ kind: "font-family", families: ["fantasy"] });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("fantasy");
	});

	it("should return error for null input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(null);
		expect(result.ok).toBe(false);
	});

	it("should return error for undefined input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(undefined);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/typography/font-family.ts ===
// b_path:: src/generate/typography/font-family.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FontFamily } from "@/core/types";

/**
 * Generate CSS font-family property from IR.
 *
 * Outputs comma-separated list of font families.
 *
 * @param fontFamily - FontFamily IR
 * @returns CSS string like "Arial, sans-serif"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-family}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/font-family";
 *
 * const css = toCss({ kind: "font-family", families: ["Arial", "sans-serif"] });
 * // "Arial, sans-serif"
 * ```
 *
 * @public
 */
export function generate(fontFamily: FontFamily): GenerateResult {
	if (fontFamily === undefined || fontFamily === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(
		fontFamily.families
			.map((family) => {
				// Quote families with spaces
				if (family.includes(" ")) {
					return `"${family}"`;
				}
				return family;
			})
			.join(", "),
	);
}


=== File: src/generate/typography/font-size.test.ts ===
// b_path:: src/generate/typography/font-size.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./font-size";

describe("font-size generator", () => {
	it("should generate absolute sizes", () => {
		let result = generate({ kind: "font-size", value: "xx-small" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("xx-small");

		result = generate({ kind: "font-size", value: "x-small" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("x-small");

		result = generate({ kind: "font-size", value: "small" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("small");

		result = generate({ kind: "font-size", value: "medium" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("medium");

		result = generate({ kind: "font-size", value: "large" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("large");

		result = generate({ kind: "font-size", value: "x-large" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("x-large");

		result = generate({ kind: "font-size", value: "xx-large" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("xx-large");

		result = generate({ kind: "font-size", value: "xxx-large" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("xxx-large");
	});

	it("should generate relative sizes", () => {
		let result = generate({ kind: "font-size", value: "larger" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("larger");

		result = generate({ kind: "font-size", value: "smaller" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("smaller");
	});

	it("should generate length values", () => {
		let result = generate({ kind: "font-size", value: { value: 16, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("16px");

		result = generate({ kind: "font-size", value: { value: 1.5, unit: "em" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1.5em");

		result = generate({ kind: "font-size", value: { value: 2, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("2rem");

		result = generate({ kind: "font-size", value: { value: 14, unit: "pt" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("14pt");
	});

	it("should generate percentage values", () => {
		let result = generate({ kind: "font-size", value: { value: 100, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("100%");

		result = generate({ kind: "font-size", value: { value: 120, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("120%");
	});

	it("should handle zero", () => {
		const result = generate({ kind: "font-size", value: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0px");
	});

	it("should return error for null input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(null);
		expect(result.ok).toBe(false);
	});

	it("should return error for undefined input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(undefined);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/typography/font-size.ts ===
// b_path:: src/generate/typography/font-size.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FontSize } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS font-size property from IR.
 *
 * Outputs length-percentage value or keyword.
 *
 * @param fontSize - FontSize IR
 * @returns CSS string like "16px", "1.2em", or "medium"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/font-size";
 *
 * const css = toCss({ kind: "font-size", value: { value: 16, unit: "px" } });
 * // "16px"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "font-size", value: "medium" });
 * // "medium"
 * ```
 *
 * @public
 */
export function generate(fontSize: FontSize): GenerateResult {
	if (fontSize === undefined || fontSize === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof fontSize.value === "string") {
		return generateOk(fontSize.value);
	}
	return generateOk(GenUtils.lengthPercentageToCss(fontSize.value));
}


=== File: src/generate/typography/font-style.failure.test.ts ===
// b_path:: src/generate/typography/font-style.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/font-style.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/typography/font-style";

describe("generate/typography/font-style - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/typography/font-style.test.ts ===
// b_path:: src/generate/typography/font-style.test.ts
// Auto-generated from scripts/generate-test-generator/configs/typography/font-style.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/typography/font-style";
import * as Parser from "@/parse/typography/font-style";

describe("generate/typography/font-style - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate normal keyword", () => {
			const input: Type.FontStyle = {
				kind: "font-style",
				value: "normal",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("normal");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate italic keyword", () => {
			const input: Type.FontStyle = {
				kind: "font-style",
				value: "italic",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("italic");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate oblique keyword", () => {
			const input: Type.FontStyle = {
				kind: "font-style",
				value: "oblique",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("oblique");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/typography/font-style.ts ===
// b_path:: src/generate/typography/font-style.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FontStyle } from "@/core/types";

/**
 * Generate CSS font-style property from IR.
 *
 * Outputs keyword value.
 *
 * @param fontStyle - FontStyle IR
 * @returns CSS string like "normal", "italic", or "oblique"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/font-style";
 *
 * const css = toCss({ kind: "font-style", value: "italic" });
 * // "italic"
 * ```
 *
 * @public
 */
export function generate(fontStyle: FontStyle): GenerateResult {
	if (fontStyle === undefined || fontStyle === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(fontStyle.value);
}


=== File: src/generate/typography/font-weight.test.ts ===
// b_path:: src/generate/typography/font-weight.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./font-weight";

describe("font-weight generator", () => {
	it("should generate keyword values", () => {
		let result = generate({ kind: "font-weight", value: "normal" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("normal");

		result = generate({ kind: "font-weight", value: "bold" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("bold");

		result = generate({ kind: "font-weight", value: "bolder" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("bolder");

		result = generate({ kind: "font-weight", value: "lighter" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("lighter");
	});

	it("should generate numeric values", () => {
		let result = generate({ kind: "font-weight", value: 100 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("100");

		result = generate({ kind: "font-weight", value: 200 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("200");

		result = generate({ kind: "font-weight", value: 300 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("300");

		result = generate({ kind: "font-weight", value: 400 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("400");

		result = generate({ kind: "font-weight", value: 500 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("500");

		result = generate({ kind: "font-weight", value: 600 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("600");

		result = generate({ kind: "font-weight", value: 700 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("700");

		result = generate({ kind: "font-weight", value: 800 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("800");

		result = generate({ kind: "font-weight", value: 900 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("900");
	});

	it("should generate variable font weights", () => {
		let result = generate({ kind: "font-weight", value: 350 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("350");

		result = generate({ kind: "font-weight", value: 550 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("550");

		result = generate({ kind: "font-weight", value: 750 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("750");
	});

	it("should return error for null input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(null);
		expect(result.ok).toBe(false);
	});

	it("should return error for undefined input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(undefined);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/typography/font-weight.ts ===
// b_path:: src/generate/typography/font-weight.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { FontWeight } from "@/core/types";

/**
 * Generate CSS font-weight property from IR.
 *
 * Outputs numeric value or keyword.
 *
 * @param fontWeight - FontWeight IR
 * @returns CSS string like "400", "bold", or "normal"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/font-weight";
 *
 * const css = toCss({ kind: "font-weight", value: 400 });
 * // "400"
 * ```
 *
 * @example
 * ```typescript
 * const css = toCss({ kind: "font-weight", value: "bold" });
 * // "bold"
 * ```
 *
 * @public
 */
export function generate(fontWeight: FontWeight): GenerateResult {
	if (fontWeight === undefined || fontWeight === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(String(fontWeight.value));
}


=== File: src/generate/typography/index.ts ===
// b_path:: src/generate/typography/index.ts

export * as FontFamily from "./font-family";
export * as FontSize from "./font-size";
export * as FontStyle from "./font-style";
export * as FontWeight from "./font-weight";
export * as LetterSpacing from "./letter-spacing";
export * as LineHeight from "./line-height";
export * as OverflowWrap from "./overflow-wrap";
export * as TextAlign from "./text-align";
export * as TextTransform from "./text-transform";
export * as VerticalAlign from "./vertical-align";
export * as WordBreak from "./word-break";


=== File: src/generate/typography/letter-spacing.test.ts ===
// b_path:: src/generate/typography/letter-spacing.test.ts
import { describe, expect, test } from "vitest";
import * as Parse from "@/parse/typography/letter-spacing";
import * as Generate from "./letter-spacing";

describe("letter-spacing generator", () => {
	test("should generate 'normal'", () => {
		const result = Generate.generate({ kind: "letter-spacing", value: "normal" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("normal");
	});

	test("should generate length in px", () => {
		const result = Generate.generate({ kind: "letter-spacing", value: { value: 2, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("2px");
	});

	test("should generate length in em", () => {
		const result = Generate.generate({ kind: "letter-spacing", value: { value: 0.1, unit: "em" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0.1em");
	});

	test("should round-trip with parser", () => {
		const inputs = ["normal", "2px", "0.1em", "-1px"];
		for (const input of inputs) {
			const parsed = Parse.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = Generate.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (generated.ok) expect(generated.value).toBe(input);
			}
		}
	});
});


=== File: src/generate/typography/letter-spacing.ts ===
// b_path:: src/generate/typography/letter-spacing.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { LetterSpacing } from "@/core/types";
import { lengthPercentageToCss } from "@/utils/generate/values";

/**
 * Generate CSS letter-spacing property from IR.
 *
 * Outputs length value or 'normal' keyword.
 *
 * @param letterSpacing - LetterSpacing IR
 * @returns CSS string like "normal", "0.1em", or "2px"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/letter-spacing";
 *
 * const css = toCss({ kind: "letter-spacing", value: "normal" });
 * // "normal"
 * ```
 *
 * @public
 */
export function generate(letterSpacing: LetterSpacing): GenerateResult {
	if (letterSpacing === undefined || letterSpacing === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (letterSpacing.value === "normal") {
		return generateOk("normal");
	}
	return generateOk(lengthPercentageToCss(letterSpacing.value));
}


=== File: src/generate/typography/line-height.test.ts ===
// b_path:: src/generate/typography/line-height.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./line-height";

describe("line-height generator", () => {
	it("should generate keyword values", () => {
		const result = generate({ kind: "line-height", value: "normal" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("normal");
	});

	it("should generate unitless numbers", () => {
		let result = generate({ kind: "line-height", value: 1 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1");

		result = generate({ kind: "line-height", value: 1.5 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1.5");

		result = generate({ kind: "line-height", value: 2 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("2");

		result = generate({ kind: "line-height", value: 0.8 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0.8");
	});

	it("should generate length values", () => {
		let result = generate({ kind: "line-height", value: { value: 20, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("20px");

		result = generate({ kind: "line-height", value: { value: 1.5, unit: "em" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("1.5em");

		result = generate({ kind: "line-height", value: { value: 2, unit: "rem" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("2rem");
	});

	it("should generate percentage values", () => {
		let result = generate({ kind: "line-height", value: { value: 120, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("120%");

		result = generate({ kind: "line-height", value: { value: 150, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("150%");
	});

	it("should handle zero", () => {
		let result = generate({ kind: "line-height", value: 0 });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0");

		result = generate({ kind: "line-height", value: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0px");
	});

	it("should return error for null input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(null);
		expect(result.ok).toBe(false);
	});

	it("should return error for undefined input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(undefined);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/typography/line-height.ts ===
// b_path:: src/generate/typography/line-height.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { LineHeight } from "@/core/types";
import * as GenUtils from "@/utils/generate";

/**
 * Generate CSS line-height property from IR.
 *
 * Outputs unitless number, length-percentage, or keyword.
 *
 * @param lineHeight - LineHeight IR
 * @returns CSS string like "1.5", "20px", or "normal"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/line-height}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/line-height";
 *
 * const css = toCss({ kind: "line-height", value: 1.5 });
 * // "1.5"
 * ```
 *
 * @public
 */
export function generate(lineHeight: LineHeight): GenerateResult {
	if (lineHeight === undefined || lineHeight === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	const { value } = lineHeight;

	if (typeof value === "string") {
		return generateOk(value);
	}

	if (typeof value === "number") {
		return generateOk(String(value));
	}

	return generateOk(GenUtils.lengthPercentageToCss(value));
}


=== File: src/generate/typography/overflow-wrap.test.ts ===
// b_path:: src/generate/typography/overflow-wrap.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./overflow-wrap";

describe("overflow-wrap generator", () => {
	test("should generate 'normal'", () => {
		const result = generate({ kind: "overflow-wrap", value: "normal" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("normal");
	});

	test("should generate 'break-word'", () => {
		const result = generate({ kind: "overflow-wrap", value: "break-word" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("break-word");
	});

	test("should generate 'anywhere'", () => {
		const result = generate({ kind: "overflow-wrap", value: "anywhere" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("anywhere");
	});
});


=== File: src/generate/typography/overflow-wrap.ts ===
// b_path:: src/generate/typography/overflow-wrap.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { OverflowWrap } from "@/core/types";

/**
 * Generate CSS overflow-wrap property from IR.
 *
 * Outputs keyword value.
 *
 * @param overflowWrap - OverflowWrap IR
 * @returns CSS string like "normal", "break-word", or "anywhere"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/overflow-wrap";
 *
 * const css = toCss({ kind: "overflow-wrap", value: "break-word" });
 * // "break-word"
 * ```
 *
 * @public
 */
export function generate(overflowWrap: OverflowWrap): GenerateResult {
	if (overflowWrap === undefined || overflowWrap === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(overflowWrap.value);
}


=== File: src/generate/typography/text-align.failure.test.ts ===
// b_path:: src/generate/typography/text-align.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/text-align.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/text-align
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/typography/text-align";

describe("generate/typography/text-align - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/typography/text-align.test.ts ===
// b_path:: src/generate/typography/text-align.test.ts
// Auto-generated from scripts/generate-test-generator/configs/typography/text-align.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/text-align
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/typography/text-align";
import * as Parser from "@/parse/typography/text-align";

describe("generate/typography/text-align - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate left keyword", () => {
			const input: Type.TextAlign = {
				kind: "text-align",
				value: "left",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("left");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate right keyword", () => {
			const input: Type.TextAlign = {
				kind: "text-align",
				value: "right",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("right");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate center keyword", () => {
			const input: Type.TextAlign = {
				kind: "text-align",
				value: "center",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("center");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate justify keyword", () => {
			const input: Type.TextAlign = {
				kind: "text-align",
				value: "justify",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("justify");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/typography/text-align.ts ===
// b_path:: src/generate/typography/text-align.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { TextAlign } from "@/core/types";

/**
 * Generate CSS text-align property from IR.
 *
 * Outputs alignment keyword.
 *
 * @param textAlign - TextAlign IR
 * @returns CSS string like "center", "left", or "justify"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-align}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/text-align";
 *
 * const css = toCss({ kind: "text-align", value: "center" });
 * // "center"
 * ```
 *
 * @public
 */
export function generate(textAlign: TextAlign): GenerateResult {
	if (textAlign === undefined || textAlign === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(textAlign.value);
}


=== File: src/generate/typography/text-transform.failure.test.ts ===
// b_path:: src/generate/typography/text-transform.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/text-transform.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/typography/text-transform";

describe("generate/typography/text-transform - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Input must not be null or undefined");
		});
	});
});


=== File: src/generate/typography/text-transform.test.ts ===
// b_path:: src/generate/typography/text-transform.test.ts
// Auto-generated from scripts/generate-test-generator/configs/typography/text-transform.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/typography/text-transform";
import * as Parser from "@/parse/typography/text-transform";

describe("generate/typography/text-transform - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate none keyword", () => {
			const input: Type.TextTransform = {
				kind: "text-transform",
				value: "none",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("none");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate capitalize keyword", () => {
			const input: Type.TextTransform = {
				kind: "text-transform",
				value: "capitalize",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("capitalize");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate uppercase keyword", () => {
			const input: Type.TextTransform = {
				kind: "text-transform",
				value: "uppercase",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("uppercase");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate lowercase keyword", () => {
			const input: Type.TextTransform = {
				kind: "text-transform",
				value: "lowercase",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("lowercase");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/typography/text-transform.ts ===
// b_path:: src/generate/typography/text-transform.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { TextTransform } from "@/core/types";

/**
 * Generate CSS text-transform property from IR.
 *
 * Outputs keyword value.
 *
 * @param textTransform - TextTransform IR
 * @returns CSS string like "none", "uppercase", or "capitalize"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/text-transform";
 *
 * const css = toCss({ kind: "text-transform", value: "uppercase" });
 * // "uppercase"
 * ```
 *
 * @public
 */
export function generate(textTransform: TextTransform): GenerateResult {
	if (textTransform === undefined || textTransform === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(textTransform.value);
}


=== File: src/generate/typography/vertical-align.test.ts ===
// b_path:: src/generate/typography/vertical-align.test.ts
import { describe, expect, it } from "vitest";
import { generate } from "./vertical-align";

describe("vertical-align generator", () => {
	it("should generate baseline alignment keywords", () => {
		let result = generate({ kind: "vertical-align", value: "baseline" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("baseline");

		result = generate({ kind: "vertical-align", value: "sub" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("sub");

		result = generate({ kind: "vertical-align", value: "super" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("super");
	});

	it("should generate text alignment keywords", () => {
		let result = generate({ kind: "vertical-align", value: "text-top" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("text-top");

		result = generate({ kind: "vertical-align", value: "text-bottom" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("text-bottom");
	});

	it("should generate box alignment keywords", () => {
		let result = generate({ kind: "vertical-align", value: "top" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("top");

		result = generate({ kind: "vertical-align", value: "middle" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("middle");

		result = generate({ kind: "vertical-align", value: "bottom" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("bottom");
	});

	it("should generate length values", () => {
		let result = generate({ kind: "vertical-align", value: { value: 5, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("5px");

		result = generate({ kind: "vertical-align", value: { value: -2, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("-2px");

		result = generate({ kind: "vertical-align", value: { value: 0.5, unit: "em" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0.5em");
	});

	it("should generate percentage values", () => {
		let result = generate({ kind: "vertical-align", value: { value: 50, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("50%");

		result = generate({ kind: "vertical-align", value: { value: -25, unit: "%" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("-25%");
	});

	it("should handle zero", () => {
		const result = generate({ kind: "vertical-align", value: { value: 0, unit: "px" } });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("0px");
	});

	it("should return error for null input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(null);
		expect(result.ok).toBe(false);
	});

	it("should return error for undefined input", () => {
		// @ts-expect-error - testing invalid input
		const result = generate(undefined);
		expect(result.ok).toBe(false);
	});
});


=== File: src/generate/typography/vertical-align.ts ===
// b_path:: src/generate/typography/vertical-align.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { VerticalAlign } from "@/core/types";
import { lengthPercentageToCss } from "@/utils/generate/values";

/**
 * Generate CSS vertical-align property from IR.
 *
 * Outputs keyword, length, or percentage value.
 *
 * @param verticalAlign - VerticalAlign IR
 * @returns CSS string like "middle", "5px", or "50%"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/vertical-align";
 *
 * const css = toCss({ kind: "vertical-align", value: "middle" });
 * // "middle"
 * ```
 *
 * @public
 */
export function generate(verticalAlign: VerticalAlign): GenerateResult {
	if (verticalAlign === undefined || verticalAlign === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	if (typeof verticalAlign.value === "string") {
		return generateOk(verticalAlign.value);
	}
	return generateOk(lengthPercentageToCss(verticalAlign.value));
}


=== File: src/generate/typography/word-break.test.ts ===
// b_path:: src/generate/typography/word-break.test.ts
import { describe, expect, test } from "vitest";
import { generate } from "./word-break";

describe("word-break generator", () => {
	test("should generate 'normal'", () => {
		const result = generate({ kind: "word-break", value: "normal" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("normal");
	});

	test("should generate 'break-all'", () => {
		const result = generate({ kind: "word-break", value: "break-all" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("break-all");
	});

	test("should generate 'keep-all'", () => {
		const result = generate({ kind: "word-break", value: "keep-all" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("keep-all");
	});

	test("should generate 'break-word'", () => {
		const result = generate({ kind: "word-break", value: "break-word" });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe("break-word");
	});
});


=== File: src/generate/typography/word-break.ts ===
// b_path:: src/generate/typography/word-break.ts

import { type GenerateResult, generateErr, generateOk } from "@/core/result";
import type { WordBreak } from "@/core/types";

/**
 * Generate CSS word-break property from IR.
 *
 * Outputs keyword value.
 *
 * @param wordBreak - WordBreak IR
 * @returns CSS string like "normal", "break-all", or "keep-all"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/word-break}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/typography/word-break";
 *
 * const css = toCss({ kind: "word-break", value: "break-all" });
 * // "break-all"
 * ```
 *
 * @public
 */
export function generate(wordBreak: WordBreak): GenerateResult {
	if (wordBreak === undefined || wordBreak === null) {
		return generateErr("invalid-ir", "Input must not be null or undefined");
	}
	return generateOk(wordBreak.value);
}


=== File: src/generate/visual/background-blend-mode.failure.test.ts ===
// b_path:: src/generate/visual/background-blend-mode.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/background-blend-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/visual/background-blend-mode";

describe("generate/visual/background-blend-mode - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "background-blend-mode",
				mode: "invalid",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"mode: Expected normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "background-blend-mode",
				mode: 123,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"mode: Expected normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
			);
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "mix-blend-mode",
				mode: "multiply",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "background-blend-mode"');
		});
	});
});


=== File: src/generate/visual/background-blend-mode.test.ts ===
// b_path:: src/generate/visual/background-blend-mode.test.ts
// Auto-generated from scripts/generate-test-generator/configs/visual/background-blend-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/visual/background-blend-mode";
import * as Parser from "@/parse/visual/background-blend-mode";

describe("generate/visual/background-blend-mode - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate normal blend mode", () => {
			const input: Type.BackgroundBlendMode = {
				kind: "background-blend-mode",
				mode: "normal",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("normal");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiply blend mode", () => {
			const input: Type.BackgroundBlendMode = {
				kind: "background-blend-mode",
				mode: "multiply",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("multiply");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate screen blend mode", () => {
			const input: Type.BackgroundBlendMode = {
				kind: "background-blend-mode",
				mode: "screen",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("screen");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate overlay blend mode", () => {
			const input: Type.BackgroundBlendMode = {
				kind: "background-blend-mode",
				mode: "overlay",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("overlay");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-advanced", () => {
		it("should generate color-dodge blend mode", () => {
			const input: Type.BackgroundBlendMode = {
				kind: "background-blend-mode",
				mode: "color-dodge",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("color-dodge");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-color", () => {
		it("should generate hue blend mode", () => {
			const input: Type.BackgroundBlendMode = {
				kind: "background-blend-mode",
				mode: "hue",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("hue");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/visual/background-blend-mode.ts ===
// b_path:: src/generate/visual/background-blend-mode.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { BackgroundBlendMode } from "@/core/types";
import { backgroundBlendModeSchema } from "@/core/types/visual";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS background-blend-mode property from IR.
 *
 * Outputs blend mode keyword value.
 *
 * @param blendMode - BackgroundBlendMode IR
 * @returns CSS string like "multiply" or "screen"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode}
 *
 * @example
 * ```typescript
 * import { generate } from "@/generate/visual/background-blend-mode";
 *
 * const css = generate({ kind: "background-blend-mode", mode: "multiply" });
 * // "multiply"
 * ```
 *
 * @public
 */
export function generate(blendMode: BackgroundBlendMode): GenerateResult {
	// Validate IR with Zod schema
	const validation = backgroundBlendModeSchema.safeParse(blendMode);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(blendMode.mode);
}

// Legacy export for backward compatibility
export const generateBackgroundBlendMode = generate;


=== File: src/generate/visual/index.ts ===
// b_path:: src/generate/visual/index.ts
export * as BackgroundBlendMode from "./background-blend-mode";
export * as MixBlendMode from "./mix-blend-mode";
export * as Opacity from "./opacity";
export * as Visibility from "./visibility";


=== File: src/generate/visual/mix-blend-mode.failure.test.ts ===
// b_path:: src/generate/visual/mix-blend-mode.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/mix-blend-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/visual/mix-blend-mode";

describe("generate/visual/mix-blend-mode - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "mix-blend-mode",
				mode: "invalid",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"mode: Expected normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "mix-blend-mode",
				mode: 123,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe(
				"mode: Expected normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity",
			);
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "background-blend-mode",
				mode: "multiply",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "mix-blend-mode"');
		});
	});
});


=== File: src/generate/visual/mix-blend-mode.test.ts ===
// b_path:: src/generate/visual/mix-blend-mode.test.ts
// Auto-generated from scripts/generate-test-generator/configs/visual/mix-blend-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/visual/mix-blend-mode";
import * as Parser from "@/parse/visual/mix-blend-mode";

describe("generate/visual/mix-blend-mode - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate normal blend mode", () => {
			const input: Type.MixBlendMode = {
				kind: "mix-blend-mode",
				mode: "normal",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("normal");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate multiply blend mode", () => {
			const input: Type.MixBlendMode = {
				kind: "mix-blend-mode",
				mode: "multiply",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("multiply");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate screen blend mode", () => {
			const input: Type.MixBlendMode = {
				kind: "mix-blend-mode",
				mode: "screen",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("screen");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate overlay blend mode", () => {
			const input: Type.MixBlendMode = {
				kind: "mix-blend-mode",
				mode: "overlay",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("overlay");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-advanced", () => {
		it("should generate color-dodge blend mode", () => {
			const input: Type.MixBlendMode = {
				kind: "mix-blend-mode",
				mode: "color-dodge",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("color-dodge");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-color", () => {
		it("should generate hue blend mode", () => {
			const input: Type.MixBlendMode = {
				kind: "mix-blend-mode",
				mode: "hue",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("hue");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/visual/mix-blend-mode.ts ===
// b_path:: src/generate/visual/mix-blend-mode.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { MixBlendMode } from "@/core/types";
import { mixBlendModeSchema } from "@/core/types/visual";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS mix-blend-mode property from IR.
 *
 * Outputs blend mode keyword value.
 *
 * @param blendMode - MixBlendMode IR
 * @returns CSS string like "screen" or "overlay"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode}
 *
 * @example
 * ```typescript
 * import { generate } from "@/generate/visual/mix-blend-mode";
 *
 * const css = generate({ kind: "mix-blend-mode", mode: "screen" });
 * // "screen"
 * ```
 *
 * @public
 */
export function generate(blendMode: MixBlendMode): GenerateResult {
	// Validate IR with Zod schema
	const validation = mixBlendModeSchema.safeParse(blendMode);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(blendMode.mode);
}

// Legacy export for backward compatibility
export const generateMixBlendMode = generate;


=== File: src/generate/visual/opacity.failure.test.ts ===
// b_path:: src/generate/visual/opacity.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/opacity.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/visual/opacity";

describe("generate/visual/opacity - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-range", () => {
		it("should reject negative value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "opacity",
				value: -1,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Too small: expected number to be >=0");
		});

		it("should reject value greater than 1", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "opacity",
				value: 2,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Too big: expected number to be <=1");
		});
	});

	describe("invalid-type", () => {
		it("should reject string value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "opacity",
				value: "0.5",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Invalid input: expected number, received string");
		});

		it("should reject null value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "opacity",
				value: null,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Invalid input: expected number, received null");
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "visibility",
				value: 0.5,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "opacity"');
		});
	});
});


=== File: src/generate/visual/opacity.test.ts ===
// b_path:: src/generate/visual/opacity.test.ts
// Auto-generated from scripts/generate-test-generator/configs/visual/opacity.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/visual/opacity";
import * as Parser from "@/parse/visual/opacity";

describe("generate/visual/opacity - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate fully transparent", () => {
			const input: Type.Opacity = {
				kind: "opacity",
				value: 0,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate fully opaque", () => {
			const input: Type.Opacity = {
				kind: "opacity",
				value: 1,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("1");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate 50% transparent", () => {
			const input: Type.Opacity = {
				kind: "opacity",
				value: 0.5,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.5");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});

	describe("valid-decimal", () => {
		it("should generate 25% transparent", () => {
			const input: Type.Opacity = {
				kind: "opacity",
				value: 0.25,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.25");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate 75% transparent", () => {
			const input: Type.Opacity = {
				kind: "opacity",
				value: 0.75,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("0.75");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/visual/opacity.ts ===
// b_path:: src/generate/visual/opacity.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { Opacity } from "@/core/types";
import { opacitySchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS opacity property from IR.
 *
 * Outputs opacity value as a number (0-1).
 *
 * @param opacity - Opacity IR
 * @returns CSS string like "0.5" or "1"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/opacity}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/opacity";
 *
 * const css = toCss({ kind: "opacity", value: 0.5 });
 * // "0.5"
 * ```
 *
 * @public
 */
export function generate(opacity: Opacity): GenerateResult {
	// Validate IR with Zod schema
	const validation = opacitySchema.safeParse(opacity);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(opacity.value.toString());
}


=== File: src/generate/visual/visibility.failure.test.ts ===
// b_path:: src/generate/visual/visibility.failure.test.ts
// Auto-generated from scripts/generate-test-generator/configs/visibility.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/visibility
import { describe, expect, it } from "vitest";
import * as Generator from "@/generate/visual/visibility";

describe("generate/visual/visibility - invalid cases", () => {
	describe("invalid-null", () => {
		it("should reject null input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = null;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received null");
		});

		it("should reject undefined input", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = undefined;
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("Invalid input: expected object, received undefined");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword auto", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "visibility",
				value: "auto",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Expected visible | hidden | collapse");
		});

		it("should reject invalid keyword none", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "visibility",
				value: "none",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Expected visible | hidden | collapse");
		});

		it("should reject display keyword", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "visibility",
				value: "block",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Expected visible | hidden | collapse");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "visibility",
				value: 0,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Expected visible | hidden | collapse");
		});

		it("should reject null value", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "visibility",
				value: null,
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe("value: Expected visible | hidden | collapse");
		});
	});

	describe("invalid-kind", () => {
		it("should reject wrong kind field", () => {
			// biome-ignore lint/suspicious/noExplicitAny: Testing invalid input
			const input: any = {
				kind: "opacity",
				value: "visible",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.issues).toHaveLength(1);
			expect(result.issues?.[0]?.message).toBe('kind: Invalid input: expected "visibility"');
		});
	});
});


=== File: src/generate/visual/visibility.test.ts ===
// b_path:: src/generate/visual/visibility.test.ts
// Auto-generated from scripts/generate-test-generator/configs/visual/visibility.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/visibility
import { describe, expect, it } from "vitest";
import type * as Type from "@/core/types";
import * as Generator from "@/generate/visual/visibility";
import * as Parser from "@/parse/visual/visibility";

describe("generate/visual/visibility - valid cases", () => {
	describe("valid-basic", () => {
		it("should generate visible keyword", () => {
			const input: Type.Visibility = {
				kind: "visibility",
				value: "visible",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("visible");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate hidden keyword", () => {
			const input: Type.Visibility = {
				kind: "visibility",
				value: "hidden",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("hidden");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});

		it("should generate collapse keyword", () => {
			const input: Type.Visibility = {
				kind: "visibility",
				value: "collapse",
			};
			const result = Generator.generate(input);
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toBe("collapse");

			// Roundtrip validation
			const parseResult = Parser.parse(result.value);
			expect(parseResult.ok).toBe(true);
			if (!parseResult.ok) return;
			expect(parseResult.value).toEqual(input);
		});
	});
});


=== File: src/generate/visual/visibility.ts ===
// b_path:: src/generate/visual/visibility.ts

import { type GenerateResult, generateOk } from "@/core/result";
import type { Visibility } from "@/core/types";
import { visibilitySchema } from "@/core/types/layout";
import { zodErrorToIssues } from "@/utils/generate";

/**
 * Generate CSS visibility property from IR.
 *
 * Outputs visibility keyword value.
 *
 * @param visibility - Visibility IR
 * @returns CSS string like "visible" or "hidden"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility}
 *
 * @example
 * ```typescript
 * import { toCss } from "@/generate/layout/visibility";
 *
 * const css = toCss({ kind: "visibility", value: "hidden" });
 * // "hidden"
 * ```
 *
 * @public
 */
export function generate(visibility: Visibility): GenerateResult {
	// Validate IR with Zod schema
	const validation = visibilitySchema.safeParse(visibility);

	if (!validation.success) {
		// Convert Zod errors to Issue array
		const issues = zodErrorToIssues(validation.error);
		return {
			ok: false,
			issues,
		};
	}

	// Generate CSS
	return generateOk(visibility.value);
}


=== File: src/index.ts ===
// b_path:: src/index.ts

/**
 * b_value - Bidirectional CSS value parser
 *
 * Parse CSS values to structured IR and generate CSS from IR.
 * Built on css-tree and Zod for type-safe, spec-compliant CSS value handling.
 *
 * @packageDocumentation
 *
 * @example
 * Parse CSS to IR:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(circle at center, red 0%, blue 100%)"
 * );
 *
 * if (result.ok) {
 *   console.log(result.value);
 * }
 * ```
 *
 * @example
 * Generate IR to CSS:
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "circle",
 *   position: { horizontal: "center", vertical: "center" },
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * });
 *
 * console.log(css);
 * // "radial-gradient(circle at center center, red 0%, blue 100%)"
 * ```
 *
 * @example
 * Round-trip transformation:
 * ```typescript
 * import { Parse, Generate } from "b_value";
 *
 * const original = "radial-gradient(circle, red, blue)";
 * const parsed = Parse.Gradient.Radial.parse(original);
 *
 * if (parsed.ok) {
 *   const generated = Generate.Gradient.Radial.toCss(parsed.value);
 *   console.log(generated === original); // true
 * }
 * ```
 */

/**
 * Core types, schemas, units, and keywords.
 *
 * Provides access to all Zod schemas and TypeScript types used for CSS value
 * intermediate representation (IR). Most users won't need to use Core directly,
 * but it's available for advanced use cases like custom validation or schema
 * composition.
 *
 * @example
 * ```typescript
 * import { Core } from "b_value";
 *
 * // Access TypeScript types
 * type RadialGradient = Core.Type.RadialGradient;
 * type ColorStop = Core.Type.ColorStop;
 *
 * // Access Zod schemas for validation
 * const result = Core.Schema.radialGradientSchema.safeParse(data);
 * ```
 */
export * as Core from "./core";
/**
 * Public API types for parsing and generation.
 *
 * @example
 * ```typescript
 * import type { ParseResult, GenerateResult, Issue, CSSPropertyName } from "b_value";
 *
 * const result: ParseResult<Color> = Parse.Color.parse("#ff0000");
 * if (result.ok) {
 *   console.log(result.value);
 * } else {
 *   console.error(result.issues);
 * }
 * ```
 */
export type {
	CSSLonghandProperty,
	CSSPropertyName,
	CSSShorthandProperty,
	GenerateResult,
	Issue,
	IssueCode,
	ParseResult,
} from "./core/result";

export {
	addIssue,
	combineResults,
	generateErr,
	generateOk,
	Issues,
	parseErr,
	parseOk,
	withWarning,
} from "./core/result";

// Export CSSValue union type and helpers
export type { CSSValue } from "./core/types/css-value";
export { isCSSValue, isUnparsedString } from "./core/types/css-value";
/**
 * CSS → IR generators (convert IR to CSS strings).
 *
 * Generators take intermediate representation (IR) objects and produce
 * spec-compliant CSS strings. All generators return strings directly
 * (no Result type needed since generation cannot fail).
 *
 * @example
 * ```typescript
 * import { Generate } from "b_value";
 *
 * const css = Generate.Gradient.Radial.toCss({
 *   kind: "radial",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * // "radial-gradient(red, blue)"
 * ```
 */
export * as Generate from "./generate";
/**
 * CSS → IR parsers (convert CSS strings to structured IR).
 *
 * Parsers take CSS strings and produce type-safe intermediate representation
 * (IR) objects. All parsers return Result<T, string> for type-safe error
 * handling without exceptions.
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(red, blue)"
 * );
 *
 * if (result.ok) {
 *   console.log(result.value); // RadialGradient IR
 * } else {
 *   console.error(result.error); // Error message
 * }
 * ```
 */
export * as Parse from "./parse";
// export { parse } = Parse.parse;
/**
 * Universal API for parsing and generating ANY CSS longhand property.
 *
 * Parse declarations like "color: red" and generate CSS from IR with property names.
 *
 * @example
 * Parse any longhand property:
 * ```typescript
 * import { parse } from "b_value";
 *
 * const result = parse("color: red");
 * if (result.ok) {
 *   console.log(result.property); // "color"
 *   console.log(result.value);    // { kind: "named", name: "red" }
 * }
 * ```
 *
 * @example
 * Generate CSS from IR:
 * ```typescript
 * import { generate } from "b_value";
 *
 * const result = generate({
 *   property: "color",
 *   value: { kind: "hex", r: 255, g: 0, b: 0 }
 * });
 * if (result.ok) {
 *   console.log(result.value); // "#ff0000"
 * }
 * ```
 *
 * @example
 * Batch parse multiple properties:
 * ```typescript
 * import { parse } from "b_value";
 *
 * const result = parse("color: red; width: 10px");
 * if (result.ok) {
 *   console.log(result.value.color);  // { kind: "named", name: "red" }
 *   console.log(result.value.width);  // { kind: "length", value: 10, unit: "px" }
 * }
 * ```
 *
 * @example
 * Batch generate CSS from properties:
 * ```typescript
 * import { generate } from "b_value";
 *
 * const css = generate({
 *   color: { kind: "hex", r: 255, g: 0, b: 0 },
 *   width: { kind: "length", value: 10, unit: "px" }
 * });
 * console.log(css); // "color: #ff0000; width: 10px"
 * ```
 *
 * @example
 * Round-trip: parse, modify, generate:
 * ```typescript
 * import { parse, generate } from "b_value";
 *
 * const parsed = parse("color: red; width: 10px");
 * if (parsed.ok) {
 *   // Modify the color
 *   parsed.value.color = { kind: "hex", r: 0, g: 255, b: 0 };
 *
 *   // Generate back to CSS
 *   const css = generate(parsed.value);
 *   console.log(css); // "color: #00ff00; width: 10px"
 * }
 * ```
 */


=== File: src/parse/animation/animation.test.ts ===
// b_path:: src/parse/animation/animation.test.ts

import { describe, expect, test } from "vitest";
import { parse } from "./animation";

describe("parse() - auto-detection", () => {
	describe("duration", () => {
		test("detects time values", () => {
			const result = parse("1s");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-duration");
		});

		test("detects auto", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-duration");
		});
	});

	describe("delay", () => {
		test("detects delay values", () => {
			const result = parse("500ms");
			expect(result.ok).toBe(true);
			// Note: Ambiguous with duration - duration takes precedence
			expect(result.value?.kind).toBe("animation-duration");
		});
	});

	describe("timing-function", () => {
		test("detects ease keywords", () => {
			const result = parse("ease-in-out");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-timing-function");
		});

		test("detects cubic-bezier", () => {
			const result = parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-timing-function");
		});

		test("detects steps", () => {
			const result = parse("steps(4, end)");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-timing-function");
		});
	});

	describe("iteration-count", () => {
		test("detects infinite", () => {
			const result = parse("infinite");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-iteration-count");
		});

		test("detects number", () => {
			const result = parse("2.5");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-iteration-count");
		});
	});

	describe("direction", () => {
		test("detects normal", () => {
			const result = parse("normal");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-direction");
		});

		test("detects alternate", () => {
			const result = parse("alternate");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-direction");
		});

		test("detects reverse", () => {
			const result = parse("reverse");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-direction");
		});
	});

	describe("fill-mode", () => {
		test("detects forwards", () => {
			const result = parse("forwards");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-fill-mode");
		});

		test("detects backwards", () => {
			const result = parse("backwards");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-fill-mode");
		});

		test("detects both", () => {
			const result = parse("both");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-fill-mode");
		});
	});

	describe("play-state", () => {
		test("detects running", () => {
			const result = parse("running");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-play-state");
		});

		test("detects paused", () => {
			const result = parse("paused");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-play-state");
		});
	});

	describe("name", () => {
		test("detects custom name", () => {
			const result = parse("slideIn");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-name");
		});

		test("none matches fill-mode first (ambiguous)", () => {
			// "none" is valid for both fill-mode and animation-name
			// fill-mode parser comes first in dispatch order
			const result = parse("none");
			expect(result.ok).toBe(true);
			expect(result.value?.kind).toBe("animation-fill-mode");
		});
	});

	describe("error handling", () => {
		test("rejects truly invalid value", () => {
			const result = parse("@invalid");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues).toHaveLength(1);
				expect(result.issues[0]?.severity).toBe("error");
				expect(result.issues[0]?.message).toContain("Invalid animation property value");
			}
		});

		test("provides helpful suggestion", () => {
			const result = parse("@bad");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.suggestion).toBeDefined();
			}
		});
	});
});


=== File: src/parse/animation/animation.ts ===
// b_path:: src/parse/animation/animation.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";
import type * as Type from "@/core/types/animation";

import * as Delay from "./delay";
import * as Direction from "./direction";
import * as Duration from "./duration";
import * as FillMode from "./fill-mode";
import * as IterationCount from "./iteration-count";
import * as Name from "./name";
import * as PlayState from "./play-state";
import * as TimingFunction from "./timing-function";

/**
 * Animation property type union.
 *
 * @public
 */
export type Animation =
	| Type.AnimationDelay
	| Type.AnimationDirection
	| Type.AnimationDuration
	| Type.AnimationFillMode
	| Type.AnimationIterationCount
	| Type.AnimationName
	| Type.AnimationPlayState
	| Type.AnimationTimingFunction;

/**
 * Parse animation property value with auto-detection.
 *
 * Attempts to parse as each animation property type in order:
 * - duration (time values, auto)
 * - delay (time values)
 * - timing-function (ease, linear, cubic-bezier, steps)
 * - iteration-count (number, infinite)
 * - direction (normal, reverse, alternate, alternate-reverse)
 * - fill-mode (none, forwards, backwards, both)
 * - play-state (running, paused)
 * - name (identifier, none)
 *
 * @param value - CSS animation property value
 * @returns ParseResult with detected animation property IR
 *
 * @example
 * ```typescript
 * parse("1s");                  // duration
 * parse("500ms");               // duration or delay (ambiguous - tries duration first)
 * parse("ease-in-out");         // timing-function
 * parse("infinite");            // iteration-count
 * parse("alternate");           // direction
 * parse("forwards");            // fill-mode
 * parse("paused");              // play-state
 * parse("slideIn");             // name
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Animation> {
	const durationResult = Duration.parse(value);
	if (durationResult.ok) return toParseResult(durationResult);

	const delayResult = Delay.parse(value);
	if (delayResult.ok) return toParseResult(delayResult);

	const timingResult = TimingFunction.parse(value);
	if (timingResult.ok) return toParseResult(timingResult);

	const iterationResult = IterationCount.parse(value);
	if (iterationResult.ok) return toParseResult(iterationResult);

	const directionResult = Direction.parse(value);
	if (directionResult.ok) return toParseResult(directionResult);

	const fillModeResult = FillMode.parse(value);
	if (fillModeResult.ok) return toParseResult(fillModeResult);

	const playStateResult = PlayState.parse(value);
	if (playStateResult.ok) return toParseResult(playStateResult);

	const nameResult = Name.parse(value);
	if (nameResult.ok) return toParseResult(nameResult);

	return parseErr("invalid-value", "Invalid animation property value", {
		suggestion:
			"Expected duration (1s, 500ms, auto), delay, timing-function, iteration-count, direction, fill-mode, play-state, or name",
	});
}


=== File: src/parse/animation/delay.failure.test.ts ===
// b_path:: src/parse/animation/delay.failure.test.ts
// Auto-generated from scripts/test-generator/configs/delay.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-delay
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/delay";

describe("parse/animation/delay - invalid cases", () => {
	describe("invalid-unit", () => {
		it("should reject length unit", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Invalid time unit: px. Expected 's' or 'ms'");
		});

		it("should reject font unit", () => {
			const result = Parser.parse("1em");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Invalid time unit: em. Expected 's' or 'ms'");
		});

		it("should reject angle unit", () => {
			const result = Parser.parse("1deg");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Invalid time unit: deg. Expected 's' or 'ms'");
		});

		it("should reject missing unit", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Expected time dimension, got: Number");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject auto keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Expected time dimension, got: Identifier");
		});

		it("should reject none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Expected time dimension, got: Identifier");
		});

		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Expected time dimension, got: Identifier");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("1s,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("1s,,2s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-delay: Empty value before comma");
		});
	});
});


=== File: src/parse/animation/delay.test.ts ===
// b_path:: src/parse/animation/delay.test.ts
// Auto-generated from scripts/parse-test-generator/configs/animation/delay.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-delay
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/delay";

describe("parse/animation/delay - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse zero delay", () => {
			const result = Parser.parse("0s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 0,
						unit: "s",
					},
				],
			});
		});

		it("should parse seconds", () => {
			const result = Parser.parse("1s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
				],
			});
		});

		it("should parse milliseconds", () => {
			const result = Parser.parse("500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 500,
						unit: "ms",
					},
				],
			});
		});

		it("should parse zero milliseconds", () => {
			const result = Parser.parse("0ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 0,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-decimal", () => {
		it("should parse decimal seconds", () => {
			const result = Parser.parse("0.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 0.5,
						unit: "s",
					},
				],
			});
		});

		it("should parse larger decimal", () => {
			const result = Parser.parse("2.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 2.5,
						unit: "s",
					},
				],
			});
		});

		it("should parse decimal milliseconds", () => {
			const result = Parser.parse("100.5ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 100.5,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-negative", () => {
		it("should parse negative seconds", () => {
			const result = Parser.parse("-1s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: -1,
						unit: "s",
					},
				],
			});
		});

		it("should parse negative milliseconds", () => {
			const result = Parser.parse("-500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: -500,
						unit: "ms",
					},
				],
			});
		});

		it("should parse negative decimal", () => {
			const result = Parser.parse("-0.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: -0.5,
						unit: "s",
					},
				],
			});
		});
	});

	describe("valid-large", () => {
		it("should parse large value", () => {
			const result = Parser.parse("3600s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 3600,
						unit: "s",
					},
				],
			});
		});

		it("should parse very large milliseconds", () => {
			const result = Parser.parse("999999ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 999999,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple delays", () => {
			const result = Parser.parse("1s, 500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
					{
						value: 500,
						unit: "ms",
					},
				],
			});
		});

		it("should parse multiple time values", () => {
			const result = Parser.parse("0s, 1s, 2s, 3s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 0,
						unit: "s",
					},
					{
						value: 1,
						unit: "s",
					},
					{
						value: 2,
						unit: "s",
					},
					{
						value: 3,
						unit: "s",
					},
				],
			});
		});

		it("should parse delays with whitespace", () => {
			const result = Parser.parse("1s , 2s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
					{
						value: 2,
						unit: "s",
					},
				],
			});
		});

		it("should parse mixed negative and positive", () => {
			const result = Parser.parse("-1s, 0s, 1s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-delay",
				delays: [
					{
						value: -1,
						unit: "s",
					},
					{
						value: 0,
						unit: "s",
					},
					{
						value: 1,
						unit: "s",
					},
				],
			});
		});
	});
});


=== File: src/parse/animation/delay.ts ===
// b_path:: src/parse/animation/delay.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse time value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with Time object or error
 *
 * @internal
 */
function parseTime(node: csstree.CssNode): Result<Type.Time, string> {
	if (node.type !== "Dimension") {
		return err(`Expected time dimension, got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);
	const unit = node.unit.toLowerCase();

	if (unit !== "s" && unit !== "ms") {
		return err(`Invalid time unit: ${unit}. Expected 's' or 'ms'`);
	}

	return ok({
		value,
		unit: unit as "s" | "ms",
	});
}

/**
 * Parse CSS animation-delay property value.
 *
 * Parses comma-separated list of time values.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-delay value (e.g., "1s, 500ms, 2s")
 * @returns Result with AnimationDelay IR or error message
 *
 * @example
 * Simple delay:
 * ```typescript
 * const result = parse("1s");
 * // { ok: true, value: { kind: "animation-delay", delays: [{ value: 1, unit: "s" }] } }
 * ```
 *
 * @example
 * Multiple delays:
 * ```typescript
 * const result = parse("1s, 500ms, 2s");
 * // { ok: true, value: { kind: "animation-delay", delays: [...] } }
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-delay | MDN: animation-delay}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-delay | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationDelay, string> {
	const delaysResult = parseCommaSeparatedSingle(css, parseTime, "animation-delay");

	if (!delaysResult.ok) {
		return err(delaysResult.error);
	}

	return ok({
		kind: "animation-delay",
		delays: delaysResult.value,
	});
}


=== File: src/parse/animation/direction.failure.test.ts ===
// b_path:: src/parse/animation/direction.failure.test.ts
// Auto-generated from scripts/test-generator/configs/direction.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-direction
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/direction";

describe("parse/animation/direction - invalid cases", () => {
	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-direction: Invalid animation-direction keyword: invalid. Expected one of: normal, reverse, alternate, alternate-reverse",
			);
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("forwards");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-direction: Invalid animation-direction keyword: forwards. Expected one of: normal, reverse, alternate, alternate-reverse",
			);
		});

		it("should reject another wrong keyword", () => {
			const result = Parser.parse("backwards");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-direction: Invalid animation-direction keyword: backwards. Expected one of: normal, reverse, alternate, alternate-reverse",
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject number", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-direction: Expected direction keyword, got: Number");
		});

		it("should reject time value", () => {
			const result = Parser.parse("1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-direction: Expected direction keyword, got: Dimension");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-direction: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("normal,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-direction: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",normal");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-direction: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("normal,,reverse");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-direction: Empty value before comma");
		});
	});
});


=== File: src/parse/animation/direction.test.ts ===
// b_path:: src/parse/animation/direction.test.ts
// Auto-generated from scripts/parse-test-generator/configs/animation/direction.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-direction
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/direction";

describe("parse/animation/direction - valid cases", () => {
	describe("valid-keyword", () => {
		it("should parse normal keyword", () => {
			const result = Parser.parse("normal");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["normal"],
			});
		});

		it("should parse reverse keyword", () => {
			const result = Parser.parse("reverse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["reverse"],
			});
		});

		it("should parse alternate keyword", () => {
			const result = Parser.parse("alternate");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["alternate"],
			});
		});

		it("should parse alternate-reverse keyword", () => {
			const result = Parser.parse("alternate-reverse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["alternate-reverse"],
			});
		});

		it("should parse case insensitive", () => {
			const result = Parser.parse("NORMAL");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["normal"],
			});
		});

		it("should parse mixed case", () => {
			const result = Parser.parse("Alternate");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["alternate"],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple keywords", () => {
			const result = Parser.parse("normal, reverse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["normal", "reverse"],
			});
		});

		it("should parse three keywords", () => {
			const result = Parser.parse("alternate, normal, reverse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["alternate", "normal", "reverse"],
			});
		});

		it("should parse list with whitespace", () => {
			const result = Parser.parse("normal , reverse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-direction",
				directions: ["normal", "reverse"],
			});
		});
	});
});


=== File: src/parse/animation/direction.ts ===
// b_path:: src/parse/animation/direction.ts
import type * as csstree from "css-tree";
import { ANIMATION_DIRECTION_KEYWORDS } from "@/core/keywords/animation";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse direction keyword from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with direction keyword or error
 *
 * @internal
 */
function parseDirection(node: csstree.CssNode): Result<Type.AnimationDirection["directions"][number], string> {
	if (node.type !== "Identifier") {
		return err(`Expected direction keyword, got: ${node.type}`);
	}

	const keyword = node.name.toLowerCase();
	if (!ANIMATION_DIRECTION_KEYWORDS.includes(keyword as (typeof ANIMATION_DIRECTION_KEYWORDS)[number])) {
		return err(
			`Invalid animation-direction keyword: ${keyword}. Expected one of: ${ANIMATION_DIRECTION_KEYWORDS.join(", ")}`,
		);
	}

	return ok(keyword as Type.AnimationDirection["directions"][number]);
}

/**
 * Parse CSS animation-direction property value.
 *
 * Parses comma-separated list of direction keywords.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-direction value (e.g., "normal, reverse, alternate")
 * @returns Result with AnimationDirection IR or error message
 *
 * @example
 * Single direction:
 * ```typescript
 * const result = parse("normal");
 * // { ok: true, value: { kind: "animation-direction", directions: ["normal"] } }
 * ```
 *
 * @example
 * Multiple directions:
 * ```typescript
 * const result = parse("normal, reverse, alternate");
 * // { ok: true, value: { kind: "animation-direction", directions: ["normal", "reverse", "alternate"] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction | MDN: animation-direction}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-direction | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationDirection, string> {
	const directionsResult = parseCommaSeparatedSingle(css, parseDirection, "animation-direction");

	if (!directionsResult.ok) {
		return err(directionsResult.error);
	}

	return ok({
		kind: "animation-direction",
		directions: directionsResult.value,
	});
}


=== File: src/parse/animation/duration.failure.test.ts ===
// b_path:: src/parse/animation/duration.failure.test.ts
// Auto-generated from scripts/test-generator/configs/duration.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-duration
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/duration";

describe("parse/animation/duration - invalid cases", () => {
	describe("invalid-negative", () => {
		it("should reject negative duration", () => {
			const result = Parser.parse("-1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: animation-duration must be non-negative, got: -1");
		});

		it("should reject negative milliseconds", () => {
			const result = Parser.parse("-500ms");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: animation-duration must be non-negative, got: -500");
		});
	});

	describe("invalid-unit", () => {
		it("should reject invalid unit", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Invalid time unit: px. Expected 's' or 'ms'");
		});

		it("should reject wrong unit type", () => {
			const result = Parser.parse("1em");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Invalid time unit: em. Expected 's' or 'ms'");
		});

		it("should reject missing unit", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Expected time dimension or 'auto', got: Number");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("1s,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("1s,,2s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Empty value before comma");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Expected time dimension or 'auto', got: Identifier");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-duration: Expected time dimension or 'auto', got: Identifier");
		});
	});
});


=== File: src/parse/animation/duration.test.ts ===
// b_path:: src/parse/animation/duration.test.ts
// Auto-generated from scripts/parse-test-generator/configs/animation/duration.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-duration
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/duration";

describe("parse/animation/duration - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse single time value in seconds", () => {
			const result = Parser.parse("1s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "s",
					},
				],
			});
		});

		it("should parse single time value in milliseconds", () => {
			const result = Parser.parse("500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 500,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-keyword", () => {
		it("should parse auto keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "auto",
					},
				],
			});
		});

		it("should parse case insensitive auto", () => {
			const result = Parser.parse("AUTO");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "auto",
					},
				],
			});
		});
	});

	describe("valid-edge", () => {
		it("should parse zero duration", () => {
			const result = Parser.parse("0s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 0,
						unit: "s",
					},
				],
			});
		});

		it("should parse zero duration in ms", () => {
			const result = Parser.parse("0ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 0,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-decimal", () => {
		it("should parse decimal values", () => {
			const result = Parser.parse("0.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 0.5,
						unit: "s",
					},
				],
			});
		});

		it("should parse decimal seconds", () => {
			const result = Parser.parse("2.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 2.5,
						unit: "s",
					},
				],
			});
		});

		it("should parse decimal milliseconds", () => {
			const result = Parser.parse("100.5ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 100.5,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-large", () => {
		it("should parse large values", () => {
			const result = Parser.parse("3600s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 3600,
						unit: "s",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple durations", () => {
			const result = Parser.parse("1s, auto, 500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "s",
					},
					{
						type: "auto",
					},
					{
						type: "time",
						value: 500,
						unit: "ms",
					},
				],
			});
		});

		it("should parse durations with whitespace", () => {
			const result = Parser.parse("1s , auto , 2s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "s",
					},
					{
						type: "auto",
					},
					{
						type: "time",
						value: 2,
						unit: "s",
					},
				],
			});
		});

		it("should parse multiple time values", () => {
			const result = Parser.parse("1s, 2s, 3s, 4s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-duration",
				durations: [
					{
						type: "time",
						value: 1,
						unit: "s",
					},
					{
						type: "time",
						value: 2,
						unit: "s",
					},
					{
						type: "time",
						value: 3,
						unit: "s",
					},
					{
						type: "time",
						value: 4,
						unit: "s",
					},
				],
			});
		});
	});
});


=== File: src/parse/animation/duration.ts ===
// b_path:: src/parse/animation/duration.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse duration value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with duration object or error
 *
 * @internal
 */
function parseDuration(node: csstree.CssNode): Result<{ type: "auto" } | (Type.Time & { type: "time" }), string> {
	if (node.type === "Identifier" && node.name.toLowerCase() === "auto") {
		return ok({ type: "auto" as const });
	}

	if (node.type !== "Dimension") {
		return err(`Expected time dimension or 'auto', got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);
	const unit = node.unit.toLowerCase();

	if (unit !== "s" && unit !== "ms") {
		return err(`Invalid time unit: ${unit}. Expected 's' or 'ms'`);
	}

	if (value < 0) {
		return err(`animation-duration must be non-negative, got: ${value}`);
	}

	return ok({
		type: "time" as const,
		value,
		unit: unit as "s" | "ms",
	});
}

/**
 * Parse CSS animation-duration property value.
 *
 * Parses comma-separated list of time values or 'auto'.
 * Time values must be non-negative.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-duration value (e.g., "1s, auto, 500ms")
 * @returns Result with AnimationDuration IR or error message
 *
 * @example
 * Simple duration:
 * ```typescript
 * const result = parse("1s");
 * // { ok: true, value: { kind: "animation-duration", durations: [{ type: "time", value: 1, unit: "s" }] } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "animation-duration", durations: [{ type: "auto" }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-duration | MDN: animation-duration}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-duration | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationDuration, string> {
	const durationsResult = parseCommaSeparatedSingle(css, parseDuration, "animation-duration");

	if (!durationsResult.ok) {
		return err(durationsResult.error);
	}

	return ok({
		kind: "animation-duration",
		durations: durationsResult.value,
	});
}


=== File: src/parse/animation/fill-mode.failure.test.ts ===
// b_path:: src/parse/animation/fill-mode.failure.test.ts
// Auto-generated from scripts/test-generator/configs/fill-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-fill-mode
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/fill-mode";

describe("parse/animation/fill-mode - invalid cases", () => {
	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-fill-mode: Invalid animation-fill-mode keyword: invalid. Expected one of: none, forwards, backwards, both",
			);
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("normal");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-fill-mode: Invalid animation-fill-mode keyword: normal. Expected one of: none, forwards, backwards, both",
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject number", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-fill-mode: Expected fill mode keyword, got: Number");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-fill-mode: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("none,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-fill-mode: Empty value");
		});
	});
});


=== File: src/parse/animation/fill-mode.test.ts ===
// b_path:: src/parse/animation/fill-mode.test.ts
// Auto-generated from scripts/parse-test-generator/configs/animation/fill-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-fill-mode
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/fill-mode";

describe("parse/animation/fill-mode - valid cases", () => {
	describe("valid-keyword", () => {
		it("should parse none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-fill-mode",
				modes: ["none"],
			});
		});

		it("should parse forwards keyword", () => {
			const result = Parser.parse("forwards");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-fill-mode",
				modes: ["forwards"],
			});
		});

		it("should parse backwards keyword", () => {
			const result = Parser.parse("backwards");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-fill-mode",
				modes: ["backwards"],
			});
		});

		it("should parse both keyword", () => {
			const result = Parser.parse("both");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-fill-mode",
				modes: ["both"],
			});
		});

		it("should parse case insensitive", () => {
			const result = Parser.parse("NONE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-fill-mode",
				modes: ["none"],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple keywords", () => {
			const result = Parser.parse("none, forwards");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-fill-mode",
				modes: ["none", "forwards"],
			});
		});

		it("should parse three keywords", () => {
			const result = Parser.parse("forwards, backwards, both");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-fill-mode",
				modes: ["forwards", "backwards", "both"],
			});
		});
	});
});


=== File: src/parse/animation/fill-mode.ts ===
// b_path:: src/parse/animation/fill-mode.ts
import type * as csstree from "css-tree";
import { ANIMATION_FILL_MODE_KEYWORDS } from "@/core/keywords/animation";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse fill mode keyword from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with fill mode keyword or error
 *
 * @internal
 */
function parseFillMode(node: csstree.CssNode): Result<Type.AnimationFillMode["modes"][number], string> {
	if (node.type !== "Identifier") {
		return err(`Expected fill mode keyword, got: ${node.type}`);
	}

	const keyword = node.name.toLowerCase();
	if (!ANIMATION_FILL_MODE_KEYWORDS.includes(keyword as (typeof ANIMATION_FILL_MODE_KEYWORDS)[number])) {
		return err(
			`Invalid animation-fill-mode keyword: ${keyword}. Expected one of: ${ANIMATION_FILL_MODE_KEYWORDS.join(", ")}`,
		);
	}

	return ok(keyword as Type.AnimationFillMode["modes"][number]);
}

/**
 * Parse CSS animation-fill-mode property value.
 *
 * Parses comma-separated list of fill mode keywords.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-fill-mode value (e.g., "none, forwards, both")
 * @returns Result with AnimationFillMode IR or error message
 *
 * @example
 * Single fill mode:
 * ```typescript
 * const result = parse("forwards");
 * // { ok: true, value: { kind: "animation-fill-mode", modes: ["forwards"] } }
 * ```
 *
 * @example
 * Multiple fill modes:
 * ```typescript
 * const result = parse("none, forwards, both");
 * // { ok: true, value: { kind: "animation-fill-mode", modes: ["none", "forwards", "both"] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode | MDN: animation-fill-mode}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-fill-mode | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationFillMode, string> {
	const modesResult = parseCommaSeparatedSingle(css, parseFillMode, "animation-fill-mode");

	if (!modesResult.ok) {
		return err(modesResult.error);
	}

	return ok({
		kind: "animation-fill-mode",
		modes: modesResult.value,
	});
}


=== File: src/parse/animation/index.ts ===
// b_path:: src/parse/animation/index.ts

export { parse } from "./animation";

export * as Delay from "./delay";
export * as Direction from "./direction";
export * as Duration from "./duration";
export * as FillMode from "./fill-mode";
export * as IterationCount from "./iteration-count";
export * as Name from "./name";
export * as PlayState from "./play-state";
export * as TimingFunction from "./timing-function";


=== File: src/parse/animation/iteration-count.failure.test.ts ===
// b_path:: src/parse/animation/iteration-count.failure.test.ts
// Auto-generated from scripts/test-generator/configs/iteration-count.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-iteration-count
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/iteration-count";

describe("parse/animation/iteration-count - invalid cases", () => {
	describe("invalid-negative", () => {
		it("should reject negative count", () => {
			const result = Parser.parse("-1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: animation-iteration-count must be non-negative, got: -1");
		});

		it("should reject negative decimal", () => {
			const result = Parser.parse("-0.5");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: animation-iteration-count must be non-negative, got: -0.5");
		});
	});

	describe("invalid-unit", () => {
		it("should reject time unit", () => {
			const result = Parser.parse("1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Expected number or 'infinite', got: Dimension");
		});

		it("should reject length unit", () => {
			const result = Parser.parse("2px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Expected number or 'infinite', got: Dimension");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject auto keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Expected number or 'infinite', got: Identifier");
		});

		it("should reject none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Expected number or 'infinite', got: Identifier");
		});

		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Expected number or 'infinite', got: Identifier");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("1,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("1,,2");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-iteration-count: Empty value before comma");
		});
	});
});


=== File: src/parse/animation/iteration-count.test.ts ===
// b_path:: src/parse/animation/iteration-count.test.ts
// Auto-generated from scripts/parse-test-generator/configs/animation/iteration-count.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-iteration-count
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/iteration-count";

describe("parse/animation/iteration-count - valid cases", () => {
	describe("valid-number", () => {
		it("should parse integer", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 1,
					},
				],
			});
		});

		it("should parse zero", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 0,
					},
				],
			});
		});

		it("should parse multiple iterations", () => {
			const result = Parser.parse("3");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 3,
					},
				],
			});
		});

		it("should parse larger count", () => {
			const result = Parser.parse("10");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 10,
					},
				],
			});
		});
	});

	describe("valid-decimal", () => {
		it("should parse half iteration", () => {
			const result = Parser.parse("0.5");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 0.5,
					},
				],
			});
		});

		it("should parse decimal iterations", () => {
			const result = Parser.parse("2.5");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 2.5,
					},
				],
			});
		});

		it("should parse small decimal", () => {
			const result = Parser.parse("0.1");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 0.1,
					},
				],
			});
		});
	});

	describe("valid-keyword", () => {
		it("should parse infinite keyword", () => {
			const result = Parser.parse("infinite");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "infinite",
					},
				],
			});
		});

		it("should parse case insensitive", () => {
			const result = Parser.parse("INFINITE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "infinite",
					},
				],
			});
		});

		it("should parse mixed case", () => {
			const result = Parser.parse("Infinite");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "infinite",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple numbers", () => {
			const result = Parser.parse("1, 2, 3");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 1,
					},
					{
						type: "number",
						value: 2,
					},
					{
						type: "number",
						value: 3,
					},
				],
			});
		});

		it("should parse infinite with number", () => {
			const result = Parser.parse("infinite, 2");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "infinite",
					},
					{
						type: "number",
						value: 2,
					},
				],
			});
		});

		it("should parse mixed values", () => {
			const result = Parser.parse("1, infinite, 0.5");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 1,
					},
					{
						type: "infinite",
					},
					{
						type: "number",
						value: 0.5,
					},
				],
			});
		});

		it("should parse list with whitespace", () => {
			const result = Parser.parse("1 , 2");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-iteration-count",
				counts: [
					{
						type: "number",
						value: 1,
					},
					{
						type: "number",
						value: 2,
					},
				],
			});
		});
	});
});


=== File: src/parse/animation/iteration-count.ts ===
// b_path:: src/parse/animation/iteration-count.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse iteration count value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with iteration count object or error
 *
 * @internal
 */
function parseIterationCount(
	node: csstree.CssNode,
): Result<{ type: "infinite" } | { type: "number"; value: number }, string> {
	if (node.type === "Identifier" && node.name.toLowerCase() === "infinite") {
		return ok({ type: "infinite" as const });
	}

	if (node.type !== "Number") {
		return err(`Expected number or 'infinite', got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);

	if (value < 0) {
		return err(`animation-iteration-count must be non-negative, got: ${value}`);
	}

	return ok({
		type: "number" as const,
		value,
	});
}

/**
 * Parse CSS animation-iteration-count property value.
 *
 * Parses comma-separated list of numbers or 'infinite'.
 * Number values must be non-negative.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-iteration-count value (e.g., "infinite, 2, 0.5")
 * @returns Result with AnimationIterationCount IR or error message
 *
 * @example
 * Number count:
 * ```typescript
 * const result = parse("3");
 * // { ok: true, value: { kind: "animation-iteration-count", counts: [{ type: "number", value: 3 }] } }
 * ```
 *
 * @example
 * Infinite keyword:
 * ```typescript
 * const result = parse("infinite");
 * // { ok: true, value: { kind: "animation-iteration-count", counts: [{ type: "infinite" }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-iteration-count | MDN: animation-iteration-count}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-iteration-count | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationIterationCount, string> {
	const countsResult = parseCommaSeparatedSingle(css, parseIterationCount, "animation-iteration-count");

	if (!countsResult.ok) {
		return err(countsResult.error);
	}

	return ok({
		kind: "animation-iteration-count",
		counts: countsResult.value,
	});
}


=== File: src/parse/animation/name.failure.test.ts ===
// b_path:: src/parse/animation/name.failure.test.ts
// Auto-generated from scripts/test-generator/configs/name.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-name
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/name";

describe("parse/animation/name - invalid cases", () => {
	describe("invalid-type", () => {
		it("should reject number", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-name: Expected identifier or 'none', got: Number");
		});

		it("should reject time value", () => {
			const result = Parser.parse("1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-name: Expected identifier or 'none', got: Dimension");
		});

		it("should reject length value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-name: Expected identifier or 'none', got: Dimension");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-name: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("slideIn,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-name: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",slideIn");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-name: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("a,,b");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-name: Empty value before comma");
		});
	});
});


=== File: src/parse/animation/name.test.ts ===
// b_path:: src/parse/animation/name.test.ts
// Auto-generated from scripts/parse-test-generator/configs/animation/name.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-name
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/name";

describe("parse/animation/name - valid cases", () => {
	describe("valid-identifier", () => {
		it("should parse simple identifier", () => {
			const result = Parser.parse("slideIn");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "slideIn",
					},
				],
			});
		});

		it("should parse camelCase identifier", () => {
			const result = Parser.parse("fadeOut");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "fadeOut",
					},
				],
			});
		});

		it("should parse hyphenated identifier", () => {
			const result = Parser.parse("my-animation");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "my-animation",
					},
				],
			});
		});

		it("should parse underscore identifier", () => {
			const result = Parser.parse("_animation");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "_animation",
					},
				],
			});
		});

		it("should parse identifier with numbers", () => {
			const result = Parser.parse("animation123");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "animation123",
					},
				],
			});
		});
	});

	describe("valid-keyword", () => {
		it("should parse none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "none",
					},
				],
			});
		});

		it("should parse case insensitive none", () => {
			const result = Parser.parse("NONE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "none",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple names", () => {
			const result = Parser.parse("slideIn, fadeOut");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "slideIn",
					},
					{
						type: "identifier",
						value: "fadeOut",
					},
				],
			});
		});

		it("should parse none with identifier", () => {
			const result = Parser.parse("none, slideIn");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "none",
					},
					{
						type: "identifier",
						value: "slideIn",
					},
				],
			});
		});

		it("should parse short names", () => {
			const result = Parser.parse("a, b, c");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-name",
				names: [
					{
						type: "identifier",
						value: "a",
					},
					{
						type: "identifier",
						value: "b",
					},
					{
						type: "identifier",
						value: "c",
					},
				],
			});
		});
	});
});


=== File: src/parse/animation/name.ts ===
// b_path:: src/parse/animation/name.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse animation name from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with animation name object or error
 *
 * @internal
 */
function parseAnimationName(
	node: csstree.CssNode,
): Result<{ type: "none" } | { type: "identifier"; value: string }, string> {
	if (node.type !== "Identifier") {
		return err(`Expected identifier or 'none', got: ${node.type}`);
	}

	const name = node.name;

	if (name.toLowerCase() === "none") {
		return ok({ type: "none" as const });
	}

	return ok({
		type: "identifier" as const,
		value: name,
	});
}

/**
 * Parse CSS animation-name property value.
 *
 * Parses comma-separated list of keyframe names or 'none'.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-name value (e.g., "slideIn, fadeOut")
 * @returns Result with AnimationName IR or error message
 *
 * @example
 * Single name:
 * ```typescript
 * const result = parse("slideIn");
 * // { ok: true, value: { kind: "animation-name", names: [{ type: "identifier", value: "slideIn" }] } }
 * ```
 *
 * @example
 * None keyword:
 * ```typescript
 * const result = parse("none");
 * // { ok: true, value: { kind: "animation-name", names: [{ type: "none" }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-name | MDN: animation-name}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-name | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationName, string> {
	const namesResult = parseCommaSeparatedSingle(css, parseAnimationName, "animation-name");

	if (!namesResult.ok) {
		return err(namesResult.error);
	}

	return ok({
		kind: "animation-name",
		names: namesResult.value,
	});
}


=== File: src/parse/animation/play-state.failure.test.ts ===
// b_path:: src/parse/animation/play-state.failure.test.ts
// Auto-generated from scripts/test-generator/configs/play-state.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-play-state
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/play-state";

describe("parse/animation/play-state - invalid cases", () => {
	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-play-state: Invalid animation-play-state keyword: invalid. Expected one of: running, paused",
			);
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("stopped");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-play-state: Invalid animation-play-state keyword: stopped. Expected one of: running, paused",
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject number", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-play-state: Expected play state keyword, got: Number");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-play-state: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("running,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-play-state: Empty value");
		});
	});
});


=== File: src/parse/animation/play-state.test.ts ===
// b_path:: src/parse/animation/play-state.test.ts
// Auto-generated from scripts/parse-test-generator/configs/animation/play-state.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-play-state
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/play-state";

describe("parse/animation/play-state - valid cases", () => {
	describe("valid-keyword", () => {
		it("should parse running keyword", () => {
			const result = Parser.parse("running");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-play-state",
				states: ["running"],
			});
		});

		it("should parse paused keyword", () => {
			const result = Parser.parse("paused");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-play-state",
				states: ["paused"],
			});
		});

		it("should parse case insensitive", () => {
			const result = Parser.parse("RUNNING");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-play-state",
				states: ["running"],
			});
		});

		it("should parse mixed case", () => {
			const result = Parser.parse("Paused");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-play-state",
				states: ["paused"],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple keywords", () => {
			const result = Parser.parse("running, paused");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-play-state",
				states: ["running", "paused"],
			});
		});

		it("should parse three keywords", () => {
			const result = Parser.parse("paused, running, paused");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-play-state",
				states: ["paused", "running", "paused"],
			});
		});
	});
});


=== File: src/parse/animation/play-state.ts ===
// b_path:: src/parse/animation/play-state.ts
import type * as csstree from "css-tree";
import { ANIMATION_PLAY_STATE_KEYWORDS } from "@/core/keywords/animation";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse play state keyword from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with play state keyword or error
 *
 * @internal
 */
function parsePlayState(node: csstree.CssNode): Result<Type.AnimationPlayState["states"][number], string> {
	if (node.type !== "Identifier") {
		return err(`Expected play state keyword, got: ${node.type}`);
	}

	const keyword = node.name.toLowerCase();
	if (!ANIMATION_PLAY_STATE_KEYWORDS.includes(keyword as (typeof ANIMATION_PLAY_STATE_KEYWORDS)[number])) {
		return err(
			`Invalid animation-play-state keyword: ${keyword}. Expected one of: ${ANIMATION_PLAY_STATE_KEYWORDS.join(", ")}`,
		);
	}

	return ok(keyword as Type.AnimationPlayState["states"][number]);
}

/**
 * Parse CSS animation-play-state property value.
 *
 * Parses comma-separated list of play state keywords.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-play-state value (e.g., "running, paused")
 * @returns Result with AnimationPlayState IR or error message
 *
 * @example
 * Single play state:
 * ```typescript
 * const result = parse("running");
 * // { ok: true, value: { kind: "animation-play-state", states: ["running"] } }
 * ```
 *
 * @example
 * Multiple play states:
 * ```typescript
 * const result = parse("running, paused");
 * // { ok: true, value: { kind: "animation-play-state", states: ["running", "paused"] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-play-state | MDN: animation-play-state}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-play-state | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationPlayState, string> {
	const statesResult = parseCommaSeparatedSingle(css, parsePlayState, "animation-play-state");

	if (!statesResult.ok) {
		return err(statesResult.error);
	}

	return ok({
		kind: "animation-play-state",
		states: statesResult.value,
	});
}


=== File: src/parse/animation/timing-function.failure.test.ts ===
// b_path:: src/parse/animation/timing-function.failure.test.ts
// Auto-generated from scripts/test-generator/configs/timing-function.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-timing-function
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/timing-function";

describe("parse/animation/timing-function - invalid cases", () => {
	describe("invalid-bezier", () => {
		it("should reject bezier X1 out of range", () => {
			const result = Parser.parse("cubic-bezier(-1, 0, 1, 1)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-timing-function: cubic-bezier validation failed: x1 Too small: expected number to be >=0",
			);
		});

		it("should reject bezier X2 out of range", () => {
			const result = Parser.parse("cubic-bezier(0, 0, 2, 1)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-timing-function: cubic-bezier validation failed: x2 Too big: expected number to be <=1",
			);
		});

		it("should reject bezier X2 above 1", () => {
			const result = Parser.parse("cubic-bezier(0.5, 0, 1.5, 1)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"animation-timing-function: cubic-bezier validation failed: x2 Too big: expected number to be <=1",
			);
		});

		it("should reject bezier missing arguments", () => {
			const result = Parser.parse("cubic-bezier(0, 0)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: cubic-bezier requires exactly 4 numbers, got 2");
		});

		it("should reject bezier too many arguments", () => {
			const result = Parser.parse("cubic-bezier(0, 0, 1, 1, 0)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: cubic-bezier requires exactly 4 numbers, got 5");
		});
	});

	describe("invalid-steps", () => {
		it("should reject zero steps", () => {
			const result = Parser.parse("steps(0)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: steps() requires a positive integer, got 0");
		});

		it("should reject negative steps", () => {
			const result = Parser.parse("steps(-1)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: steps() requires a positive integer, got -1");
		});

		it("should reject fractional steps", () => {
			const result = Parser.parse("steps(1.5)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: steps() requires a positive integer, got 1.5");
		});

		it("should reject steps missing argument", () => {
			const result = Parser.parse("steps()");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: steps() requires a step count");
		});

		it("should reject steps invalid position", () => {
			const result = Parser.parse("steps(2, invalid)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: Invalid step position keyword: invalid");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: Invalid easing keyword: invalid");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: Invalid easing keyword: none");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("ease,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",ease");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("ease,,linear");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("animation-timing-function: Empty value before comma");
		});
	});
});


=== File: src/parse/animation/timing-function.test.ts ===
// b_path:: src/parse/animation/timing-function.test.ts
// Auto-generated from scripts/parse-test-generator/configs/animation/timing-function.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function
// - W3C: https://www.w3.org/TR/css-animations-1/#animation-timing-function
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/animation/timing-function";

describe("parse/animation/timing-function - valid cases", () => {
	describe("valid-keyword", () => {
		it("should parse ease keyword", () => {
			const result = Parser.parse("ease");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["ease"],
			});
		});

		it("should parse linear keyword", () => {
			const result = Parser.parse("linear");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["linear"],
			});
		});

		it("should parse ease-in keyword", () => {
			const result = Parser.parse("ease-in");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["ease-in"],
			});
		});

		it("should parse ease-out keyword", () => {
			const result = Parser.parse("ease-out");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["ease-out"],
			});
		});

		it("should parse ease-in-out keyword", () => {
			const result = Parser.parse("ease-in-out");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["ease-in-out"],
			});
		});

		it("should parse step-start keyword", () => {
			const result = Parser.parse("step-start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["step-start"],
			});
		});

		it("should parse step-end keyword", () => {
			const result = Parser.parse("step-end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["step-end"],
			});
		});

		it("should parse case insensitive keyword", () => {
			const result = Parser.parse("EASE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["ease"],
			});
		});
	});

	describe("valid-bezier", () => {
		it("should parse basic bezier", () => {
			const result = Parser.parse("cubic-bezier(0, 0, 1, 1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0,
						y1: 0,
						x2: 1,
						y2: 1,
					},
				],
			});
		});

		it("should parse custom bezier", () => {
			const result = Parser.parse("cubic-bezier(0.42, 0, 0.58, 1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0.42,
						y1: 0,
						x2: 0.58,
						y2: 1,
					},
				],
			});
		});

		it("should parse bezier with Y outside 0-1", () => {
			const result = Parser.parse("cubic-bezier(0, -2, 1, 3)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0,
						y1: -2,
						x2: 1,
						y2: 3,
					},
				],
			});
		});

		it("should parse ease bezier values", () => {
			const result = Parser.parse("cubic-bezier(0.25, 0.1, 0.25, 1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0.25,
						y1: 0.1,
						x2: 0.25,
						y2: 1,
					},
				],
			});
		});

		it("should parse reverse bezier", () => {
			const result = Parser.parse("cubic-bezier(1, 0, 0, 1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 1,
						y1: 0,
						x2: 0,
						y2: 1,
					},
				],
			});
		});
	});

	describe("valid-steps", () => {
		it("should parse single step", () => {
			const result = Parser.parse("steps(1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 1,
					},
				],
			});
		});

		it("should parse multiple steps", () => {
			const result = Parser.parse("steps(4)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 4,
					},
				],
			});
		});

		it("should parse steps with jump-start", () => {
			const result = Parser.parse("steps(4, jump-start)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 4,
						position: "jump-start",
					},
				],
			});
		});

		it("should parse steps with jump-end", () => {
			const result = Parser.parse("steps(10, jump-end)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 10,
						position: "jump-end",
					},
				],
			});
		});

		it("should parse steps with jump-none", () => {
			const result = Parser.parse("steps(5, jump-none)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 5,
						position: "jump-none",
					},
				],
			});
		});

		it("should parse steps with jump-both", () => {
			const result = Parser.parse("steps(3, jump-both)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 3,
						position: "jump-both",
					},
				],
			});
		});

		it("should parse steps with legacy start", () => {
			const result = Parser.parse("steps(2, start)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 2,
						position: "start",
					},
				],
			});
		});

		it("should parse steps with legacy end", () => {
			const result = Parser.parse("steps(2, end)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					{
						type: "steps",
						steps: 2,
						position: "end",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple keywords", () => {
			const result = Parser.parse("ease, linear");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["ease", "linear"],
			});
		});

		it("should parse mixed functions", () => {
			const result = Parser.parse("ease-in, cubic-bezier(0, 0, 1, 1), steps(2)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: [
					"ease-in",
					{
						type: "cubic-bezier",
						x1: 0,
						y1: 0,
						x2: 1,
						y2: 1,
					},
					{
						type: "steps",
						steps: 2,
					},
				],
			});
		});

		it("should parse list with whitespace", () => {
			const result = Parser.parse("ease , linear");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "animation-timing-function",
				functions: ["ease", "linear"],
			});
		});
	});
});


=== File: src/parse/animation/timing-function.ts ===
// b_path:: src/parse/animation/timing-function.ts
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";
import { parseEasingFunction } from "@/utils/parse/easing";

/**
 * Parse CSS animation-timing-function property value.
 *
 * Parses comma-separated list of easing functions.
 *
 * Per CSS Animations Level 1 specification.
 *
 * @param css - CSS animation-timing-function value (e.g., "ease-in, cubic-bezier(0.1, 0.7, 1.0, 0.1)")
 * @returns Result with AnimationTimingFunction IR or error message
 *
 * @example
 * Keyword:
 * ```typescript
 * const result = parse("ease-in");
 * // { ok: true, value: { kind: "animation-timing-function", functions: ["ease-in"] } }
 * ```
 *
 * @example
 * Cubic bezier:
 * ```typescript
 * const result = parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)");
 * // { ok: true, value: { kind: "animation-timing-function", functions: [{ type: "cubic-bezier", x1: 0.1, ... }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/animation-timing-function | MDN: animation-timing-function}
 * @see {@link https://www.w3.org/TR/css-animations-1/#animation-timing-function | W3C Spec}
 */
export function parse(css: string): Result<Type.AnimationTimingFunction, string> {
	const functionsResult = parseCommaSeparatedSingle(css, parseEasingFunction, "animation-timing-function");

	if (!functionsResult.ok) {
		return err(functionsResult.error);
	}

	return ok({
		kind: "animation-timing-function",
		functions: functionsResult.value,
	});
}


=== File: src/parse/background/attachment.test.ts ===
// b_path:: src/parse/background/attachment.test.ts

import { describe, expect, it } from "vitest";
import * as Attachment from "./attachment";

describe("parse/background/attachment", () => {
	describe("valid values", () => {
		it("parses scroll", () => {
			const result = Attachment.parse("scroll");
			expect(result).toEqual({ ok: true, value: "scroll", error: undefined });
		});

		it("parses fixed", () => {
			const result = Attachment.parse("fixed");
			expect(result).toEqual({ ok: true, value: "fixed", error: undefined });
		});

		it("parses local", () => {
			const result = Attachment.parse("local");
			expect(result).toEqual({ ok: true, value: "local", error: undefined });
		});
	});

	describe("normalization", () => {
		it("handles whitespace", () => {
			const result = Attachment.parse("  fixed  ");
			expect(result).toEqual({ ok: true, value: "fixed", error: undefined });
		});
	});

	describe("invalid values", () => {
		it("rejects invalid keyword", () => {
			const result = Attachment.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = Attachment.parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/background/attachment.ts ===
// b_path:: src/parse/background/attachment.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse background-attachment value.
 *
 * Parses CSS background-attachment values that control whether a background
 * image's position is fixed within the viewport, or scrolls with its containing block.
 *
 * Valid values: scroll | fixed | local
 *
 * @param css - CSS string containing background-attachment value
 * @returns Result containing BackgroundAttachmentKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Attachment.parse("fixed");
 * if (result.ok) {
 *   console.log(result.value); // "fixed"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment | MDN: background-attachment}
 */
export function parse(css: string): Result<Keyword.BackgroundAttachmentKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.backgroundAttachmentKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid background-attachment value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/background/background.test.ts ===
// b_path:: src/parse/background/background.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./background";

describe("parse background dispatcher", () => {
	describe("dispatches to Size parser", () => {
		it("parses cover", () => {
			const result = parse("cover");
			expect(result.ok).toBe(true);
		});

		it("parses contain", () => {
			const result = parse("contain");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Repeat parser", () => {
		it("parses repeat-x", () => {
			const result = parse("repeat-x");
			expect(result.ok).toBe(true);
		});

		it("parses no-repeat", () => {
			const result = parse("no-repeat");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Attachment parser", () => {
		it("parses fixed", () => {
			const result = parse("fixed");
			expect(result.ok).toBe(true);
		});

		it("parses scroll", () => {
			const result = parse("scroll");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Clip parser", () => {
		it("parses border-box", () => {
			const result = parse("border-box");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Origin parser", () => {
		it("parses padding-box", () => {
			const result = parse("padding-box");
			expect(result.ok).toBe(true);
		});
	});

	describe("error handling", () => {
		it("rejects invalid value", () => {
			const result = parse("invalid-background-xyz");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues.length).toBeGreaterThan(0);
			}
		});

		it("rejects empty string", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/background/background.ts ===
// b_path:: src/parse/background/background.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";

import * as Attachment from "./attachment";
import * as Clip from "./clip";
import * as Origin from "./origin";
import * as Repeat from "./repeat";
import * as Size from "./size";

export function parse(value: string): ParseResult<unknown> {
	const sizeResult = Size.parse(value);
	if (sizeResult.ok) return toParseResult(sizeResult);

	const repeatResult = Repeat.parse(value);
	if (repeatResult.ok) return toParseResult(repeatResult);

	const attachmentResult = Attachment.parse(value);
	if (attachmentResult.ok) return toParseResult(attachmentResult);

	const clipResult = Clip.parse(value);
	if (clipResult.ok) return toParseResult(clipResult);

	const originResult = Origin.parse(value);
	if (originResult.ok) return toParseResult(originResult);

	return parseErr("invalid-value", "Invalid background property value", {
		suggestion: "Expected size, repeat, attachment, clip, or origin",
	});
}


=== File: src/parse/background/clip.test.ts ===
// b_path:: src/parse/background/clip.test.ts

import { describe, expect, it } from "vitest";
import * as Clip from "./clip";

describe("parse/background/clip", () => {
	describe("valid values", () => {
		it("parses border-box", () => {
			const result = Clip.parse("border-box");
			expect(result).toEqual({ ok: true, value: "border-box", error: undefined });
		});

		it("parses padding-box", () => {
			const result = Clip.parse("padding-box");
			expect(result).toEqual({ ok: true, value: "padding-box", error: undefined });
		});

		it("parses content-box", () => {
			const result = Clip.parse("content-box");
			expect(result).toEqual({ ok: true, value: "content-box", error: undefined });
		});

		it("parses text", () => {
			const result = Clip.parse("text");
			expect(result).toEqual({ ok: true, value: "text", error: undefined });
		});
	});

	describe("normalization", () => {
		it("handles whitespace", () => {
			const result = Clip.parse("  padding-box  ");
			expect(result).toEqual({ ok: true, value: "padding-box", error: undefined });
		});
	});

	describe("invalid values", () => {
		it("rejects invalid keyword", () => {
			const result = Clip.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = Clip.parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/background/clip.ts ===
// b_path:: src/parse/background/clip.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse background-clip value.
 *
 * Parses CSS background-clip values that set whether an element's background
 * extends underneath its border box, padding box, or content box.
 *
 * Valid values: border-box | padding-box | content-box | text
 *
 * @param css - CSS string containing background-clip value
 * @returns Result containing BackgroundClipKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Clip.parse("padding-box");
 * if (result.ok) {
 *   console.log(result.value); // "padding-box"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip | MDN: background-clip}
 */
export function parse(css: string): Result<Keyword.BackgroundClipKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.backgroundClipKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid background-clip value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/background/image.test.ts ===
// b_path:: src/parse/background/image.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./image";

describe("background-image", () => {
	describe("single values", () => {
		it("parses single linear gradient", () => {
			const result = parse("linear-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				expect(result.value[0]?.kind).toBe("linear");
			}
		});

		it("parses single radial gradient", () => {
			const result = parse("radial-gradient(circle, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				expect(result.value[0]?.kind).toBe("radial");
			}
		});

		it("parses single conic gradient", () => {
			const result = parse("conic-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				expect(result.value[0]?.kind).toBe("conic");
			}
		});

		it("parses url()", () => {
			const result = parse("url(image.png)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				const layer0 = result.value[0];
				expect(layer0).toEqual({ kind: "url", url: "image.png" });
			}
		});

		it("parses url() with quotes", () => {
			const result = parse('url("image.png")');
			expect(result.ok).toBe(true);
			if (result.ok) {
				const layer0 = result.value[0];
				expect(layer0).toEqual({ kind: "url", url: "image.png" });
			}
		});

		it("parses none", () => {
			const result = parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				const layer0 = result.value[0];
				expect(layer0).toEqual({ kind: "none" });
			}
		});
	});

	describe("multiple values", () => {
		it("parses two gradients", () => {
			const result = parse("linear-gradient(red, blue), radial-gradient(green, yellow)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(2);
				expect(result.value[0]?.kind).toBe("linear");
				expect(result.value[1]?.kind).toBe("radial");
			}
		});

		it("parses three gradients", () => {
			const result = parse(`
        linear-gradient(red, blue),
        radial-gradient(green, yellow),
        conic-gradient(red, blue)
      `);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(3);
			}
		});

		it("parses mixed layers (url + gradient)", () => {
			const result = parse("url(bg.png), linear-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(2);
				expect(result.value[0]?.kind).toBe("url");
				expect(result.value[1]?.kind).toBe("linear");
			}
		});

		it("parses mixed layers (gradient + none)", () => {
			const result = parse("linear-gradient(red, blue), none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(2);
				expect(result.value[0]?.kind).toBe("linear");
				expect(result.value[1]?.kind).toBe("none");
			}
		});
	});

	describe("complex gradients (multiple layers)", () => {
		it("parses 7-layer gradient stack", () => {
			// Note: User's original example has bare numbers (e.g., "0") which current gradient parser doesn't support yet
			// This is a simplified version that demonstrates the comma-separated list capability
			const css = `
        radial-gradient(circle, white, transparent),
        radial-gradient(circle, rgba(255,255,255,0.15) 30%, transparent),
        radial-gradient(circle, rgba(255,255,255,0.2) 17%, transparent),
        radial-gradient(circle, rgba(255,255,255,0.2) 11%, transparent),
        radial-gradient(circle, rgba(255,255,255,0.2) 11%, transparent),
        radial-gradient(circle, rgba(255,255,255,0.1) 11%, transparent),
        linear-gradient(45deg, #343702 0%, #184500 20%, #187546 30%)
      `;
			const result = parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(7);
				expect(result.value[0]?.kind).toBe("radial");
				expect(result.value[6]?.kind).toBe("linear");
			}
		});

		it("parses 5 different gradient types", () => {
			const css = `
        linear-gradient(red, blue),
        radial-gradient(circle, green, yellow),
        conic-gradient(red, blue),
        url(texture.png),
        linear-gradient(to right, purple, pink)
      `;
			const result = parse(css);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(5);
				expect(result.value[0]?.kind).toBe("linear");
				expect(result.value[1]?.kind).toBe("radial");
				expect(result.value[2]?.kind).toBe("conic");
				expect(result.value[3]?.kind).toBe("url");
				expect(result.value[4]?.kind).toBe("linear");
			}
		});
	});

	describe("error handling", () => {
		it("returns error for invalid gradient", () => {
			const result = parse("invalid-gradient(red, blue)");
			expect(result.ok).toBe(false);
		});

		it("handles partial failures in list", () => {
			const result = parse("linear-gradient(red, blue), invalid");
			// First gradient parses, second fails
			expect(result.ok).toBe(false);
			expect(result.issues.length).toBeGreaterThan(0);
		});
	});
});


=== File: src/parse/background/image.ts ===
// b_path:: src/parse/background/image.ts

import type { CssNode } from "css-tree";
import * as csstree from "css-tree";
import { err, ok, type ParseResult, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as GradientParse from "@/parse/gradient/gradient";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Background image layer - can be gradient, URL, or none.
 */
export type BackgroundImageLayer = { kind: "none" } | { kind: "url"; url: string } | Type.Gradient;

/**
 * Background image value - array of layers.
 */
export type BackgroundImage = BackgroundImageLayer[];

/**
 * Parse background-image value.
 *
 * Supports comma-separated list of:
 * - Gradients: linear-gradient(), radial-gradient(), conic-gradient()
 * - URLs: url(...)
 * - Keyword: none
 *
 * @param value - CSS background-image value
 * @returns ParseResult with array of layers
 *
 * @example
 * ```typescript
 * parse("linear-gradient(red, blue)");
 * // Returns: [{ kind: "linear", ... }]
 *
 * parse("url(bg.png), linear-gradient(red, blue)");
 * // Returns: [{ kind: "url", url: "bg.png" }, { kind: "linear", ... }]
 *
 * parse("none");
 * // Returns: [{ kind: "none" }]
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<BackgroundImage> {
	const result = parseCommaSeparatedSingle(value, parseSingleLayerNode, "background-image");

	return toParseResult(result);
}

/**
 * Parse a single background-image layer from AST node.
 *
 * @param node - CSS AST node for single layer
 * @returns Result with layer or error
 *
 * @internal
 */
function parseSingleLayerNode(node: CssNode): Result<BackgroundImageLayer, string> {
	// Convert node back to CSS string for parsing
	const css = csstree.generate(node);
	const trimmed = css.trim();

	// Check for 'none' keyword
	if (node.type === "Identifier" && trimmed === "none") {
		return ok({ kind: "none" });
	}

	// Check for url() function
	if (node.type === "Url") {
		return parseURLNode(node);
	}

	// Must be a gradient function
	if (node.type === "Function") {
		const gradientResult = GradientParse.parse(css);
		if (!gradientResult.ok) {
			return err(gradientResult.issues[0]?.message || "Invalid gradient syntax");
		}

		if (!gradientResult.value) {
			return err("Gradient parsing returned undefined value");
		}

		return ok(gradientResult.value);
	}

	return err(`Unexpected node type: ${node.type}`);
}

/**
 * Parse url() AST node.
 *
 * @param node - Url AST node
 * @returns Result with URL layer or error
 *
 * @internal
 */
function parseURLNode(node: CssNode): Result<BackgroundImageLayer, string> {
	if (node.type !== "Url") {
		return err("Expected Url node");
	}

	// Convert to CSS and extract URL
	const css = csstree.generate(node);
	const match = css.match(/^url\(\s*(['"]?)([^'"()]+)\1\s*\)$/);

	if (!match || !match[2]) {
		return err("Invalid url() syntax");
	}

	return ok({
		kind: "url",
		url: match[2],
	});
}


=== File: src/parse/background/index.ts ===
// b_path:: src/parse/background/index.ts

export * as Attachment from "./attachment";
export { parse } from "./background";
export * as Clip from "./clip";
export * as Image from "./image";
export * as Origin from "./origin";
export * as PositionX from "./position-x";
export * as PositionY from "./position-y";
export * as Repeat from "./repeat";
export * as Size from "./size";


=== File: src/parse/background/origin.test.ts ===
// b_path:: src/parse/background/origin.test.ts

import { describe, expect, it } from "vitest";
import * as Origin from "./origin";

describe("parse/background/origin", () => {
	describe("valid values", () => {
		it("parses border-box", () => {
			const result = Origin.parse("border-box");
			expect(result).toEqual({ ok: true, value: "border-box", error: undefined });
		});

		it("parses padding-box", () => {
			const result = Origin.parse("padding-box");
			expect(result).toEqual({ ok: true, value: "padding-box", error: undefined });
		});

		it("parses content-box", () => {
			const result = Origin.parse("content-box");
			expect(result).toEqual({ ok: true, value: "content-box", error: undefined });
		});
	});

	describe("normalization", () => {
		it("handles whitespace", () => {
			const result = Origin.parse("  content-box  ");
			expect(result).toEqual({ ok: true, value: "content-box", error: undefined });
		});
	});

	describe("invalid values", () => {
		it("rejects invalid keyword", () => {
			const result = Origin.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = Origin.parse("");
			expect(result.ok).toBe(false);
		});

		it("rejects text keyword", () => {
			const result = Origin.parse("text");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/background/origin.ts ===
// b_path:: src/parse/background/origin.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse background-origin value.
 *
 * Parses CSS background-origin values that set the background's origin,
 * from the border start, inside the border, or inside the padding.
 *
 * Valid values: border-box | padding-box | content-box
 *
 * @param css - CSS string containing background-origin value
 * @returns Result containing VisualBoxKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Origin.parse("content-box");
 * if (result.ok) {
 *   console.log(result.value); // "content-box"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin | MDN: background-origin}
 */
export function parse(css: string): Result<Keyword.VisualBoxKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.visualBoxKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid background-origin value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/background/position-x.test.ts ===
// b_path:: src/parse/background/position-x.test.ts

import { describe, expect, it } from "vitest";
import * as PositionX from "./position-x";

describe("parse/background/position-x", () => {
	describe("valid keywords", () => {
		it("parses left", () => {
			const result = PositionX.parse("left");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("left");
			}
		});

		it("parses center", () => {
			const result = PositionX.parse("center");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("center");
			}
		});

		it("parses right", () => {
			const result = PositionX.parse("right");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("right");
			}
		});
	});

	describe("valid lengths", () => {
		it("parses pixels", () => {
			const result = PositionX.parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 10, unit: "px" });
			}
		});

		it("parses em", () => {
			const result = PositionX.parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 2, unit: "em" });
			}
		});

		it("parses zero without unit", () => {
			const result = PositionX.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("valid percentages", () => {
		it("parses 50%", () => {
			const result = PositionX.parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 50, unit: "%" });
			}
		});

		it("parses 0%", () => {
			const result = PositionX.parse("0%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 0, unit: "%" });
			}
		});

		it("parses 100%", () => {
			const result = PositionX.parse("100%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 100, unit: "%" });
			}
		});
	});

	describe("normalization", () => {
		it("handles uppercase", () => {
			const result = PositionX.parse("CENTER");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("center");
			}
		});

		it("handles whitespace", () => {
			const result = PositionX.parse("  left  ");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("left");
			}
		});
	});

	describe("invalid values", () => {
		it("rejects multiple values", () => {
			const result = PositionX.parse("left center");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = PositionX.parse("");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid unit", () => {
			const result = PositionX.parse("10invalid");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/background/position-x.ts ===
// b_path:: src/parse/background/position-x.ts

import { type ParseResult, parseErr, parseOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse background-position-x value.
 *
 * Parses the horizontal position of a background image.
 * Supports keywords (left, center, right) and length-percentage values.
 *
 * @param css - CSS string containing background-position-x value
 * @returns ParseResult containing PositionValue IR or error
 *
 * @public
 *
 * @example
 * Keyword:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.PositionX.parse("center");
 * if (result.ok) {
 *   console.log(result.value); // "center"
 * }
 * ```
 *
 * @example
 * Percentage:
 * ```typescript
 * const result = Parse.Background.PositionX.parse("25%");
 * if (result.ok) {
 *   console.log(result.value); // { value: 25, unit: "%" }
 * }
 * ```
 *
 * @example
 * Length:
 * ```typescript
 * const result = Parse.Background.PositionX.parse("10px");
 * if (result.ok) {
 *   console.log(result.value); // { value: 10, unit: "px" }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position-x | MDN: background-position-x}
 */
export function parse(css: string): ParseResult<Type.PositionValue> {
	const csstree = require("css-tree");

	try {
		const ast = csstree.parse(css, { context: "value" });
		const children = ast.children.toArray();

		if (children.length === 0) {
			return parseErr("invalid-syntax", "No position value found in CSS string");
		}

		if (children.length > 1) {
			return parseErr("invalid-value", "background-position-x accepts only a single value");
		}

		const node = children[0];
		if (!node) {
			return parseErr("invalid-syntax", "Missing position value");
		}

		const result = ParseUtils.parsePositionValueNode(node);
		if (!result.ok) {
			return parseErr("invalid-value", result.error);
		}

		return parseOk(result.value);
	} catch (e) {
		return parseErr("invalid-syntax", `Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/background/position-y.test.ts ===
// b_path:: src/parse/background/position-y.test.ts

import { describe, expect, it } from "vitest";
import * as PositionY from "./position-y";

describe("parse/background/position-y", () => {
	describe("valid keywords", () => {
		it("parses top", () => {
			const result = PositionY.parse("top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("top");
			}
		});

		it("parses center", () => {
			const result = PositionY.parse("center");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("center");
			}
		});

		it("parses bottom", () => {
			const result = PositionY.parse("bottom");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("bottom");
			}
		});
	});

	describe("valid lengths", () => {
		it("parses pixels", () => {
			const result = PositionY.parse("20px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 20, unit: "px" });
			}
		});

		it("parses em", () => {
			const result = PositionY.parse("3em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 3, unit: "em" });
			}
		});

		it("parses zero without unit", () => {
			const result = PositionY.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("valid percentages", () => {
		it("parses 50%", () => {
			const result = PositionY.parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 50, unit: "%" });
			}
		});

		it("parses 0%", () => {
			const result = PositionY.parse("0%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 0, unit: "%" });
			}
		});

		it("parses 100%", () => {
			const result = PositionY.parse("100%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 100, unit: "%" });
			}
		});
	});

	describe("normalization", () => {
		it("handles uppercase", () => {
			const result = PositionY.parse("TOP");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("top");
			}
		});

		it("handles whitespace", () => {
			const result = PositionY.parse("  bottom  ");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("bottom");
			}
		});
	});

	describe("invalid values", () => {
		it("rejects multiple values", () => {
			const result = PositionY.parse("top bottom");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = PositionY.parse("");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid unit", () => {
			const result = PositionY.parse("20invalid");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/background/position-y.ts ===
// b_path:: src/parse/background/position-y.ts

import { type ParseResult, parseErr, parseOk } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse background-position-y value.
 *
 * Parses the vertical position of a background image.
 * Supports keywords (top, center, bottom) and length-percentage values.
 *
 * @param css - CSS string containing background-position-y value
 * @returns ParseResult containing PositionValue IR or error
 *
 * @public
 *
 * @example
 * Keyword:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.PositionY.parse("top");
 * if (result.ok) {
 *   console.log(result.value); // "top"
 * }
 * ```
 *
 * @example
 * Percentage:
 * ```typescript
 * const result = Parse.Background.PositionY.parse("50%");
 * if (result.ok) {
 *   console.log(result.value); // { value: 50, unit: "%" }
 * }
 * ```
 *
 * @example
 * Length:
 * ```typescript
 * const result = Parse.Background.PositionY.parse("20px");
 * if (result.ok) {
 *   console.log(result.value); // { value: 20, unit: "px" }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position-y | MDN: background-position-y}
 */
export function parse(css: string): ParseResult<Type.PositionValue> {
	const csstree = require("css-tree");

	try {
		const ast = csstree.parse(css, { context: "value" });
		const children = ast.children.toArray();

		if (children.length === 0) {
			return parseErr("invalid-syntax", "No position value found in CSS string");
		}

		if (children.length > 1) {
			return parseErr("invalid-value", "background-position-y accepts only a single value");
		}

		const node = children[0];
		if (!node) {
			return parseErr("invalid-syntax", "Missing position value");
		}

		const result = ParseUtils.parsePositionValueNode(node);
		if (!result.ok) {
			return parseErr("invalid-value", result.error);
		}

		return parseOk(result.value);
	} catch (e) {
		return parseErr("invalid-syntax", `Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/background/repeat.test.ts ===
// b_path:: src/parse/background/repeat.test.ts

import { describe, expect, it } from "vitest";
import * as Repeat from "./repeat";

describe("parse/background/repeat", () => {
	describe("valid values", () => {
		it("parses repeat", () => {
			const result = Repeat.parse("repeat");
			expect(result).toEqual({ ok: true, value: "repeat", error: undefined });
		});

		it("parses repeat-x", () => {
			const result = Repeat.parse("repeat-x");
			expect(result).toEqual({ ok: true, value: "repeat-x", error: undefined });
		});

		it("parses repeat-y", () => {
			const result = Repeat.parse("repeat-y");
			expect(result).toEqual({ ok: true, value: "repeat-y", error: undefined });
		});

		it("parses no-repeat", () => {
			const result = Repeat.parse("no-repeat");
			expect(result).toEqual({ ok: true, value: "no-repeat", error: undefined });
		});

		it("parses space", () => {
			const result = Repeat.parse("space");
			expect(result).toEqual({ ok: true, value: "space", error: undefined });
		});

		it("parses round", () => {
			const result = Repeat.parse("round");
			expect(result).toEqual({ ok: true, value: "round", error: undefined });
		});
	});

	describe("normalization", () => {
		it("handles whitespace", () => {
			const result = Repeat.parse("  repeat-x  ");
			expect(result).toEqual({ ok: true, value: "repeat-x", error: undefined });
		});
	});

	describe("invalid values", () => {
		it("rejects invalid keyword", () => {
			const result = Repeat.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = Repeat.parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/background/repeat.ts ===
// b_path:: src/parse/background/repeat.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse background-repeat value.
 *
 * Parses CSS background-repeat values that control how background images repeat.
 * Supports single-value syntax (repeat, repeat-x, repeat-y, no-repeat, space, round).
 *
 * @param css - CSS string containing background-repeat value
 * @returns Result containing RepeatKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Repeat.parse("repeat-x");
 * if (result.ok) {
 *   console.log(result.value); // "repeat-x"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat | MDN: background-repeat}
 */
export function parse(css: string): Result<Keyword.RepeatKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.repeatKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid background-repeat value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/background/size.test.ts ===
// b_path:: src/parse/background/size.test.ts

import { describe, expect, it } from "vitest";
import * as Size from "./size";

describe("parse/background/size", () => {
	describe("keyword values", () => {
		it("parses cover", () => {
			const result = Size.parse("cover");
			expect(result).toEqual({ ok: true, value: "cover", error: undefined });
		});

		it("parses contain", () => {
			const result = Size.parse("contain");
			expect(result).toEqual({ ok: true, value: "contain", error: undefined });
		});

		it("parses auto", () => {
			const result = Size.parse("auto");
			expect(result).toEqual({ ok: true, value: "auto", error: undefined });
		});
	});

	describe("length values", () => {
		it("parses pixel value", () => {
			const result = Size.parse("100px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 100, unit: "px" });
			}
		});

		it("parses percentage value", () => {
			const result = Size.parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 50, unit: "%" });
			}
		});

		it("parses em value", () => {
			const result = Size.parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ value: 2, unit: "em" });
			}
		});
	});

	describe("normalization", () => {
		it("handles whitespace", () => {
			const result = Size.parse("  cover  ");
			expect(result).toEqual({ ok: true, value: "cover", error: undefined });
		});
	});

	describe("invalid values", () => {
		it("rejects invalid keyword", () => {
			const result = Size.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = Size.parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/background/size.ts ===
// b_path:: src/parse/background/size.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Background size value (keyword or length-percentage).
 *
 * @public
 */
export type BackgroundSizeValue = Keyword.SizingKeyword | Type.LengthPercentage | "auto";

/**
 * Parse background-size value (single dimension).
 *
 * Parses CSS background-size values that control the size of background images.
 * Supports keywords (cover, contain), auto, and length/percentage values.
 *
 * @param css - CSS string containing background-size value
 * @returns Result containing BackgroundSizeValue, or error message
 *
 * @public
 *
 * @example
 * Keywords:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Background.Size.parse("cover");
 * if (result.ok) {
 *   console.log(result.value); // "cover"
 * }
 * ```
 *
 * @example
 * Length values:
 * ```typescript
 * const result = Parse.Background.Size.parse("100px");
 * if (result.ok) {
 *   console.log(result.value); // { value: 100, unit: "px" }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size | MDN: background-size}
 */
export function parse(css: string): Result<BackgroundSizeValue, string> {
	const trimmed = css.trim();

	// Try sizing keywords (cover, contain)
	const keywordResult = Keyword.sizingKeywordsSchema.safeParse(trimmed);
	if (keywordResult.success) {
		return ok(keywordResult.data);
	}

	// Try 'auto' keyword
	if (trimmed === "auto") {
		return ok("auto");
	}

	// Try length-percentage
	const csstree = require("css-tree");
	try {
		const ast = csstree.parse(trimmed, { context: "value" });
		const children = ast.children.toArray();
		if (children.length === 1) {
			const lengthResult = ParseUtils.parseLengthPercentageNode(children[0]);
			if (lengthResult.ok) {
				return lengthResult;
			}
		}
	} catch {
		// Continue to error
	}

	return err(`Invalid background-size value: "${css}"`);
}


=== File: src/parse/border/border.test.ts ===
// b_path:: src/parse/border/border.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./border";

describe("parse border dispatcher", () => {
	describe("dispatches to Width parser", () => {
		it("parses thin keyword", () => {
			const result = parse("thin");
			expect(result.ok).toBe(true);
		});

		it("parses length value", () => {
			const result = parse("2px");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Style parser", () => {
		it("parses solid", () => {
			const result = parse("solid");
			expect(result.ok).toBe(true);
		});

		it("parses dashed", () => {
			const result = parse("dashed");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Color parser", () => {
		it("parses named color", () => {
			const result = parse("red");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Radius parser", () => {
		it("parses radius length", () => {
			const result = parse("5px");
			expect(result.ok).toBe(true);
		});
	});

	describe("error handling", () => {
		it("rejects invalid value", () => {
			const result = parse("invalid-border-value-xyz");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues.length).toBeGreaterThan(0);
			}
		});

		it("rejects empty string", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/border.ts ===
// b_path:: src/parse/border/border.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";

import * as Color from "./color";
import * as Radius from "./radius";
import * as Style from "./style";
import * as Width from "./width";

export function parse(value: string): ParseResult<unknown> {
	const widthResult = Width.parse(value);
	if (widthResult.ok) return toParseResult(widthResult);

	const styleResult = Style.parse(value);
	if (styleResult.ok) return toParseResult(styleResult);

	const radiusResult = Radius.parse(value);
	if (radiusResult.ok) return toParseResult(radiusResult);

	const colorResult = Color.parse(value);
	if (colorResult.ok) return toParseResult(colorResult);

	return parseErr("invalid-value", "Invalid border property value", {
		suggestion: "Expected width, style, radius, or color",
	});
}


=== File: src/parse/border/color.test.ts ===
// b_path:: src/parse/border/color.test.ts
import { describe, expect, it } from "vitest";
import * as BorderColor from "./color";

describe("Parse.Border.Color", () => {
	describe("valid keywords", () => {
		it("should parse 'transparent'", () => {
			const result = BorderColor.parse("transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "transparent",
				});
			}
		});

		it("should parse 'currentcolor'", () => {
			const result = BorderColor.parse("currentcolor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "currentcolor",
				});
			}
		});

		it("should parse 'red'", () => {
			const result = BorderColor.parse("red");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "red",
				});
			}
		});

		it("should parse 'blue'", () => {
			const result = BorderColor.parse("blue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "blue",
				});
			}
		});

		it("should parse 'green'", () => {
			const result = BorderColor.parse("green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "green",
				});
			}
		});

		it("should parse 'black'", () => {
			const result = BorderColor.parse("black");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "black",
				});
			}
		});

		it("should parse 'white'", () => {
			const result = BorderColor.parse("white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-color",
					color: "white",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = BorderColor.parse("notacolor");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("color keyword");
			}
		});

		it("should reject length values", () => {
			const result = BorderColor.parse("1px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = BorderColor.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = BorderColor.parse("red blue");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/color.ts ===
// b_path:: src/parse/border/color.ts
import * as csstree from "css-tree";
import { ALL_NAMED_COLOR_KEYWORDS } from "@/core/keywords/color-value-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS border-color property value.
 *
 * Accepts color keywords (currentcolor, transparent, named colors).
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * Note: This parser currently handles color keywords only.
 * For full color support (rgb, hsl, hex, etc.), use the color parsers.
 *
 * @param css - CSS border-color value (e.g., "red", "transparent", "currentcolor")
 * @returns Result with BorderColor IR or error message
 *
 * @example
 * Named color:
 * ```typescript
 * const result = parse("red");
 * // { ok: true, value: { kind: "border-color", color: "red" } }
 * ```
 *
 * @example
 * Transparent:
 * ```typescript
 * const result = parse("transparent");
 * // { ok: true, value: { kind: "border-color", color: "transparent" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color | MDN: border-color}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-color | W3C Spec}
 */
export function parse(css: string): Result<Type.BorderColorValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single border-color value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty border-color value");
		}

		if (node.type !== "Identifier") {
			return err(`Expected color keyword for border-color, got: ${node.type}`);
		}

		const keyword = node.name.toLowerCase();
		if (!ALL_NAMED_COLOR_KEYWORDS.includes(keyword as (typeof ALL_NAMED_COLOR_KEYWORDS)[number])) {
			return err(`Invalid color keyword: ${keyword}`);
		}

		return ok({
			kind: "border-color",
			color: keyword as (typeof ALL_NAMED_COLOR_KEYWORDS)[number],
		});
	} catch (e) {
		return err(`Failed to parse border-color: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/border/index.ts ===
// b_path:: src/parse/border/index.ts

export { parse } from "./border";

export * as Color from "./color";
export * as Radius from "./radius";
export * as Style from "./style";
export * as Width from "./width";


=== File: src/parse/border/radius.test.ts ===
// b_path:: src/parse/border/radius.test.ts
import { describe, expect, it } from "vitest";
import * as BorderRadius from "./radius";

describe("Parse.Border.Radius", () => {
	describe("valid lengths", () => {
		it("should parse '0' (unitless zero)", () => {
			const result = BorderRadius.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '5px'", () => {
			const result = BorderRadius.parse("5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 5, unit: "px" },
				});
			}
		});

		it("should parse '10.5px'", () => {
			const result = BorderRadius.parse("10.5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 10.5, unit: "px" },
				});
			}
		});

		it("should parse '1em'", () => {
			const result = BorderRadius.parse("1em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 1, unit: "em" },
				});
			}
		});

		it("should parse '2rem'", () => {
			const result = BorderRadius.parse("2rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 2, unit: "rem" },
				});
			}
		});
	});

	describe("valid percentages", () => {
		it("should parse '50%'", () => {
			const result = BorderRadius.parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 50, unit: "%" },
				});
			}
		});

		it("should parse '100%'", () => {
			const result = BorderRadius.parse("100%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 100, unit: "%" },
				});
			}
		});

		it("should parse '25.5%'", () => {
			const result = BorderRadius.parse("25.5%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-radius",
					radius: { value: 25.5, unit: "%" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject negative values", () => {
			const result = BorderRadius.parse("-5px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject keywords", () => {
			const result = BorderRadius.parse("medium");
			expect(result.ok).toBe(false);
		});

		it("should reject unitless non-zero", () => {
			const result = BorderRadius.parse("5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless");
			}
		});

		it("should reject empty string", () => {
			const result = BorderRadius.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = BorderRadius.parse("5px 10px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/radius.ts ===
// b_path:: src/parse/border/radius.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS border-radius property value.
 *
 * Accepts length or percentage values.
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param css - CSS border-radius value (e.g., "5px", "50%", "1em")
 * @returns Result with BorderRadius IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("5px");
 * // { ok: true, value: { kind: "border-radius", radius: { value: 5, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "border-radius", radius: { value: 50, unit: "%" } } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius | MDN: border-radius}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-radius | W3C Spec}
 */
export function parse(css: string): Result<Type.BorderRadiusValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single border-radius value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty border-radius value");
		}

		// Handle zero without unit
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value !== 0) {
				return err("Unitless values must be zero");
			}
			return ok({
				kind: "border-radius",
				radius: {
					value: 0,
					unit: "px",
				},
			});
		}

		// Use utility to parse length-percentage
		const radiusResult = ParseUtils.parseLengthPercentageNode(node);
		if (!radiusResult.ok) {
			return err(`Invalid border-radius value: ${radiusResult.error}`);
		}

		// border-radius doesn't accept negative values
		if (radiusResult.value.value < 0) {
			return err(`border-radius must be non-negative, got: ${radiusResult.value.value}`);
		}

		return ok({
			kind: "border-radius",
			radius: radiusResult.value,
		});
	} catch (e) {
		return err(`Failed to parse border-radius: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/border/style.test.ts ===
// b_path:: src/parse/border/style.test.ts
import { describe, expect, it } from "vitest";
import * as BorderStyle from "./style";

describe("Parse.Border.Style", () => {
	describe("valid keywords", () => {
		it("should parse 'none'", () => {
			const result = BorderStyle.parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "none",
				});
			}
		});

		it("should parse 'hidden'", () => {
			const result = BorderStyle.parse("hidden");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "hidden",
				});
			}
		});

		it("should parse 'dotted'", () => {
			const result = BorderStyle.parse("dotted");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "dotted",
				});
			}
		});

		it("should parse 'dashed'", () => {
			const result = BorderStyle.parse("dashed");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "dashed",
				});
			}
		});

		it("should parse 'solid'", () => {
			const result = BorderStyle.parse("solid");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "solid",
				});
			}
		});

		it("should parse 'double'", () => {
			const result = BorderStyle.parse("double");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "double",
				});
			}
		});

		it("should parse 'groove'", () => {
			const result = BorderStyle.parse("groove");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "groove",
				});
			}
		});

		it("should parse 'ridge'", () => {
			const result = BorderStyle.parse("ridge");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "ridge",
				});
			}
		});

		it("should parse 'inset'", () => {
			const result = BorderStyle.parse("inset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "inset",
				});
			}
		});

		it("should parse 'outset'", () => {
			const result = BorderStyle.parse("outset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-style",
					style: "outset",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = BorderStyle.parse("wavy");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("keyword");
			}
		});

		it("should reject length values", () => {
			const result = BorderStyle.parse("1px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = BorderStyle.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = BorderStyle.parse("solid dashed");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/style.ts ===
// b_path:: src/parse/border/style.ts
import * as csstree from "css-tree";
import { BORDER_STYLE_KEYWORDS } from "@/core/keywords/border-style-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS border-style property value.
 *
 * Accepts predefined style keywords.
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param css - CSS border-style value (e.g., "solid", "dashed", "dotted")
 * @returns Result with BorderStyle IR or error message
 *
 * @example
 * Solid border:
 * ```typescript
 * const result = parse("solid");
 * // { ok: true, value: { kind: "border-style", style: "solid" } }
 * ```
 *
 * @example
 * Dashed border:
 * ```typescript
 * const result = parse("dashed");
 * // { ok: true, value: { kind: "border-style", style: "dashed" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style | MDN: border-style}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-style | W3C Spec}
 */
export function parse(css: string): Result<Type.BorderStyleValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single border-style value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty border-style value");
		}

		if (node.type !== "Identifier") {
			return err(`Expected keyword for border-style, got: ${node.type}`);
		}

		const keyword = node.name.toLowerCase();
		if (!BORDER_STYLE_KEYWORDS.includes(keyword as Type.BorderStyle)) {
			return err(`Invalid border-style keyword: ${keyword}`);
		}

		return ok({
			kind: "border-style",
			style: keyword as Type.BorderStyle,
		});
	} catch (e) {
		return err(`Failed to parse border-style: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/border/width.test.ts ===
// b_path:: src/parse/border/width.test.ts
import { describe, expect, it } from "vitest";
import * as BorderWidth from "./width";

describe("Parse.Border.Width", () => {
	describe("valid keywords", () => {
		it("should parse 'thin'", () => {
			const result = BorderWidth.parse("thin");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: "thin",
				});
			}
		});

		it("should parse 'medium'", () => {
			const result = BorderWidth.parse("medium");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: "medium",
				});
			}
		});

		it("should parse 'thick'", () => {
			const result = BorderWidth.parse("thick");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: "thick",
				});
			}
		});
	});

	describe("valid lengths", () => {
		it("should parse '0' (unitless zero)", () => {
			const result = BorderWidth.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '1px'", () => {
			const result = BorderWidth.parse("1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 1, unit: "px" },
				});
			}
		});

		it("should parse '2.5em'", () => {
			const result = BorderWidth.parse("2.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 2.5, unit: "em" },
				});
			}
		});

		it("should parse '0.5rem'", () => {
			const result = BorderWidth.parse("0.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 0.5, unit: "rem" },
				});
			}
		});

		it("should parse '10pt'", () => {
			const result = BorderWidth.parse("10pt");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "border-width",
					width: { value: 10, unit: "pt" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject negative values", () => {
			const result = BorderWidth.parse("-1px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject invalid keywords", () => {
			const result = BorderWidth.parse("large");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("keyword");
			}
		});

		it("should reject unitless non-zero", () => {
			const result = BorderWidth.parse("5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless");
			}
		});

		it("should reject percentage values", () => {
			const result = BorderWidth.parse("50%");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = BorderWidth.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = BorderWidth.parse("1px 2px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/border/width.ts ===
// b_path:: src/parse/border/width.ts
import * as csstree from "css-tree";
import { BORDER_WIDTH_KEYWORDS } from "@/core/keywords/border-width-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { ABSOLUTE_LENGTH_UNITS, FONT_LENGTH_UNITS, VIEWPORT_LENGTH_UNITS } from "@/core/units";

/**
 * Parse CSS border-width property value.
 *
 * Accepts length values or predefined keywords (thin, medium, thick).
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param css - CSS border-width value (e.g., "1px", "medium", "0.5em")
 * @returns Result with BorderWidth IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("1px");
 * // { ok: true, value: { kind: "border-width", width: { value: 1, unit: "px" } } }
 * ```
 *
 * @example
 * Keyword value:
 * ```typescript
 * const result = parse("medium");
 * // { ok: true, value: { kind: "border-width", width: "medium" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width | MDN: border-width}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#border-width | W3C Spec}
 */
export function parse(css: string): Result<Type.BorderWidthValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single border-width value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty border-width value");
		}

		// Handle keywords
		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			const keywordValue = keyword as "thin" | "medium" | "thick";
			if (BORDER_WIDTH_KEYWORDS.includes(keywordValue)) {
				return ok({
					kind: "border-width",
					width: keywordValue,
				});
			}
			return err(`Invalid border-width keyword: ${keyword}`);
		}

		// Handle length
		if (node.type === "Dimension") {
			const value = Number.parseFloat(node.value);
			const unit = node.unit.toLowerCase();

			const allLengthUnits = [...ABSOLUTE_LENGTH_UNITS, ...FONT_LENGTH_UNITS, ...VIEWPORT_LENGTH_UNITS];
			if (!allLengthUnits.includes(unit as (typeof allLengthUnits)[number])) {
				return err(`Invalid length unit for border-width: ${unit}`);
			}

			if (value < 0) {
				return err(`border-width must be non-negative, got: ${value}`);
			}

			return ok({
				kind: "border-width",
				width: {
					value,
					unit: unit as (typeof allLengthUnits)[number],
				},
			});
		}

		// Handle zero without unit
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value !== 0) {
				return err("Unitless values must be zero");
			}
			return ok({
				kind: "border-width",
				width: {
					value: 0,
					unit: "px",
				},
			});
		}

		return err(`Unexpected node type: ${node.type}`);
	} catch (e) {
		return err(`Failed to parse border-width: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/clip-path/circle.test.ts ===
// b_path:: src/parse/clip-path/circle.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "./circle";

describe("Parse.ClipPath.Circle", () => {
	describe("Basic parsing", () => {
		it("parses circle() with no arguments (all defaults)", () => {
			const result = Parse.parse("circle()");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
			});
		});

		it("parses circle() with radius only", () => {
			const result = Parse.parse("circle(50px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "px" },
			});
		});

		it("parses circle() with percentage radius", () => {
			const result = Parse.parse("circle(50%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "%" },
			});
		});

		it("parses circle() with closest-side radius", () => {
			const result = Parse.parse("circle(closest-side)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: "closest-side",
			});
		});

		it("parses circle() with farthest-side radius", () => {
			const result = Parse.parse("circle(farthest-side)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: "farthest-side",
			});
		});
	});

	describe("Position parsing", () => {
		it("parses circle() with position only", () => {
			const result = Parse.parse("circle(at center)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				position: { horizontal: "center", vertical: "center" },
			});
		});

		it("parses circle() with radius and position", () => {
			const result = Parse.parse("circle(50px at center)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "px" },
				position: { horizontal: "center", vertical: "center" },
			});
		});

		it("parses circle() with length-percentage position", () => {
			const result = Parse.parse("circle(at 30px 40%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				position: {
					horizontal: { value: 30, unit: "px" },
					vertical: { value: 40, unit: "%" },
				},
			});
		});

		it("parses circle() with mixed keyword and value position", () => {
			const result = Parse.parse("circle(closest-side at 30% top)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.kind).toBe("clip-path-circle");
			expect(result.value.radius).toBe("closest-side");
			expect(result.value.position).toBeDefined();
		});

		it("parses circle() with keyword position", () => {
			const result = Parse.parse("circle(at left top)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				position: { horizontal: "left", vertical: "top" },
			});
		});
	});

	describe("Edge cases", () => {
		it("parses zero radius", () => {
			const result = Parse.parse("circle(0)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 0, unit: "px" },
			});
		});

		it("parses zero percentage radius", () => {
			const result = Parse.parse("circle(0%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 0, unit: "%" },
			});
		});

		it("rejects negative radius", () => {
			const result = Parse.parse("circle(-10px)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("non-negative");
		});

		it("rejects negative percentage radius", () => {
			const result = Parse.parse("circle(-50%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("non-negative");
		});
	});

	describe("Error handling", () => {
		it("rejects non-circle function", () => {
			const result = Parse.parse("inset(10px)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("circle");
		});

		it("rejects missing position after 'at'", () => {
			const result = Parse.parse("circle(50px at)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("Expected position");
		});

		it("rejects invalid keyword", () => {
			const result = Parse.parse("circle(invalid)");
			expect(result.ok).toBe(false);
		});

		it("rejects extra content", () => {
			const result = Parse.parse("circle(50px at center extra)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("Unexpected");
		});

		it("rejects position without 'at'", () => {
			const result = Parse.parse("circle(50px center)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("'at'");
		});
	});

	describe("Whitespace handling", () => {
		it("handles extra whitespace", () => {
			const result = Parse.parse("circle(  50px   at   center  )");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-circle",
				radius: { value: 50, unit: "px" },
				position: { horizontal: "center", vertical: "center" },
			});
		});

		it("handles no whitespace", () => {
			const result = Parse.parse("circle(50px at center)");
			expect(result.ok).toBe(true);
		});
	});
});


=== File: src/parse/clip-path/circle.ts ===
// b_path:: src/parse/clip-path/circle.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunctionRaw } from "./utils";

/**
 * Parse circle() shape function.
 *
 * Syntax: circle( <length-percentage>? [ at <position> ]? )
 *
 * @param css - CSS string
 * @returns Result with ClipPathCircle IR or error
 *
 * @example
 * ```typescript
 * parse("circle()");
 * parse("circle(50px)");
 * parse("circle(closest-side at center)");
 * parse("circle(50% at 30px 40px)");
 * ```
 *
 * @public
 */
export function parse(css: string): Result<Type.ClipPathCircle, string> {
	return parseShapeFunctionRaw(css, "circle", parseCircleChildren);
}

function parseCircleChildren(children: CssNode[]): Result<Type.ClipPathCircle, string> {
	if (children.length === 0) {
		return ok({
			kind: "clip-path-circle",
		});
	}

	let idx = 0;
	let radius: Type.ClipPathCircle["radius"];

	// Parse optional radius (using utility, allow 'at' keyword)
	const radiusResult = ParseUtils.parseRadialSize(children[idx], "circle() radius", true);
	if (!radiusResult.ok) return radiusResult;
	if (radiusResult.value !== undefined) {
		radius = radiusResult.value;
		idx++;
	}

	// Parse optional position after 'at' (using utility)
	let position: Type.Position2D | undefined;
	if (idx < children.length) {
		const atResult = ParseUtils.parseAtPosition(children, idx);
		if (!atResult.ok) return atResult;

		// If position is undefined, there was content but no 'at' keyword
		if (atResult.value.position === undefined) {
			return err("Expected 'at' keyword before position");
		}

		position = atResult.value.position;
		idx = atResult.value.nextIdx;
	}

	// Check for extra content
	if (idx < children.length) {
		return err("Unexpected content after circle() arguments");
	}

	return ok({
		kind: "clip-path-circle",
		...(radius !== undefined && { radius }),
		...(position !== undefined && { position }),
	});
}


=== File: src/parse/clip-path/clip-path.test.ts ===
// b_path:: src/parse/clip-path/clip-path.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./clip-path";

describe("parse() - unified dispatcher", () => {
	describe("basic shapes", () => {
		it("detects circle()", () => {
			const result = parse("circle(50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-circle");
			}
		});

		it("detects ellipse()", () => {
			const result = parse("ellipse(50% 30%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-ellipse");
			}
		});

		it("detects inset()", () => {
			const result = parse("inset(10px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-inset");
			}
		});

		it("detects polygon()", () => {
			const result = parse("polygon(0 0, 100% 0, 100% 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-polygon");
			}
		});

		it("detects rect()", () => {
			const result = parse("rect(10px 20px 30px 40px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-rect");
			}
		});

		it("detects xywh()", () => {
			const result = parse("xywh(10px 20px 30px 40px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-xywh");
			}
		});

		it("detects path()", () => {
			const result = parse('path("M 10 10 L 50 50")');
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-path");
			}
		});
	});

	describe("keywords", () => {
		it("detects none", () => {
			const result = parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-none");
			}
		});
	});

	describe("geometry-box keywords", () => {
		it("detects border-box", () => {
			const result = parse("border-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("border-box");
				}
			}
		});

		it("detects padding-box", () => {
			const result = parse("padding-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("padding-box");
				}
			}
		});

		it("detects content-box", () => {
			const result = parse("content-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("content-box");
				}
			}
		});

		it("detects fill-box", () => {
			const result = parse("fill-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("fill-box");
				}
			}
		});

		it("detects stroke-box", () => {
			const result = parse("stroke-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("stroke-box");
				}
			}
		});

		it("detects view-box", () => {
			const result = parse("view-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-geometry-box");
				if (result.value?.kind === "clip-path-geometry-box") {
					expect(result.value?.value).toBe("view-box");
				}
			}
		});
	});

	describe("url reference", () => {
		it("detects url()", () => {
			const result = parse("url(#clip-shape)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("url");
				if (result.value?.kind === "url") {
					expect(result.value?.value).toBe("#clip-shape");
				}
			}
		});
	});

	describe("error cases", () => {
		it("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Empty");
			}
		});

		it("rejects unknown function", () => {
			const result = parse("unknown(10px)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown clip-path function");
			}
		});

		it("rejects invalid identifier", () => {
			const result = parse("invalid-keyword");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Invalid geometry-box value");
			}
		});
	});

	describe("case insensitivity", () => {
		it("handles CIRCLE()", () => {
			const result = parse("CIRCLE(50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-circle");
			}
		});

		it("handles Polygon()", () => {
			const result = parse("Polygon(0 0, 100% 0, 100% 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("clip-path-polygon");
			}
		});
	});
});


=== File: src/parse/clip-path/clip-path.ts ===
// b_path:: src/parse/clip-path/clip-path.ts

import type { CssNode } from "css-tree";
import * as cssTree from "css-tree";
import { err, type ParseResult, parseErr, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as Circle from "./circle";
import * as Ellipse from "./ellipse";
import * as GeometryBox from "./geometry-box";
import * as Inset from "./inset";
import * as None from "./none";
import * as Path from "./path";
import * as Polygon from "./polygon";
import * as Rect from "./rect";
import * as Url from "./url";
import * as Xywh from "./xywh";

/**
 * Parse clip-path value with auto-detection.
 *
 * Automatically detects and parses any clip-path value:
 * - Basic shapes: circle(), ellipse(), inset(), polygon(), rect(), xywh(), path()
 * - Reference: url()
 * - Keyword: none
 * - Geometry box: border-box, padding-box, content-box, etc.
 *
 * @param value - CSS clip-path value string
 * @returns Result with ClipPathValue IR or error
 *
 * @example
 * ```typescript
 * parse("circle(50%)");           // Auto-detects circle
 * parse("polygon(0 0, 100% 0, 100% 100%)"); // Auto-detects polygon
 * parse("none");                  // Auto-detects keyword
 * parse("url(#clip)");            // Auto-detects reference
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Type.ClipPathValue> {
	const ast = cssTree.parse(value, { context: "value" }) as cssTree.Value;
	if (!ast.children) return parseErr("invalid-syntax", "Empty value");
	const first = ast.children.first;
	if (!first) return parseErr("invalid-syntax", "Empty value");
	const result = parseNode(first);
	return toParseResult(result);
}

/**
 * Parse clip-path AST node with auto-detection.
 *
 * @param node - CSS AST node
 * @returns Result with ClipPathValue IR or error
 *
 * @internal
 */
function parseNode(node: CssNode): Result<Type.ClipPathValue, string> {
	// Keyword: none
	if (node.type === "Identifier" && node.name === "none") {
		return None.parse("none");
	}

	// URL reference
	if (node.type === "Url") {
		const css = cssTree.generate(node);
		return Url.parse(css);
	}

	// Basic shapes (function)
	if (node.type === "Function") {
		const css = cssTree.generate(node);
		switch (node.name.toLowerCase()) {
			case "circle":
				return Circle.parse(css);
			case "ellipse":
				return Ellipse.parse(css);
			case "inset":
				return Inset.parse(css);
			case "polygon":
				return Polygon.parse(css);
			case "rect":
				return Rect.parse(css);
			case "xywh":
				return Xywh.parse(css);
			case "path":
				return Path.parse(css);
			default:
				return err(`Unknown clip-path function: ${node.name}`);
		}
	}

	// Geometry-box keyword
	if (node.type === "Identifier") {
		return GeometryBox.parse(node.name);
	}

	return err(`Invalid clip-path node type: ${node.type}`);
}


=== File: src/parse/clip-path/ellipse.test.ts ===
// b_path:: src/parse/clip-path/ellipse.test.ts
import { describe, expect, it } from "vitest";
import * as Ellipse from "./ellipse";

describe("parse/clip-path/ellipse", () => {
	describe("basic parsing", () => {
		it("should parse ellipse with no arguments", () => {
			const result = Ellipse.parse("ellipse()");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
				},
			});
		});

		it("should parse ellipse with single radius (both X and Y)", () => {
			const result = Ellipse.parse("ellipse(50px)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "px" },
				},
			});
		});

		it("should parse ellipse with two radii", () => {
			const result = Ellipse.parse("ellipse(50px 100px)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "px" },
					radiusY: { value: 100, unit: "px" },
				},
			});
		});

		it("should parse ellipse with percentage radii", () => {
			const result = Ellipse.parse("ellipse(50% 75%)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "%" },
					radiusY: { value: 75, unit: "%" },
				},
			});
		});

		it("should parse ellipse with mixed units", () => {
			const result = Ellipse.parse("ellipse(2rem 100px)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 2, unit: "rem" },
					radiusY: { value: 100, unit: "px" },
				},
			});
		});
	});

	describe("keyword radii", () => {
		it("should parse ellipse with closest-side keywords", () => {
			const result = Ellipse.parse("ellipse(closest-side closest-side)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: "closest-side",
					radiusY: "closest-side",
				},
			});
		});

		it("should parse ellipse with farthest-side keywords", () => {
			const result = Ellipse.parse("ellipse(farthest-side farthest-side)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: "farthest-side",
					radiusY: "farthest-side",
				},
			});
		});

		it("should parse ellipse with mixed keywords", () => {
			const result = Ellipse.parse("ellipse(closest-side farthest-side)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: "closest-side",
					radiusY: "farthest-side",
				},
			});
		});

		it("should parse ellipse with keyword and value", () => {
			const result = Ellipse.parse("ellipse(50px farthest-side)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "px" },
					radiusY: "farthest-side",
				},
			});
		});
	});

	describe("position parsing", () => {
		it("should parse ellipse with position only", () => {
			const result = Ellipse.parse("ellipse(at center center)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					position: {
						horizontal: "center",
						vertical: "center",
					},
				},
			});
		});

		it("should parse ellipse with radii and position", () => {
			const result = Ellipse.parse("ellipse(50px 100px at 30px 40px)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 50, unit: "px" },
					radiusY: { value: 100, unit: "px" },
					position: {
						horizontal: { value: 30, unit: "px" },
						vertical: { value: 40, unit: "px" },
					},
				},
			});
		});

		it("should parse ellipse with keywords and position", () => {
			const result = Ellipse.parse("ellipse(closest-side farthest-side at left top)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: "closest-side",
					radiusY: "farthest-side",
					position: {
						horizontal: "left",
						vertical: "top",
					},
				},
			});
		});

		it("should parse ellipse with mixed position", () => {
			const result = Ellipse.parse("ellipse(at 30% top)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					position: {
						horizontal: { value: 30, unit: "%" },
						vertical: "top",
					},
				},
			});
		});
	});

	describe("edge cases", () => {
		it("should parse ellipse with zero radii", () => {
			const result = Ellipse.parse("ellipse(0 0)");
			expect(result).toEqual({
				ok: true,
				value: {
					kind: "clip-path-ellipse",
					radiusX: { value: 0, unit: "px" },
					radiusY: { value: 0, unit: "px" },
				},
			});
		});

		it("should parse ellipse with unitless zero", () => {
			const result = Ellipse.parse("ellipse(0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.radiusX).toEqual({ value: 0, unit: "px" });
				expect(result.value.radiusY).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should reject negative radiusX", () => {
			const result = Ellipse.parse("ellipse(-50px 100px)");
			expect(result).toEqual({
				ok: false,
				error: "ellipse() radiusX must be non-negative",
			});
		});

		it("should reject negative radiusY", () => {
			const result = Ellipse.parse("ellipse(50px -100px)");
			expect(result).toEqual({
				ok: false,
				error: "ellipse() radiusY must be non-negative",
			});
		});
	});

	describe("error handling", () => {
		it("should reject non-ellipse function", () => {
			const result = Ellipse.parse("circle(50px)");
			expect(result.ok).toBe(false);
		});

		it("should reject missing position after at", () => {
			const result = Ellipse.parse("ellipse(50px 100px at)");
			expect(result).toEqual({
				ok: false,
				error: "Expected position after 'at'",
			});
		});

		it("should reject invalid syntax", () => {
			const result = Ellipse.parse("ellipse(50px 100px center)");
			expect(result).toEqual({
				ok: false,
				error: "Expected 'at' keyword before position",
			});
		});

		it("should reject extra content", () => {
			const result = Ellipse.parse("ellipse(50px 100px at center extra)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid keyword", () => {
			const result = Ellipse.parse("ellipse(invalid)");
			expect(result.ok).toBe(false);
		});
	});

	describe("whitespace handling", () => {
		it("should handle extra whitespace", () => {
			const result = Ellipse.parse("ellipse(  50px   100px   at   center   center  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.radiusX).toEqual({ value: 50, unit: "px" });
				expect(result.value.radiusY).toEqual({ value: 100, unit: "px" });
			}
		});

		it("should handle no whitespace", () => {
			const result = Ellipse.parse("ellipse(50px 100px at center center)");
			expect(result.ok).toBe(true);
		});
	});
});


=== File: src/parse/clip-path/ellipse.ts ===
// b_path:: src/parse/clip-path/ellipse.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunctionRaw } from "./utils";

/**
 * Parse ellipse() shape function.
 *
 * Syntax: ellipse( <radial-size>{2}? [ at <position> ]? )
 *
 * @param css - CSS string
 * @returns Result with ClipPathEllipse IR or error
 *
 * @example
 * ```typescript
 * parse("ellipse()");
 * parse("ellipse(50px 100px)");
 * parse("ellipse(closest-side farthest-side at center)");
 * parse("ellipse(50% 100% at 30px 40px)");
 * ```
 *
 * @public
 */
export function parse(css: string): Result<Type.ClipPathEllipse, string> {
	return parseShapeFunctionRaw(css, "ellipse", parseEllipseChildren);
}

function parseEllipseChildren(children: CssNode[]): Result<Type.ClipPathEllipse, string> {
	if (children.length === 0) {
		return ok({
			kind: "clip-path-ellipse",
		});
	}

	let idx = 0;
	let radiusX: Type.ClipPathEllipse["radiusX"];
	let radiusY: Type.ClipPathEllipse["radiusY"];

	// Parse optional radiusX (using utility, allow 'at' keyword)
	const radiusXResult = ParseUtils.parseRadialSize(children[idx], "ellipse() radiusX", true);
	if (!radiusXResult.ok) return radiusXResult;
	if (radiusXResult.value !== undefined) {
		radiusX = radiusXResult.value;
		idx++;
	}

	// Parse optional radiusY (if radiusX was parsed, also allow 'at' keyword)
	if (radiusX !== undefined && idx < children.length) {
		const radiusYResult = ParseUtils.parseRadialSize(children[idx], "ellipse() radiusY", true);
		if (!radiusYResult.ok) return radiusYResult;
		if (radiusYResult.value !== undefined) {
			radiusY = radiusYResult.value;
			idx++;
		}
	}

	// Parse optional position after 'at' (using utility)
	let position: Type.Position2D | undefined;
	if (idx < children.length) {
		const atResult = ParseUtils.parseAtPosition(children, idx);
		if (!atResult.ok) return atResult;

		// If position is undefined, there was content but no 'at' keyword
		if (atResult.value.position === undefined) {
			return err("Expected 'at' keyword before position");
		}

		position = atResult.value.position;
		idx = atResult.value.nextIdx;
	}

	// Check for extra content
	if (idx < children.length) {
		return err("Unexpected content after ellipse() arguments");
	}

	return ok({
		kind: "clip-path-ellipse",
		...(radiusX !== undefined && { radiusX }),
		...(radiusY !== undefined && { radiusY }),
		...(position !== undefined && { position }),
	});
}


=== File: src/parse/clip-path/geometry-box.test.ts ===
// b_path:: src/parse/clip-path/geometry-box.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./geometry-box";

describe("parse clip-path geometry-box", () => {
	it("parses content-box", () => {
		const result = parse("content-box");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "clip-path-geometry-box",
				value: "content-box",
			});
		}
	});

	it("parses padding-box", () => {
		const result = parse("padding-box");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("padding-box");
		}
	});

	it("parses border-box", () => {
		const result = parse("border-box");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("border-box");
		}
	});

	it("parses margin-box", () => {
		const result = parse("margin-box");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("margin-box");
		}
	});

	it("parses fill-box", () => {
		const result = parse("fill-box");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("fill-box");
		}
	});

	it("parses stroke-box", () => {
		const result = parse("stroke-box");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("stroke-box");
		}
	});

	it("parses view-box", () => {
		const result = parse("view-box");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("view-box");
		}
	});

	it("parses with whitespace", () => {
		const result = parse("  content-box  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("content-box");
		}
	});

	it("rejects invalid keyword", () => {
		const result = parse("invalid-box");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid geometry-box value");
		}
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects other CSS values", () => {
		const result = parse("circle()");
		expect(result.ok).toBe(false);
	});

	it("is case sensitive", () => {
		const result = parse("Content-Box");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/clip-path/geometry-box.ts ===
// b_path:: src/parse/clip-path/geometry-box.ts

import { geometryBoxKeywordsSchema } from "@/core/keywords/geometry-box";
import { err, ok, type Result } from "@/core/result";
import type { ClipPathGeometryBox } from "@/core/types/clip-path";

/**
 * Parse geometry-box keyword for clip-path property.
 *
 * Parses box model keywords that define the clipping region reference box.
 * Supports visual boxes (content-box, padding-box, border-box), shape boxes
 * (adds margin-box), and SVG boxes (fill-box, stroke-box, view-box).
 *
 * @param input - CSS string like "content-box" or "padding-box"
 * @returns Result with ClipPathGeometryBox IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path#geometry-box}
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.ClipPath.GeometryBox.parse("content-box");
 * // { ok: true, value: { kind: "clip-path-geometry-box", value: "content-box" } }
 *
 * const result2 = Parse.ClipPath.GeometryBox.parse("fill-box");
 * // { ok: true, value: { kind: "clip-path-geometry-box", value: "fill-box" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<ClipPathGeometryBox, string> {
	const trimmed = input.trim();
	const result = geometryBoxKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid geometry-box value: "${input}"`);
	}

	return ok({
		kind: "clip-path-geometry-box",
		value: result.data,
	});
}


=== File: src/parse/clip-path/index.ts ===
// b_path:: src/parse/clip-path/index.ts

export * as Circle from "./circle";
export { parse } from "./clip-path";
export * as Ellipse from "./ellipse";
export * as GeometryBox from "./geometry-box";
export * as Inset from "./inset";
export * as None from "./none";
export * as Path from "./path";
export * as Polygon from "./polygon";
export * as Rect from "./rect";
export * as Url from "./url";
export * as Xywh from "./xywh";


=== File: src/parse/clip-path/inset.test.ts ===
// b_path:: src/parse/clip-path/inset.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./inset";

describe("parse inset()", () => {
	describe("basic TRBL", () => {
		it("should parse single value (all sides)", () => {
			const result = parse("inset(10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("clip-path-inset");
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius).toBeUndefined();
			}
		});

		it("should parse two values (vertical | horizontal)", () => {
			const result = parse("inset(10px 20px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse three values", () => {
			const result = parse("inset(10px 20px 30px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse four values (TRBL)", () => {
			const result = parse("inset(10px 20px 30px 40px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 40, unit: "px" });
			}
		});

		it("should handle mixed units", () => {
			const result = parse("inset(10% 20px 5em 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "%" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 5, unit: "em" });
				expect(result.value.left).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should handle unitless zero", () => {
			const result = parse("inset(0 10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should handle all zero", () => {
			const result = parse("inset(0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should handle percentage values", () => {
			const result = parse("inset(10% 20%)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "%" });
				expect(result.value.right).toEqual({ value: 20, unit: "%" });
			}
		});

		it("should handle negative insets", () => {
			const result = parse("inset(-10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: -10, unit: "px" });
			}
		});
	});

	describe("border-radius", () => {
		it("should parse single radius (all corners)", () => {
			const result = parse("inset(10px round 5px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse two radii (diagonal corners)", () => {
			const result = parse("inset(10px round 5px 10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse four radii (all corners)", () => {
			const result = parse("inset(10px round 5px 10px 15px 20px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 15, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse zero radius", () => {
			const result = parse("inset(10px round 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should parse mixed TRBL with radius", () => {
			const result = parse("inset(10px 20px round 5px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse full complex example", () => {
			const result = parse("inset(5% 10% 15% 20% round 2px 4px 6px 8px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 5, unit: "%" });
				expect(result.value.right).toEqual({ value: 10, unit: "%" });
				expect(result.value.bottom).toEqual({ value: 15, unit: "%" });
				expect(result.value.left).toEqual({ value: 20, unit: "%" });
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 2, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 4, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 6, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 8, unit: "px" });
			}
		});
	});

	describe("edge cases and errors", () => {
		it("should reject empty function", () => {
			const result = parse("inset()");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("at least one");
			}
		});

		it("should reject too many TRBL values", () => {
			const result = parse("inset(1px 2px 3px 4px 5px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("accepts 1-4");
			}
		});

		it("should reject round without value", () => {
			const result = parse("inset(10px round)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("after 'round'");
			}
		});

		it("should reject negative radius", () => {
			const result = parse("inset(10px round -5px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject invalid syntax", () => {
			const result = parse("inset(round 10px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toBeTruthy();
			}
		});

		it("should reject invalid function name", () => {
			const result = parse("circle(10px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("inset");
			}
		});
	});
});


=== File: src/parse/clip-path/inset.ts ===
// b_path:: src/parse/clip-path/inset.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunction } from "./utils";

/**
 * Parse CSS inset() function for clip-path.
 *
 * Accepts 1-4 length-percentage values for inset offsets (TRBL),
 * optionally followed by 'round' keyword and border-radius values.
 *
 * Syntax: inset( <length-percentage>{1,4} [ round <border-radius> ]? )
 *
 * @param css - CSS inset() function (e.g., "inset(10px round 5px)")
 * @returns Result with ClipPathInset IR or error message
 *
 * @example
 * Simple inset:
 * ```typescript
 * const result = parse("inset(10px)");
 * // { kind: "clip-path-inset", top: 10px, right: 10px, bottom: 10px, left: 10px }
 * ```
 *
 * @example
 * With border-radius:
 * ```typescript
 * const result = parse("inset(10px 20px round 5px)");
 * // { kind: "clip-path-inset", top: 10px, right: 20px, ..., borderRadius: { ... } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/inset | MDN: inset()}
 */
export function parse(css: string): Result<Type.ClipPathInset, string> {
	return parseShapeFunction(css, "inset", parseInsetArgs);
}

function parseInsetArgs(args: CssNode[]): Result<Type.ClipPathInset, string> {
	if (args.length === 0) {
		return err("inset() requires at least one value");
	}

	// Parse optional border-radius (using utility)
	const roundResult = ParseUtils.parseRoundBorderRadius(args);
	if (!roundResult.ok) return roundResult;
	const { roundIndex, borderRadius } = roundResult.value;

	// Parse TRBL values (before 'round' or all args if no 'round')
	const trblNodes = roundIndex !== -1 ? args.slice(0, roundIndex) : args;

	if (trblNodes.length === 0 || trblNodes.length > 4) {
		return err("inset() accepts 1-4 length-percentage values");
	}

	// Parse each inset value
	const insetValues: Type.LengthPercentage[] = [];

	for (const node of trblNodes) {
		const lpResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lpResult.ok) {
			return err(`Invalid inset value: ${lpResult.error}`);
		}
		insetValues.push(lpResult.value);
	}

	// Expand TRBL values (1-4 values → 4 values)
	const [val0, val1, val2, val3] = insetValues;
	let top: Type.LengthPercentage;
	let right: Type.LengthPercentage;
	let bottom: Type.LengthPercentage;
	let left: Type.LengthPercentage;

	if (insetValues.length === 1 && val0) {
		top = right = bottom = left = val0;
	} else if (insetValues.length === 2 && val0 && val1) {
		top = bottom = val0;
		right = left = val1;
	} else if (insetValues.length === 3 && val0 && val1 && val2) {
		top = val0;
		right = left = val1;
		bottom = val2;
	} else if (insetValues.length === 4 && val0 && val1 && val2 && val3) {
		top = val0;
		right = val1;
		bottom = val2;
		left = val3;
	} else {
		return err("inset() requires valid values");
	}

	return ok({
		kind: "clip-path-inset",
		top,
		right,
		bottom,
		left,
		borderRadius,
	});
}


=== File: src/parse/clip-path/none.test.ts ===
// b_path:: src/parse/clip-path/none.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./none";

describe("parse clip-path none", () => {
	it("parses 'none' keyword", () => {
		const result = parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "clip-path-none" });
		}
	});

	it("parses 'none' with whitespace", () => {
		const result = parse("  none  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "clip-path-none" });
		}
	});

	it("rejects invalid keyword", () => {
		const result = parse("not-none");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid clip-path none value");
		}
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects other CSS values", () => {
		const result = parse("circle()");
		expect(result.ok).toBe(false);
	});

	it("is case sensitive", () => {
		const result = parse("None");
		expect(result.ok).toBe(false);
	});

	it("rejects partial match", () => {
		const result = parse("none-value");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/clip-path/none.ts ===
// b_path:: src/parse/clip-path/none.ts

import { err, ok, type Result } from "@/core/result";
import type { ClipPathNone } from "@/core/types/clip-path";

/**
 * Parse clip-path none keyword.
 *
 * Parses the "none" keyword which indicates no clipping is applied.
 * This is the initial/default value for clip-path.
 *
 * @param css - CSS string containing "none"
 * @returns Result with ClipPathNone IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.ClipPath.None.parse("none");
 * // { ok: true, value: { kind: "clip-path-none" } }
 * ```
 *
 * @public
 */
export function parse(css: string): Result<ClipPathNone, string> {
	const trimmed = css.trim();

	if (trimmed !== "none") {
		return err(`Invalid clip-path none value: "${css}"`);
	}

	return ok({ kind: "clip-path-none" });
}


=== File: src/parse/clip-path/path.test.ts ===
// b_path:: src/parse/clip-path/path.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./path";

describe("parse path()", () => {
	describe("basic path data", () => {
		it("should parse simple path", () => {
			const result = parse("path('M 10,10 L 90,10 L 50,90 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("clip-path-path");
				expect(result.value.pathData).toBe("M 10,10 L 90,10 L 50,90 Z");
				expect(result.value.fillRule).toBeUndefined();
			}
		});

		it("should parse path with lowercase commands", () => {
			const result = parse("path('m 10,10 l 80,0 l -40,80 z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("m 10,10 l 80,0 l -40,80 z");
			}
		});

		it("should parse compact path syntax", () => {
			const result = parse("path('M10 10L90 10L50 90z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M10 10L90 10L50 90z");
			}
		});

		it("should parse path with various commands", () => {
			const result = parse("path('M 0,0 H 100 V 100 L 0,100 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 0,0 H 100 V 100 L 0,100 Z");
			}
		});

		it("should parse path with curves", () => {
			const result = parse("path('M 10,10 C 20,20 40,20 50,10')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 10,10 C 20,20 40,20 50,10");
			}
		});

		it("should parse path with quadratic curves", () => {
			const result = parse("path('M 10,10 Q 25,5 40,10')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 10,10 Q 25,5 40,10");
			}
		});

		it("should parse path with arcs", () => {
			const result = parse("path('M 10,10 A 20,20 0 0,0 30,10')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 10,10 A 20,20 0 0,0 30,10");
			}
		});
	});

	describe("fill-rule", () => {
		it("should parse with nonzero fill-rule", () => {
			const result = parse("path(nonzero, 'M 10,10 L 90,10 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.fillRule).toBe("nonzero");
				expect(result.value.pathData).toBe("M 10,10 L 90,10 Z");
			}
		});

		it("should parse with evenodd fill-rule", () => {
			const result = parse("path(evenodd, 'M 10,10 L 90,10 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.fillRule).toBe("evenodd");
				expect(result.value.pathData).toBe("M 10,10 L 90,10 Z");
			}
		});

		it("should parse fill-rule case-insensitively", () => {
			const result = parse("path(EVENODD, 'M 10,10 L 90,10 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.fillRule).toBe("evenodd");
			}
		});
	});

	describe("edge cases", () => {
		it("should parse path with extra whitespace", () => {
			const result = parse("path('  M 10,10   L 90,10   Z  ')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("  M 10,10   L 90,10   Z  ");
			}
		});

		it("should parse path with negative coordinates", () => {
			const result = parse("path('M -10,-10 L 90,10 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M -10,-10 L 90,10 Z");
			}
		});

		it("should parse path with decimal coordinates", () => {
			const result = parse("path('M 10.5,10.5 L 90.5,10.5 Z')");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.pathData).toBe("M 10.5,10.5 L 90.5,10.5 Z");
			}
		});
	});

	describe("errors", () => {
		it("should error on empty function", () => {
			const result = parse("path()");
			expect(result.ok).toBe(false);
		});

		it("should error on non-string path data", () => {
			const result = parse("path(10px)");
			expect(result.ok).toBe(false);
		});

		it("should error on empty path data", () => {
			const result = parse("path('')");
			expect(result.ok).toBe(false);
		});

		it("should error on invalid fill-rule", () => {
			const result = parse("path(invalid, 'M 10,10 Z')");
			expect(result.ok).toBe(false);
		});

		it("should error on path without commands", () => {
			const result = parse("path('10,10 90,10')");
			expect(result.ok).toBe(false);
		});

		it("should error on path not starting with M/m", () => {
			const result = parse("path('L 10,10 Z')");
			expect(result.ok).toBe(false);
		});

		it("should error on non-path function", () => {
			const result = parse("circle(50px)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/clip-path/path.ts ===
// b_path:: src/parse/clip-path/path.ts
import type csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseShapeFunction } from "./utils";

/**
 * Parse CSS path() function for clip-path.
 *
 * Accepts an optional fill-rule keyword followed by an SVG path data string.
 *
 * Syntax: path( [<fill-rule>,]? <string> )
 *
 * @param css - CSS path() function (e.g., "path('M 10,10 L 90,10 L 50,90 Z')")
 * @returns Result with ClipPathPath IR or error message
 *
 * @example
 * Simple path:
 * ```typescript
 * const result = parse("path('M 10,10 L 90,10 L 50,90 Z')");
 * // { kind: "clip-path-path", pathData: "M 10,10 L 90,10 L 50,90 Z" }
 * ```
 *
 * @example
 * With fill-rule:
 * ```typescript
 * const result = parse("path(evenodd, 'M 10,10 L 90,10 Z')");
 * // { kind: "clip-path-path", fillRule: "evenodd", pathData: "M 10,10 L 90,10 Z" }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/path | MDN: path()}
 */
export function parse(css: string): Result<Type.ClipPathPath, string> {
	return parseShapeFunction(css, "path", parsePathArgs);
}

function parsePathArgs(args: csstree.CssNode[]): Result<Type.ClipPathPath, string> {
	if (args.length === 0) {
		return err("path() requires a path data string");
	}

	// Check if first argument is fill-rule keyword
	let fillRule: "nonzero" | "evenodd" | undefined;
	let pathDataNode: csstree.CssNode;

	if (args.length === 1) {
		// Only path data
		const arg0 = args[0];
		if (!arg0) {
			return err("path() requires a path data string");
		}
		pathDataNode = arg0;
	} else if (args.length >= 2) {
		// Check if first argument is fill-rule
		const firstArg = args[0];
		const secondArg = args[1];

		if (!firstArg || !secondArg) {
			return err("path() requires valid arguments");
		}

		if (firstArg.type === "Identifier") {
			const keyword = firstArg.name.toLowerCase();
			if (keyword === "nonzero" || keyword === "evenodd") {
				fillRule = keyword;
				pathDataNode = secondArg;
			} else {
				return err(`Invalid fill-rule: ${firstArg.name}. Expected 'nonzero' or 'evenodd'`);
			}
		} else {
			return err("First argument must be fill-rule keyword or path data string");
		}
	} else {
		return err("path() requires a path data string");
	}

	// Extract string value
	if (pathDataNode.type !== "String") {
		return err("Path data must be a string");
	}

	const pathData = pathDataNode.value;

	// Validate path data contains valid SVG commands
	const validationResult = validatePathData(pathData);
	if (!validationResult.ok) {
		return err(validationResult.error);
	}

	return ok({
		kind: "clip-path-path",
		fillRule,
		pathData,
	});
}

/**
 * Validate SVG path data string.
 *
 * Checks for valid SVG path commands (M, L, H, V, C, S, Q, T, A, Z).
 * Does not perform deep validation of coordinate syntax.
 *
 * @internal
 */
function validatePathData(pathData: string): Result<void, string> {
	if (!pathData || pathData.trim() === "") {
		return err("Path data cannot be empty");
	}

	// Check for valid SVG path commands
	const pathCommandRegex = /[MmLlHhVvCcSsQqTtAaZz]/;
	if (!pathCommandRegex.test(pathData)) {
		return err("Path data must contain valid SVG commands (M, L, H, V, C, S, Q, T, A, Z)");
	}

	// Path data should start with M or m (moveto)
	const trimmed = pathData.trim();
	if (!trimmed.match(/^[Mm]/)) {
		return err("Path data should start with M or m (moveto) command");
	}

	return ok(undefined);
}


=== File: src/parse/clip-path/polygon.test.ts ===
// b_path:: src/parse/clip-path/polygon.test.ts

import { describe, expect, it } from "vitest";
import * as Polygon from "./polygon";

describe("Parse.ClipPath.Polygon.parse", () => {
	describe("basic parsing", () => {
		it("should parse 3-point triangle", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 100%, 0% 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value).toEqual({
				kind: "clip-path-polygon",
				points: [
					{ x: { value: 50, unit: "%" }, y: { value: 0, unit: "%" } },
					{ x: { value: 100, unit: "%" }, y: { value: 100, unit: "%" } },
					{ x: { value: 0, unit: "%" }, y: { value: 100, unit: "%" } },
				],
			});
		});

		it("should parse 4-point square", () => {
			const result = Polygon.parse("polygon(0px 0px, 100px 0px, 100px 100px, 0px 100px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(4);
			expect(result.value.points[0]).toEqual({ x: { value: 0, unit: "px" }, y: { value: 0, unit: "px" } });
			expect(result.value.points[3]).toEqual({ x: { value: 0, unit: "px" }, y: { value: 100, unit: "px" } });
		});

		it("should parse 5-point pentagon", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(5);
		});

		it("should parse polygon with mixed units", () => {
			const result = Polygon.parse("polygon(10px 20%, 50% 30px, 100px 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toEqual([
				{ x: { value: 10, unit: "px" }, y: { value: 20, unit: "%" } },
				{ x: { value: 50, unit: "%" }, y: { value: 30, unit: "px" } },
				{ x: { value: 100, unit: "px" }, y: { value: 100, unit: "%" } },
			]);
		});

		it("should parse polygon with unitless zero", () => {
			const result = Polygon.parse("polygon(0 0, 100px 0, 100px 100px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points[0]).toEqual({ x: { value: 0, unit: "px" }, y: { value: 0, unit: "px" } });
		});
	});

	describe("fill-rule parsing", () => {
		it("should parse nonzero fill-rule", () => {
			const result = Polygon.parse("polygon(nonzero, 50% 0%, 100% 50%, 50% 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.fillRule).toBe("nonzero");
			expect(result.value.points).toHaveLength(3);
		});

		it("should parse evenodd fill-rule", () => {
			const result = Polygon.parse("polygon(evenodd, 0px 0px, 100px 0px, 100px 100px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.fillRule).toBe("evenodd");
			expect(result.value.points).toHaveLength(3);
		});

		it("should parse polygon without fill-rule", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 50%, 50% 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.fillRule).toBeUndefined();
		});
	});

	describe("complex shapes", () => {
		it("should parse 6-point star", () => {
			const result = Polygon.parse(
				"polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)",
			);
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(10);
		});

		it("should parse 6-sided hexagon", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(6);
		});
	});

	describe("edge cases", () => {
		it("should handle minimum 3 points", () => {
			const result = Polygon.parse("polygon(0px 0px, 50px 50px, 100px 0px)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(3);
		});

		it("should handle many points", () => {
			const points = Array.from({ length: 20 }, (_, i) => `${i * 5}% ${(i * 3) % 100}%`).join(", ");
			const result = Polygon.parse(`polygon(${points})`);
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(20);
		});
	});

	describe("error handling", () => {
		it("should reject too few points", () => {
			const result = Polygon.parse("polygon(50% 0%, 100% 50%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("at least 3 points");
		});

		it("should reject odd number of coordinates", () => {
			const result = Polygon.parse("polygon(50% 0%, 100%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("coordinate");
		});

		it("should reject invalid fill-rule", () => {
			const result = Polygon.parse("polygon(invalid, 50% 0%, 100% 50%, 50% 100%)");
			expect(result.ok).toBe(false);
		});

		it("should reject wrong function name", () => {
			const result = Polygon.parse("circle(50%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("polygon");
		});

		it("should reject missing comma after fill-rule", () => {
			const result = Polygon.parse("polygon(nonzero 50% 0%, 100% 50%, 50% 100%)");
			expect(result.ok).toBe(false);
			if (result.ok) return;

			expect(result.error).toContain("comma");
		});
	});

	describe("whitespace handling", () => {
		it("should handle extra spaces", () => {
			const result = Polygon.parse("polygon(  50%   0%  ,  100%   50%  ,  50%   100%  )");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(3);
		});

		it("should handle no spaces", () => {
			const result = Polygon.parse("polygon(50% 0%,100% 50%,50% 100%)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;

			expect(result.value.points).toHaveLength(3);
		});
	});
});


=== File: src/parse/clip-path/polygon.ts ===
// b_path:: src/parse/clip-path/polygon.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunctionRaw } from "./utils";

/**
 * Parse polygon() basic shape function.
 *
 * Syntax: polygon( <fill-rule>? , <shape-arg># )
 *
 * where:
 *   <fill-rule> = nonzero | evenodd
 *   <shape-arg> = <length-percentage> <length-percentage>
 *
 * @example
 * parse("polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)");
 * // { kind: "clip-path-polygon", points: [{x: 50%, y: 0%}, {x: 100%, y: 50%}, ...] }
 *
 * parse("polygon(nonzero, 0px 0px, 100px 0px, 100px 100px)");
 * // { kind: "clip-path-polygon", fillRule: "nonzero", points: [...] }
 *
 * @public
 */
export function parse(css: string): Result<Type.ClipPathPolygon, string> {
	return parseShapeFunctionRaw(css, "polygon", parsePolygonChildren);
}

function parsePolygonChildren(children: CssNode[]): Result<Type.ClipPathPolygon, string> {
	let idx = 0;

	let fillRule: Type.ClipPathPolygon["fillRule"];
	const points: Type.ClipPathPolygon["points"] = [];

	// Check for optional fill-rule keyword
	if (idx < children.length) {
		const firstNode = children[idx];
		if (firstNode?.type === "Identifier") {
			const keyword = firstNode.name.toLowerCase();
			if (keyword === "nonzero" || keyword === "evenodd") {
				fillRule = keyword;
				idx++;

				// After fill-rule, require a comma
				if (!AstUtils.isCommaAt(children, idx)) {
					return err("Expected comma after fill-rule");
				}
				idx = AstUtils.skipComma(children, idx);
			}
		}
	}

	// Split remaining nodes into point pairs (x y, x y, ...)
	const pointGroups = AstUtils.splitNodesByComma(children, {
		startIndex: idx,
	});

	// Parse each point pair
	for (const group of pointGroups) {
		if (group.length !== 2) {
			return err("Each point must have exactly 2 coordinates (x y), separated by spaces");
		}

		const xNode = group[0];
		const yNode = group[1];
		if (!xNode || !yNode) {
			return err("Invalid point coordinates");
		}

		const xResult = ParseUtils.parseLengthPercentageNode(xNode);
		if (!xResult.ok) return xResult;

		const yResult = ParseUtils.parseLengthPercentageNode(yNode);
		if (!yResult.ok) return yResult;

		points.push({ x: xResult.value, y: yResult.value });
	}

	// Validate minimum 3 points
	if (points.length < 3) {
		return err("polygon() requires at least 3 points");
	}

	const polygon: Type.ClipPathPolygon = {
		kind: "clip-path-polygon",
		...(fillRule !== undefined && { fillRule }),
		points,
	};

	const validated = Type.clipPathPolygonSchema.safeParse(polygon);
	if (!validated.success) {
		return err(`Invalid polygon: ${validated.error.message}`);
	}

	return ok(validated.data);
}


=== File: src/parse/clip-path/rect.test.ts ===
// b_path:: src/parse/clip-path/rect.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./rect";

describe("parse rect()", () => {
	describe("basic TRBL", () => {
		it("should parse single value (all sides)", () => {
			const result = parse("rect(10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("clip-path-rect");
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius).toBeUndefined();
			}
		});

		it("should parse two values (vertical | horizontal)", () => {
			const result = parse("rect(10px 20px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse three values", () => {
			const result = parse("rect(10px 20px 30px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse four values (TRBL)", () => {
			const result = parse("rect(10px 20px 30px 40px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 40, unit: "px" });
			}
		});
	});

	describe("auto keyword", () => {
		it("should parse auto for all sides", () => {
			const result = parse("rect(auto)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toBe("auto");
				expect(result.value.right).toBe("auto");
				expect(result.value.bottom).toBe("auto");
				expect(result.value.left).toBe("auto");
			}
		});

		it("should parse mixed auto and length values", () => {
			const result = parse("rect(10px auto 20px auto)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toBe("auto");
				expect(result.value.bottom).toEqual({ value: 20, unit: "px" });
				expect(result.value.left).toBe("auto");
			}
		});

		it("should parse auto with percentage", () => {
			const result = parse("rect(auto 50% auto 25%)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toBe("auto");
				expect(result.value.right).toEqual({ value: 50, unit: "%" });
				expect(result.value.bottom).toBe("auto");
				expect(result.value.left).toEqual({ value: 25, unit: "%" });
			}
		});
	});

	describe("border-radius", () => {
		it("should parse with single border-radius", () => {
			const result = parse("rect(10px round 5px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse with multiple border-radius values", () => {
			const result = parse("rect(10px 20px round 5px 10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse with auto and border-radius", () => {
			const result = parse("rect(auto 10px round 8px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toBe("auto");
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius).toBeDefined();
			}
		});
	});

	describe("edge cases", () => {
		it("should parse zero values", () => {
			const result = parse("rect(0 0 0 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should parse percentages", () => {
			const result = parse("rect(10% 20% 30% 40%)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "%" });
				expect(result.value.right).toEqual({ value: 20, unit: "%" });
			}
		});

		it("should parse mixed units", () => {
			const result = parse("rect(10px 5em 20% 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 5, unit: "em" });
				expect(result.value.bottom).toEqual({ value: 20, unit: "%" });
				expect(result.value.left).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("errors", () => {
		it("should error on empty function", () => {
			const result = parse("rect()");
			expect(result.ok).toBe(false);
		});

		it("should error on too many values", () => {
			const result = parse("rect(1px 2px 3px 4px 5px)");
			expect(result.ok).toBe(false);
		});

		it("should error on invalid value", () => {
			const result = parse("rect(invalid)");
			expect(result.ok).toBe(false);
		});

		it("should error on round without radius", () => {
			const result = parse("rect(10px round)");
			expect(result.ok).toBe(false);
		});

		it("should error on non-rect function", () => {
			const result = parse("circle(50px)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/clip-path/rect.ts ===
// b_path:: src/parse/clip-path/rect.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunction } from "./utils";

/**
 * Parse CSS rect() function for clip-path.
 *
 * Accepts 1-4 length-percentage or 'auto' values for edge offsets (TRBL),
 * optionally followed by 'round' keyword and border-radius values.
 *
 * Syntax: rect( [<length-percentage> | auto]{1,4} [ round <border-radius> ]? )
 *
 * @param css - CSS rect() function (e.g., "rect(10px auto 20px auto round 5px)")
 * @returns Result with ClipPathRect IR or error message
 *
 * @example
 * Simple rect:
 * ```typescript
 * const result = parse("rect(10px 20px 30px 40px)");
 * // { kind: "clip-path-rect", top: 10px, right: 20px, bottom: 30px, left: 40px }
 * ```
 *
 * @example
 * With auto:
 * ```typescript
 * const result = parse("rect(10px auto 20px auto)");
 * // { kind: "clip-path-rect", top: 10px, right: "auto", bottom: 20px, left: "auto" }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/rect | MDN: rect()}
 */
export function parse(css: string): Result<Type.ClipPathRect, string> {
	return parseShapeFunction(css, "rect", parseRectArgs);
}

function parseRectArgs(args: CssNode[]): Result<Type.ClipPathRect, string> {
	if (args.length === 0) {
		return err("rect() requires at least one value");
	}

	// Parse optional border-radius (using utility)
	const roundResult = ParseUtils.parseRoundBorderRadius(args);
	if (!roundResult.ok) return roundResult;
	const { roundIndex, borderRadius } = roundResult.value;

	// Parse TRBL values (before 'round' or all args if no 'round')
	const trblNodes = roundIndex !== -1 ? args.slice(0, roundIndex) : args;

	if (trblNodes.length === 0) {
		return err("rect() requires at least one edge value");
	}

	// Parse each edge value (can be length-percentage or 'auto')
	const edgeValues: (Type.LengthPercentage | "auto")[] = [];

	for (const node of trblNodes) {
		// Check for 'auto' keyword
		if (node.type === "Identifier" && node.name.toLowerCase() === "auto") {
			edgeValues.push("auto");
			continue;
		}

		// Parse as length-percentage
		const lpResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lpResult.ok) {
			return err(`Invalid edge value: ${lpResult.error}`);
		}

		edgeValues.push(lpResult.value);
	}

	// Expand TRBL values (1-4 values → 4 values)
	if (edgeValues.length < 1 || edgeValues.length > 4) {
		return err("rect() accepts 1-4 edge values");
	}

	const [val0, val1, val2, val3] = edgeValues;
	let top: Type.LengthPercentage | "auto";
	let right: Type.LengthPercentage | "auto";
	let bottom: Type.LengthPercentage | "auto";
	let left: Type.LengthPercentage | "auto";

	if (edgeValues.length === 1 && val0) {
		top = right = bottom = left = val0;
	} else if (edgeValues.length === 2 && val0 && val1) {
		top = bottom = val0;
		right = left = val1;
	} else if (edgeValues.length === 3 && val0 && val1 && val2) {
		top = val0;
		right = left = val1;
		bottom = val2;
	} else if (edgeValues.length === 4 && val0 && val1 && val2 && val3) {
		top = val0;
		right = val1;
		bottom = val2;
		left = val3;
	} else {
		return err("rect() requires valid edge values");
	}

	return ok({
		kind: "clip-path-rect",
		top,
		right,
		bottom,
		left,
		borderRadius,
	});
}


=== File: src/parse/clip-path/url.test.ts ===
// b_path:: src/parse/clip-path/url.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./url";

describe("parse clip-path url", () => {
	it("parses url with fragment identifier", () => {
		const result = parse("url(#clip-shape)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "url",
				value: "#clip-shape",
			});
		}
	});

	it("parses url with file and fragment", () => {
		const result = parse("url(shapes.svg#clip)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "url",
				value: "shapes.svg#clip",
			});
		}
	});

	it("parses url with single quotes", () => {
		const result = parse("url('shapes.svg#clip')");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "url",
				value: "shapes.svg#clip",
			});
		}
	});

	it("parses url with double quotes", () => {
		const result = parse('url("shapes.svg#clip")');
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "url",
				value: "shapes.svg#clip",
			});
		}
	});

	it("parses url with path", () => {
		const result = parse("url(/path/to/shapes.svg#myClip)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("/path/to/shapes.svg#myClip");
		}
	});

	it("parses url with whitespace", () => {
		const result = parse("  url(#clip)  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("#clip");
		}
	});

	it("rejects invalid url format", () => {
		const result = parse("not-a-url");
		expect(result.ok).toBe(false);
	});

	it("rejects empty url", () => {
		const result = parse("url()");
		expect(result.ok).toBe(false);
	});

	it("handles missing closing parenthesis", () => {
		const result = parse("url(#clip");
		// The underlying parseUrl might handle this, so we just test it works
		expect(result).toBeDefined();
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/clip-path/url.ts ===
// b_path:: src/parse/clip-path/url.ts

import type { Result } from "@/core/result";
import type { Url } from "@/core/types/url";
import { parseUrl } from "@/utils/parse/url";

/**
 * Parse CSS url() for clip-path property.
 *
 * Parses URL references to SVG clipping paths.
 * Accepts fragment identifiers (#id) or file paths.
 * Supports quoted and unquoted URLs.
 *
 * @param input - CSS string like "url(#clip)" or "url('shapes.svg#clip')"
 * @returns Result with Url IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path}
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.ClipPath.Url.parse("url(#clip-shape)");
 * // { ok: true, value: { kind: "url", value: "#clip-shape" } }
 *
 * const result2 = Parse.ClipPath.Url.parse("url('shapes.svg#clip')");
 * // { ok: true, value: { kind: "url", value: "shapes.svg#clip" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<Url, string> {
	return parseUrl(input);
}


=== File: src/parse/clip-path/utils.ts ===
// b_path:: src/parse/clip-path/utils.ts
import type { CssNode } from "css-tree";
import { err, type Result } from "@/core/result";
import * as AstUtils from "@/utils/ast";

/**
 * Common wrapper for parsing CSS basic shape functions.
 *
 * Eliminates boilerplate of:
 * - Parsing CSS string to AST
 * - Finding the function node
 * - Extracting function arguments
 * - Error handling and try/catch
 *
 * @param css - CSS string to parse (e.g., "rect(10px 20px 30px 40px)")
 * @param functionName - Name of the shape function (e.g., "rect", "circle")
 * @param parser - Function to parse shape-specific arguments
 * @returns Result with parsed shape IR or error
 *
 * @example
 * Basic usage:
 * ```typescript
 * export function parse(css: string): Result<ClipPathRect, string> {
 *   return parseShapeFunction(css, "rect", parseRectArgs);
 * }
 *
 * function parseRectArgs(args: CssNode[]): Result<ClipPathRect, string> {
 *   // Parse rect-specific arguments
 *   return ok({ kind: "clip-path-rect", ... });
 * }
 * ```
 *
 * @example
 * With error handling:
 * ```typescript
 * function parseRectArgs(args: CssNode[]): Result<ClipPathRect, string> {
 *   if (args.length === 0) {
 *     return err("rect() requires at least one value");
 *   }
 *   // ... parse logic ...
 * }
 * ```
 *
 * @public
 */
export function parseShapeFunction<T>(
	css: string,
	functionName: string,
	parser: (args: CssNode[]) => Result<T, string>,
): Result<T, string> {
	try {
		// Parse CSS string to AST
		const astResult = AstUtils.parseCssString(css);
		if (!astResult.ok) {
			return err(astResult.error);
		}

		// Find the shape function node
		const fnResult = AstUtils.findFunctionNode(astResult.value, functionName);
		if (!fnResult.ok) {
			return err(fnResult.error);
		}

		// Extract function arguments (commas removed)
		const args = AstUtils.parseFunctionArguments(fnResult.value);

		// Delegate to shape-specific parser
		return parser(args);
	} catch (e) {
		return err(`Failed to parse ${functionName}(): ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Similar to parseShapeFunction but returns raw AST children.
 *
 * Use this variant when you need direct access to AST nodes with commas
 * preserved (e.g., polygon needs to split by commas manually).
 *
 * @param css - CSS string to parse
 * @param functionName - Name of the shape function
 * @param parser - Function to parse raw AST children
 * @returns Result with parsed shape IR or error
 *
 * @example
 * For shapes that need comma handling:
 * ```typescript
 * export function parse(css: string): Result<ClipPathPolygon, string> {
 *   return parseShapeFunctionRaw(css, "polygon", parsePolygonChildren);
 * }
 *
 * function parsePolygonChildren(children: CssNode[]): Result<ClipPathPolygon, string> {
 *   // Split by commas manually
 *   const pointGroups = AstUtils.splitNodesByComma(children);
 *   // ... parse points ...
 * }
 * ```
 *
 * @public
 */
export function parseShapeFunctionRaw<T>(
	css: string,
	functionName: string,
	parser: (children: CssNode[]) => Result<T, string>,
): Result<T, string> {
	try {
		// Parse CSS string to AST
		const astResult = AstUtils.parseCssString(css);
		if (!astResult.ok) {
			return err(astResult.error);
		}

		// Find the shape function node
		const fnResult = AstUtils.findFunctionNode(astResult.value, functionName);
		if (!fnResult.ok) {
			return err(fnResult.error);
		}

		// Get raw children (commas included)
		const children = fnResult.value.children ? Array.from(fnResult.value.children) : [];

		// Delegate to shape-specific parser
		return parser(children);
	} catch (e) {
		return err(`Failed to parse ${functionName}(): ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/clip-path/xywh.test.ts ===
// b_path:: src/parse/clip-path/xywh.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./xywh";

describe("parse xywh()", () => {
	describe("basic position and size", () => {
		it("should parse all four values", () => {
			const result = parse("xywh(10px 20px 100px 50px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("clip-path-xywh");
				expect(result.value.x).toEqual({ value: 10, unit: "px" });
				expect(result.value.y).toEqual({ value: 20, unit: "px" });
				expect(result.value.width).toEqual({ value: 100, unit: "px" });
				expect(result.value.height).toEqual({ value: 50, unit: "px" });
				expect(result.value.borderRadius).toBeUndefined();
			}
		});

		it("should parse with percentages", () => {
			const result = parse("xywh(0% 0% 100% 100%)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.x).toEqual({ value: 0, unit: "%" });
				expect(result.value.y).toEqual({ value: 0, unit: "%" });
				expect(result.value.width).toEqual({ value: 100, unit: "%" });
				expect(result.value.height).toEqual({ value: 100, unit: "%" });
			}
		});

		it("should parse with mixed units", () => {
			const result = parse("xywh(10px 5em 50% 80px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.x).toEqual({ value: 10, unit: "px" });
				expect(result.value.y).toEqual({ value: 5, unit: "em" });
				expect(result.value.width).toEqual({ value: 50, unit: "%" });
				expect(result.value.height).toEqual({ value: 80, unit: "px" });
			}
		});

		it("should parse zero values", () => {
			const result = parse("xywh(0 0 0 0)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.x).toEqual({ value: 0, unit: "px" });
				expect(result.value.width).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("border-radius", () => {
		it("should parse with single border-radius", () => {
			const result = parse("xywh(10px 20px 100px 50px round 5px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse with multiple border-radius values", () => {
			const result = parse("xywh(0 0 100% 100% round 5px 10px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse with full border-radius", () => {
			const result = parse("xywh(10% 20% 50px 80px round 5px 10px 15px 20px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.borderRadius?.bottomRight).toEqual({ value: 15, unit: "px" });
				expect(result.value.borderRadius?.bottomLeft).toEqual({ value: 20, unit: "px" });
			}
		});
	});

	describe("validation", () => {
		it("should reject negative width", () => {
			const result = parse("xywh(10px 20px -100px 50px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Width must be non-negative");
			}
		});

		it("should reject negative height", () => {
			const result = parse("xywh(10px 20px 100px -50px)");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Height must be non-negative");
			}
		});

		it("should allow negative x position", () => {
			const result = parse("xywh(-10px 20px 100px 50px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.x).toEqual({ value: -10, unit: "px" });
			}
		});

		it("should allow negative y position", () => {
			const result = parse("xywh(10px -20px 100px 50px)");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.y).toEqual({ value: -20, unit: "px" });
			}
		});
	});

	describe("errors", () => {
		it("should error on empty function", () => {
			const result = parse("xywh()");
			expect(result.ok).toBe(false);
		});

		it("should error on too few values", () => {
			const result = parse("xywh(10px 20px)");
			expect(result.ok).toBe(false);
		});

		it("should error on too many values", () => {
			const result = parse("xywh(10px 20px 100px 50px 30px)");
			expect(result.ok).toBe(false);
		});

		it("should error on invalid value", () => {
			const result = parse("xywh(invalid 20px 100px 50px)");
			expect(result.ok).toBe(false);
		});

		it("should error on round without radius", () => {
			const result = parse("xywh(10px 20px 100px 50px round)");
			expect(result.ok).toBe(false);
		});

		it("should error on non-xywh function", () => {
			const result = parse("rect(10px 20px 30px 40px)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/clip-path/xywh.ts ===
// b_path:: src/parse/clip-path/xywh.ts
import type { CssNode } from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";
import { parseShapeFunction } from "./utils";

/**
 * Parse CSS xywh() function for clip-path.
 *
 * Accepts 4 length-percentage values for position (x, y) and dimensions (width, height),
 * optionally followed by 'round' keyword and border-radius values.
 *
 * Syntax: xywh( <length-percentage>{4} [ round <border-radius> ]? )
 *
 * @param css - CSS xywh() function (e.g., "xywh(10px 20px 100px 50px round 5px)")
 * @returns Result with ClipPathXywh IR or error message
 *
 * @example
 * Simple xywh:
 * ```typescript
 * const result = parse("xywh(10px 20px 100px 50px)");
 * // { kind: "clip-path-xywh", x: 10px, y: 20px, width: 100px, height: 50px }
 * ```
 *
 * @example
 * With border-radius:
 * ```typescript
 * const result = parse("xywh(0 0 100% 100% round 10px)");
 * // { kind: "clip-path-xywh", x: 0, y: 0, ..., borderRadius: { ... } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/xywh | MDN: xywh()}
 */
export function parse(css: string): Result<Type.ClipPathXywh, string> {
	return parseShapeFunction(css, "xywh", parseXywhArgs);
}

function parseXywhArgs(args: CssNode[]): Result<Type.ClipPathXywh, string> {
	if (args.length === 0) {
		return err("xywh() requires exactly 4 values");
	}

	// Parse optional border-radius (using utility)
	const roundResult = ParseUtils.parseRoundBorderRadius(args);
	if (!roundResult.ok) return roundResult;
	const { roundIndex, borderRadius } = roundResult.value;

	// Parse position/size values (before 'round' or all args if no 'round')
	const xywhNodes = roundIndex !== -1 ? args.slice(0, roundIndex) : args;

	if (xywhNodes.length !== 4) {
		return err("xywh() requires exactly 4 values (x, y, width, height)");
	}

	// Parse x, y, width, height
	const [xNode, yNode, widthNode, heightNode] = xywhNodes;

	if (!xNode || !yNode || !widthNode || !heightNode) {
		return err("xywh() requires exactly 4 values (x, y, width, height)");
	}

	const xResult = ParseUtils.parseLengthPercentageNode(xNode);
	if (!xResult.ok) {
		return err(`Invalid x value: ${xResult.error}`);
	}

	const yResult = ParseUtils.parseLengthPercentageNode(yNode);
	if (!yResult.ok) {
		return err(`Invalid y value: ${yResult.error}`);
	}

	const widthResult = ParseUtils.parseLengthPercentageNode(widthNode);
	if (!widthResult.ok) {
		return err(`Invalid width value: ${widthResult.error}`);
	}

	const heightResult = ParseUtils.parseLengthPercentageNode(heightNode);
	if (!heightResult.ok) {
		return err(`Invalid height value: ${heightResult.error}`);
	}

	// Validate non-negative width and height
	if (widthResult.value.value < 0) {
		return err("Width must be non-negative");
	}

	if (heightResult.value.value < 0) {
		return err("Height must be non-negative");
	}

	return ok({
		kind: "clip-path-xywh",
		x: xResult.value,
		y: yResult.value,
		width: widthResult.value,
		height: heightResult.value,
		borderRadius,
	});
}


=== File: src/parse/color/color-function.test.ts ===
// b_path:: src/parse/color/color-function.test.ts
import { describe, expect, test } from "vitest";
import * as ColorFunction from "./color-function";

describe("parse() - color() function parser", () => {
	describe("Color Spaces", () => {
		test("srgb color space", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "srgb",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("srgb-linear color space", () => {
			const result = ColorFunction.parse("color(srgb-linear 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "srgb-linear",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("display-p3 color space", () => {
			const result = ColorFunction.parse("color(display-p3 0.928 0.322 0.203)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "display-p3",
					channels: [0.928, 0.322, 0.203],
				});
			}
		});

		test("a98-rgb color space", () => {
			const result = ColorFunction.parse("color(a98-rgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "a98-rgb",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("prophoto-rgb color space", () => {
			const result = ColorFunction.parse("color(prophoto-rgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "prophoto-rgb",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("rec2020 color space", () => {
			const result = ColorFunction.parse("color(rec2020 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "rec2020",
					channels: [0.5, 0.2, 0.8],
				});
			}
		});

		test("xyz color space", () => {
			const result = ColorFunction.parse("color(xyz 0.3 0.4 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "xyz",
					channels: [0.3, 0.4, 0.5],
				});
			}
		});

		test("xyz-d50 color space", () => {
			const result = ColorFunction.parse("color(xyz-d50 0.3 0.4 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "xyz-d50",
					channels: [0.3, 0.4, 0.5],
				});
			}
		});

		test("xyz-d65 color space", () => {
			const result = ColorFunction.parse("color(xyz-d65 0.3 0.4 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "xyz-d65",
					channels: [0.3, 0.4, 0.5],
				});
			}
		});
	});

	describe("Channel Formats", () => {
		test("numeric channel values", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.5, 0.2, 0.8]);
			}
		});

		test("percentage channel values", () => {
			const result = ColorFunction.parse("color(srgb 50% 20% 80%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.5, 0.2, 0.8]);
			}
		});

		test("mixed numeric and percentage values", () => {
			const result = ColorFunction.parse("color(srgb 0.5 20% 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.5, 0.2, 0.8]);
			}
		});
	});

	describe("Alpha Channel", () => {
		test("color with numeric alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "color",
					colorSpace: "srgb",
					channels: [0.5, 0.2, 0.8],
					alpha: 0.5,
				});
			}
		});

		test("color with percentage alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});

		test("color without alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBeUndefined();
			}
		});
	});

	describe("Edge Cases", () => {
		test("zero values", () => {
			const result = ColorFunction.parse("color(srgb 0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0, 0, 0]);
			}
		});

		test("one values", () => {
			const result = ColorFunction.parse("color(srgb 1 1 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([1, 1, 1]);
			}
		});

		test("values with high precision", () => {
			const result = ColorFunction.parse("color(srgb 0.123456 0.789012 0.345678)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.123456, 0.789012, 0.345678]);
			}
		});

		test("negative values (allowed for some spaces)", () => {
			const result = ColorFunction.parse("color(xyz -0.1 0.5 -0.2)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([-0.1, 0.5, -0.2]);
			}
		});

		test("values over 1 (allowed for some spaces)", () => {
			const result = ColorFunction.parse("color(xyz 1.5 2.0 1.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([1.5, 2.0, 1.8]);
			}
		});

		test("case insensitive color space", () => {
			const result = ColorFunction.parse("color(SRGB 0.5 0.2 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.colorSpace).toBe("srgb");
			}
		});

		test("extra whitespace", () => {
			const result = ColorFunction.parse("color(  srgb   0.5   0.2   0.8  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.channels).toEqual([0.5, 0.2, 0.8]);
			}
		});
	});

	describe("Error Cases", () => {
		test("invalid color space", () => {
			const result = ColorFunction.parse("color(invalid 0.5 0.2 0.8)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid color space");
			}
		});

		test("missing color space", () => {
			const result = ColorFunction.parse("color(0.5 0.2 0.8)");
			expect(result.ok).toBe(false);
		});

		test("missing channels", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("requires at least 4 arguments");
			}
		});

		test("too few channels", () => {
			const result = ColorFunction.parse("color(srgb 0.5)");
			expect(result.ok).toBe(false);
		});

		test("invalid alpha value", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 / 1.5)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Alpha must be between 0 and 1");
			}
		});

		test("negative alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 / -0.1)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Alpha must be between 0 and 1");
			}
		});

		test("slash without alpha", () => {
			const result = ColorFunction.parse("color(srgb 0.5 0.2 0.8 /)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected alpha value after /");
			}
		});

		test("not a color function", () => {
			const result = ColorFunction.parse("rgb(255 0 0)");
			expect(result.ok).toBe(false);
		});

		test("empty string", () => {
			const result = ColorFunction.parse("");
			expect(result.ok).toBe(false);
		});

		test("invalid syntax", () => {
			const result = ColorFunction.parse("color(srgb 0.5, 0.2, 0.8)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/color/color-function.ts ===
// b_path:: src/parse/color/color-function.ts
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";

/**
 * Parse color() function with explicit color space.
 *
 * Syntax: color(colorspace c1 c2 c3 [ / alpha ]?)
 *
 * @param input - CSS color() function string
 * @returns Result with ColorFunction IR or error
 *
 * @example
 * ```typescript
 * parse("color(display-p3 0.928 0.322 0.203)");
 * parse("color(srgb 0.5 0.2 0.8 / 0.8)");
 * parse("color(xyz-d50 0.3 0.4 0.5)");
 * ```
 *
 * @public
 */
export function parse(input: string): Result<Type.ColorFunction, string> {
	try {
		const astResult = AstUtils.parseCssString(input);
		if (!astResult.ok) return err(astResult.error);

		const fnResult = AstUtils.findFunctionNode(astResult.value, "color");
		if (!fnResult.ok) return err(fnResult.error);

		const children = fnResult.value.children.toArray();

		if (children.length < 4) {
			return err("color() requires at least 4 arguments: colorspace + 3 channels");
		}

		// 1. Parse color space
		const colorSpaceNode = children[0];
		if (!colorSpaceNode || colorSpaceNode.type !== "Identifier") {
			return err("Expected color space identifier");
		}

		const colorSpace = colorSpaceNode.name.toLowerCase();
		const validSpaces = [
			"srgb",
			"srgb-linear",
			"display-p3",
			"a98-rgb",
			"prophoto-rgb",
			"rec2020",
			"xyz",
			"xyz-d50",
			"xyz-d65",
		];

		if (!validSpaces.includes(colorSpace)) {
			return err(`Invalid color space: ${colorSpace}`);
		}

		// 2. Parse 3 channel values
		const channels: [number, number, number] = [0, 0, 0];

		for (let i = 0; i < 3; i++) {
			const channelNode = children[i + 1];
			if (!channelNode) {
				return err(`Missing channel ${i + 1}`);
			}

			if (channelNode.type === "Number") {
				const value = Number.parseFloat(channelNode.value);
				if (Number.isNaN(value)) {
					return err(`Invalid channel ${i + 1} value`);
				}
				channels[i] = value;
			} else if (channelNode.type === "Percentage") {
				const value = Number.parseFloat(channelNode.value) / 100;
				if (Number.isNaN(value)) {
					return err(`Invalid channel ${i + 1} percentage`);
				}
				channels[i] = value;
			} else {
				return err(`Expected number or percentage for channel ${i + 1}`);
			}
		}

		// 3. Parse optional alpha after /
		let alpha: number | undefined;
		let idx = 4;

		if (idx < children.length) {
			const slashNode = children[idx];
			if (slashNode?.type === "Operator" && slashNode.value === "/") {
				idx++;
				const alphaNode = children[idx];
				if (!alphaNode) {
					return err("Expected alpha value after /");
				}

				if (alphaNode.type === "Number") {
					alpha = Number.parseFloat(alphaNode.value);
				} else if (alphaNode.type === "Percentage") {
					alpha = Number.parseFloat(alphaNode.value) / 100;
				} else {
					return err("Expected number or percentage for alpha");
				}

				if (Number.isNaN(alpha) || alpha < 0 || alpha > 1) {
					return err("Alpha must be between 0 and 1");
				}
			}
		}

		return ok({
			kind: "color",
			colorSpace: colorSpace as Type.ColorFunction["colorSpace"],
			channels,
			...(alpha !== undefined && { alpha }),
		});
	} catch (e) {
		return err(`Failed to parse color(): ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/color/color.test.ts ===
// b_path:: src/parse/color/color.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./color";

describe("parse() - unified color dispatcher", () => {
	describe("hex colors", () => {
		it("detects 3-digit hex", () => {
			const result = parse("#abc");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hex");
			}
		});

		it("detects 6-digit hex", () => {
			const result = parse("#ff5733");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hex");
			}
		});

		it("detects 8-digit hex with alpha", () => {
			const result = parse("#ff573380");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hex");
			}
		});
	});

	describe("rgb/rgba functions", () => {
		it("detects rgb()", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("rgb");
			}
		});

		it("detects rgba()", () => {
			const result = parse("rgba(255, 0, 0, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("rgb");
			}
		});

		it("detects modern rgb with alpha", () => {
			const result = parse("rgb(255 0 0 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("rgb");
			}
		});
	});

	describe("hsl/hsla functions", () => {
		it("detects hsl()", () => {
			const result = parse("hsl(0, 100%, 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hsl");
			}
		});

		it("detects hsla()", () => {
			const result = parse("hsla(120, 100%, 50%, 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hsl");
			}
		});

		it("detects modern hsl with alpha", () => {
			const result = parse("hsl(240 100% 50% / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hsl");
			}
		});
	});

	describe("hwb function", () => {
		it("detects hwb()", () => {
			const result = parse("hwb(0 0% 0%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hwb");
			}
		});

		it("detects hwb with alpha", () => {
			const result = parse("hwb(120 30% 40% / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hwb");
			}
		});
	});

	describe("lab function", () => {
		it("detects lab()", () => {
			const result = parse("lab(50% 40 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("lab");
			}
		});

		it("detects lab with alpha", () => {
			const result = parse("lab(50% 40 30 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("lab");
			}
		});
	});

	describe("lch function", () => {
		it("detects lch()", () => {
			const result = parse("lch(50% 40 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("lch");
			}
		});

		it("detects lch with alpha", () => {
			const result = parse("lch(50% 40 30 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("lch");
			}
		});
	});

	describe("oklab function", () => {
		it("detects oklab()", () => {
			const result = parse("oklab(0.5 0.4 0.3)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklab");
			}
		});

		it("detects oklab with alpha", () => {
			const result = parse("oklab(0.5 0.4 0.3 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklab");
			}
		});
	});

	describe("oklch function", () => {
		it("detects oklch()", () => {
			const result = parse("oklch(0.5 0.4 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklch");
			}
		});

		it("detects oklch with alpha", () => {
			const result = parse("oklch(0.5 0.4 30 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklch");
			}
		});
	});

	describe("color function", () => {
		it("detects color() with srgb", () => {
			const result = parse("color(srgb 1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("color");
			}
		});

		it("detects color() with display-p3", () => {
			const result = parse("color(display-p3 1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("color");
			}
		});
	});

	describe("named colors", () => {
		it("detects basic named color", () => {
			const result = parse("red");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("named");
				if (result.value?.kind === "named") {
					expect(result.value?.name).toBe("red");
				}
			}
		});

		it("detects extended named color", () => {
			const result = parse("cornflowerblue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("named");
				if (result.value?.kind === "named") {
					expect(result.value?.name).toBe("cornflowerblue");
				}
			}
		});

		it("handles case insensitivity", () => {
			const result = parse("BLUE");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("named");
			}
		});
	});

	describe("special colors", () => {
		it("detects transparent", () => {
			const result = parse("transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("special");
				if (result.value?.kind === "special") {
					expect(result.value?.keyword).toBe("transparent");
				}
			}
		});

		it("detects currentcolor", () => {
			const result = parse("currentcolor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("special");
				if (result.value?.kind === "special") {
					expect(result.value?.keyword).toBe("currentcolor");
				}
			}
		});

		it("handles case insensitivity for special", () => {
			const result = parse("CurrentColor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("special");
			}
		});
	});

	describe("system colors", () => {
		it("detects Canvas", () => {
			const result = parse("Canvas");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("system");
			}
		});

		it("detects ButtonText", () => {
			const result = parse("ButtonText");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("system");
			}
		});
	});

	describe("error cases", () => {
		it("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Empty");
			}
		});

		it("rejects unknown function", () => {
			const result = parse("unknown(10, 20, 30)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown color function");
			}
		});

		it("rejects invalid identifier", () => {
			const result = parse("notacolor");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("color name");
			}
		});

		it("rejects invalid hex", () => {
			const result = parse("#gggggg");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Invalid hex");
			}
		});
	});

	describe("case insensitivity", () => {
		it("handles RGB()", () => {
			const result = parse("RGB(255, 0, 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("rgb");
			}
		});

		it("handles HSL()", () => {
			const result = parse("HSL(0, 100%, 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hsl");
			}
		});

		it("handles OKLCH()", () => {
			const result = parse("OKLCH(0.5 0.4 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("oklch");
			}
		});
	});
});


=== File: src/parse/color/color.ts ===
// b_path:: src/parse/color/color.ts

import type { CssNode } from "css-tree";
import * as cssTree from "css-tree";
import { err, type ParseResult, parseErr, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as ColorFunction from "./color-function";
import * as Hex from "./hex";
import * as Hsl from "./hsl";
import * as Hwb from "./hwb";
import * as Lab from "./lab";
import * as Lch from "./lch";
import * as Named from "./named";
import * as Oklab from "./oklab";
import * as Oklch from "./oklch";
import * as Rgb from "./rgb";
import * as Special from "./special";
import * as System from "./system";

/**
 * Parse color value with auto-detection.
 *
 * Automatically detects and parses any CSS color format:
 * - Hex: #rgb, #rrggbb, #rrggbbaa
 * - RGB: rgb(), rgba()
 * - HSL: hsl(), hsla()
 * - HWB: hwb()
 * - LAB: lab()
 * - LCH: lch()
 * - OKLab: oklab()
 * - OKLCH: oklch()
 * - Color function: color()
 * - Named colors: red, blue, cornflowerblue, etc.
 * - Special: transparent, currentcolor
 * - System colors: Canvas, ButtonText, etc.
 *
 * @param value - CSS color value string
 * @returns Result with Color IR or error
 *
 * @example
 * ```typescript
 * parse("#ff0000");              // Auto-detects hex
 * parse("rgb(255, 0, 0)");       // Auto-detects rgb
 * parse("hsl(0, 100%, 50%)");    // Auto-detects hsl
 * parse("red");                  // Auto-detects named
 * parse("transparent");          // Auto-detects special
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Type.Color> {
	const ast = cssTree.parse(value, { context: "value" }) as cssTree.Value;
	if (!ast.children) return parseErr("invalid-syntax", "Empty value");
	const first = ast.children.first;
	if (!first) return parseErr("invalid-syntax", "Empty value");
	const result = parseNode(first);
	return toParseResult(result);
}

/**
 * Parse color AST node with auto-detection.
 *
 * Efficiently parses color from an existing AST node without string serialization.
 * Use this when you already have a parsed AST node from css-tree.
 *
 * @param node - CSS AST node
 * @returns Result with Color IR or error
 *
 * @example
 * ```typescript
 * import * as cssTree from "css-tree";
 * import { parseNode } from "@/parse/color";
 *
 * const ast = cssTree.parse("red", { context: "value" });
 * const result = parseNode(ast.children.first);
 * ```
 *
 * @public
 */
export function parseNode(node: CssNode): Result<Type.Color, string> {
	// 1. Hex color (Hash node)
	if (node.type === "Hash") {
		const css = `#${node.value}`;
		return Hex.parse(css);
	}

	// 2. Color functions
	if (node.type === "Function") {
		const css = cssTree.generate(node);
		switch (node.name.toLowerCase()) {
			case "rgb":
			case "rgba":
				return Rgb.parse(css);
			case "hsl":
			case "hsla":
				return Hsl.parse(css);
			case "hwb":
				return Hwb.parse(css);
			case "lab":
				return Lab.parse(css);
			case "lch":
				return Lch.parse(css);
			case "oklab":
				return Oklab.parse(css);
			case "oklch":
				return Oklch.parse(css);
			case "color":
				return ColorFunction.parse(css);
			default:
				return err(`Unknown color function: ${node.name}`);
		}
	}

	// 3. Identifier (named, special, or system colors)
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();

		// Special keywords (transparent, currentcolor)
		if (keyword === "transparent" || keyword === "currentcolor") {
			return Special.parse(node.name);
		}

		// Try system colors first (smaller set, more specific)
		const systemResult = System.parse(node.name);
		if (systemResult.ok) return systemResult;

		// Fallback to named colors (larger set)
		return Named.parse(node.name);
	}

	return err(`Invalid color node type: ${node.type}`);
}


=== File: src/parse/color/hex.test.ts ===
// b_path:: src/parse/color/hex.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./hex";

describe("parse hex color", () => {
	it("parses 3-digit hex color", () => {
		const result = parse("#abc");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("hex");
			expect(result.value.value).toBe("#AABBCC");
		}
	});

	it("parses 6-digit hex color", () => {
		const result = parse("#ff5733");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("#FF5733");
		}
	});

	it("parses 4-digit hex color with alpha", () => {
		const result = parse("#abcd");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("#AABBCCDD");
		}
	});

	it("parses 8-digit hex color with alpha", () => {
		const result = parse("#ff573380");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("#FF573380");
		}
	});

	it("normalizes to uppercase", () => {
		const result = parse("#ffffff");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("#FFFFFF");
		}
	});

	it("rejects missing # prefix", () => {
		const result = parse("abc");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("must start with #");
		}
	});

	it("rejects invalid characters", () => {
		const result = parse("#xyz");
		expect(result.ok).toBe(false);
	});

	it("rejects invalid length", () => {
		const result = parse("#ab");
		expect(result.ok).toBe(false);
	});

	it("rejects empty value", () => {
		const result = parse("#");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/color/hex.ts ===
// b_path:: src/parse/color/hex.ts
import { err, ok, type Result } from "@/core/result";
import type { HexColor } from "@/core/types/color";

/**
 * Parse a CSS hex color value.
 *
 * Accepts #RGB, #RRGGBB, #RGBA, or #RRGGBBAA formats.
 * Normalizes short forms to long forms and converts to uppercase.
 *
 * @param input - The hex color string to parse (e.g., "#abc", "#ff5733", "#ff573380")
 * @returns Result containing the parsed HexColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/hex";
 *
 * // Short form
 * const color1 = parse("#abc");
 * // => { ok: true, value: { kind: "hex", value: "#AABBCC" } }
 *
 * // Long form
 * const color2 = parse("#ff5733");
 * // => { ok: true, value: { kind: "hex", value: "#FF5733" } }
 *
 * // With alpha
 * const color3 = parse("#ff573380");
 * // => { ok: true, value: { kind: "hex", value: "#FF573380" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<HexColor, string> {
	if (!input.startsWith("#")) {
		return err("Hex color must start with #");
	}

	const hex = input.slice(1);

	// #RGB → #RRGGBB
	if (hex.length === 3) {
		if (!/^[0-9A-Fa-f]{3}$/.test(hex)) {
			return err("Invalid hex color format");
		}
		const normalized = hex
			.split("")
			.map((c) => c + c)
			.join("");
		return ok({ kind: "hex", value: `#${normalized.toUpperCase()}` });
	}

	// #RGBA → #RRGGBBAA
	if (hex.length === 4) {
		if (!/^[0-9A-Fa-f]{4}$/.test(hex)) {
			return err("Invalid hex color format");
		}
		const normalized = hex
			.split("")
			.map((c) => c + c)
			.join("");
		return ok({ kind: "hex", value: `#${normalized.toUpperCase()}` });
	}

	// #RRGGBB or #RRGGBBAA
	if (hex.length === 6 || hex.length === 8) {
		if (!/^[0-9A-Fa-f]+$/.test(hex)) {
			return err("Invalid hex color format");
		}
		return ok({ kind: "hex", value: `#${hex.toUpperCase()}` });
	}

	return err("Hex color must be #RGB, #RRGGBB, #RGBA, or #RRGGBBAA");
}


=== File: src/parse/color/hsl.ts ===
// b_path:: src/parse/color/hsl.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { HSLColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS HSL color value.
 *
 * Supports all HSL syntax variations:
 * - Modern space-separated: `hsl(120 100% 50%)`, `hsl(120deg 100% 50%)`
 * - Modern with alpha: `hsl(120 100% 50% / 0.5)`
 * - Legacy comma-separated: `hsl(120, 100%, 50%)`
 * - Legacy hsla: `hsla(120, 100%, 50%, 0.5)`
 * - Angle units: deg, rad, grad, turn (or unitless defaults to deg)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 *
 * @param input - The HSL color string to parse
 * @returns Result containing the parsed HSLColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/hsl";
 *
 * // Modern syntax
 * const color1 = parse("hsl(120 100% 50%)");
 * // => { ok: true, value: { kind: "hsl", h: 120, s: 100, l: 50 } }
 *
 * // With angle unit
 * const color2 = parse("hsl(1turn 100% 50%)");
 * // => { ok: true, value: { kind: "hsl", h: 360, s: 100, l: 50 } }
 *
 * // With alpha
 * const color3 = parse("hsl(120 100% 50% / 0.5)");
 * // => { ok: true, value: { kind: "hsl", h: 120, s: 100, l: 50, alpha: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<HSLColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find hsl() or hsla() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["hsl", "hsla"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - handle both comma and space syntax
	return parseHSLArguments(children);
}

/**
 * Parse HSL function arguments from AST nodes.
 *
 * @internal
 */
function parseHSLArguments(nodes: csstree.CssNode[]): Result<HSLColor, string> {
	// Check if we have comma separators (legacy syntax)
	const hasComma = nodes.some((node) => node.type === "Operator" && "value" in node && node.value === ",");

	if (hasComma) {
		return parseCommaHSL(nodes);
	}
	return parseSpaceHSL(nodes);
}

/**
 * Parse space-separated HSL syntax: hsl(H S% L%) or hsl(H S% L% / A)
 *
 * @internal
 */
function parseSpaceHSL(nodes: csstree.CssNode[]): Result<HSLColor, string> {
	let h: number | undefined;
	let s: number | undefined;
	let l: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			const alphaResult = ParseUtils.parseAlpha(node);
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			break;
		}

		// Parse H, S, L components
		if (componentIndex === 0) {
			// Hue (angle or unitless number)
			const hueResult = ParseUtils.parseHue(node);
			if (!hueResult.ok) {
				return err(hueResult.error);
			}
			h = hueResult.value;
		} else if (componentIndex === 1 || componentIndex === 2) {
			// Saturation or Lightness (percentage)
			const percentResult = ParseUtils.parsePercentage(node, { clamp: true });
			if (!percentResult.ok) {
				return err(percentResult.error);
			}
			if (componentIndex === 1) {
				s = percentResult.value;
			} else {
				l = percentResult.value;
			}
		}
		componentIndex++;
	}

	if (h === undefined || s === undefined || l === undefined) {
		return err("Expected 3 HSL values (hue, saturation, lightness)");
	}

	const color: HSLColor = { kind: "hsl", h, s, l };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse comma-separated HSL syntax: hsl(H, S%, L%) or hsla(H, S%, L%, A)
 *
 * @internal
 */
function parseCommaHSL(nodes: csstree.CssNode[]): Result<HSLColor, string> {
	// Filter out comma operators
	const valueNodes = nodes.filter((node) => !(node.type === "Operator" && "value" in node && node.value === ","));

	if (valueNodes.length !== 3 && valueNodes.length !== 4) {
		return err(`Expected 3 or 4 values (H, S, L, [A]), got ${valueNodes.length}`);
	}

	// Parse hue
	const hueNode = valueNodes[0];
	if (!hueNode) {
		return err("Missing hue value");
	}
	const hueResult = ParseUtils.parseHue(hueNode);
	if (!hueResult.ok) {
		return err(hueResult.error);
	}
	const h = hueResult.value;

	// Parse saturation
	const satNode = valueNodes[1];
	if (!satNode) {
		return err("Missing saturation value");
	}
	const satResult = ParseUtils.parsePercentage(satNode);
	if (!satResult.ok) {
		return err(satResult.error);
	}
	const s = satResult.value;

	// Parse lightness
	const lightNode = valueNodes[2];
	if (!lightNode) {
		return err("Missing lightness value");
	}
	const lightResult = ParseUtils.parsePercentage(lightNode);
	if (!lightResult.ok) {
		return err(lightResult.error);
	}
	const l = lightResult.value;

	const color: HSLColor = { kind: "hsl", h, s, l };

	// Parse alpha if present (4th value)
	if (valueNodes.length === 4) {
		const alphaNode = valueNodes[3];
		if (!alphaNode) {
			return err("Invalid alpha value");
		}
		const alphaResult = ParseUtils.parseAlpha(alphaNode);
		if (!alphaResult.ok) {
			return err(alphaResult.error);
		}
		color.alpha = alphaResult.value;
	}

	return ok(color);
}


=== File: src/parse/color/hwb.ts ===
// b_path:: src/parse/color/hwb.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { HWBColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS HWB color value.
 *
 * Supports HWB syntax (modern only, no legacy comma syntax):
 * - Space-separated: `hwb(120 20% 30%)`, `hwb(120deg 20% 30%)`
 * - With alpha: `hwb(120 20% 30% / 0.5)`
 * - Angle units: deg, rad, grad, turn (or unitless defaults to deg)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 * Whiteness and blackness are clamped to 0-100%.
 *
 * @param input - The HWB color string to parse
 * @returns Result containing the parsed HWBColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/hwb";
 *
 * // Basic syntax
 * const color1 = parse("hwb(120 20% 30%)");
 * // => { ok: true, value: { kind: "hwb", h: 120, w: 20, b: 30 } }
 *
 * // With angle unit
 * const color2 = parse("hwb(0.5turn 20% 30%)");
 * // => { ok: true, value: { kind: "hwb", h: 180, w: 20, b: 30 } }
 *
 * // With alpha
 * const color3 = parse("hwb(120 20% 30% / 0.5)");
 * // => { ok: true, value: { kind: "hwb", h: 120, w: 20, b: 30, alpha: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<HWBColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find hwb() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["hwb"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (HWB is modern, no legacy syntax)
	return parseHWBArguments(children);
}

/**
 * Parse HWB function arguments from AST nodes.
 * HWB only supports space-separated syntax: hwb(H W% B%) or hwb(H W% B% / A)
 *
 * @internal
 */
function parseHWBArguments(nodes: csstree.CssNode[]): Result<HWBColor, string> {
	// Filter out whitespace nodes
	const valueNodes = nodes.filter((node) => node.type !== "WhiteSpace");

	// Check for slash separator for alpha
	const slashIndex = valueNodes.findIndex((node) => node.type === "Operator" && "value" in node && node.value === "/");

	if (slashIndex !== -1) {
		// Has alpha: hwb(H W% B% / A)
		if (slashIndex !== 3) {
			return err("Invalid HWB syntax: expected 3 values before '/'");
		}
		if (valueNodes.length !== 5) {
			return err("Invalid HWB syntax: expected alpha value after '/'");
		}
		const [hueNode, whitenessNode, blacknessNode, , alphaNode] = valueNodes;
		if (!hueNode || !whitenessNode || !blacknessNode || !alphaNode) {
			return err("Invalid HWB syntax: missing required values");
		}

		// Parse hue
		const hueResult = ParseUtils.parseHue(hueNode);
		if (!hueResult.ok) {
			return err(`Invalid hue: ${hueResult.error}`);
		}
		const h = hueResult.value;

		// Parse whiteness (percentage)
		const wResult = ParseUtils.parsePercentage(whitenessNode, { clamp: true });
		if (!wResult.ok) {
			return err(`Invalid whiteness: ${wResult.error}`);
		}
		const w = wResult.value;

		// Parse blackness (percentage)
		const bResult = ParseUtils.parsePercentage(blacknessNode, { clamp: true });
		if (!bResult.ok) {
			return err(`Invalid blackness: ${bResult.error}`);
		}
		const b = bResult.value;

		// Parse alpha
		const alphaResult = ParseUtils.parseAlpha(alphaNode, { clamp: true });
		if (!alphaResult.ok) {
			return err(`Invalid alpha: ${alphaResult.error}`);
		}
		const alpha = alphaResult.value;

		const color: HWBColor = { kind: "hwb", h, w, b };
		if (alpha !== undefined && alpha !== 1) {
			color.alpha = alpha;
		}
		return ok(color);
	} else {
		// No alpha: hwb(H W% B%)
		if (valueNodes.length !== 3) {
			return err(`Invalid HWB syntax: expected 3 values, got ${valueNodes.length}`);
		}
		const [hueNode, whitenessNode, blacknessNode] = valueNodes;
		if (!hueNode || !whitenessNode || !blacknessNode) {
			return err("Invalid HWB syntax: missing required values");
		}

		// Parse hue
		const hueResult = ParseUtils.parseHue(hueNode);
		if (!hueResult.ok) {
			return err(`Invalid hue: ${hueResult.error}`);
		}
		const h = hueResult.value;

		// Parse whiteness (percentage)
		const wResult = ParseUtils.parsePercentage(whitenessNode, { clamp: true });
		if (!wResult.ok) {
			return err(`Invalid whiteness: ${wResult.error}`);
		}
		const w = wResult.value;

		// Parse blackness (percentage)
		const bResult = ParseUtils.parsePercentage(blacknessNode, { clamp: true });
		if (!bResult.ok) {
			return err(`Invalid blackness: ${bResult.error}`);
		}
		const b = bResult.value;

		return ok({ kind: "hwb", h, w, b });
	}
}


=== File: src/parse/color/index.ts ===
// b_path:: src/parse/color/index.ts

/**
 * CSS color parsers - convert color strings to structured IR.
 *
 * All color parsers return Result<T, string> for type-safe error handling.
 *
 * @module Parse.Color
 * @public
 */

export { parse, parseNode } from "./color";

/**
 * Parse color() function values.
 *
 * @see {@link ColorFunction.parse}
 */
export * as ColorFunction from "./color-function";
/**
 * Parse hex color values.
 *
 * @see {@link Hex.parse}
 */
export * as Hex from "./hex";
/**
 * Parse HSL color values.
 *
 * @see {@link Hsl.parse}
 */
export * as Hsl from "./hsl";
/**
 * Parse HWB color values.
 *
 * @see {@link Hwb.parse}
 */
export * as Hwb from "./hwb";
/**
 * Parse LAB color values.
 *
 * @see {@link Lab.parse}
 */
export * as Lab from "./lab";
/**
 * Parse LCH color values.
 *
 * @see {@link Lch.parse}
 */
export * as Lch from "./lch";
/**
 * Parse named color values.
 *
 * @see {@link Named.parse}
 */
export * as Named from "./named";
/**
 * Parse OKLab color values.
 *
 * @see {@link Oklab.parse}
 */
export * as Oklab from "./oklab";
/**
 * Parse OKLCH color values.
 *
 * @see {@link Oklch.parse}
 */
export * as Oklch from "./oklch";
/**
 * Parse RGB color values.
 *
 * @see {@link Rgb.parse}
 */
export * as Rgb from "./rgb";
/**
 * Parse special color values (transparent, currentcolor).
 *
 * @see {@link Special.parse}
 */
export * as Special from "./special";
/**
 * Parse system color values.
 *
 * @see {@link System.parse}
 */
export * as System from "./system";


=== File: src/parse/color/lab.test.ts ===
// b_path:: src/parse/color/lab.test.ts
import { describe, expect, it } from "vitest";
import type { LABColor } from "@/core/types/color";
import * as LABGenerator from "@/generate/color/lab";
import * as LABParser from "./lab";

describe("LAB Color Parser", () => {
	describe("basic space-separated syntax", () => {
		it("should parse lab with percentage lightness", () => {
			const result = LABParser.parse("lab(50% -20 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
				});
			}
		});

		it("should parse lab with number lightness", () => {
			const result = LABParser.parse("lab(50 -20 30)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
				});
			}
		});

		it("should parse lab with positive a and b values", () => {
			const result = LABParser.parse("lab(75% 40 60)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 75,
					a: 40,
					b: 60,
				});
			}
		});

		it("should parse lab with zero values", () => {
			const result = LABParser.parse("lab(0% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 0,
					a: 0,
					b: 0,
				});
			}
		});
	});

	describe("lightness handling", () => {
		it("should clamp lightness percentage above 100%", () => {
			const result = LABParser.parse("lab(150% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100);
			}
		});

		it("should clamp lightness number above 100", () => {
			const result = LABParser.parse("lab(120 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100);
			}
		});

		it("should clamp negative lightness to 0", () => {
			const result = LABParser.parse("lab(-10% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0);
			}
		});
	});

	describe("axis value clamping", () => {
		it("should clamp a value above 125", () => {
			const result = LABParser.parse("lab(50% 150 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.a).toBe(125);
			}
		});

		it("should clamp a value below -125", () => {
			const result = LABParser.parse("lab(50% -200 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.a).toBe(-125);
			}
		});

		it("should clamp b value above 125", () => {
			const result = LABParser.parse("lab(50% 0 200)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(125);
			}
		});

		it("should clamp b value below -125", () => {
			const result = LABParser.parse("lab(50% 0 -150)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(-125);
			}
		});
	});

	describe("alpha channel", () => {
		it("should parse lab with alpha as number", () => {
			const result = LABParser.parse("lab(50% -20 30 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
					alpha: 0.5,
				});
			}
		});

		it("should parse lab with alpha as percentage", () => {
			const result = LABParser.parse("lab(50% -20 30 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
					alpha: 0.5,
				});
			}
		});

		it("should parse lab with alpha 0", () => {
			const result = LABParser.parse("lab(50% -20 30 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("should parse lab with alpha 1", () => {
			const result = LABParser.parse("lab(50% -20 30 / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("should parse lab with alpha 100%", () => {
			const result = LABParser.parse("lab(50% -20 30 / 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});
	});

	describe("edge cases", () => {
		it("should parse pure white (L=100, a=0, b=0)", () => {
			const result = LABParser.parse("lab(100% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 100,
					a: 0,
					b: 0,
				});
			}
		});

		it("should parse pure black (L=0, a=0, b=0)", () => {
			const result = LABParser.parse("lab(0% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 0,
					a: 0,
					b: 0,
				});
			}
		});

		it("should parse decimal values", () => {
			const result = LABParser.parse("lab(53.5% -12.3 45.7)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBeCloseTo(53.5);
				expect(result.value.a).toBeCloseTo(-12.3);
				expect(result.value.b).toBeCloseTo(45.7);
			}
		});

		it("should handle extra whitespace", () => {
			const result = LABParser.parse("lab(  50%   -20   30  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lab",
					l: 50,
					a: -20,
					b: 30,
				});
			}
		});
	});

	describe("error handling", () => {
		it("should reject invalid function name", () => {
			const result = LABParser.parse("rgb(50% 0 0)");
			expect(result.ok).toBe(false);
		});

		it("should reject missing values", () => {
			const result = LABParser.parse("lab(50% -20)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values without alpha", () => {
			const result = LABParser.parse("lab(50% -20 30 40)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid alpha value > 1", () => {
			const result = LABParser.parse("lab(50% -20 30 / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.alpha).toBe(1);
		});

		it("should reject invalid alpha percentage > 100%", () => {
			const result = LABParser.parse("lab(50% -20 30 / 150%)");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.alpha).toBe(1);
		});

		it("should reject non-numeric values", () => {
			const result = LABParser.parse("lab(50% abc 30)");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip with generator", () => {
		const testCases: Array<{ input: string; expected: LABColor }> = [
			{
				input: "lab(50 -20 30)",
				expected: { kind: "lab", l: 50, a: -20, b: 30 },
			},
			{
				input: "lab(75 40 60)",
				expected: { kind: "lab", l: 75, a: 40, b: 60 },
			},
			{
				input: "lab(0 0 0)",
				expected: { kind: "lab", l: 0, a: 0, b: 0 },
			},
			{
				input: "lab(100 0 0)",
				expected: { kind: "lab", l: 100, a: 0, b: 0 },
			},
			{
				input: "lab(50 -20 30 / 0.5)",
				expected: { kind: "lab", l: 50, a: -20, b: 30, alpha: 0.5 },
			},
			{
				input: "lab(50 -20 30 / 0)",
				expected: { kind: "lab", l: 50, a: -20, b: 30, alpha: 0 },
			},
		];

		for (const { input, expected } of testCases) {
			it(`should round-trip: ${input}`, () => {
				const parseResult = LABParser.parse(input);
				expect(parseResult.ok).toBe(true);
				if (parseResult.ok) {
					expect(parseResult.value).toEqual(expected);
					const generated = LABGenerator.generate(parseResult.value);
					expect(generated.ok).toBe(true);
					if (!generated.ok) return;
					const reparsed = LABParser.parse(generated.value);
					expect(reparsed.ok).toBe(true);
					if (reparsed.ok) {
						expect(reparsed.value).toEqual(expected);
					}
				}
			});
		}
	});
});


=== File: src/parse/color/lab.ts ===
// b_path:: src/parse/color/lab.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { LABColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS LAB color value.
 *
 * Supports LAB syntax (modern only, no legacy comma syntax):
 * - Space-separated: `lab(50% -20 30)`, `lab(50 -20 30)`
 * - With alpha: `lab(50% -20 30 / 0.5)`
 * - Lightness can be percentage (0-100%) or number (0-100)
 * - a and b axes: -125 to 125 (clamped)
 *
 * @param input - The LAB color string to parse
 * @returns Result containing the parsed LABColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/lab";
 *
 * // Basic syntax
 * const color1 = parse("lab(50% -20 30)");
 * // => { ok: true, value: { kind: "lab", l: 50, a: -20, b: 30 } }
 *
 * // With alpha
 * const color2 = parse("lab(50% -20 30 / 0.5)");
 * // => { ok: true, value: { kind: "lab", l: 50, a: -20, b: 30, alpha: 0.5 } }
 *
 * // Lightness as number
 * const color3 = parse("lab(50 -20 30)");
 * // => { ok: true, value: { kind: "lab", l: 50, a: -20, b: 30 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<LABColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find lab() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["lab"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (LAB is modern, no legacy syntax)
	return parseLABArguments(children);
}

/**
 * Parse LAB function arguments from AST nodes.
 * LAB only supports space-separated syntax: lab(L a b) or lab(L a b / A)
 *
 * @internal
 */
function parseLABArguments(nodes: csstree.CssNode[]): Result<LABColor, string> {
	let l: number | undefined;
	let a: number | undefined;
	let b: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			if (alpha !== undefined) {
				return err("Too many values after '/' in LAB color");
			}
			const alphaResult = ParseUtils.parseAlpha(node, { clamp: true });
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			continue;
		}

		// Parse L, a, b components
		if (componentIndex === 0) {
			// Lightness (percentage or number)
			const lightnessResult = ParseUtils.parseLightness(node, "0-100");
			if (!lightnessResult.ok) {
				return err(lightnessResult.error);
			}
			l = lightnessResult.value;
		} else if (componentIndex === 1) {
			// a axis (number)
			const axisResult = parseAxisValue(node);
			if (!axisResult.ok) {
				return err(axisResult.error);
			}
			a = axisResult.value;
		} else if (componentIndex === 2) {
			// b axis (number)
			const axisResult = parseAxisValue(node);
			if (!axisResult.ok) {
				return err(axisResult.error);
			}
			b = axisResult.value;
		} else {
			// Too many values (more than 3 before slash)
			return err("Too many values in LAB color (expected 3: lightness, a, b)");
		}
		componentIndex++;
	}

	if (l === undefined || a === undefined || b === undefined) {
		return err("Expected 3 LAB values (lightness, a, b)");
	}

	const color: LABColor = { kind: "lab", l, a, b };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse an axis value (a or b).
 *
 * Accepts: number (typically -125 to 125, but clamped)
 *
 * @internal
 */
function parseAxisValue(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Clamp to -125 to 125 range (CSS spec)
		const clamped = Math.max(-125, Math.min(125, value));
		return ok(clamped);
	}

	return err(`Expected number for axis value, got ${node.type}`);
}


=== File: src/parse/color/lch.test.ts ===
// b_path:: src/parse/color/lch.test.ts
import { describe, expect, it } from "vitest";
import type { LCHColor } from "@/core/types/color";
import * as LCHGenerator from "@/generate/color/lch";
import * as LCHParser from "./lch";

describe("LCH Color Parser", () => {
	describe("basic space-separated syntax", () => {
		it("should parse lch with percentage lightness", () => {
			const result = LCHParser.parse("lch(50% 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
				});
			}
		});

		it("should parse lch with number lightness", () => {
			const result = LCHParser.parse("lch(50 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
				});
			}
		});

		it("should parse lch with unitless hue", () => {
			const result = LCHParser.parse("lch(75% 60 270)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 75,
					c: 60,
					h: 270,
				});
			}
		});

		it("should parse lch with zero values", () => {
			const result = LCHParser.parse("lch(0% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 0,
					c: 0,
					h: 0,
				});
			}
		});
	});

	describe("angle units", () => {
		it("should parse hue with deg unit", () => {
			const result = LCHParser.parse("lch(50% 50 180deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with turn unit", () => {
			const result = LCHParser.parse("lch(50% 50 0.5turn)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with rad unit", () => {
			const result = LCHParser.parse("lch(50% 50 3.14159rad)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBeCloseTo(180, 0);
			}
		});

		it("should parse hue with grad unit", () => {
			const result = LCHParser.parse("lch(50% 50 200grad)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with 1turn", () => {
			const result = LCHParser.parse("lch(50% 50 1turn)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0); // 360 wraps to 0
			}
		});
	});

	describe("hue wrapping", () => {
		it("should wrap hue 360deg to 0", () => {
			const result = LCHParser.parse("lch(50% 50 360)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("should wrap hue 450deg to 90deg", () => {
			const result = LCHParser.parse("lch(50% 50 450)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(90);
			}
		});

		it("should wrap negative hue -90deg to 270deg", () => {
			const result = LCHParser.parse("lch(50% 50 -90)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(270);
			}
		});

		it("should wrap negative hue -180deg to 180deg", () => {
			const result = LCHParser.parse("lch(50% 50 -180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should wrap large positive hue", () => {
			const result = LCHParser.parse("lch(50% 50 720)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0); // 720 = 2 * 360
			}
		});
	});

	describe("lightness handling", () => {
		it("should clamp lightness percentage above 100%", () => {
			const result = LCHParser.parse("lch(150% 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100);
			}
		});

		it("should clamp lightness number above 100", () => {
			const result = LCHParser.parse("lch(120 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(100);
			}
		});

		it("should clamp negative lightness to 0", () => {
			const result = LCHParser.parse("lch(-10% 50 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0);
			}
		});
	});

	describe("chroma clamping", () => {
		it("should clamp chroma above 150", () => {
			const result = LCHParser.parse("lch(50% 200 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(150);
			}
		});

		it("should clamp negative chroma to 0", () => {
			const result = LCHParser.parse("lch(50% -10 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(0);
			}
		});

		it("should accept chroma at max value 150", () => {
			const result = LCHParser.parse("lch(50% 150 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(150);
			}
		});
	});

	describe("alpha channel", () => {
		it("should parse lch with alpha as number", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
					alpha: 0.5,
				});
			}
		});

		it("should parse lch with alpha as percentage", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
					alpha: 0.5,
				});
			}
		});

		it("should parse lch with alpha 0", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("should parse lch with alpha 1", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("should parse lch with alpha 100%", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});
	});

	describe("edge cases", () => {
		it("should parse pure white (L=100, C=0, H=0)", () => {
			const result = LCHParser.parse("lch(100% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 100,
					c: 0,
					h: 0,
				});
			}
		});

		it("should parse pure black (L=0, C=0, H=0)", () => {
			const result = LCHParser.parse("lch(0% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 0,
					c: 0,
					h: 0,
				});
			}
		});

		it("should parse decimal values", () => {
			const result = LCHParser.parse("lch(53.5% 62.3 135.7)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBeCloseTo(53.5);
				expect(result.value.c).toBeCloseTo(62.3);
				expect(result.value.h).toBeCloseTo(135.7);
			}
		});

		it("should handle extra whitespace", () => {
			const result = LCHParser.parse("lch(  50%   50   180  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "lch",
					l: 50,
					c: 50,
					h: 180,
				});
			}
		});
	});

	describe("error handling", () => {
		it("should reject invalid function name", () => {
			const result = LCHParser.parse("rgb(50% 50 180)");
			expect(result.ok).toBe(false);
		});

		it("should reject missing values", () => {
			const result = LCHParser.parse("lch(50% 50)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values without alpha", () => {
			const result = LCHParser.parse("lch(50% 50 180 90)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid alpha value > 1", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.alpha).toBe(1);
		});

		it("should reject invalid alpha percentage > 100%", () => {
			const result = LCHParser.parse("lch(50% 50 180 / 150%)");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.alpha).toBe(1);
		});

		it("should reject non-numeric values", () => {
			const result = LCHParser.parse("lch(50% abc 180)");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip with generator", () => {
		const testCases: Array<{ input: string; expected: LCHColor }> = [
			{
				input: "lch(50 50 180)",
				expected: { kind: "lch", l: 50, c: 50, h: 180 },
			},
			{
				input: "lch(75 60 270)",
				expected: { kind: "lch", l: 75, c: 60, h: 270 },
			},
			{
				input: "lch(0 0 0)",
				expected: { kind: "lch", l: 0, c: 0, h: 0 },
			},
			{
				input: "lch(100 0 0)",
				expected: { kind: "lch", l: 100, c: 0, h: 0 },
			},
			{
				input: "lch(50 50 180 / 0.5)",
				expected: { kind: "lch", l: 50, c: 50, h: 180, alpha: 0.5 },
			},
			{
				input: "lch(50 50 180 / 0)",
				expected: { kind: "lch", l: 50, c: 50, h: 180, alpha: 0 },
			},
			{
				input: "lch(50 50 90)",
				expected: { kind: "lch", l: 50, c: 50, h: 90 },
			},
			{
				input: "lch(50 50 360)",
				expected: { kind: "lch", l: 50, c: 50, h: 0 }, // wrapped
			},
		];

		for (const { input, expected } of testCases) {
			it(`should round-trip: ${input}`, () => {
				const parseResult = LCHParser.parse(input);
				expect(parseResult.ok).toBe(true);
				if (parseResult.ok) {
					expect(parseResult.value).toEqual(expected);
					const generated = LCHGenerator.generate(parseResult.value);
					expect(generated.ok).toBe(true);
					if (!generated.ok) return;
					const reparsed = LCHParser.parse(generated.value);
					expect(reparsed.ok).toBe(true);
					if (reparsed.ok) {
						expect(reparsed.value).toEqual(expected);
					}
				}
			});
		}
	});
});


=== File: src/parse/color/lch.ts ===
// b_path:: src/parse/color/lch.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { LCHColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS LCH color value.
 *
 * Supports LCH syntax (modern only, no legacy comma syntax):
 * - Space-separated: `lch(50% 50 180deg)`, `lch(50 50 180)`
 * - With alpha: `lch(50% 50 180 / 0.5)`
 * - Lightness can be percentage (0-100%) or number (0-100)
 * - Chroma: 0-150 (clamped)
 * - Hue: angle with deg, rad, grad, turn units (or unitless defaults to deg)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 *
 * @param input - The LCH color string to parse
 * @returns Result containing the parsed LCHColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/lch";
 *
 * // Basic syntax
 * const color1 = parse("lch(50% 50 180)");
 * // => { ok: true, value: { kind: "lch", l: 50, c: 50, h: 180 } }
 *
 * // With angle unit
 * const color2 = parse("lch(50% 50 0.5turn)");
 * // => { ok: true, value: { kind: "lch", l: 50, c: 50, h: 180 } }
 *
 * // With alpha
 * const color3 = parse("lch(50% 50 180 / 0.5)");
 * // => { ok: true, value: { kind: "lch", l: 50, c: 50, h: 180, alpha: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<LCHColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find lch() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["lch"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (LCH is modern, no legacy syntax)
	return parseLCHArguments(children);
}

/**
 * Parse LCH function arguments from AST nodes.
 * LCH only supports space-separated syntax: lch(L C H) or lch(L C H / A)
 *
 * @internal
 */
function parseLCHArguments(nodes: csstree.CssNode[]): Result<LCHColor, string> {
	let l: number | undefined;
	let c: number | undefined;
	let h: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			if (alpha !== undefined) {
				return err("Too many values after '/' in LCH color");
			}
			const alphaResult = ParseUtils.parseAlpha(node, { clamp: true });
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			continue;
		}

		// Parse L, C, H components
		if (componentIndex === 0) {
			// Lightness (percentage or number)
			const lightnessResult = ParseUtils.parseLightness(node, "0-100");
			if (!lightnessResult.ok) {
				return err(lightnessResult.error);
			}
			l = lightnessResult.value;
		} else if (componentIndex === 1) {
			// Chroma (number)
			const chromaResult = parseChroma(node);
			if (!chromaResult.ok) {
				return err(chromaResult.error);
			}
			c = chromaResult.value;
		} else if (componentIndex === 2) {
			// Hue (angle or unitless number)
			const hueResult = ParseUtils.parseHue(node);
			if (!hueResult.ok) {
				return err(hueResult.error);
			}
			h = hueResult.value;
		} else {
			// Too many values (more than 3 before slash)
			return err("Too many values in LCH color (expected 3: lightness, chroma, hue)");
		}
		componentIndex++;
	}

	if (l === undefined || c === undefined || h === undefined) {
		return err("Expected 3 LCH values (lightness, chroma, hue)");
	}

	const color: LCHColor = { kind: "lch", l, c, h };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse a chroma value.
 *
 * Accepts: number (0-150, clamped)
 *
 * @internal
 */
function parseChroma(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Clamp to 0-150 range (CSS spec)
		const clamped = Math.max(0, Math.min(150, value));
		return ok(clamped);
	}

	return err(`Expected number for chroma, got ${node.type}`);
}


=== File: src/parse/color/named.test.ts ===
// b_path:: src/parse/color/named.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./named";

describe("parse named color", () => {
	it("parses basic color 'red'", () => {
		const result = parse("red");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "named",
				name: "red",
			});
		}
	});

	it("parses basic color 'blue'", () => {
		const result = parse("blue");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.name).toBe("blue");
		}
	});

	it("parses basic color 'green'", () => {
		const result = parse("green");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.name).toBe("green");
		}
	});

	it("parses extended color 'cornflowerblue'", () => {
		const result = parse("cornflowerblue");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.name).toBe("cornflowerblue");
		}
	});

	it("parses extended color 'rebeccapurple'", () => {
		const result = parse("rebeccapurple");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.name).toBe("rebeccapurple");
		}
	});

	it("parses case-insensitively", () => {
		const result = parse("RED");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.name).toBe("red");
		}
	});

	it("parses mixed case", () => {
		const result = parse("CornFlowerBlue");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.name).toBe("cornflowerblue");
		}
	});

	it("rejects invalid color name", () => {
		const result = parse("notacolor");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Unknown color name");
		}
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects whitespace only", () => {
		const result = parse("   ");
		expect(result.ok).toBe(false);
	});

	it("parses all basic colors", () => {
		const basicColors = [
			"aqua",
			"black",
			"blue",
			"fuchsia",
			"gray",
			"green",
			"lime",
			"maroon",
			"navy",
			"olive",
			"purple",
			"red",
			"silver",
			"teal",
			"white",
			"yellow",
		];

		for (const color of basicColors) {
			const result = parse(color);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.name).toBe(color);
			}
		}
	});
});


=== File: src/parse/color/named.ts ===
// b_path:: src/parse/color/named.ts

import { BASIC_NAMED_COLOR_KEYWORDS, EXTENDED_NAMED_COLOR_KEYWORDS } from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type { NamedColor } from "@/core/types/color";

/**
 * Set of all valid CSS named colors.
 * Includes both basic (22) and extended (126) color keywords.
 */
const ALL_NAMED_COLORS = new Set<string>([...BASIC_NAMED_COLOR_KEYWORDS, ...EXTENDED_NAMED_COLOR_KEYWORDS]);

/**
 * Parse a CSS named color value.
 *
 * Accepts any valid CSS color keyword name (case-insensitive).
 * Includes basic colors (red, blue, etc.) and extended X11/SVG colors.
 *
 * @param input - The color name to parse (e.g., "red", "cornflowerblue")
 * @returns Result containing the parsed NamedColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/named";
 *
 * // Basic color
 * const color1 = parse("red");
 * // => { ok: true, value: { kind: "named", name: "red" } }
 *
 * // Extended color
 * const color2 = parse("cornflowerblue");
 * // => { ok: true, value: { kind: "named", name: "cornflowerblue" } }
 *
 * // Case-insensitive
 * const color3 = parse("BLUE");
 * // => { ok: true, value: { kind: "named", name: "blue" } }
 *
 * // Invalid color
 * const invalid = parse("notacolor");
 * // => { ok: false, error: "Unknown color name: notacolor" }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<NamedColor, string> {
	const lower = input.toLowerCase();

	if (ALL_NAMED_COLORS.has(lower)) {
		return ok({ kind: "named", name: lower });
	}

	return err(`Unknown color name: ${input}`);
}


=== File: src/parse/color/oklab.test.ts ===
// b_path:: src/parse/color/oklab.test.ts
import { describe, expect, it } from "vitest";
import * as OKLabGenerator from "@/generate/color/oklab";
import * as OKLabParser from "./oklab";

describe("OKLab Color Parser", () => {
	describe("basic space-separated syntax", () => {
		it("should parse oklab with number lightness", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.5,
					a: -0.2,
					b: 0.3,
				});
			}
		});

		it("should parse oklab with percentage lightness", () => {
			const result = OKLabParser.parse("oklab(50% -0.2 0.3)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.5,
					a: -0.2,
					b: 0.3,
				});
			}
		});

		it("should parse oklab with positive a and b values", () => {
			const result = OKLabParser.parse("oklab(0.75 0.1 0.2)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.75,
					a: 0.1,
					b: 0.2,
				});
			}
		});

		it("should parse oklab with zero values", () => {
			const result = OKLabParser.parse("oklab(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0,
					a: 0,
					b: 0,
				});
			}
		});
	});

	describe("lightness handling", () => {
		it("should convert percentage lightness to 0-1 range", () => {
			const result = OKLabParser.parse("oklab(100% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp lightness percentage above 100%", () => {
			const result = OKLabParser.parse("oklab(150% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp lightness number above 1", () => {
			const result = OKLabParser.parse("oklab(1.5 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp negative lightness to 0", () => {
			const result = OKLabParser.parse("oklab(-0.1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0);
			}
		});
	});

	describe("axis value clamping", () => {
		it("should clamp a value above 0.4", () => {
			const result = OKLabParser.parse("oklab(0.5 0.5 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.a).toBe(0.4);
			}
		});

		it("should clamp a value below -0.4", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.6 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.a).toBe(-0.4);
			}
		});

		it("should clamp b value above 0.4", () => {
			const result = OKLabParser.parse("oklab(0.5 0 0.8)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(0.4);
			}
		});

		it("should clamp b value below -0.4", () => {
			const result = OKLabParser.parse("oklab(0.5 0 -0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.b).toBe(-0.4);
			}
		});
	});

	describe("alpha channel", () => {
		it("should parse alpha with number", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.5,
					a: -0.2,
					b: 0.3,
					alpha: 0.5,
				});
			}
		});

		it("should parse alpha with percentage", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("should clamp alpha above 1", () => {
			const result = OKLabParser.parse("oklab(0.5 0 0 / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("should clamp alpha below 0", () => {
			const result = OKLabParser.parse("oklab(0.5 0 0 / -0.1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("should parse alpha of 0", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});
	});

	describe("edge cases", () => {
		it("should parse white (maximum lightness)", () => {
			const result = OKLabParser.parse("oklab(1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 1,
					a: 0,
					b: 0,
				});
			}
		});

		it("should parse black (minimum lightness)", () => {
			const result = OKLabParser.parse("oklab(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0,
					a: 0,
					b: 0,
				});
			}
		});

		it("should parse decimal values", () => {
			const result = OKLabParser.parse("oklab(0.123 -0.234 0.345)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBeCloseTo(0.123);
				expect(result.value.a).toBeCloseTo(-0.234);
				expect(result.value.b).toBeCloseTo(0.345);
			}
		});

		it("should handle extra whitespace", () => {
			const result = OKLabParser.parse("oklab(  0.5   -0.2   0.3  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklab",
					l: 0.5,
					a: -0.2,
					b: 0.3,
				});
			}
		});
	});

	describe("error handling", () => {
		it("should reject missing values", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values before slash", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 0.4)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values after slash", () => {
			const result = OKLabParser.parse("oklab(0.5 -0.2 0.3 / 0.5 0.6)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid function name", () => {
			const result = OKLabParser.parse("oklabs(0.5 -0.2 0.3)");
			expect(result.ok).toBe(false);
		});

		it("should reject non-numeric values", () => {
			const result = OKLabParser.parse("oklab(red 0 0)");
			expect(result.ok).toBe(false);
		});

		it("should reject empty function", () => {
			const result = OKLabParser.parse("oklab()");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip (parse -> generate -> parse)", () => {
		it("should round-trip oklab with number lightness", () => {
			const input = "oklab(0.5 -0.2 0.3)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLabParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklab with percentage lightness (normalizes to number)", () => {
			const input = "oklab(50% -0.2 0.3)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLabParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklab with alpha", () => {
			const input = "oklab(0.5 -0.2 0.3 / 0.5)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLabParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklab with clamped values", () => {
			const input = "oklab(1.5 0.5 -0.6)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLabParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip white", () => {
			const input = "oklab(1 0 0)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLabParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip black", () => {
			const input = "oklab(0 0 0)";
			const parsed = OKLabParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLabGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLabParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/parse/color/oklab.ts ===
// b_path:: src/parse/color/oklab.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { OKLabColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS OKLab color value.
 *
 * Supports OKLab syntax (modern only, no legacy comma syntax):
 * - Space-separated: `oklab(0.5 -0.2 0.3)`, `oklab(50% -0.2 0.3)`
 * - With alpha: `oklab(0.5 -0.2 0.3 / 0.5)`
 * - Lightness can be percentage (0-100%) or number (0-1)
 * - a and b axes: -0.4 to 0.4 (clamped)
 *
 * @param input - The OKLab color string to parse
 * @returns Result containing the parsed OKLabColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/oklab";
 *
 * // Basic syntax with number lightness
 * const color1 = parse("oklab(0.5 -0.2 0.3)");
 * // => { ok: true, value: { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 } }
 *
 * // With alpha
 * const color2 = parse("oklab(0.5 -0.2 0.3 / 0.5)");
 * // => { ok: true, value: { kind: "oklab", l: 0.5, a: -0.2, b: 0.3, alpha: 0.5 } }
 *
 * // Lightness as percentage
 * const color3 = parse("oklab(50% -0.2 0.3)");
 * // => { ok: true, value: { kind: "oklab", l: 0.5, a: -0.2, b: 0.3 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<OKLabColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find oklab() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["oklab"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (OKLab is modern, no legacy syntax)
	return parseOKLabArguments(children);
}

/**
 * Parse OKLab function arguments from AST nodes.
 * OKLab only supports space-separated syntax: oklab(L a b) or oklab(L a b / A)
 *
 * @internal
 */
function parseOKLabArguments(nodes: csstree.CssNode[]): Result<OKLabColor, string> {
	let l: number | undefined;
	let a: number | undefined;
	let b: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			if (alpha !== undefined) {
				return err("Too many values after '/' in OKLab color");
			}
			const alphaResult = ParseUtils.parseAlpha(node, { clamp: true });
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			continue;
		}

		// Parse L, a, b components
		if (componentIndex === 0) {
			// Lightness (percentage or number)
			const lightnessResult = ParseUtils.parseLightness(node, "0-1");
			if (!lightnessResult.ok) {
				return err(lightnessResult.error);
			}
			l = lightnessResult.value;
		} else if (componentIndex === 1) {
			// a axis (number)
			const axisResult = parseAxisValue(node);
			if (!axisResult.ok) {
				return err(axisResult.error);
			}
			a = axisResult.value;
		} else if (componentIndex === 2) {
			// b axis (number)
			const axisResult = parseAxisValue(node);
			if (!axisResult.ok) {
				return err(axisResult.error);
			}
			b = axisResult.value;
		} else {
			// Too many values (more than 3 before slash)
			return err("Too many values in OKLab color (expected 3: lightness, a, b)");
		}
		componentIndex++;
	}

	if (l === undefined || a === undefined || b === undefined) {
		return err("Expected 3 OKLab values (lightness, a, b)");
	}

	const color: OKLabColor = { kind: "oklab", l, a, b };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse an axis value (a or b).
 *
 * Accepts: number (typically -0.4 to 0.4, but clamped)
 *
 * @internal
 */
function parseAxisValue(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Clamp to -0.4 to 0.4 range (CSS spec)
		const clamped = Math.max(-0.4, Math.min(0.4, value));
		return ok(clamped);
	}

	return err(`Expected number for axis value, got ${node.type}`);
}


=== File: src/parse/color/oklch.test.ts ===
// b_path:: src/parse/color/oklch.test.ts
import { describe, expect, it } from "vitest";
import * as OKLCHGenerator from "@/generate/color/oklch";
import * as OKLCHParser from "./oklch";

describe("OKLCH Color Parser", () => {
	describe("basic space-separated syntax", () => {
		it("should parse oklch with number lightness", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.5,
					c: 0.2,
					h: 180,
				});
			}
		});

		it("should parse oklch with percentage lightness", () => {
			const result = OKLCHParser.parse("oklch(50% 0.2 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.5,
					c: 0.2,
					h: 180,
				});
			}
		});

		it("should parse oklch with unitless hue", () => {
			const result = OKLCHParser.parse("oklch(0.75 0.15 270)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.75,
					c: 0.15,
					h: 270,
				});
			}
		});

		it("should parse oklch with zero values", () => {
			const result = OKLCHParser.parse("oklch(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0,
					c: 0,
					h: 0,
				});
			}
		});
	});

	describe("angle units", () => {
		it("should parse hue with deg unit", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with turn unit", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 0.5turn)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with rad unit", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 3.14159rad)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBeCloseTo(180, 0);
			}
		});

		it("should parse hue with grad unit", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 200grad)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(180);
			}
		});

		it("should parse hue with 1turn", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 1turn)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0); // 360 wraps to 0
			}
		});
	});

	describe("hue wrapping", () => {
		it("should wrap hue 360deg to 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 360)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("should wrap hue 450deg to 90deg", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 450)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(90);
			}
		});

		it("should wrap hue 720deg to 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 720)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});

		it("should wrap negative hue -90deg to 270deg", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 -90)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(270);
			}
		});

		it("should wrap negative hue -360deg to 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 -360)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.h).toBe(0);
			}
		});
	});

	describe("lightness handling", () => {
		it("should convert percentage lightness to 0-1 range", () => {
			const result = OKLCHParser.parse("oklch(100% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp lightness percentage above 100%", () => {
			const result = OKLCHParser.parse("oklch(150% 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp lightness number above 1", () => {
			const result = OKLCHParser.parse("oklch(1.5 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(1);
			}
		});

		it("should clamp negative lightness to 0", () => {
			const result = OKLCHParser.parse("oklch(-0.1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBe(0);
			}
		});
	});

	describe("chroma clamping", () => {
		it("should clamp chroma above 0.4", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.8 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(0.4);
			}
		});

		it("should clamp negative chroma to 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 -0.1 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(0);
			}
		});

		it("should accept chroma of 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0 180)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.c).toBe(0);
			}
		});
	});

	describe("alpha channel", () => {
		it("should parse alpha with number", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.5,
					c: 0.2,
					h: 180,
					alpha: 0.5,
				});
			}
		});

		it("should parse alpha with percentage", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 / 50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0.5);
			}
		});

		it("should clamp alpha above 1", () => {
			const result = OKLCHParser.parse("oklch(0.5 0 0 / 1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(1);
			}
		});

		it("should clamp alpha below 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0 0 / -0.1)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});

		it("should parse alpha of 0", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 / 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.alpha).toBe(0);
			}
		});
	});

	describe("edge cases", () => {
		it("should parse white (maximum lightness)", () => {
			const result = OKLCHParser.parse("oklch(1 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 1,
					c: 0,
					h: 0,
				});
			}
		});

		it("should parse black (minimum lightness)", () => {
			const result = OKLCHParser.parse("oklch(0 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0,
					c: 0,
					h: 0,
				});
			}
		});

		it("should parse decimal values", () => {
			const result = OKLCHParser.parse("oklch(0.123 0.234 123.45)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.l).toBeCloseTo(0.123);
				expect(result.value.c).toBeCloseTo(0.234);
				expect(result.value.h).toBeCloseTo(123.45);
			}
		});

		it("should handle extra whitespace", () => {
			const result = OKLCHParser.parse("oklch(  0.5   0.2   180  )");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "oklch",
					l: 0.5,
					c: 0.2,
					h: 180,
				});
			}
		});
	});

	describe("error handling", () => {
		it("should reject missing values", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values before slash", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 90)");
			expect(result.ok).toBe(false);
		});

		it("should reject too many values after slash", () => {
			const result = OKLCHParser.parse("oklch(0.5 0.2 180 / 0.5 0.6)");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid function name", () => {
			const result = OKLCHParser.parse("oklchs(0.5 0.2 180)");
			expect(result.ok).toBe(false);
		});

		it("should reject non-numeric values", () => {
			const result = OKLCHParser.parse("oklch(red 0 0)");
			expect(result.ok).toBe(false);
		});

		it("should reject empty function", () => {
			const result = OKLCHParser.parse("oklch()");
			expect(result.ok).toBe(false);
		});
	});

	describe("round-trip (parse -> generate -> parse)", () => {
		it("should round-trip oklch with number lightness", () => {
			const input = "oklch(0.5 0.2 180)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLCHParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with percentage lightness (normalizes to number)", () => {
			const input = "oklch(50% 0.2 180)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLCHParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with angle units (normalizes to unitless)", () => {
			const input = "oklch(0.5 0.2 0.5turn)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLCHParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with alpha", () => {
			const input = "oklch(0.5 0.2 180 / 0.5)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLCHParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with wrapped hue", () => {
			const input = "oklch(0.5 0.2 450)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLCHParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip oklch with clamped values", () => {
			const input = "oklch(1.5 0.8 -90)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLCHParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip white", () => {
			const input = "oklch(1 0 0)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLCHParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});

		it("should round-trip black", () => {
			const input = "oklch(0 0 0)";
			const parsed = OKLCHParser.parse(input);
			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = OKLCHGenerator.generate(parsed.value);
				expect(generated.ok).toBe(true);
				if (!generated.ok) return;
				const reparsed = OKLCHParser.parse(generated.value);
				expect(reparsed.ok).toBe(true);
				if (reparsed.ok) {
					expect(reparsed.value).toEqual(parsed.value);
				}
			}
		});
	});
});


=== File: src/parse/color/oklch.ts ===
// b_path:: src/parse/color/oklch.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { OKLCHColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS OKLCH color value.
 *
 * Supports OKLCH syntax (modern only, no legacy comma syntax):
 * - Space-separated: `oklch(0.5 0.2 180deg)`, `oklch(50% 0.2 180)`
 * - With alpha: `oklch(0.5 0.2 180 / 0.5)`
 * - Lightness can be percentage (0-100%) or number (0-1)
 * - Chroma: 0-0.4 (clamped)
 * - Hue: angle with deg, rad, grad, turn units (or unitless defaults to deg)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 *
 * @param input - The OKLCH color string to parse
 * @returns Result containing the parsed OKLCHColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/oklch";
 *
 * // Basic syntax with number lightness
 * const color1 = parse("oklch(0.5 0.2 180)");
 * // => { ok: true, value: { kind: "oklch", l: 0.5, c: 0.2, h: 180 } }
 *
 * // With angle unit
 * const color2 = parse("oklch(0.5 0.2 0.5turn)");
 * // => { ok: true, value: { kind: "oklch", l: 0.5, c: 0.2, h: 180 } }
 *
 * // With alpha
 * const color3 = parse("oklch(0.5 0.2 180 / 0.5)");
 * // => { ok: true, value: { kind: "oklch", l: 0.5, c: 0.2, h: 180, alpha: 0.5 } }
 *
 * // Lightness as percentage
 * const color4 = parse("oklch(50% 0.2 180)");
 * // => { ok: true, value: { kind: "oklch", l: 0.5, c: 0.2, h: 180 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<OKLCHColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find oklch() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["oklch"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;
	const children = fn.children.toArray();

	// Parse arguments - space-separated only (OKLCH is modern, no legacy syntax)
	return parseOKLCHArguments(children);
}

/**
 * Parse OKLCH function arguments from AST nodes.
 * OKLCH only supports space-separated syntax: oklch(L C H) or oklch(L C H / A)
 *
 * @internal
 */
function parseOKLCHArguments(nodes: csstree.CssNode[]): Result<OKLCHColor, string> {
	let l: number | undefined;
	let c: number | undefined;
	let h: number | undefined;
	let alpha: number | undefined;
	let foundSlash = false;
	let componentIndex = 0;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			if (alpha !== undefined) {
				return err("Too many values after '/' in OKLCH color");
			}
			const alphaResult = ParseUtils.parseAlpha(node, { clamp: true });
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			continue;
		}

		// Parse L, C, H components
		if (componentIndex === 0) {
			// Lightness (percentage or number)
			const lightnessResult = ParseUtils.parseLightness(node, "0-1");
			if (!lightnessResult.ok) {
				return err(lightnessResult.error);
			}
			l = lightnessResult.value;
		} else if (componentIndex === 1) {
			// Chroma (number)
			const chromaResult = parseChroma(node);
			if (!chromaResult.ok) {
				return err(chromaResult.error);
			}
			c = chromaResult.value;
		} else if (componentIndex === 2) {
			// Hue (angle or unitless number)
			const hueResult = ParseUtils.parseHue(node);
			if (!hueResult.ok) {
				return err(hueResult.error);
			}
			h = hueResult.value;
		} else {
			// Too many values (more than 3 before slash)
			return err("Too many values in OKLCH color (expected 3: lightness, chroma, hue)");
		}
		componentIndex++;
	}

	if (l === undefined || c === undefined || h === undefined) {
		return err("Expected 3 OKLCH values (lightness, chroma, hue)");
	}

	const color: OKLCHColor = { kind: "oklch", l, c, h };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse a chroma value.
 *
 * Accepts: number (0-0.4, clamped)
 *
 * @internal
 */
function parseChroma(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Clamp to 0-0.4 range (CSS spec)
		const clamped = Math.max(0, Math.min(0.4, value));
		return ok(clamped);
	}

	return err(`Expected number for chroma, got ${node.type}`);
}


=== File: src/parse/color/rgb.ts ===
// b_path:: src/parse/color/rgb.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { RGBColor } from "@/core/types/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse a CSS RGB color value.
 *
 * Supports all RGB syntax variations:
 * - Modern space-separated: `rgb(255 0 0)`, `rgb(255 0 0 / 0.5)`
 * - Legacy comma-separated: `rgb(255, 0, 0)`, `rgba(255, 0, 0, 0.5)`
 * - Percentage values: `rgb(100% 0% 0%)`
 * - Mixed formats handled according to CSS spec
 *
 * @param input - The RGB color string to parse
 * @returns Result containing the parsed RGBColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/rgb";
 *
 * // Modern syntax
 * const color1 = parse("rgb(255 0 0)");
 * // => { ok: true, value: { kind: "rgb", r: 255, g: 0, b: 0 } }
 *
 * // With alpha
 * const color2 = parse("rgb(255 0 0 / 0.5)");
 * // => { ok: true, value: { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 } }
 *
 * // Legacy comma syntax
 * const color3 = parse("rgb(255, 0, 0)");
 * // => { ok: true, value: { kind: "rgb", r: 255, g: 0, b: 0 } }
 *
 * // Percentage values
 * const color4 = parse("rgb(100% 0% 0%)");
 * // => { ok: true, value: { kind: "rgb", r: 255, g: 0, b: 0 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<RGBColor, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find rgb() or rgba() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, ["rgb", "rgba"]);
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get all children nodes (arguments)
	const children = fn.children.toArray();

	// Parse arguments - handle both comma and space syntax
	return parseRGBArguments(children);
}

/**
 * Parse RGB function arguments from AST nodes.
 *
 * Handles both comma-separated and space-separated syntax:
 * - Space: rgb(255 0 0) or rgb(255 0 0 / 0.5)
 * - Comma: rgb(255, 0, 0) or rgba(255, 0, 0, 0.5)
 *
 * @param nodes - Array of CSS AST nodes from function arguments
 * @returns Result containing parsed RGBColor or error message
 *
 * @internal
 */
function parseRGBArguments(nodes: csstree.CssNode[]): Result<RGBColor, string> {
	// Check if we have comma separators (legacy syntax)
	const hasComma = nodes.some((node) => node.type === "Operator" && "value" in node && node.value === ",");

	if (hasComma) {
		return parseCommaRGB(nodes);
	}
	return parseSpaceRGB(nodes);
}

/**
 * Parse space-separated RGB syntax: rgb(255 0 0) or rgb(255 0 0 / 0.5)
 *
 * @internal
 */
function parseSpaceRGB(nodes: csstree.CssNode[]): Result<RGBColor, string> {
	const values: number[] = [];
	let alpha: number | undefined;
	let foundSlash = false;

	for (const node of nodes) {
		// Skip operators except slash
		if (node.type === "Operator" && "value" in node) {
			if (node.value === "/") {
				foundSlash = true;
				continue;
			}
			continue;
		}

		if (foundSlash) {
			// After slash, parse alpha
			const alphaResult = ParseUtils.parseAlpha(node);
			if (!alphaResult.ok) {
				return err(alphaResult.error);
			}
			alpha = alphaResult.value;
			break;
		}

		// Parse RGB component (number or percentage)
		const componentResult = parseRGBComponent(node);
		if (!componentResult.ok) {
			return err(componentResult.error);
		}
		values.push(componentResult.value);
	}

	if (values.length !== 3) {
		return err(`Expected 3 RGB values, got ${values.length}`);
	}

	const [r, g, b] = values;
	if (r === undefined || g === undefined || b === undefined) {
		return err("Missing RGB values");
	}

	const color: RGBColor = { kind: "rgb", r, g, b };
	if (alpha !== undefined) {
		color.alpha = alpha;
	}

	return ok(color);
}

/**
 * Parse comma-separated RGB syntax: rgb(255, 0, 0) or rgba(255, 0, 0, 0.5)
 *
 * @internal
 */
function parseCommaRGB(nodes: csstree.CssNode[]): Result<RGBColor, string> {
	// Filter out comma operators
	const valueNodes = nodes.filter((node) => !(node.type === "Operator" && "value" in node && node.value === ","));

	if (valueNodes.length !== 3 && valueNodes.length !== 4) {
		return err(`Expected 3 or 4 values (R, G, B, [A]), got ${valueNodes.length}`);
	}

	const values: number[] = [];

	// Parse RGB components
	for (let i = 0; i < 3; i++) {
		const node = valueNodes[i];
		if (!node) {
			return err(`Missing RGB component at position ${i}`);
		}
		const componentResult = parseRGBComponent(node);
		if (!componentResult.ok) {
			return err(componentResult.error);
		}
		values.push(componentResult.value);
	}

	const [r, g, b] = values;
	if (r === undefined || g === undefined || b === undefined) {
		return err("Missing RGB values");
	}

	const color: RGBColor = { kind: "rgb", r, g, b };

	// Parse alpha if present (4th value)
	if (valueNodes.length === 4) {
		const alphaNode = valueNodes[3];
		if (!alphaNode) {
			return err("Invalid alpha value");
		}
		const alphaResult = ParseUtils.parseAlpha(alphaNode);
		if (!alphaResult.ok) {
			return err(alphaResult.error);
		}
		color.alpha = alphaResult.value;
	}

	return ok(color);
}

/**
 * Parse an RGB component (R, G, or B value).
 *
 * Accepts:
 * - Integer: 0-255 (values are clamped to range after rounding)
 * - Percentage: 0%-100% (converted to 0-255, clamped)
 *
 * @internal
 */
function parseRGBComponent(node: csstree.CssNode): Result<number, string> {
	// Try parsing as number (0-255)
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;
		// Round first, then clamp to 0-255 range
		const rounded = Math.round(value);
		const clamped = Math.max(0, Math.min(255, rounded));
		return ok(clamped);
	}

	// Try parsing as percentage (0%-100%)
	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value");
		}
		// Convert percentage to 0-255 range, then clamp
		const converted = (value / 100) * 255;
		const rounded = Math.round(converted);
		const clamped = Math.max(0, Math.min(255, rounded));
		return ok(clamped);
	}

	return err(`Expected number or percentage for RGB component, got ${node.type}`);
}


=== File: src/parse/color/special.test.ts ===
// b_path:: src/parse/color/special.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./special";

describe("parse special color", () => {
	it("parses 'transparent'", () => {
		const result = parse("transparent");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "special",
				keyword: "transparent",
			});
		}
	});

	it("parses 'currentcolor'", () => {
		const result = parse("currentcolor");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "special",
				keyword: "currentcolor",
			});
		}
	});

	it("parses 'transparent' case-insensitively", () => {
		const result = parse("TRANSPARENT");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("transparent");
		}
	});

	it("parses 'currentcolor' case-insensitively", () => {
		const result = parse("CurrentColor");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("currentcolor");
		}
	});

	it("parses with whitespace", () => {
		const result = parse("  transparent  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("transparent");
		}
	});

	it("rejects invalid keyword", () => {
		const result = parse("notspecial");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid special color keyword");
		}
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects named colors", () => {
		const result = parse("red");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/color/special.ts ===
// b_path:: src/parse/color/special.ts

import { SPECIAL_COLOR_KEYWORDS } from "@/core/keywords/color-keywords";
import { err, ok, type Result } from "@/core/result";
import type { SpecialColor } from "@/core/types/color";

/**
 * Parse a CSS special color keyword.
 *
 * Special color keywords have unique behavior:
 * - `transparent`: Fully transparent color (rgba(0, 0, 0, 0))
 * - `currentcolor`: Uses the current value of the color property
 *
 * These values are case-insensitive.
 *
 * @param input - The special color keyword to parse
 * @returns Result containing the parsed SpecialColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/special";
 *
 * const color1 = parse("transparent");
 * // => { ok: true, value: { kind: "special", keyword: "transparent" } }
 *
 * const color2 = parse("CurrentColor"); // case-insensitive
 * // => { ok: true, value: { kind: "special", keyword: "currentcolor" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<SpecialColor, string> {
	const trimmed = input.trim();

	// Special color keywords are case-insensitive in CSS
	const lowerInput = trimmed.toLowerCase();

	// Check if it's a valid special color keyword
	if (SPECIAL_COLOR_KEYWORDS.includes(lowerInput as (typeof SPECIAL_COLOR_KEYWORDS)[number])) {
		return ok({
			kind: "special",
			keyword: lowerInput as "transparent" | "currentcolor",
		});
	}

	return err(`Invalid special color keyword: ${trimmed}`);
}


=== File: src/parse/color/system.test.ts ===
// b_path:: src/parse/color/system.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./system";

describe("parse system color", () => {
	it("parses 'ButtonText'", () => {
		const result = parse("ButtonText");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "system",
				keyword: "ButtonText",
			});
		}
	});

	it("parses 'Canvas'", () => {
		const result = parse("Canvas");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("Canvas");
		}
	});

	it("parses 'CanvasText'", () => {
		const result = parse("CanvasText");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("CanvasText");
		}
	});

	it("parses 'AccentColor'", () => {
		const result = parse("AccentColor");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("AccentColor");
		}
	});

	it("parses 'Highlight'", () => {
		const result = parse("Highlight");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("Highlight");
		}
	});

	it("parses case-insensitively lowercase", () => {
		const result = parse("canvas");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("Canvas");
		}
	});

	it("parses case-insensitively uppercase", () => {
		const result = parse("BUTTONTEXT");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("ButtonText");
		}
	});

	it("parses with whitespace", () => {
		const result = parse("  ButtonText  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.keyword).toBe("ButtonText");
		}
	});

	it("rejects invalid keyword", () => {
		const result = parse("InvalidColor");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid system color keyword");
		}
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects named colors", () => {
		const result = parse("red");
		expect(result.ok).toBe(false);
	});

	it("parses multiple system colors", () => {
		const systemColors = ["AccentColor", "ButtonBorder", "ButtonFace", "Field", "FieldText", "LinkText", "Mark"];

		for (const color of systemColors) {
			const result = parse(color);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.keyword).toBe(color);
			}
		}
	});
});


=== File: src/parse/color/system.ts ===
// b_path:: src/parse/color/system.ts

import { SYSTEM_COLOR_KEYWORDS } from "@/core/keywords/system-color-keywords";
import { err, ok, type Result } from "@/core/result";
import type { SystemColor } from "@/core/types/color";

/**
 * Parse a CSS system color keyword.
 *
 * System colors represent colors from the user's operating system or browser theme.
 * These values are case-insensitive.
 *
 * Supported keywords:
 * - AccentColor, AccentColorText, ActiveText
 * - ButtonBorder, ButtonFace, ButtonText
 * - Canvas, CanvasText
 * - Field, FieldText
 * - GrayText, Highlight, HighlightText
 * - LinkText, Mark, MarkText
 * - SelectedItem, SelectedItemText
 * - VisitedText
 *
 * @param input - The system color keyword to parse
 * @returns Result containing the parsed SystemColor or error message
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/color/system";
 *
 * const color1 = parse("ButtonText");
 * // => { ok: true, value: { kind: "system", keyword: "ButtonText" } }
 *
 * const color2 = parse("canvas"); // case-insensitive
 * // => { ok: true, value: { kind: "system", keyword: "Canvas" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<SystemColor, string> {
	const trimmed = input.trim();

	// System color keywords are case-insensitive in CSS
	const lowerInput = trimmed.toLowerCase();

	// Find matching keyword (case-insensitive comparison)
	const matchedKeyword = SYSTEM_COLOR_KEYWORDS.find((keyword) => keyword.toLowerCase() === lowerInput);

	if (matchedKeyword) {
		return ok({ kind: "system", keyword: matchedKeyword });
	}

	return err(`Invalid system color keyword: ${trimmed}`);
}


=== File: src/parse/filter/blur.test.ts ===
// b_path:: src/parse/filter/blur.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./blur";

describe("parse blur filter", () => {
	it("parses blur with px value", () => {
		const result = parse("blur(5px)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("blur");
			expect(result.value.radius).toEqual({ value: 5, unit: "px" });
		}
	});

	it("parses blur with rem value", () => {
		const result = parse("blur(1rem)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.radius).toEqual({ value: 1, unit: "rem" });
		}
	});

	it("parses blur with em value", () => {
		const result = parse("blur(0.5em)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.radius).toEqual({ value: 0.5, unit: "em" });
		}
	});

	it("parses blur with zero", () => {
		const result = parse("blur(0px)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.radius).toEqual({ value: 0, unit: "px" });
		}
	});

	it("rejects negative radius", () => {
		const result = parse("blur(-5px)");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("non-negative");
		}
	});

	it("rejects no arguments", () => {
		const result = parse("blur()");
		expect(result.ok).toBe(false);
	});

	it("rejects multiple arguments", () => {
		const result = parse("blur(5px, 10px)");
		expect(result.ok).toBe(false);
	});

	it("rejects invalid unit", () => {
		const result = parse("blur(5%)");
		expect(result.ok).toBe(false);
	});

	it("rejects non-function input", () => {
		const result = parse("5px");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/filter/blur.ts ===
// b_path:: src/parse/filter/blur.ts
import { err, ok, type Result } from "@/core/result";
import type { BlurFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS blur() filter function.
 *
 * Parses blur filter with length value (px, em, rem, etc.).
 * Value: Length dimension representing blur radius.
 * Negative values are not allowed.
 *
 * @param input - CSS string like "blur(5px)" or "blur(1rem)"
 * @returns Result with BlurFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/blur";
 *
 * const result = parse("blur(5px)");
 * // { ok: true, value: { kind: "blur", radius: { value: 5, unit: "px" } } }
 *
 * const result2 = parse("blur(1rem)");
 * // { ok: true, value: { kind: "blur", radius: { value: 1, unit: "rem" } } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<BlurFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find blur() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "blur");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`blur() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("blur() expects 1 argument");
	}

	// Parse length value
	const lengthResult = ParseUtils.parseLengthNode(valueNode);
	if (!lengthResult.ok) {
		return err(lengthResult.error);
	}

	const radius = lengthResult.value;

	// Validate non-negative
	if (radius.value < 0) {
		return err(`blur() radius must be non-negative, got ${radius.value}${radius.unit}`);
	}

	return ok({ kind: "blur", radius });
}


=== File: src/parse/filter/brightness.ts ===
// b_path:: src/parse/filter/brightness.ts
import { err, ok, type Result } from "@/core/result";
import type { BrightnessFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS brightness() filter function.
 *
 * Parses brightness filter with number or percentage value.
 * Number values: 1 = 100% brightness (no change)
 * Percentage values: converted to decimal (150% → 1.5)
 * Value range: 0 to infinity (0 = completely black)
 *
 * @param input - CSS string like "brightness(1.5)" or "brightness(150%)"
 * @returns Result with BrightnessFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/brightness";
 *
 * const result = parse("brightness(1.5)");
 * // { ok: true, value: { kind: "brightness", value: 1.5 } }
 *
 * const result2 = parse("brightness(150%)");
 * // { ok: true, value: { kind: "brightness", value: 1.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<BrightnessFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find brightness() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "brightness");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`brightness() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("brightness() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - brightness allows > 100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		if (rawValue < 0) {
			return err(`brightness() value must be non-negative, got ${rawValue}%`);
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (non-negative)
	if (value < 0) {
		return err(`brightness() value must be non-negative, got ${value}`);
	}

	return ok({ kind: "brightness", value });
}


=== File: src/parse/filter/contrast.ts ===
// b_path:: src/parse/filter/contrast.ts
import { err, ok, type Result } from "@/core/result";
import type { ContrastFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS contrast() filter function.
 *
 * Parses contrast filter with number or percentage value.
 * Number values: 1 = 100% contrast (no change)
 * Percentage values: converted to decimal (150% → 1.5)
 * Value range: 0 to infinity (0 = completely black)
 *
 * @param input - CSS string like "contrast(1.5)" or "contrast(150%)"
 * @returns Result with ContrastFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/contrast";
 *
 * const result = parse("contrast(1.5)");
 * // { ok: true, value: { kind: "contrast", value: 1.5 } }
 *
 * const result2 = parse("contrast(150%)");
 * // { ok: true, value: { kind: "contrast", value: 1.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<ContrastFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find contrast() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "contrast");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`contrast() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("contrast() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - contrast allows > 100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		if (rawValue < 0) {
			return err(`contrast() value must be non-negative, got ${rawValue}%`);
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (non-negative)
	if (value < 0) {
		return err(`contrast() value must be non-negative, got ${value}`);
	}

	return ok({ kind: "contrast", value });
}


=== File: src/parse/filter/drop-shadow.ts ===
// b_path:: src/parse/filter/drop-shadow.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import type { DropShadowFilter } from "@/core/types/filter";
import type { Length } from "@/core/types/length-percentage";
import { parseNode as parseColorNode } from "@/parse/color";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Convert an AST node to string representation for error messages.
 *
 * @param node - CSS AST node
 * @returns String representation of the node
 * @internal
 */
function nodeToString(node: csstree.CssNode): string {
	try {
		return csstree.generate(node);
	} catch {
		return node.type;
	}
}

/**
 * Parse CSS drop-shadow() filter function.
 *
 * Applies a drop shadow effect to the element.
 * Syntax: drop-shadow(offset-x offset-y [blur-radius] [color])
 *
 * @param input - CSS string like "drop-shadow(2px 2px)" or "drop-shadow(2px 2px 4px rgba(0,0,0,0.5))"
 * @returns Result with DropShadowFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/drop-shadow";
 *
 * // Basic drop shadow
 * const result = parse("drop-shadow(2px 2px)");
 * // { ok: true, value: { kind: "drop-shadow", offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" } } }
 *
 * // With blur radius
 * const result2 = parse("drop-shadow(2px 2px 4px)");
 * // { ok: true, value: { kind: "drop-shadow", offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" }, blurRadius: { value: 4, unit: "px" } } }
 *
 * // With color
 * const result3 = parse("drop-shadow(2px 2px 4px black)");
 * // { ok: true, value: { kind: "drop-shadow", offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" }, blurRadius: { value: 4, unit: "px" }, color: { kind: "named", name: "black" } } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<DropShadowFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find drop-shadow() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "drop-shadow");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect at least 2 arguments (offset-x and offset-y are required)
	if (children.length < 2) {
		return err(`drop-shadow() expects at least 2 arguments, got ${children.length}`);
	}

	// Parse arguments - need to identify lengths vs color
	return parseDropShadowArguments(children);
}

/**
 * Parse drop-shadow function arguments from AST nodes.
 *
 * Handles the complexity of identifying which arguments are lengths vs color.
 * Color can appear in any position after the first two required length arguments.
 *
 * @param nodes - Array of CSS AST nodes from function arguments
 * @returns Result containing parsed DropShadowFilter or error message
 *
 * @internal
 */
function parseDropShadowArguments(nodes: csstree.CssNode[]): Result<DropShadowFilter, string> {
	// First two arguments are always offset-x and offset-y (required lengths)
	const firstNode = nodes[0];
	const secondNode = nodes[1];

	if (!firstNode) {
		return err("drop-shadow() missing offset-x");
	}
	if (!secondNode) {
		return err("drop-shadow() missing offset-y");
	}

	const offsetXResult = ParseUtils.parseLengthNode(firstNode);
	if (!offsetXResult.ok) {
		return err(`drop-shadow() offset-x: ${offsetXResult.error}`);
	}

	const offsetYResult = ParseUtils.parseLengthNode(secondNode);
	if (!offsetYResult.ok) {
		return err(`drop-shadow() offset-y: ${offsetYResult.error}`);
	}

	const offsetX = offsetXResult.value;
	const offsetY = offsetYResult.value;

	// Default values
	let blurRadius: Length | undefined;
	let color: Color | undefined;

	// Process remaining arguments (2-4 total, so 0-2 more arguments)
	const remainingNodes = nodes.slice(2);

	// If we have remaining arguments, determine their types
	if (remainingNodes.length > 0) {
		const result = parseRemainingArguments(remainingNodes);
		if (!result.ok) {
			return err(result.error);
		}

		({ blurRadius, color } = result.value);
	}

	return ok({
		kind: "drop-shadow",
		offsetX,
		offsetY,
		blurRadius,
		color,
	});
}

/**
 * Parse the remaining arguments after offset-x and offset-y.
 *
 * Handles the complexity where:
 * - blur-radius is optional length
 * - color is optional and can appear in any position
 * - We need to distinguish between length and color arguments
 *
 * @param nodes - Remaining AST nodes to parse
 * @returns Result with parsed blurRadius and color, or error
 *
 * @internal
 */
function parseRemainingArguments(
	nodes: csstree.CssNode[],
): Result<{ blurRadius: Length | undefined; color: Color | undefined }, string> {
	let blurRadius: Length | undefined;
	let color: Color | undefined;

	// Process each remaining node
	for (const node of nodes) {
		// Skip operators (like commas if present)
		if (node.type === "Operator") {
			continue;
		}

		// Try parsing as length first (for blur-radius)
		const lengthResult = ParseUtils.parseLengthNode(node);
		if (lengthResult.ok) {
			if (blurRadius !== undefined) {
				return err("drop-shadow() can have at most one blur-radius");
			}
			blurRadius = lengthResult.value;
			continue;
		}

		// If not a length, try parsing as color
		const colorResult = parseColorNode(node);
		if (colorResult.ok) {
			if (color !== undefined) {
				return err("drop-shadow() can have at most one color");
			}
			color = colorResult.value;
			continue;
		}

		// If neither length nor color, it's an invalid argument
		return err(`drop-shadow() invalid argument: ${nodeToString(node)}. Expected length or color.`);
	}

	// Check for too many arguments (more than 2 remaining = more than 4 total)
	if (nodes.length > 2) {
		return err(`drop-shadow() expects at most 4 arguments, got ${nodes.length + 2}`);
	}

	return ok({ blurRadius, color });
}


=== File: src/parse/filter/filter.test.ts ===
// b_path:: src/parse/filter/filter.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./filter";

describe("parse() - unified filter dispatcher", () => {
	describe("auto-detection", () => {
		it("detects blur()", () => {
			const result = parse("blur(5px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("blur");
			}
		});

		it("detects brightness()", () => {
			const result = parse("brightness(1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("brightness");
			}
		});

		it("detects contrast()", () => {
			const result = parse("contrast(200%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("contrast");
			}
		});

		it("detects drop-shadow()", () => {
			const result = parse("drop-shadow(2px 2px 4px black)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("drop-shadow");
			}
		});

		it("detects grayscale()", () => {
			const result = parse("grayscale(50%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("grayscale");
			}
		});

		it("detects hue-rotate()", () => {
			const result = parse("hue-rotate(90deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("hue-rotate");
			}
		});

		it("detects invert()", () => {
			const result = parse("invert(100%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("invert");
			}
		});

		it("detects opacity()", () => {
			const result = parse("opacity(0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("opacity");
			}
		});

		it("detects saturate()", () => {
			const result = parse("saturate(150%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("saturate");
			}
		});

		it("detects sepia()", () => {
			const result = parse("sepia(75%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("sepia");
			}
		});

		it("detects url()", () => {
			const result = parse("url(#filter-id)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("url");
			}
		});
	});

	describe("error handling", () => {
		it("rejects unknown filter function", () => {
			const result = parse("unknown(50%)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown filter function");
			}
		});

		it("rejects invalid syntax", () => {
			const result = parse("not-a-filter");
			expect(result.ok).toBe(false);
		});

		it("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});

	describe("case insensitivity", () => {
		it("handles uppercase function names", () => {
			const result = parse("BLUR(5px)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("blur");
			}
		});

		it("handles mixed case function names", () => {
			const result = parse("BrIgHtNeSs(1.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("brightness");
			}
		});
	});
});


=== File: src/parse/filter/filter.ts ===
// b_path:: src/parse/filter/filter.ts

import type { CssNode } from "css-tree";
import * as cssTree from "css-tree";
import { err, type ParseResult, parseErr, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as Blur from "./blur";
import * as Brightness from "./brightness";
import * as Contrast from "./contrast";
import * as DropShadow from "./drop-shadow";
import * as Grayscale from "./grayscale";
import * as HueRotate from "./hue-rotate";
import * as Invert from "./invert";
import * as Opacity from "./opacity";
import * as Saturate from "./saturate";
import * as Sepia from "./sepia";
import * as Url from "./url";

/**
 * Parse filter value with auto-detection.
 *
 * Automatically detects and parses any CSS filter function:
 * - blur(), brightness(), contrast(), drop-shadow()
 * - grayscale(), hue-rotate(), invert(), opacity()
 * - saturate(), sepia(), url()
 *
 * @param value - CSS filter value string
 * @returns Result with FilterFunction IR or error
 *
 * @example
 * ```typescript
 * parse("blur(5px)");              // Auto-detects blur
 * parse("brightness(1.5)");        // Auto-detects brightness
 * parse("drop-shadow(2px 2px 4px black)"); // Auto-detects drop-shadow
 * parse("url(#filter)");           // Auto-detects url
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Type.FilterFunction> {
	const ast = cssTree.parse(value, { context: "value" }) as cssTree.Value;
	if (!ast.children) return parseErr("invalid-syntax", "Empty value");
	const first = ast.children.first;
	if (!first) return parseErr("invalid-syntax", "Empty value");
	const result = parseNode(first);
	return toParseResult(result);
}

/**
 * Parse filter AST node with auto-detection.
 *
 * @param node - CSS AST node
 * @returns Result with FilterFunction IR or error
 *
 * @internal
 */
function parseNode(node: CssNode): Result<Type.FilterFunction, string> {
	// URL filter (special case - Url node type)
	if (node.type === "Url") {
		const css = cssTree.generate(node);
		return Url.parse(css);
	}

	// Filter functions
	if (node.type === "Function") {
		const css = cssTree.generate(node);
		switch (node.name.toLowerCase()) {
			case "blur":
				return Blur.parse(css);
			case "brightness":
				return Brightness.parse(css);
			case "contrast":
				return Contrast.parse(css);
			case "drop-shadow":
				return DropShadow.parse(css);
			case "grayscale":
				return Grayscale.parse(css);
			case "hue-rotate":
				return HueRotate.parse(css);
			case "invert":
				return Invert.parse(css);
			case "opacity":
				return Opacity.parse(css);
			case "saturate":
				return Saturate.parse(css);
			case "sepia":
				return Sepia.parse(css);
			default:
				return err(`Unknown filter function: ${node.name}`);
		}
	}

	return err("Invalid filter value");
}


=== File: src/parse/filter/grayscale.ts ===
// b_path:: src/parse/filter/grayscale.ts
import { err, ok, type Result } from "@/core/result";
import type { GrayscaleFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS grayscale() filter function.
 *
 * Parses grayscale filter with number or percentage value.
 * Number values: 0 to 1, where 1 = 100% grayscale
 * Percentage values: converted to decimal (50% → 0.5)
 * Value range: 0 to 1 (clamped)
 *
 * @param input - CSS string like "grayscale(0.5)" or "grayscale(50%)"
 * @returns Result with GrayscaleFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/grayscale";
 *
 * const result = parse("grayscale(0.5)");
 * // { ok: true, value: { kind: "grayscale", value: 0.5 } }
 *
 * const result2 = parse("grayscale(50%)");
 * // { ok: true, value: { kind: "grayscale", value: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<GrayscaleFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find grayscale() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "grayscale");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`grayscale() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("grayscale() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - grayscale bounded 0-100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (0 to 1)
	if (value < 0 || value > 1) {
		return err(`grayscale() value must be between 0 and 1, got ${value}`);
	}

	return ok({ kind: "grayscale", value });
}


=== File: src/parse/filter/hue-rotate.test.ts ===
// b_path:: src/parse/filter/hue-rotate.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./hue-rotate";

describe("parse hue-rotate filter", () => {
	it("parses hue-rotate with deg value", () => {
		const result = parse("hue-rotate(90deg)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("hue-rotate");
			expect(result.value.angle).toEqual({ value: 90, unit: "deg" });
		}
	});

	it("parses hue-rotate with turn value", () => {
		const result = parse("hue-rotate(0.5turn)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.angle).toEqual({ value: 0.5, unit: "turn" });
		}
	});

	it("parses hue-rotate with rad value", () => {
		const result = parse("hue-rotate(1.57rad)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.angle).toEqual({ value: 1.57, unit: "rad" });
		}
	});

	it("parses hue-rotate with grad value", () => {
		const result = parse("hue-rotate(100grad)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.angle).toEqual({ value: 100, unit: "grad" });
		}
	});

	it("parses negative angle", () => {
		const result = parse("hue-rotate(-90deg)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.angle).toEqual({ value: -90, unit: "deg" });
		}
	});

	it("parses zero angle", () => {
		const result = parse("hue-rotate(0deg)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.angle).toEqual({ value: 0, unit: "deg" });
		}
	});

	it("rejects no arguments", () => {
		const result = parse("hue-rotate()");
		expect(result.ok).toBe(false);
	});

	it("rejects multiple arguments", () => {
		const result = parse("hue-rotate(90deg, 180deg)");
		expect(result.ok).toBe(false);
	});

	it("rejects invalid unit", () => {
		const result = parse("hue-rotate(90px)");
		expect(result.ok).toBe(false);
	});

	it("rejects non-function input", () => {
		const result = parse("90deg");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/filter/hue-rotate.ts ===
// b_path:: src/parse/filter/hue-rotate.ts
import { err, ok, type Result } from "@/core/result";
import type { HueRotateFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS hue-rotate() filter function.
 *
 * Parses hue-rotate filter with angle value (deg, grad, rad, turn).
 * Value: Angle dimension representing hue rotation.
 * Any angle value is allowed (positive or negative).
 *
 * @param input - CSS string like "hue-rotate(90deg)" or "hue-rotate(0.5turn)"
 * @returns Result with HueRotateFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/hue-rotate";
 *
 * const result = parse("hue-rotate(90deg)");
 * // { ok: true, value: { kind: "hue-rotate", angle: { value: 90, unit: "deg" } } }
 *
 * const result2 = parse("hue-rotate(0.5turn)");
 * // { ok: true, value: { kind: "hue-rotate", angle: { value: 0.5, unit: "turn" } } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<HueRotateFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find hue-rotate() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "hue-rotate");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`hue-rotate() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("hue-rotate() expects 1 argument");
	}

	// Parse angle value
	const angleResult = ParseUtils.parseAngleNode(valueNode);
	if (!angleResult.ok) {
		return err(angleResult.error);
	}

	const angle = angleResult.value;

	return ok({ kind: "hue-rotate", angle });
}


=== File: src/parse/filter/index.ts ===
// b_path:: src/parse/filter/index.ts

/**
 * CSS filter parsers - convert filter strings to structured IR.
 *
 * All filter parsers return Result<T, string> for type-safe error handling.
 *
 * @module Parse.Filter
 * @public
 */

/**
 * Parse blur filter functions.
 *
 * @see {@link Blur.parse}
 */
export * as Blur from "./blur";
/**
 * Parse brightness filter functions.
 *
 * @see {@link Brightness.parse}
 */
export * as Brightness from "./brightness";
/**
 * Parse contrast filter functions.
 *
 * @see {@link Contrast.parse}
 */
export * as Contrast from "./contrast";
/**
 * Parse drop-shadow filter functions.
 *
 * @see {@link DropShadow.parse}
 */
export * as DropShadow from "./drop-shadow";
/**
 * Unified filter dispatcher with auto-detection.
 *
 * @see {@link module:Parse.Filter}
 */
export { parse } from "./filter";
/**
 * Parse grayscale filter functions.
 *
 * @see {@link Grayscale.parse}
 */
export * as Grayscale from "./grayscale";
/**
 * Parse hue-rotate filter functions.
 *
 * @see {@link HueRotate.parse}
 */
export * as HueRotate from "./hue-rotate";
/**
 * Parse invert filter functions.
 *
 * @see {@link Invert.parse}
 */
export * as Invert from "./invert";
/**
 * Parse opacity filter functions.
 *
 * @see {@link Opacity.parse}
 */
export * as Opacity from "./opacity";
/**
 * Parse saturate filter functions.
 *
 * @see {@link Saturate.parse}
 */
export * as Saturate from "./saturate";
/**
 * Parse sepia filter functions.
 *
 * @see {@link Sepia.parse}
 */
export * as Sepia from "./sepia";
/**
 * Parse URL filter functions.
 *
 * @see {@link Url.parse}
 */
export * as Url from "./url";


=== File: src/parse/filter/invert.ts ===
// b_path:: src/parse/filter/invert.ts
import { err, ok, type Result } from "@/core/result";
import type { InvertFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS invert() filter function.
 *
 * Parses invert filter with number or percentage value.
 * Number values: 0 to 1, where 1 = 100% invert
 * Percentage values: converted to decimal (50% → 0.5)
 * Value range: 0 to 1 (clamped)
 *
 * @param input - CSS string like "invert(0.5)" or "invert(50%)"
 * @returns Result with InvertFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/invert";
 *
 * const result = parse("invert(0.5)");
 * // { ok: true, value: { kind: "invert", value: 0.5 } }
 *
 * const result2 = parse("invert(50%)");
 * // { ok: true, value: { kind: "invert", value: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<InvertFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find invert() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "invert");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`invert() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("invert() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - invert bounded 0-100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (0 to 1)
	if (value < 0 || value > 1) {
		return err(`invert() value must be between 0 and 1, got ${value}`);
	}

	return ok({ kind: "invert", value });
}


=== File: src/parse/filter/opacity.ts ===
// b_path:: src/parse/filter/opacity.ts
import { err, ok, type Result } from "@/core/result";
import type { OpacityFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS opacity() filter function.
 *
 * Parses opacity filter with number or percentage value.
 * Number values: 0 to 1, where 1 = 100% opacity
 * Percentage values: converted to decimal (50% → 0.5)
 * Value range: 0 to 1 (clamped)
 *
 * @param input - CSS string like "opacity(0.5)" or "opacity(50%)"
 * @returns Result with OpacityFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/opacity}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/opacity";
 *
 * const result = parse("opacity(0.5)");
 * // { ok: true, value: { kind: "opacity", value: 0.5 } }
 *
 * const result2 = parse("opacity(50%)");
 * // { ok: true, value: { kind: "opacity", value: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<OpacityFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find opacity() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "opacity");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`opacity() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("opacity() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - opacity bounded 0-100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (0 to 1)
	if (value < 0 || value > 1) {
		return err(`opacity() value must be between 0 and 1, got ${value}`);
	}

	return ok({ kind: "opacity", value });
}


=== File: src/parse/filter/saturate.ts ===
// b_path:: src/parse/filter/saturate.ts
import { err, ok, type Result } from "@/core/result";
import type { SaturateFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS saturate() filter function.
 *
 * Parses saturate filter with number or percentage value.
 * Number values: 1 = 100% saturate (no change)
 * Percentage values: converted to decimal (150% → 1.5)
 * Value range: 0 to infinity (0 = completely black)
 *
 * @param input - CSS string like "saturate(1.5)" or "saturate(150%)"
 * @returns Result with SaturateFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/saturate";
 *
 * const result = parse("saturate(1.5)");
 * // { ok: true, value: { kind: "saturate", value: 1.5 } }
 *
 * const result2 = parse("saturate(150%)");
 * // { ok: true, value: { kind: "saturate", value: 1.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<SaturateFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find saturate() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "saturate");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`saturate() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("saturate() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - saturate allows > 100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		if (rawValue < 0) {
			return err(`saturate() value must be non-negative, got ${rawValue}%`);
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (non-negative)
	if (value < 0) {
		return err(`saturate() value must be non-negative, got ${value}`);
	}

	return ok({ kind: "saturate", value });
}


=== File: src/parse/filter/sepia.ts ===
// b_path:: src/parse/filter/sepia.ts
import { err, ok, type Result } from "@/core/result";
import type { SepiaFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS sepia() filter function.
 *
 * Parses sepia filter with number or percentage value.
 * Number values: 0 to 1, where 1 = 100% sepia
 * Percentage values: converted to decimal (50% → 0.5)
 * Value range: 0 to 1 (clamped)
 *
 * @param input - CSS string like "sepia(0.5)" or "sepia(50%)"
 * @returns Result with SepiaFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/sepia";
 *
 * const result = parse("sepia(0.5)");
 * // { ok: true, value: { kind: "sepia", value: 0.5 } }
 *
 * const result2 = parse("sepia(50%)");
 * // { ok: true, value: { kind: "sepia", value: 0.5 } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<SepiaFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find sepia() function
	const funcResult = ASTUtils.findFunctionNode(astResult.value, "sepia");
	if (!funcResult.ok) {
		return err(funcResult.error);
	}

	const fn = funcResult.value;

	// Get function arguments
	const children = ASTUtils.parseFunctionArguments(fn);

	// Expect exactly one argument
	if (children.length !== 1) {
		return err(`sepia() expects 1 argument, got ${children.length}`);
	}

	const valueNode = children[0];
	if (!valueNode) {
		return err("sepia() expects 1 argument");
	}

	// Parse number or percentage
	let value: number;

	if (valueNode.type === "Percentage") {
		// Parse percentage value - sepia bounded 0-100%
		const rawValue = Number.parseFloat(valueNode.value);
		if (Number.isNaN(rawValue)) {
			return err("Invalid percentage value");
		}
		value = rawValue / 100; // Convert to decimal
	} else if (valueNode.type === "Number") {
		const numberResult = ParseUtils.parseNumberNode(valueNode);
		if (!numberResult.ok) {
			return err(numberResult.error);
		}
		value = numberResult.value;
	} else {
		return err(`Expected number or percentage, got ${valueNode.type}`);
	}

	// Validate range (0 to 1)
	if (value < 0 || value > 1) {
		return err(`sepia() value must be between 0 and 1, got ${value}`);
	}

	return ok({ kind: "sepia", value });
}


=== File: src/parse/filter/url.test.ts ===
// b_path:: src/parse/filter/url.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./url";

describe("parse filter url", () => {
	it("parses url with fragment identifier", () => {
		const result = parse("url(#filter-id)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({
				kind: "url",
				url: "#filter-id",
			});
		}
	});

	it("parses url with file path", () => {
		const result = parse("url(filters.svg#blur)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.url).toBe("filters.svg#blur");
		}
	});

	it("parses url with single quotes", () => {
		const result = parse("url('path/to/filter.svg')");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.url).toBe("path/to/filter.svg");
		}
	});

	it("parses url with double quotes", () => {
		const result = parse('url("path/to/filter.svg")');
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.url).toBe("path/to/filter.svg");
		}
	});

	it("parses simple fragment", () => {
		const result = parse("url(#glow)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.url).toBe("#glow");
		}
	});

	it("rejects missing url()", () => {
		const result = parse("not-a-url");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Expected url() function");
		}
	});

	it("rejects empty url", () => {
		const result = parse("url()");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/filter/url.ts ===
// b_path:: src/parse/filter/url.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { UrlFilter } from "@/core/types/filter";
import * as ASTUtils from "@/utils/ast";

/**
 * Parse CSS url() filter function.
 *
 * Parses url filter for SVG filter references.
 * Accepts fragment identifiers (#id) or file paths.
 * Supports quoted and unquoted URLs.
 *
 * @param input - CSS string like "url(#filter)" or "url('path/to/filter.svg')"
 * @returns Result with UrlFilter IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/url}
 *
 * @example
 * ```typescript
 * import { parse } from "@/parse/filter/url";
 *
 * const result = parse("url(#filter-id)");
 * // { ok: true, value: { kind: "url", url: "#filter-id" } }
 *
 * const result2 = parse("url('path/to/filter.svg')");
 * // { ok: true, value: { kind: "url", url: "path/to/filter.svg" } }
 * ```
 *
 * @public
 */
export function parse(input: string): Result<UrlFilter, string> {
	// Parse CSS string to AST
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	// Find url() in the AST
	// url() is represented as a Url node, not a Function node
	const ast = astResult.value;
	let foundUrl = "";

	// Walk the AST to find Url node
	csstree.walk(ast, {
		visit: "Url",
		enter(node: csstree.Url) {
			foundUrl = node.value;
			return false; // Stop walking once found
		},
	});

	if (foundUrl === "") {
		return err("Expected url() function");
	}

	return ok({ kind: "url", url: foundUrl });
}


=== File: src/parse/flexbox/align-content.failure.test.ts ===
// b_path:: src/parse/flexbox/align-content.failure.test.ts
// Auto-generated from scripts/test-generator/configs/align-content.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/align-content";

describe("parse/flexbox/align-content - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("center stretch");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/flexbox/align-content.test.ts ===
// b_path:: src/parse/flexbox/align-content.test.ts
// Auto-generated from scripts/parse-test-generator/configs/flexbox/align-content.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/align-content";

describe("parse/flexbox/align-content - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse flex-start keyword", () => {
			const result = Parser.parse("flex-start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-content",
				value: "flex-start",
			});
		});

		it("should parse flex-end keyword", () => {
			const result = Parser.parse("flex-end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-content",
				value: "flex-end",
			});
		});

		it("should parse center keyword", () => {
			const result = Parser.parse("center");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-content",
				value: "center",
			});
		});

		it("should parse space-between keyword", () => {
			const result = Parser.parse("space-between");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-content",
				value: "space-between",
			});
		});

		it("should parse space-around keyword", () => {
			const result = Parser.parse("space-around");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-content",
				value: "space-around",
			});
		});

		it("should parse stretch keyword", () => {
			const result = Parser.parse("stretch");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-content",
				value: "stretch",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase center", () => {
			const result = Parser.parse("CENTER");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-content",
				value: "center",
			});
		});
	});
});


=== File: src/parse/flexbox/align-content.ts ===
// b_path:: src/parse/flexbox/align-content.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

const VALID_VALUES = [
	"flex-start",
	"flex-end",
	"center",
	"space-between",
	"space-around",
	"space-evenly",
	"stretch",
	"start",
	"end",
] as const;

export function parse(css: string): Result<Type.AlignContent, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node || node.type !== "Identifier") return err("Expected identifier");
		const value = node.name.toLowerCase();
		if (VALID_VALUES.some((v) => v === value)) {
			return ok({ kind: "align-content", value: value as Type.AlignContent["value"] });
		}
		return err(`Invalid align-content value: ${value}`);
	} catch (error) {
		return err(`Failed to parse align-content: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/align-items.failure.test.ts ===
// b_path:: src/parse/flexbox/align-items.failure.test.ts
// Auto-generated from scripts/test-generator/configs/align-items.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/align-items";

describe("parse/flexbox/align-items - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("middle");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid align-items value: middle");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("center baseline");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/flexbox/align-items.test.ts ===
// b_path:: src/parse/flexbox/align-items.test.ts
// Auto-generated from scripts/parse-test-generator/configs/flexbox/align-items.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/align-items";

describe("parse/flexbox/align-items - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse flex-start keyword", () => {
			const result = Parser.parse("flex-start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-items",
				value: "flex-start",
			});
		});

		it("should parse flex-end keyword", () => {
			const result = Parser.parse("flex-end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-items",
				value: "flex-end",
			});
		});

		it("should parse center keyword", () => {
			const result = Parser.parse("center");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-items",
				value: "center",
			});
		});

		it("should parse baseline keyword", () => {
			const result = Parser.parse("baseline");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-items",
				value: "baseline",
			});
		});

		it("should parse stretch keyword", () => {
			const result = Parser.parse("stretch");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-items",
				value: "stretch",
			});
		});
	});

	describe("valid-logical", () => {
		it("should parse start keyword", () => {
			const result = Parser.parse("start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-items",
				value: "start",
			});
		});

		it("should parse end keyword", () => {
			const result = Parser.parse("end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-items",
				value: "end",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase center", () => {
			const result = Parser.parse("CENTER");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-items",
				value: "center",
			});
		});
	});
});


=== File: src/parse/flexbox/align-items.ts ===
// b_path:: src/parse/flexbox/align-items.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

const VALID_VALUES = [
	"flex-start",
	"flex-end",
	"center",
	"baseline",
	"stretch",
	"start",
	"end",
	"self-start",
	"self-end",
] as const;

export function parse(css: string): Result<Type.AlignItems, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node || node.type !== "Identifier") return err("Expected identifier");
		const value = node.name.toLowerCase();
		if (VALID_VALUES.some((v) => v === value)) {
			return ok({ kind: "align-items", value: value as Type.AlignItems["value"] });
		}
		return err(`Invalid align-items value: ${value}`);
	} catch (error) {
		return err(`Failed to parse align-items: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/align-self.failure.test.ts ===
// b_path:: src/parse/flexbox/align-self.failure.test.ts
// Auto-generated from scripts/test-generator/configs/align-self.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/align-self";

describe("parse/flexbox/align-self - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("center stretch");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/flexbox/align-self.test.ts ===
// b_path:: src/parse/flexbox/align-self.test.ts
// Auto-generated from scripts/parse-test-generator/configs/flexbox/align-self.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/align-self";

describe("parse/flexbox/align-self - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse auto keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-self",
				value: "auto",
			});
		});

		it("should parse flex-start keyword", () => {
			const result = Parser.parse("flex-start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-self",
				value: "flex-start",
			});
		});

		it("should parse flex-end keyword", () => {
			const result = Parser.parse("flex-end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-self",
				value: "flex-end",
			});
		});

		it("should parse center keyword", () => {
			const result = Parser.parse("center");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-self",
				value: "center",
			});
		});

		it("should parse baseline keyword", () => {
			const result = Parser.parse("baseline");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-self",
				value: "baseline",
			});
		});

		it("should parse stretch keyword", () => {
			const result = Parser.parse("stretch");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-self",
				value: "stretch",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase center", () => {
			const result = Parser.parse("CENTER");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "align-self",
				value: "center",
			});
		});
	});
});


=== File: src/parse/flexbox/align-self.ts ===
// b_path:: src/parse/flexbox/align-self.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

const VALID_VALUES = [
	"auto",
	"flex-start",
	"flex-end",
	"center",
	"baseline",
	"stretch",
	"start",
	"end",
	"self-start",
	"self-end",
] as const;

export function parse(css: string): Result<Type.AlignSelf, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node || node.type !== "Identifier") return err("Expected identifier");
		const value = node.name.toLowerCase();
		if (VALID_VALUES.some((v) => v === value)) {
			return ok({ kind: "align-self", value: value as Type.AlignSelf["value"] });
		}
		return err(`Invalid align-self value: ${value}`);
	} catch (error) {
		return err(`Failed to parse align-self: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/flex-basis.test.ts ===
// b_path:: src/parse/flexbox/flex-basis.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./flex-basis";

describe("parse flex-basis", () => {
	it("should parse pixel values", () => {
		const result = parse("200px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("flex-basis");
			expect(result.value.value).toEqual({ value: 200, unit: "px" });
		}
	});

	it("should parse percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("should parse auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("auto");
		}
	});

	it("should parse content keyword", () => {
		const result = parse("content");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("content");
		}
	});

	it("should parse max-content keyword", () => {
		const result = parse("max-content");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("max-content");
		}
	});

	it("should parse unitless zero", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});
});


=== File: src/parse/flexbox/flex-basis.ts ===
// b_path:: src/parse/flexbox/flex-basis.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

export function parse(css: string): Result<Type.FlexBasis, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node) return err("Expected flex-basis value");

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (
				keyword === "auto" ||
				keyword === "content" ||
				keyword === "max-content" ||
				keyword === "min-content" ||
				keyword === "fit-content"
			) {
				return ok({ kind: "flex-basis", value: keyword });
			}
			return err(`Invalid flex-basis keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) return ok({ kind: "flex-basis", value: { value: 0, unit: "px" } });
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) return err(lengthResult.error);
		return ok({ kind: "flex-basis", value: lengthResult.value });
	} catch (error) {
		return err(`Failed to parse flex-basis: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/flex-direction.failure.test.ts ===
// b_path:: src/parse/flexbox/flex-direction.failure.test.ts
// Auto-generated from scripts/test-generator/configs/flex-direction.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/flex-direction";

describe("parse/flexbox/flex-direction - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("horizontal");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid flex-direction value: horizontal");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("row column");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/flexbox/flex-direction.test.ts ===
// b_path:: src/parse/flexbox/flex-direction.test.ts
// Auto-generated from scripts/parse-test-generator/configs/flexbox/flex-direction.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/flex-direction";

describe("parse/flexbox/flex-direction - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse row keyword", () => {
			const result = Parser.parse("row");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-direction",
				value: "row",
			});
		});

		it("should parse row-reverse keyword", () => {
			const result = Parser.parse("row-reverse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-direction",
				value: "row-reverse",
			});
		});

		it("should parse column keyword", () => {
			const result = Parser.parse("column");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-direction",
				value: "column",
			});
		});

		it("should parse column-reverse keyword", () => {
			const result = Parser.parse("column-reverse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-direction",
				value: "column-reverse",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase row", () => {
			const result = Parser.parse("ROW");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-direction",
				value: "row",
			});
		});
	});
});


=== File: src/parse/flexbox/flex-direction.ts ===
// b_path:: src/parse/flexbox/flex-direction.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS flex-direction property value.
 *
 * @param css - CSS flex-direction value
 * @returns Result with FlexDirection IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction}
 */
export function parse(css: string): Result<Type.FlexDirection, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err("Expected identifier");
		}

		const value = node.name.toLowerCase();

		if (value === "row" || value === "row-reverse" || value === "column" || value === "column-reverse") {
			return ok({
				kind: "flex-direction",
				value,
			});
		}

		return err(`Invalid flex-direction value: ${value}`);
	} catch (error) {
		return err(`Failed to parse flex-direction: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/flex-grow.test.ts ===
// b_path:: src/parse/flexbox/flex-grow.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./flex-grow";

describe("parse flex-grow", () => {
	it("should parse 0", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("flex-grow");
			expect(result.value.value).toBe(0);
		}
	});

	it("should parse 1", () => {
		const result = parse("1");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(1);
		}
	});

	it("should parse decimal values", () => {
		const result = parse("0.5");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(0.5);
		}
	});

	it("should reject negative values", () => {
		expect(parse("-1").ok).toBe(false);
	});

	it("should reject non-numeric values", () => {
		expect(parse("auto").ok).toBe(false);
	});
});


=== File: src/parse/flexbox/flex-grow.ts ===
// b_path:: src/parse/flexbox/flex-grow.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

export function parse(css: string): Result<Type.FlexGrow, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node || node.type !== "Number") return err("Expected number");
		const value = Number.parseFloat(node.value);
		if (value < 0) return err("flex-grow must be non-negative");
		return ok({ kind: "flex-grow", value });
	} catch (error) {
		return err(`Failed to parse flex-grow: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/flex-shrink.test.ts ===
// b_path:: src/parse/flexbox/flex-shrink.test.ts

import { describe, expect, it } from "vitest";
import * as FlexShrink from "./flex-shrink";

describe("parse/flexbox/flex-shrink", () => {
	describe("valid values", () => {
		it("parses 0", () => {
			const result = FlexShrink.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ kind: "flex-shrink", value: 0 });
			}
		});

		it("parses 1", () => {
			const result = FlexShrink.parse("1");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ kind: "flex-shrink", value: 1 });
			}
		});

		it("parses decimal value", () => {
			const result = FlexShrink.parse("0.5");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ kind: "flex-shrink", value: 0.5 });
			}
		});

		it("parses large value", () => {
			const result = FlexShrink.parse("10");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ kind: "flex-shrink", value: 10 });
			}
		});
	});

	describe("invalid values", () => {
		it("rejects negative value", () => {
			const result = FlexShrink.parse("-1");
			expect(result.ok).toBe(false);
		});

		it("rejects keyword", () => {
			const result = FlexShrink.parse("auto");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = FlexShrink.parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/flexbox/flex-shrink.ts ===
// b_path:: src/parse/flexbox/flex-shrink.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

export function parse(css: string): Result<Type.FlexShrink, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node || node.type !== "Number") return err("Expected number");
		const value = Number.parseFloat(node.value);
		if (value < 0) return err("flex-shrink must be non-negative");
		return ok({ kind: "flex-shrink", value });
	} catch (error) {
		return err(`Failed to parse flex-shrink: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/flex-wrap.failure.test.ts ===
// b_path:: src/parse/flexbox/flex-wrap.failure.test.ts
// Auto-generated from scripts/test-generator/configs/flex-wrap.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/flex-wrap";

describe("parse/flexbox/flex-wrap - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid flex-wrap value: none");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("wrap nowrap");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/flexbox/flex-wrap.test.ts ===
// b_path:: src/parse/flexbox/flex-wrap.test.ts
// Auto-generated from scripts/parse-test-generator/configs/flexbox/flex-wrap.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/flex-wrap";

describe("parse/flexbox/flex-wrap - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse nowrap keyword", () => {
			const result = Parser.parse("nowrap");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-wrap",
				value: "nowrap",
			});
		});

		it("should parse wrap keyword", () => {
			const result = Parser.parse("wrap");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-wrap",
				value: "wrap",
			});
		});

		it("should parse wrap-reverse keyword", () => {
			const result = Parser.parse("wrap-reverse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-wrap",
				value: "wrap-reverse",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase wrap", () => {
			const result = Parser.parse("WRAP");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "flex-wrap",
				value: "wrap",
			});
		});
	});
});


=== File: src/parse/flexbox/flex-wrap.ts ===
// b_path:: src/parse/flexbox/flex-wrap.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

export function parse(css: string): Result<Type.FlexWrap, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node || node.type !== "Identifier") return err("Expected identifier");
		const value = node.name.toLowerCase();
		if (value === "nowrap" || value === "wrap" || value === "wrap-reverse") {
			return ok({ kind: "flex-wrap", value });
		}
		return err(`Invalid flex-wrap value: ${value}`);
	} catch (error) {
		return err(`Failed to parse flex-wrap: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/gap.test.ts ===
// b_path:: src/parse/flexbox/gap.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./gap";

describe("parse gap", () => {
	it("parses 'normal' keyword", () => {
		const result = parse("normal");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "gap", value: "normal" });
		}
	});

	it("parses 'auto' keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "gap", value: "auto" });
		}
	});

	it("parses zero without unit", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "gap", value: { value: 0, unit: "px" } });
		}
	});

	it("parses pixel length", () => {
		const result = parse("10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "gap", value: { value: 10, unit: "px" } });
		}
	});

	it("parses em length", () => {
		const result = parse("1.5em");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "gap", value: { value: 1.5, unit: "em" } });
		}
	});

	it("parses rem length", () => {
		const result = parse("2rem");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "gap", value: { value: 2, unit: "rem" } });
		}
	});

	it("parses percentage", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "gap", value: { value: 50, unit: "%" } });
		}
	});

	it("rejects number without unit", () => {
		const result = parse("10");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("require a unit");
		}
	});

	it("rejects invalid keyword", () => {
		const result = parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects multiple values", () => {
		const result = parse("10px 20px");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Expected single value");
		}
	});

	it("parses negative values", () => {
		const result = parse("-10px");
		// CSS allows negative gap in some contexts
		expect(result).toBeDefined();
	});
});


=== File: src/parse/flexbox/gap.ts ===
// b_path:: src/parse/flexbox/gap.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

export function parse(css: string): Result<Type.Gap, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node) return err("Expected gap value");

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword === "normal" || keyword === "auto") {
				return ok({ kind: "gap", value: keyword });
			}
			return err(`Invalid gap keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) return ok({ kind: "gap", value: { value: 0, unit: "px" } });
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) return err(lengthResult.error);
		return ok({ kind: "gap", value: lengthResult.value });
	} catch (error) {
		return err(`Failed to parse gap: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/index.ts ===
// b_path:: src/parse/flexbox/index.ts

export * as AlignContent from "./align-content";
export * as AlignItems from "./align-items";
export * as AlignSelf from "./align-self";
export * as FlexBasis from "./flex-basis";
export * as FlexDirection from "./flex-direction";
export * as FlexGrow from "./flex-grow";
export * as FlexShrink from "./flex-shrink";
export * as FlexWrap from "./flex-wrap";
export * as Gap from "./gap";
export * as JustifyContent from "./justify-content";
export * as Order from "./order";


=== File: src/parse/flexbox/justify-content.failure.test.ts ===
// b_path:: src/parse/flexbox/justify-content.failure.test.ts
// Auto-generated from scripts/test-generator/configs/justify-content.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/justify-content";

describe("parse/flexbox/justify-content - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("middle");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid justify-content value: middle");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected identifier");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("center flex-start");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/flexbox/justify-content.test.ts ===
// b_path:: src/parse/flexbox/justify-content.test.ts
// Auto-generated from scripts/parse-test-generator/configs/flexbox/justify-content.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/flexbox/justify-content";

describe("parse/flexbox/justify-content - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse flex-start keyword", () => {
			const result = Parser.parse("flex-start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "flex-start",
			});
		});

		it("should parse flex-end keyword", () => {
			const result = Parser.parse("flex-end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "flex-end",
			});
		});

		it("should parse center keyword", () => {
			const result = Parser.parse("center");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "center",
			});
		});

		it("should parse space-between keyword", () => {
			const result = Parser.parse("space-between");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "space-between",
			});
		});

		it("should parse space-around keyword", () => {
			const result = Parser.parse("space-around");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "space-around",
			});
		});

		it("should parse space-evenly keyword", () => {
			const result = Parser.parse("space-evenly");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "space-evenly",
			});
		});
	});

	describe("valid-logical", () => {
		it("should parse start keyword", () => {
			const result = Parser.parse("start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "start",
			});
		});

		it("should parse end keyword", () => {
			const result = Parser.parse("end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "end",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase center", () => {
			const result = Parser.parse("CENTER");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "justify-content",
				value: "center",
			});
		});
	});
});


=== File: src/parse/flexbox/justify-content.ts ===
// b_path:: src/parse/flexbox/justify-content.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

const VALID_VALUES = [
	"flex-start",
	"flex-end",
	"center",
	"space-between",
	"space-around",
	"space-evenly",
	"start",
	"end",
	"left",
	"right",
] as const;

export function parse(css: string): Result<Type.JustifyContent, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node || node.type !== "Identifier") return err("Expected identifier");
		const value = node.name.toLowerCase();
		if (VALID_VALUES.some((v) => v === value)) {
			return ok({ kind: "justify-content", value: value as Type.JustifyContent["value"] });
		}
		return err(`Invalid justify-content value: ${value}`);
	} catch (error) {
		return err(`Failed to parse justify-content: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/flexbox/order.test.ts ===
// b_path:: src/parse/flexbox/order.test.ts

import { describe, expect, it } from "vitest";
import * as Order from "./order";

describe("parse/flexbox/order", () => {
	describe("valid values", () => {
		it("parses 0", () => {
			const result = Order.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ kind: "order", value: 0 });
			}
		});

		it("parses positive integer", () => {
			const result = Order.parse("5");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ kind: "order", value: 5 });
			}
		});

		it("parses negative integer", () => {
			const result = Order.parse("-1");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ kind: "order", value: -1 });
			}
		});

		it("parses large integer", () => {
			const result = Order.parse("100");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({ kind: "order", value: 100 });
			}
		});
	});

	describe("invalid values", () => {
		it("rejects keyword", () => {
			const result = Order.parse("auto");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = Order.parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/flexbox/order.ts ===
// b_path:: src/parse/flexbox/order.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

export function parse(css: string): Result<Type.Order, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });
		if (ast.type !== "Value") return err("Expected Value node");
		const children = ast.children.toArray();
		if (children.length !== 1) return err(`Expected single value, got ${children.length} values`);
		const node = children[0];
		if (!node || node.type !== "Number") return err("Expected integer");
		const value = Number.parseInt(node.value, 10);
		if (!Number.isInteger(value)) return err("order must be an integer");
		return ok({ kind: "order", value });
	} catch (error) {
		return err(`Failed to parse order: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/gradient/color-stop.test.ts ===
// b_path:: src/parse/gradient/color-stop.test.ts

import { describe, expect, it } from "vitest";
import { fromNodes } from "./color-stop";

describe("Color Stop Parser", () => {
	it("should handle empty nodes array", () => {
		const result = fromNodes([]);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("requires at least a color value");
		}
	});

	it("should parse color-only stop", () => {
		// This would be tested through integration, but we need direct unit tests
		// for coverage of error paths
		const result = fromNodes([]);
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/gradient/color-stop.ts ===
// b_path:: src/parse/gradient/color-stop.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseNode as parseColorNode } from "@/parse/color";

/**
 * Parse color stop from CSS AST nodes.
 *
 * A color stop consists of a color value and an optional position.
 * Per CSS spec: <color-stop> = <color> [ <length-percentage> ]?
 *
 * @param nodes - Array of CSS AST nodes (color and optional position)
 * @returns Result containing ColorStop IR or error message
 *
 * @example
 * ```typescript
 * // Color only: red
 * const result1 = fromNodes([colorNode]);
 *
 * // Color with percentage: red 50%
 * const result2 = fromNodes([colorNode, percentageNode]);
 *
 * // Color with length: blue 100px
 * const result3 = fromNodes([colorNode, lengthNode]);
 * ```
 *
 * @internal
 */
export function fromNodes(nodes: csstree.CssNode[]): Result<Type.ColorStop, string> {
	if (nodes.length === 0) {
		return err("Color stop requires at least a color value");
	}

	const firstNode = nodes[0];
	if (!firstNode) {
		return err("Color stop requires at least a color value");
	}

	// Extract and parse color value
	// Parse color directly from AST node (efficient - no string round-trip)
	const colorResult = parseColorNode(firstNode);
	if (!colorResult.ok) {
		return err(`Invalid color value: ${colorResult.error}`);
	}
	const color = colorResult.value;

	// Check for optional position (second node)
	if (nodes.length >= 2) {
		const posNode = nodes[1];
		if (!posNode) {
			return ok({ color });
		}

		// Parse position as length or percentage
		if (posNode.type === "Percentage") {
			const value = Number.parseFloat(posNode.value);
			return ok({
				color,
				position: { value, unit: "%" },
			});
		}

		if (posNode.type === "Dimension") {
			const value = Number.parseFloat(posNode.value);
			const unit = posNode.unit.toLowerCase();
			// Type assertion needed for unit validation
			return ok({
				color,
				position: { value, unit } as Type.LengthPercentage,
			});
		}

		return err(`Invalid position type: ${posNode.type}`);
	}

	// Color only
	return ok({ color });
}


=== File: src/parse/gradient/conic.parse.test.ts ===
// b_path:: src/parse/gradient/conic.parse.test.ts

import { describe, expect, it } from "vitest";
import * as ConicParser from "./conic";

describe("Conic Gradient Parser", () => {
	it("should parse simple conic gradient", () => {
		const css = "conic-gradient(red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("conic");
			expect(result.value.repeating).toBe(false);
			expect(result.value.colorStops).toHaveLength(2);
			expect(result.value.colorStops[0]?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "blue" });
		}
	});

	it("should parse conic gradient with starting angle", () => {
		const css = "conic-gradient(from 45deg, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 45,
				unit: "deg",
			});
		}
	});

	it("should parse conic gradient with position", () => {
		const css = "conic-gradient(at center, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "center",
				vertical: "center",
			});
		}
	});

	it("should parse conic gradient with position keywords", () => {
		const css = "conic-gradient(at left top, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "left",
				vertical: "top",
			});
		}
	});

	it("should parse conic gradient with percentage position", () => {
		const css = "conic-gradient(at 50% 75%, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: { value: 50, unit: "%" },
				vertical: { value: 75, unit: "%" },
			});
		}
	});

	it("should parse conic gradient with both angle and position", () => {
		const css = "conic-gradient(from 90deg at 50% 50%, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 90,
				unit: "deg",
			});
			expect(result.value.position).toEqual({
				horizontal: { value: 50, unit: "%" },
				vertical: { value: 50, unit: "%" },
			});
		}
	});

	it("should parse conic gradient with turn unit", () => {
		const css = "conic-gradient(from 0.25turn, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 0.25,
				unit: "turn",
			});
		}
	});

	it("should parse conic gradient with rad unit", () => {
		const css = "conic-gradient(from 1.57rad, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 1.57,
				unit: "rad",
			});
		}
	});

	it("should parse conic gradient with color stops having angle positions", () => {
		const css = "conic-gradient(red 0deg, blue 180deg)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 0,
				unit: "deg",
			});
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 180,
				unit: "deg",
			});
		}
	});

	it("should parse conic gradient with color interpolation", () => {
		const css = "conic-gradient(in oklch, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse conic gradient with angle and color interpolation", () => {
		const css = "conic-gradient(from 45deg in oklch, red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 45,
				unit: "deg",
			});
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse repeating conic gradient", () => {
		const css = "repeating-conic-gradient(red, blue 45deg)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.repeating).toBe(true);
		}
	});

	it("should parse complex conic gradient", () => {
		const css = "conic-gradient(from 90deg at 30% 30%, red 0deg, yellow 120deg, blue 240deg)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.fromAngle).toEqual({
				value: 90,
				unit: "deg",
			});
			expect(result.value.position).toEqual({
				horizontal: { value: 30, unit: "%" },
				vertical: { value: 30, unit: "%" },
			});
			expect(result.value.colorStops).toHaveLength(3);
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "yellow" });
		}
	});

	it("should handle conic gradient with multiple color stops", () => {
		const css = "conic-gradient(red, orange, yellow, green, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(5);
		}
	});

	it("should parse conic gradient with percentage color stop positions", () => {
		const css = "conic-gradient(red 0%, blue 100%)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 0,
				unit: "%",
			});
		}
	});

	it("should return error for invalid function name", () => {
		const css = "linear-gradient(red, blue)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("No conic-gradient function found");
		}
	});

	it("should return error for insufficient color stops", () => {
		const css = "conic-gradient(red)";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});

	it("should return error for invalid CSS syntax", () => {
		const css = "not valid css";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should return error for empty function", () => {
		const css = "conic-gradient()";
		const result = ConicParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});
});


=== File: src/parse/gradient/conic.ts ===
// b_path:: src/parse/gradient/conic.ts
import * as csstree from "css-tree";
import type * as Keyword from "@/core/keywords";
import { COLOR_INTERPOLATION_KEYWORDS } from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import * as ColorStop from "./color-stop";

/**
 * Parse starting angle from nodes (from keyword followed by angle value).
 *
 * Syntax: from <angle>
 * Example: from 45deg, from 0.5turn, from 1rad
 *
 * @param nodes - Array of CSS nodes starting with "from" keyword
 * @param startIdx - Index to start parsing from
 * @returns Result with Angle and next index, or error
 *
 * @internal
 */
function parseFromAngle(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ angle: Type.Angle; nextIdx: number }, string> {
	let idx = startIdx;

	// Should start with "from" keyword
	const fromNode = nodes[idx];
	if (!fromNode || fromNode.type !== "Identifier" || fromNode.name.toLowerCase() !== "from") {
		return err("Expected 'from' keyword for starting angle");
	}
	idx++;

	// Parse angle value
	const angleNode = nodes[idx];
	if (!angleNode || angleNode.type !== "Dimension") {
		return err("Expected angle value after 'from'");
	}

	if (!["deg", "rad", "grad", "turn"].includes(angleNode.unit)) {
		return err(`Invalid angle unit: ${angleNode.unit}`);
	}

	const angle: Type.Angle = {
		value: Number.parseFloat(angleNode.value),
		unit: angleNode.unit as "deg" | "rad" | "grad" | "turn",
	};

	return ok({ angle, nextIdx: idx + 1 });
}

/**
 * Parse position from nodes (at keyword followed by position values).
 *
 * Syntax: at <position>
 * Example: at center, at left top, at 50% 50%, at 100px 200px
 *
 * @param nodes - Array of CSS nodes starting with "at" keyword
 * @param startIdx - Index to start parsing from
 * @returns Result with Position2D and next index, or error
 *
 * @internal
 */
function parsePosition(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Should start with "at" keyword
	const atNode = nodes[idx];
	if (!atNode || atNode.type !== "Identifier" || atNode.name.toLowerCase() !== "at") {
		return err("Expected 'at' keyword for position");
	}
	idx++;

	// Parse position values (1 or 2 values: horizontal and vertical)
	const positionValues: Type.PositionValue[] = [];

	// Collect position value nodes until we hit comma or end
	while (idx < nodes.length) {
		const node = nodes[idx];
		if (!node) break;

		if (node.type === "Operator" && "value" in node && node.value === ",") {
			break;
		}

		if (node.type === "Identifier") {
			// Try parsing as position keyword using shared utility
			const positionResult = ParseUtils.parsePositionValueNode(node);
			if (positionResult.ok && typeof positionResult.value === "string") {
				positionValues.push(positionResult.value);
				idx++;
			} else {
				break;
			}
		} else {
			// Try parsing as length-percentage using shared utility
			const lengthResult = ParseUtils.parseLengthPercentageNode(node);
			if (lengthResult.ok) {
				positionValues.push(lengthResult.value);
				idx++;
			} else {
				break;
			}
		}
	}

	if (positionValues.length === 0) {
		return err("Expected position values after 'at'");
	}

	// Convert 1-2 values into Position2D
	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Invalid position value");
		}
		// Single value is treated as horizontal, vertical defaults to center
		if (typeof val === "string") {
			// Keyword: if it's top/bottom, it's vertical; otherwise horizontal
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		// Two values: horizontal then vertical
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Invalid position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse conic gradient from CSS function AST.
 *
 * Handles conic-gradient() and repeating-conic-gradient() functions.
 * Supports optional starting angle, position, color interpolation, and color stops.
 *
 * Syntax: conic-gradient([ from <angle> ]? [ at <position> ]? [, in <color-space>]?, <color-stop-list>)
 *
 * @param fn - CSS Function AST node
 * @returns Result containing ConicGradient IR or error message
 *
 * @example
 * ```typescript
 * // Parse: conic-gradient(red, blue)
 * // Parse: conic-gradient(from 45deg, red, blue)
 * // Parse: conic-gradient(at center, red, blue)
 * // Parse: conic-gradient(from 90deg at 50% 50%, red, blue)
 * // Parse: repeating-conic-gradient(red, blue 45deg)
 * ```
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode): Result<Type.ConicGradient, string> {
	const functionName = fn.name.toLowerCase();
	const isRepeating = functionName === "repeating-conic-gradient";

	if (!isRepeating && functionName !== "conic-gradient") {
		return err(`Expected conic-gradient or repeating-conic-gradient, got: ${functionName}`);
	}

	// Get all children nodes
	const children = fn.children.toArray();
	if (children.length === 0) {
		return err("conic-gradient requires at least 2 color stops");
	}

	let fromAngle: Type.Angle | undefined;
	let position: Type.Position2D | undefined;
	let colorSpace: Keyword.ColorInterpolationKeyword | undefined;

	let idx = 0;

	// Parse optional "from <angle>"
	const firstNode = children[idx];
	if (firstNode?.type === "Identifier" && firstNode.name.toLowerCase() === "from") {
		const angleResult = parseFromAngle(children, idx);
		if (angleResult.ok) {
			fromAngle = angleResult.value.angle;
			idx = angleResult.value.nextIdx;
		}
	}

	// Parse optional position: "at <position>"
	const atNode = children[idx];
	if (atNode?.type === "Identifier" && atNode.name.toLowerCase() === "at") {
		const posResult = parsePosition(children, idx);
		if (posResult.ok) {
			position = posResult.value.position;
			idx = posResult.value.nextIdx;
		}
	}

	// Skip comma after from/at if present
	const commaNode = children[idx];
	if (commaNode && commaNode.type === "Operator" && "value" in commaNode && commaNode.value === ",") {
		idx++;
	}

	// Parse optional color interpolation: "in <color-space>"
	if (idx < children.length) {
		const node = children[idx];
		if (node?.type === "Identifier" && node.name.toLowerCase() === "in") {
			idx++;
			const spaceNode = children[idx];
			if (spaceNode?.type === "Identifier") {
				const space = spaceNode.name.toLowerCase();
				// Validate against core color interpolation keywords
				if (COLOR_INTERPOLATION_KEYWORDS.includes(space as Keyword.ColorInterpolationKeyword)) {
					colorSpace = space as Keyword.ColorInterpolationKeyword;
					idx++;
				}
			}

			// Skip comma after color space if present
			const spaceCommaNode = children[idx];
			if (
				spaceCommaNode &&
				spaceCommaNode.type === "Operator" &&
				"value" in spaceCommaNode &&
				spaceCommaNode.value === ","
			) {
				idx++;
			}
		}
	}

	// Split remaining nodes into color stop groups
	const stopGroups = AstUtils.splitNodesByComma(children, { startIndex: idx });

	// Parse each color stop
	const colorStops: Type.ColorStop[] = [];
	for (const stopNodes of stopGroups) {
		const stopResult = ColorStop.fromNodes(stopNodes);
		if (stopResult.ok) {
			colorStops.push(stopResult.value);
		} else {
			return err(`Invalid color stop: ${stopResult.error}`);
		}
	}

	if (colorStops.length < 2) {
		return err("conic-gradient requires at least 2 color stops");
	}

	return ok({
		kind: "conic",
		fromAngle,
		position,
		colorSpace,
		colorStops,
		repeating: isRepeating,
	});
}

/**
 * Parse a CSS conic gradient value into structured intermediate representation (IR).
 *
 * Parses both `conic-gradient()` and `repeating-conic-gradient()` functions,
 * extracting starting angle, position, color interpolation, and color stops into a
 * type-safe IR object.
 *
 * Supports all CSS conic gradient syntax per CSS Images Module Level 4:
 * - Starting angle: `from <angle>` (default: 0deg from top)
 * - Position: `at <position>` syntax with keywords or length values
 * - Color interpolation: `in <color-space>` syntax
 * - Color stops: with optional angle positions
 *
 * @param css - CSS string containing a conic gradient function
 * @returns Result containing ConicGradient IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * Simple gradient (defaults to starting from top at center):
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Conic.parse("conic-gradient(red, blue)");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { kind: "conic", colorStops: [...], repeating: false }
 * }
 * ```
 *
 * @example
 * With starting angle:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "conic-gradient(from 45deg, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.fromAngle);
 *   // { value: 45, unit: "deg" }
 * }
 * ```
 *
 * @example
 * At specific position:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "conic-gradient(at left top, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.position);
 *   // { horizontal: "left", vertical: "top" }
 * }
 * ```
 *
 * @example
 * With both angle and position:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "conic-gradient(from 90deg at 50% 50%, red 0deg, blue 180deg)"
 * );
 * if (result.ok) {
 *   console.log(result.value.fromAngle); // { value: 90, unit: "deg" }
 *   console.log(result.value.position);  // { horizontal: {value: 50, unit: "%"}, ... }
 * }
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "conic-gradient(in oklch, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.colorSpace); // "oklch"
 * }
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse(
 *   "repeating-conic-gradient(red 0deg, blue 45deg)"
 * );
 * if (result.ok) {
 *   console.log(result.value.repeating); // true
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Gradient.Conic.parse("invalid syntax");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient | MDN: conic-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-4/#conic-gradients | W3C Spec: Conic Gradients}
 * @see {@link https://github.com/mdn/data/blob/main/css/functions.json | MDN Data: conic-gradient()}
 */
export function parse(css: string): Result<Type.ConicGradient, string> {
	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the function node
		let funcNode: csstree.FunctionNode | null = null;
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (node.name === "conic-gradient" || node.name === "repeating-conic-gradient") {
					funcNode = node;
				}
			},
		});

		if (!funcNode) {
			return err("No conic-gradient function found in CSS string");
		}

		return fromFunction(funcNode);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/gradient/gradient.test.ts ===
// b_path:: src/parse/gradient/gradient.test.ts

import { describe, expect, it } from "vitest";
import { parse } from "./gradient";

describe("parse() - unified gradient dispatcher", () => {
	describe("linear gradient", () => {
		it("detects linear-gradient()", () => {
			const result = parse("linear-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
				expect(result.value?.repeating).toBe(false);
			}
		});

		it("detects repeating-linear-gradient()", () => {
			const result = parse("repeating-linear-gradient(red 0%, blue 10%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
				expect(result.value?.repeating).toBe(true);
			}
		});
	});

	describe("radial gradient", () => {
		it("detects radial-gradient()", () => {
			const result = parse("radial-gradient(circle, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("radial");
				expect(result.value?.repeating).toBe(false);
			}
		});

		it("detects repeating-radial-gradient()", () => {
			const result = parse("repeating-radial-gradient(circle, red 0%, blue 10%)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("radial");
				expect(result.value?.repeating).toBe(true);
			}
		});
	});

	describe("conic gradient", () => {
		it("detects conic-gradient()", () => {
			const result = parse("conic-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("conic");
				expect(result.value?.repeating).toBe(false);
			}
		});

		it("detects repeating-conic-gradient()", () => {
			const result = parse("repeating-conic-gradient(red 0deg, blue 180deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("conic");
				expect(result.value?.repeating).toBe(true);
			}
		});
	});

	describe("with direction/position/angle", () => {
		it("handles linear gradient with angle", () => {
			const result = parse("linear-gradient(45deg, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
			}
		});

		it("handles linear gradient with to side", () => {
			const result = parse("linear-gradient(to right, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
			}
		});

		it("handles radial gradient with position", () => {
			const result = parse("radial-gradient(at center, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("radial");
			}
		});

		it("handles conic gradient with angle", () => {
			const result = parse("conic-gradient(from 45deg, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("conic");
			}
		});
	});

	describe("error handling", () => {
		it("rejects unknown gradient function", () => {
			const result = parse("unknown-gradient(red, blue)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("Unknown gradient function");
			}
		});

		it("rejects invalid syntax", () => {
			const result = parse("not-a-gradient");
			expect(result.ok).toBe(false);
		});

		it("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});

	describe("case insensitivity", () => {
		it("handles lowercase (standard)", () => {
			const result = parse("linear-gradient(red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("linear");
			}
		});

		it("handles radial gradient", () => {
			const result = parse("radial-gradient(circle, red, blue)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("radial");
			}
		});

		it("handles repeating variants", () => {
			const result = parse("repeating-conic-gradient(red 0deg, blue 180deg)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.kind).toBe("conic");
				expect(result.value?.repeating).toBe(true);
			}
		});
	});
});


=== File: src/parse/gradient/gradient.ts ===
// b_path:: src/parse/gradient/gradient.ts

import type { CssNode } from "css-tree";
import * as cssTree from "css-tree";
import { err, type ParseResult, parseErr, type Result, toParseResult } from "@/core/result";
import type * as Type from "@/core/types";
import * as Conic from "./conic";
import * as Linear from "./linear";
import * as Radial from "./radial";

/**
 * Parse gradient value with auto-detection.
 *
 * Automatically detects and parses any CSS gradient function:
 * - linear-gradient(), repeating-linear-gradient()
 * - radial-gradient(), repeating-radial-gradient()
 * - conic-gradient(), repeating-conic-gradient()
 *
 * @param value - CSS gradient value string
 * @returns Result with Gradient IR or error
 *
 * @example
 * ```typescript
 * parse("linear-gradient(red, blue)");
 * parse("radial-gradient(circle, red, blue)");
 * parse("conic-gradient(red, blue)");
 * parse("repeating-linear-gradient(red 0%, blue 10%)");
 * ```
 *
 * @public
 */
export function parse(value: string): ParseResult<Type.Gradient> {
	const ast = cssTree.parse(value, { context: "value" }) as cssTree.Value;
	if (!ast.children) return parseErr("invalid-syntax", "Empty value");
	const first = ast.children.first;
	if (!first) return parseErr("invalid-syntax", "Empty value");
	const result = parseNode(first);
	return toParseResult(result);
}

/**
 * Parse gradient AST node with auto-detection.
 *
 * @param node - CSS AST node
 * @returns Result with Gradient IR or error
 *
 * @internal
 */
function parseNode(node: CssNode): Result<Type.Gradient, string> {
	// All gradients are Function nodes
	if (node.type === "Function") {
		const css = cssTree.generate(node);
		switch (node.name.toLowerCase()) {
			case "linear-gradient":
			case "repeating-linear-gradient":
				return Linear.parse(css);
			case "radial-gradient":
			case "repeating-radial-gradient":
				return Radial.parse(css);
			case "conic-gradient":
			case "repeating-conic-gradient":
				return Conic.parse(css);
			default:
				return err(`Unknown gradient function: ${node.name}`);
		}
	}

	return err("Invalid gradient value");
}


=== File: src/parse/gradient/index.ts ===
// b_path:: src/parse/gradient/index.ts

/**
 * CSS gradient parsers - convert gradient strings to structured IR.
 *
 * @module Parse.Gradient
 * @public
 */

/**
 * Parse color stops within gradients.
 *
 * @see {@link ColorStop.parse}
 */
export * as ColorStop from "./color-stop";
/**
 * Parse conic and repeating-conic gradients.
 *
 * @see {@link Conic.parse}
 */
export * as Conic from "./conic";
/**
 * Unified gradient dispatcher with auto-detection.
 *
 * @see {@link module:Parse.Gradient}
 */
export { parse } from "./gradient";

/**
 * Parse linear and repeating-linear gradients.
 *
 * @see {@link Linear.parse}
 */
export * as Linear from "./linear";
/**
 * Parse radial and repeating-radial gradients.
 *
 * @see {@link Radial.parse}
 */
export * as Radial from "./radial";


=== File: src/parse/gradient/linear.parse.test.ts ===
// b_path:: src/parse/gradient/linear.parse.test.ts

import { describe, expect, it } from "vitest";
import * as LinearParser from "./linear";

describe("Linear Gradient Parser", () => {
	it("should parse simple linear gradient", () => {
		const css = "linear-gradient(red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("linear");
			expect(result.value.repeating).toBe(false);
			expect(result.value.colorStops).toHaveLength(2);
			expect(result.value.colorStops[0]?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "blue" });
		}
	});

	it("should parse linear gradient with angle direction", () => {
		const css = "linear-gradient(45deg, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "angle",
				value: { value: 45, unit: "deg" },
			});
		}
	});

	it("should parse linear gradient with to-side direction", () => {
		const css = "linear-gradient(to right, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "to-side",
				value: "right",
			});
		}
	});

	it("should parse linear gradient with to-corner direction", () => {
		const css = "linear-gradient(to top right, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "to-corner",
				value: "top right",
			});
		}
	});

	it("should parse linear gradient with turn unit", () => {
		const css = "linear-gradient(0.25turn, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "angle",
				value: { value: 0.25, unit: "turn" },
			});
		}
	});

	it("should parse linear gradient with rad unit", () => {
		const css = "linear-gradient(1.57rad, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "angle",
				value: { value: 1.57, unit: "rad" },
			});
		}
	});

	it("should parse linear gradient with color stops having positions", () => {
		const css = "linear-gradient(red 0%, blue 100%)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 0,
				unit: "%",
			});
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 100,
				unit: "%",
			});
		}
	});

	it("should parse linear gradient with color interpolation", () => {
		const css = "linear-gradient(in oklch, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse linear gradient with direction and color interpolation", () => {
		const css = "linear-gradient(45deg in oklch, red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "angle",
				value: { value: 45, unit: "deg" },
			});
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse repeating linear gradient", () => {
		const css = "repeating-linear-gradient(45deg, red, blue 20px)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.repeating).toBe(true);
		}
	});

	it("should parse complex linear gradient", () => {
		const css = "linear-gradient(to bottom right, red 0%, yellow 50%, blue 100%)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.direction).toEqual({
				kind: "to-corner",
				value: "bottom right",
			});
			expect(result.value.colorStops).toHaveLength(3);
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "yellow" });
		}
	});

	it("should parse linear gradient with all directions", () => {
		const directions = ["to top", "to right", "to bottom", "to left"];

		for (const dir of directions) {
			const css = `linear-gradient(${dir}, red, blue)`;
			const result = LinearParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.direction?.kind).toBe("to-side");
			}
		}
	});

	it("should parse linear gradient with all corners", () => {
		const corners = ["to top left", "to top right", "to bottom left", "to bottom right"];

		for (const corner of corners) {
			const css = `linear-gradient(${corner}, red, blue)`;
			const result = LinearParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.direction?.kind).toBe("to-corner");
			}
		}
	});

	it("should handle linear gradient with multiple color stops", () => {
		const css = "linear-gradient(red, orange, yellow, green, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(5);
		}
	});

	it("should return error for invalid function name", () => {
		const css = "radial-gradient(red, blue)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("No linear-gradient function found");
		}
	});

	it("should return error for insufficient color stops", () => {
		const css = "linear-gradient(red)";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});

	it("should return error for invalid CSS syntax", () => {
		const css = "not valid css";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should return error for empty function", () => {
		const css = "linear-gradient()";
		const result = LinearParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});
});


=== File: src/parse/gradient/linear.ts ===
// b_path:: src/parse/gradient/linear.ts
import * as csstree from "css-tree";
import type * as Keyword from "@/core/keywords";
import { COLOR_INTERPOLATION_KEYWORDS } from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import * as ColorStop from "./color-stop";

/**
 * Parse gradient direction from nodes.
 *
 * Handles angle values, "to side" keywords, and "to corner" keywords.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @returns Result with direction and next index, or error
 *
 * @internal
 */
function parseDirection(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ direction: Type.GradientDirection; nextIdx: number }, string> {
	let idx = startIdx;
	const node = nodes[idx];

	if (!node) {
		return err("Expected direction value");
	}

	// Check for angle using shared utility
	const angleResult = ParseUtils.parseAngleNode(node);
	if (angleResult.ok) {
		return ok({
			direction: {
				kind: "angle",
				value: angleResult.value,
			},
			nextIdx: idx + 1,
		});
	}

	// Check for "to" keyword (for side or corner)
	if (node.type === "Identifier" && node.name.toLowerCase() === "to") {
		idx++;
		const firstKeyword = nodes[idx];
		if (!firstKeyword || firstKeyword.type !== "Identifier") {
			return err("Expected side or corner keyword after 'to'");
		}

		const first = firstKeyword.name.toLowerCase();
		idx++;

		// Check if there's a second keyword (for corners)
		const secondKeyword = nodes[idx];
		if (secondKeyword && secondKeyword.type === "Identifier") {
			const second = secondKeyword.name.toLowerCase();
			// Corner: "to top left", "to bottom right", etc.
			const corner = `${first} ${second}`;
			if (["top left", "top right", "bottom left", "bottom right"].includes(corner)) {
				return ok({
					direction: {
						kind: "to-corner",
						value: corner as "top left" | "top right" | "bottom left" | "bottom right",
					},
					nextIdx: idx + 1,
				});
			}
		}

		// Single keyword - side
		if (["top", "right", "bottom", "left"].includes(first)) {
			return ok({
				direction: {
					kind: "to-side",
					value: first as "top" | "right" | "bottom" | "left",
				},
				nextIdx: idx,
			});
		}

		return err(`Invalid direction keyword: ${first}`);
	}

	return err("Invalid direction syntax");
}

/**
 * Parse linear gradient from CSS function AST.
 *
 * Handles linear-gradient() and repeating-linear-gradient() functions.
 * Supports optional direction, color interpolation, and color stops.
 *
 * Syntax: linear-gradient([ <angle> | to <side-or-corner> ]? [, in <color-space>]?, <color-stop-list>)
 *
 * @param fn - CSS Function AST node
 * @returns Result containing LinearGradient IR or error message
 *
 * @example
 * ```typescript
 * // Parse: linear-gradient(red, blue)
 * // Parse: linear-gradient(45deg, red, blue)
 * // Parse: linear-gradient(to right, red, blue)
 * // Parse: linear-gradient(to top left, red, blue)
 * // Parse: repeating-linear-gradient(45deg, red, blue 20px)
 * ```
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode): Result<Type.LinearGradient, string> {
	const functionName = fn.name.toLowerCase();
	const isRepeating = functionName === "repeating-linear-gradient";

	if (!isRepeating && functionName !== "linear-gradient") {
		return err(`Expected linear-gradient or repeating-linear-gradient, got: ${functionName}`);
	}

	// Get all children nodes
	const children = fn.children.toArray();
	if (children.length === 0) {
		return err("linear-gradient requires at least 2 color stops");
	}

	let direction: Type.GradientDirection | undefined;
	let colorSpace: Keyword.ColorInterpolationKeyword | undefined;

	let idx = 0;

	// Parse optional direction
	const firstNode = children[idx];
	if (firstNode) {
		// Check for angle using shared utility
		const angleResult = ParseUtils.parseAngleNode(firstNode);
		if (angleResult.ok) {
			const dirResult = parseDirection(children, idx);
			if (dirResult.ok) {
				direction = dirResult.value.direction;
				idx = dirResult.value.nextIdx;
			}
		}
		// Check for "to" keyword
		else if (firstNode.type === "Identifier" && firstNode.name.toLowerCase() === "to") {
			const dirResult = parseDirection(children, idx);
			if (dirResult.ok) {
				direction = dirResult.value.direction;
				idx = dirResult.value.nextIdx;
			}
		}
	}

	// Skip comma after direction if present
	idx = AstUtils.skipComma(children, idx);

	// Parse optional color interpolation: "in <color-space>"
	if (idx < children.length) {
		const node = children[idx];
		if (node?.type === "Identifier" && node.name.toLowerCase() === "in") {
			idx++;
			const spaceNode = children[idx];
			if (spaceNode?.type === "Identifier") {
				const space = spaceNode.name.toLowerCase();
				// Validate against core color interpolation keywords
				if (COLOR_INTERPOLATION_KEYWORDS.includes(space as Keyword.ColorInterpolationKeyword)) {
					colorSpace = space as Keyword.ColorInterpolationKeyword;
					idx++;
				}
			}

			// Skip comma after color space if present
			idx = AstUtils.skipComma(children, idx);
		}
	}

	// Split remaining nodes into color stop groups
	const stopGroups = AstUtils.splitNodesByComma(children, { startIndex: idx });

	// Parse each color stop
	const colorStops: Type.ColorStop[] = [];
	for (const stopNodes of stopGroups) {
		const stopResult = ColorStop.fromNodes(stopNodes);
		if (stopResult.ok) {
			colorStops.push(stopResult.value);
		} else {
			return err(`Invalid color stop: ${stopResult.error}`);
		}
	}

	if (colorStops.length < 2) {
		return err("linear-gradient requires at least 2 color stops");
	}

	return ok({
		kind: "linear",
		direction,
		colorSpace,
		colorStops,
		repeating: isRepeating,
	});
}

/**
 * Parse a CSS linear gradient value into structured intermediate representation (IR).
 *
 * Parses both `linear-gradient()` and `repeating-linear-gradient()` functions,
 * extracting direction, color interpolation, and color stops into a
 * type-safe IR object.
 *
 * Supports all CSS linear gradient syntax per CSS Images Module Level 3:
 * - Direction angles: `45deg`, `0.5turn`, `1rad`, etc.
 * - Side keywords: `to top`, `to right`, `to bottom`, `to left`
 * - Corner keywords: `to top left`, `to bottom right`, etc.
 * - Color interpolation: `in <color-space>` syntax
 * - Color stops: with optional positions
 *
 * @param css - CSS string containing a linear gradient function
 * @returns Result containing LinearGradient IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * Simple gradient (defaults to top to bottom):
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Linear.parse("linear-gradient(red, blue)");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { kind: "linear", colorStops: [...], repeating: false }
 * }
 * ```
 *
 * @example
 * With angle direction:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "linear-gradient(45deg, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.direction);
 *   // { kind: "angle", value: { value: 45, unit: "deg" } }
 * }
 * ```
 *
 * @example
 * With side direction:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "linear-gradient(to right, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.direction);
 *   // { kind: "to-side", value: "right" }
 * }
 * ```
 *
 * @example
 * With corner direction:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "linear-gradient(to top right, red 0%, blue 100%)"
 * );
 * if (result.ok) {
 *   console.log(result.value.direction);
 *   // { kind: "to-corner", value: "top right" }
 * }
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "linear-gradient(in oklch, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.colorSpace); // "oklch"
 * }
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse(
 *   "repeating-linear-gradient(45deg, red 0px, blue 20px)"
 * );
 * if (result.ok) {
 *   console.log(result.value.repeating); // true
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Gradient.Linear.parse("invalid syntax");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient | MDN: linear-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients | W3C Spec: Linear Gradients}
 * @see {@link https://github.com/mdn/data/blob/main/css/functions.json | MDN Data: linear-gradient()}
 */
export function parse(css: string): Result<Type.LinearGradient, string> {
	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the function node
		let funcNode: csstree.FunctionNode | null = null;
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (node.name === "linear-gradient" || node.name === "repeating-linear-gradient") {
					funcNode = node;
				}
			},
		});

		if (!funcNode) {
			return err("No linear-gradient function found in CSS string");
		}

		return fromFunction(funcNode);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/gradient/radial.parse.test.ts ===
// b_path:: src/parse/gradient/radial.parse.test.ts

import { describe, expect, it } from "vitest";
import * as RadialParser from "./radial";

describe("Radial Gradient Parser", () => {
	it("should parse simple radial gradient", () => {
		const css = "radial-gradient(red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("radial");
			expect(result.value.repeating).toBe(false);
			expect(result.value.colorStops).toHaveLength(2);
			expect(result.value.colorStops[0]?.color).toEqual({ kind: "named", name: "red" });
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "blue" });
		}
	});

	it("should parse radial gradient with shape", () => {
		const css = "radial-gradient(circle, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("circle");
		}
	});

	it("should parse radial gradient with size keyword", () => {
		const css = "radial-gradient(circle closest-side, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "closest-side",
			});
		}
	});

	it("should parse radial gradient with position", () => {
		const css = "radial-gradient(at center, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "center",
				vertical: "center",
			});
		}
	});

	it("should parse radial gradient with color stops having positions", () => {
		const css = "radial-gradient(red 0%, blue 100%)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 0,
				unit: "%",
			});
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 100,
				unit: "%",
			});
		}
	});

	it("should parse repeating radial gradient", () => {
		const css = "repeating-radial-gradient(red, blue 20px)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.repeating).toBe(true);
		}
	});

	it("should parse complex radial gradient", () => {
		const css = "radial-gradient(ellipse farthest-corner at 30% 30%, red 0%, blue 100%)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("ellipse");
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "farthest-corner",
			});
			expect(result.value.position).toEqual({
				horizontal: { value: 30, unit: "%" },
				vertical: { value: 30, unit: "%" },
			});
		}
	});

	it("should parse radial gradient with multiple color stops", () => {
		const css = "radial-gradient(red, yellow 30%, green 60%, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(4);
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "named", name: "yellow" });
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 30,
				unit: "%",
			});
		}
	});

	it("should return error for invalid gradient syntax", () => {
		const css = "not-a-gradient";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should return error for gradient with insufficient color stops", () => {
		const css = "radial-gradient(red)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});

	it("should parse radial gradient with explicit circle radius", () => {
		const css = "radial-gradient(100px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "circle-explicit",
				radius: { value: 100, unit: "px" },
			});
		}
	});

	it("should parse radial gradient with explicit ellipse radii", () => {
		const css = "radial-gradient(50% 100px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 50, unit: "%" },
				radiusY: { value: 100, unit: "px" },
			});
		}
	});

	it("should parse radial gradient with color interpolation method", () => {
		const css = "radial-gradient(in srgb, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("srgb");
		}
	});

	it("should parse radial gradient with oklch color space", () => {
		const css = "radial-gradient(in oklch, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("oklch");
		}
	});

	it("should parse radial gradient with display-p3 color space", () => {
		const css = "radial-gradient(in display-p3, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("display-p3");
		}
	});

	it("should parse radial gradient with shape and color space", () => {
		const css = "radial-gradient(circle in srgb, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("circle");
			expect(result.value.colorSpace).toBe("srgb");
		}
	});

	it("should handle comma after color space", () => {
		const css = "radial-gradient(in srgb, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorSpace).toBe("srgb");
			expect(result.value.colorStops).toHaveLength(2);
		}
	});

	it("should handle size with single dimension value", () => {
		const css = "radial-gradient(50px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "circle-explicit",
				radius: { value: 50, unit: "px" },
			});
		}
	});

	it("should handle size with percentage value", () => {
		const css = "radial-gradient(75%, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "circle-explicit",
				radius: { value: 75, unit: "%" },
			});
		}
	});

	it("should handle ellipse with two length values", () => {
		const css = "radial-gradient(100px 50px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 100, unit: "px" },
				radiusY: { value: 50, unit: "px" },
			});
		}
	});

	it("should handle position with length values", () => {
		const css = "radial-gradient(at 10px 20px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: { value: 10, unit: "px" },
				vertical: { value: 20, unit: "px" },
			});
		}
	});

	it("should handle position with mixed keyword and length", () => {
		const css = "radial-gradient(at left 20px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position?.horizontal).toBe("left");
		}
	});

	it("should handle position with single value", () => {
		const css = "radial-gradient(at 50%, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toBeDefined();
		}
	});

	// Error path tests
	it("should return error for empty gradient", () => {
		const css = "radial-gradient()";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("at least 2 color stops");
		}
	});

	it("should return error for missing function", () => {
		const css = "not a function";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should return error for wrong function name", () => {
		const css = "linear-gradient(red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(false);
	});

	it("should handle shape without size", () => {
		const css = "radial-gradient(ellipse, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("ellipse");
			expect(result.value.size).toBeUndefined();
		}
	});

	it("should handle size closest-side", () => {
		const css = "radial-gradient(closest-side, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "closest-side",
			});
		}
	});

	it("should handle size farthest-side", () => {
		const css = "radial-gradient(farthest-side, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "farthest-side",
			});
		}
	});

	it("should handle size closest-corner", () => {
		const css = "radial-gradient(closest-corner, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "keyword",
				value: "closest-corner",
			});
		}
	});

	it("should handle circle with explicit size", () => {
		const css = "radial-gradient(circle 200px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("circle");
			expect(result.value.size).toEqual({
				kind: "circle-explicit",
				radius: { value: 200, unit: "px" },
			});
		}
	});

	it("should handle ellipse with explicit size", () => {
		const css = "radial-gradient(ellipse 100px 200px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.shape).toBe("ellipse");
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 100, unit: "px" },
				radiusY: { value: 200, unit: "px" },
			});
		}
	});

	it("should handle position right bottom", () => {
		const css = "radial-gradient(at right bottom, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "right",
				vertical: "bottom",
			});
		}
	});

	it("should handle position with percentage values", () => {
		const css = "radial-gradient(at 25% 75%, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: { value: 25, unit: "%" },
				vertical: { value: 75, unit: "%" },
			});
		}
	});

	it("should handle position with top keyword", () => {
		const css = "radial-gradient(at top, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "center",
				vertical: "top",
			});
		}
	});

	it("should handle position with bottom keyword", () => {
		const css = "radial-gradient(at bottom, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.position).toEqual({
				horizontal: "center",
				vertical: "bottom",
			});
		}
	});

	it("should handle explicit size with ellipse two dimensions", () => {
		const css = "radial-gradient(120px 80px, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 120, unit: "px" },
				radiusY: { value: 80, unit: "px" },
			});
		}
	});

	it("should handle explicit size with percentages for ellipse", () => {
		const css = "radial-gradient(60% 40%, red, blue)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.size).toEqual({
				kind: "ellipse-explicit",
				radiusX: { value: 60, unit: "%" },
				radiusY: { value: 40, unit: "%" },
			});
		}
	});

	it("should handle color stops with px positions", () => {
		const css = "radial-gradient(red 10px, blue 50px)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 10,
				unit: "px",
			});
			expect(result.value.colorStops[1]?.position).toEqual({
				value: 50,
				unit: "px",
			});
		}
	});

	it("should handle color stops with em positions", () => {
		const css = "radial-gradient(red 1em, blue 2em)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.position).toEqual({
				value: 1,
				unit: "em",
			});
		}
	});

	it("should handle rgb colors", () => {
		const css = "radial-gradient(rgb(255, 0, 0), rgb(0, 0, 255))";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(2);
		}
	});

	it("should handle hex colors", () => {
		const css = "radial-gradient(#ff0000, #0000ff)";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops[0]?.color).toEqual({ kind: "hex", value: "#FF0000" });
			expect(result.value.colorStops[1]?.color).toEqual({ kind: "hex", value: "#0000FF" });
		}
	});

	it("should handle mixed color formats", () => {
		const css = "radial-gradient(red, #00ff00, rgb(0, 0, 255))";
		const result = RadialParser.parse(css);

		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.colorStops).toHaveLength(3);
		}
	});
});


=== File: src/parse/gradient/radial.ts ===
// b_path:: src/parse/gradient/radial.ts
import type * as csstree from "css-tree";
import type * as Keyword from "@/core/keywords";
import { COLOR_INTERPOLATION_KEYWORDS } from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as AstUtils from "@/utils/ast";
import * as ParseUtils from "@/utils/parse";
import * as ColorStop from "./color-stop";

/**
 * Parse position from nodes (at keyword followed by position values).
 *
 * Syntax: at <position>
 * Example: at center, at left top, at 50% 50%, at 100px 200px
 *
 * @param nodes - Array of CSS nodes starting with "at" keyword
 * @param startIdx - Index to start parsing from
 * @returns Result with Position2D and next index, or error
 *
 * @internal
 */
function parsePosition(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Should start with "at" keyword
	const atNode = nodes[idx];
	if (!atNode || atNode.type !== "Identifier" || atNode.name.toLowerCase() !== "at") {
		return err("Expected 'at' keyword for position");
	}
	idx++;

	// Parse position values (1 or 2 values: horizontal and vertical)
	const positionValues: Type.PositionValue[] = [];

	// Collect position value nodes until we hit comma or end
	while (idx < nodes.length) {
		const node = nodes[idx];
		if (!node) break;

		if (node.type === "Operator" && "value" in node && node.value === ",") {
			break;
		}

		if (node.type === "Identifier") {
			// Try parsing as position keyword using shared utility
			const positionResult = ParseUtils.parsePositionValueNode(node);
			if (positionResult.ok && typeof positionResult.value === "string") {
				positionValues.push(positionResult.value);
				idx++;
			} else {
				break;
			}
		} else {
			// Try parsing as length-percentage using shared utility
			const lengthResult = ParseUtils.parseLengthPercentageNode(node);
			if (lengthResult.ok) {
				positionValues.push(lengthResult.value);
				idx++;
			} else {
				break;
			}
		}
	}

	if (positionValues.length === 0) {
		return err("Expected position values after 'at'");
	}

	// Convert 1-2 values into Position2D
	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Invalid position value");
		}
		// Single value is treated as horizontal, vertical defaults to center
		if (typeof val === "string") {
			// Keyword: if it's top/bottom, it's vertical; otherwise horizontal
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		// Two values: horizontal then vertical
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Invalid position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse radial gradient size from nodes.
 *
 * Handles keyword sizes (closest-side, etc.) and explicit sizes.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @param _shape - Shape parameter (reserved for future use)
 * @returns Result with size and next index, or error
 *
 * @internal
 */
function parseSize(
	nodes: csstree.CssNode[],
	startIdx: number,
	_shape?: Type.RadialGradientShape,
): Result<{ size: Type.RadialGradientSize; nextIdx: number }, string> {
	let idx = startIdx;
	const node = nodes[idx];

	if (!node) {
		return err("Expected size value");
	}

	// Check for keyword size
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();
		if (["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(keyword)) {
			return ok({
				size: {
					kind: "keyword",
					value: keyword as "closest-side" | "farthest-side" | "closest-corner" | "farthest-corner",
				},
				nextIdx: idx + 1,
			});
		}
	}

	// Check for explicit size (length or percentage)
	if (node.type === "Dimension" || node.type === "Percentage") {
		const firstValue =
			node.type === "Dimension"
				? { value: Number.parseFloat(node.value), unit: node.unit as "px" | "em" | "rem" | "%" }
				: { value: Number.parseFloat(node.value), unit: "%" as const };

		idx++;

		// Check if there's a second value (for ellipse)
		const nextNode = nodes[idx];
		if (nextNode && (nextNode.type === "Dimension" || nextNode.type === "Percentage")) {
			const secondValue =
				nextNode.type === "Dimension"
					? { value: Number.parseFloat(nextNode.value), unit: nextNode.unit as "px" | "em" | "rem" | "%" }
					: { value: Number.parseFloat(nextNode.value), unit: "%" as const };

			return ok({
				size: {
					kind: "ellipse-explicit",
					radiusX: firstValue,
					radiusY: secondValue,
				},
				nextIdx: idx + 1,
			});
		}

		// Single value - circle
		return ok({
			size: {
				kind: "circle-explicit",
				radius: firstValue,
			},
			nextIdx: idx,
		});
	}

	return err("Invalid size value");
}

/**
 * Parse radial gradient from CSS function AST.
 *
 * Handles radial-gradient() and repeating-radial-gradient() functions.
 * Supports optional shape, size, position, color interpolation, and color stops.
 *
 * Syntax: radial-gradient([ <shape> || <size> ]? [ at <position> ]? [, in <color-space>]?, <color-stop-list>)
 *
 * @param fn - CSS Function AST node
 * @returns Result containing RadialGradient IR or error message
 *
 * @example
 * ```typescript
 * // Parse: radial-gradient(red, blue)
 * // Parse: radial-gradient(circle, red, blue)
 * // Parse: radial-gradient(closest-side, red, blue)
 * // Parse: radial-gradient(circle at center, red, blue)
 * // Parse: radial-gradient(100px at left top, red, blue)
 * // Parse: repeating-radial-gradient(circle, red, blue 20px)
 * ```
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode): Result<Type.RadialGradient, string> {
	const functionName = fn.name.toLowerCase();
	const isRepeating = functionName === "repeating-radial-gradient";

	if (!isRepeating && functionName !== "radial-gradient") {
		return err(`Expected radial-gradient or repeating-radial-gradient, got: ${functionName}`);
	}

	// Get all children nodes
	const children = fn.children.toArray();
	if (children.length === 0) {
		return err("radial-gradient requires at least 2 color stops");
	}

	let shape: Type.RadialGradientShape | undefined;
	let size: Type.RadialGradientSize | undefined;
	let position: Type.Position2D | undefined;
	let colorSpace: Keyword.ColorInterpolationKeyword | undefined;

	let idx = 0;

	// Parse optional shape and/or size
	const firstNode = children[idx];
	if (firstNode?.type === "Identifier") {
		const keyword = firstNode.name.toLowerCase();

		// Check for shape keyword
		if (keyword === "circle" || keyword === "ellipse") {
			shape = keyword;
			idx++;

			// Check for size after shape
			const nextNode = children[idx];
			if (nextNode && nextNode.type !== "Identifier") {
				// Could be explicit size
				const sizeResult = parseSize(children, idx, shape);
				if (sizeResult.ok) {
					size = sizeResult.value.size;
					idx = sizeResult.value.nextIdx;
				}
			} else if (
				nextNode?.type === "Identifier" &&
				["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(nextNode.name.toLowerCase())
			) {
				// Keyword size
				const sizeResult = parseSize(children, idx, shape);
				if (sizeResult.ok) {
					size = sizeResult.value.size;
					idx = sizeResult.value.nextIdx;
				}
			}
		}
		// Check for size keyword without shape
		else if (["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(keyword)) {
			const sizeResult = parseSize(children, idx);
			if (sizeResult.ok) {
				size = sizeResult.value.size;
				idx = sizeResult.value.nextIdx;
			}
		}
	}
	// Check for explicit size without shape keyword
	else if (firstNode && (firstNode.type === "Dimension" || firstNode.type === "Percentage")) {
		const sizeResult = parseSize(children, idx);
		if (sizeResult.ok) {
			size = sizeResult.value.size;
			idx = sizeResult.value.nextIdx;
		}
	}

	// Parse optional position: "at <position>"
	const atNode = children[idx];
	if (atNode?.type === "Identifier" && atNode.name.toLowerCase() === "at") {
		const posResult = parsePosition(children, idx);
		if (posResult.ok) {
			position = posResult.value.position;
			idx = posResult.value.nextIdx;
		}
	}

	// Skip comma after shape/size/position if present
	const commaNode = children[idx];
	if (commaNode && commaNode.type === "Operator" && "value" in commaNode && commaNode.value === ",") {
		idx++;
	}

	// Parse optional color interpolation: "in <color-space>"
	if (idx < children.length) {
		const node = children[idx];
		if (node?.type === "Identifier" && node.name.toLowerCase() === "in") {
			idx++;
			const spaceNode = children[idx];
			if (spaceNode?.type === "Identifier") {
				const space = spaceNode.name.toLowerCase();
				// Validate against core color interpolation keywords
				if (COLOR_INTERPOLATION_KEYWORDS.includes(space as Keyword.ColorInterpolationKeyword)) {
					colorSpace = space as Keyword.ColorInterpolationKeyword;
					idx++;
				}
			}

			// Skip comma after color space if present
			const spaceCommaNode = children[idx];
			if (
				spaceCommaNode &&
				spaceCommaNode.type === "Operator" &&
				"value" in spaceCommaNode &&
				spaceCommaNode.value === ","
			) {
				idx++;
			}
		}
	}

	// Split remaining nodes into color stop groups
	const stopGroups = AstUtils.splitNodesByComma(children, { startIndex: idx });

	// Parse each color stop
	const colorStops: Type.ColorStop[] = [];
	for (const stopNodes of stopGroups) {
		const stopResult = ColorStop.fromNodes(stopNodes);
		if (stopResult.ok) {
			colorStops.push(stopResult.value);
		} else {
			return err(`Invalid color stop: ${stopResult.error}`);
		}
	}

	if (colorStops.length < 2) {
		return err("radial-gradient requires at least 2 color stops");
	}

	return ok({
		kind: "radial",
		shape,
		size,
		position,
		colorSpace,
		colorStops,
		repeating: isRepeating,
	});
}

/**
 * Parse a CSS radial gradient value into structured intermediate representation (IR).
 *
 * Parses both `radial-gradient()` and `repeating-radial-gradient()` functions,
 * extracting shape, size, position, color interpolation, and color stops into a
 * type-safe IR object.
 *
 * Supports all CSS radial gradient syntax per CSS Images Module Level 3:
 * - Shape keywords: `circle`, `ellipse` (default: `ellipse`)
 * - Size keywords: `closest-side`, `farthest-side`, `closest-corner`, `farthest-corner`
 * - Explicit sizes: lengths (px, em, etc.)
 * - Position: keywords (`center`, `top`, `left`, etc.) or length values
 * - Color interpolation: `in <color-space>` syntax
 * - Color stops: with optional positions
 *
 * @param css - CSS string containing a radial gradient function
 * @returns Result containing RadialGradient IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * Simple gradient (defaults to ellipse at center):
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Radial.parse("radial-gradient(red, blue)");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { kind: "radial", colorStops: [...], repeating: false }
 * }
 * ```
 *
 * @example
 * Circle with keyword size:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(circle closest-side, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.shape); // "circle"
 *   console.log(result.value.size);  // { kind: "keyword", value: "closest-side" }
 * }
 * ```
 *
 * @example
 * Positioned gradient:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(at center top, red 0%, blue 100%)"
 * );
 * if (result.ok) {
 *   console.log(result.value.position);
 *   // { horizontal: "center", vertical: "top" }
 * }
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(in oklch, red, blue)"
 * );
 * if (result.ok) {
 *   console.log(result.value.colorSpace); // "oklch"
 * }
 * ```
 *
 * @example
 * Repeating gradient:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse(
 *   "repeating-radial-gradient(circle, red 0px, blue 20px)"
 * );
 * if (result.ok) {
 *   console.log(result.value.repeating); // true
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Gradient.Radial.parse("invalid syntax");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient | MDN: radial-gradient()}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients | W3C Spec: Radial Gradients}
 * @see {@link https://github.com/mdn/data/blob/main/css/functions.json | MDN Data: radial-gradient()}
 */
export function parse(css: string): Result<Type.RadialGradient, string> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the function node
		let funcNode: csstree.FunctionNode | null = null;
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (node.name === "radial-gradient" || node.name === "repeating-radial-gradient") {
					funcNode = node;
				}
			},
		});

		if (!funcNode) {
			return err("No radial-gradient function found in CSS string");
		}

		return fromFunction(funcNode);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/index.ts ===
// b_path:: src/parse/index.ts

/**
 * CSS value parsers - convert CSS strings to structured IR.
 *
 * All parsers return Result<T, string> for type-safe error handling.
 * Parse any CSS value into a structured intermediate representation (IR)
 * that can be inspected, transformed, or converted back to CSS.
 *
 * @module Parse
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Gradient.Radial.parse(
 *   "radial-gradient(circle, red, blue)"
 * );
 *
 * if (result.ok) {
 *   console.log(result.value.shape); // "circle"
 *   console.log(result.value.colorStops); // [...]
 * } else {
 *   console.error(result.error);
 * }
 * ```
 */

/**
 * Animation parsers (delay, duration, iteration-count, direction, fill-mode, play-state, name, timing-function).
 *
 * @see {@link Animation.Delay.parse}
 */
export * as Animation from "./animation";
/**
 * Background parsers (attachment, clip, origin, repeat, size).
 *
 * @see {@link Background.Attachment.parse}
 */
export * as Background from "./background";
/**
 * Border parsers (width, style, color, radius).
 *
 * @see {@link Border.Width.parse}
 */
export * as Border from "./border";
/**
 * Clip-path parsers (url, none).
 *
 * @see {@link ClipPath.Url.parse}
 */
export * as ClipPath from "./clip-path";
/**
 * Color parsers (hex, named, RGB, HSL, HWB, LAB, LCH, OKLab, OKLCH, system, special).
 *
 * @see {@link Color.Hex.parse}
 */
export * as Color from "./color";
/**
 * Filter parsers (blur, brightness, contrast, drop-shadow, grayscale, hue-rotate, invert, opacity, saturate, sepia, url).
 *
 * @see {@link Filter.Blur.parse}
 */
export * as Filter from "./filter";
/**
 * Gradient parsers (radial, linear, conic).
 *
 * @see {@link Gradient.Radial.parse}
 */
export * as Gradient from "./gradient";
/**
 * Interaction parsers (pointer-events).
 *
 * @see {@link Interaction.PointerEvents.parse}
 */
export * as Interaction from "./interaction";
/**
 * Layout parsers (display, visibility, opacity).
 *
 * @see {@link Layout.Display.parse}
 */
export * as Layout from "./layout";
/**
 * Outline parsers (width, style, color, offset).
 *
 * @see {@link Outline.Width.parse}
 */
export * as Outline from "./outline";
/**
 * Position parsers (background-position, object-position, transform-origin, etc.).
 *
 * @see {@link Position.parse}
 */
export * as Position from "./position/position";
/**
 * Shadow parsers (box-shadow, text-shadow).
 *
 * @see {@link Shadow.BoxShadow.parse}
 */
export * as Shadow from "./shadow";
/**
 * Text decoration parsers (color, line, style, thickness).
 *
 * @see {@link Text.Color.parse}
 */
export * as Text from "./text";
/**
 * Transform parsers (translate, rotate, scale, skew, matrix, etc.).
 *
 * @see {@link Transform.parse}
 */
export * as Transform from "./transform/transform";
/**
 * Transition parsers (delay, duration, timing-function, property).
 *
 * @see {@link Transition.Delay.parse}
 */
export * as Transition from "./transition";


=== File: src/parse/interaction/index.ts ===
// b_path:: src/parse/interaction/index.ts

export * as PointerEvents from "./pointer-events";
export * as UserSelect from "./user-select";


=== File: src/parse/interaction/pointer-events.test.ts ===
// b_path:: src/parse/interaction/pointer-events.test.ts
import { describe, expect, it } from "vitest";
import * as PointerEvents from "./pointer-events";

describe("Parse.Interaction.PointerEvents", () => {
	describe("standard values", () => {
		it("should parse 'auto'", () => {
			const result = PointerEvents.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "auto",
				});
			}
		});

		it("should parse 'none'", () => {
			const result = PointerEvents.parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "none",
				});
			}
		});
	});

	describe("SVG values", () => {
		it("should parse 'visiblePainted'", () => {
			const result = PointerEvents.parse("visiblePainted");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "visiblePainted",
				});
			}
		});

		it("should parse 'visibleFill'", () => {
			const result = PointerEvents.parse("visibleFill");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "visibleFill",
				});
			}
		});

		it("should parse 'visibleStroke'", () => {
			const result = PointerEvents.parse("visibleStroke");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "visibleStroke",
				});
			}
		});

		it("should parse 'visible'", () => {
			const result = PointerEvents.parse("visible");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "visible",
				});
			}
		});

		it("should parse 'painted'", () => {
			const result = PointerEvents.parse("painted");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "painted",
				});
			}
		});

		it("should parse 'fill'", () => {
			const result = PointerEvents.parse("fill");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "fill",
				});
			}
		});

		it("should parse 'stroke'", () => {
			const result = PointerEvents.parse("stroke");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "stroke",
				});
			}
		});

		it("should parse 'all'", () => {
			const result = PointerEvents.parse("all");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "all",
				});
			}
		});

		it("should parse 'bounding-box'", () => {
			const result = PointerEvents.parse("bounding-box");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "pointer-events",
					value: "bounding-box",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = PointerEvents.parse("invalid");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid pointer-events keyword");
			}
		});

		it("should reject numeric value", () => {
			const result = PointerEvents.parse("1");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = PointerEvents.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = PointerEvents.parse("none auto");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/interaction/pointer-events.ts ===
// b_path:: src/parse/interaction/pointer-events.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS pointer-events property value.
 *
 * Accepts keyword values: auto, none, visiblePainted, visibleFill, visibleStroke,
 * visible, painted, fill, stroke, all, bounding-box.
 * Per CSS Basic User Interface Module Level 4 and SVG specifications.
 *
 * @param css - CSS pointer-events value (e.g., "none", "auto", "visiblePainted")
 * @returns Result with PointerEvents IR or error message
 *
 * @example
 * Standard values:
 * ```typescript
 * const result = parse("none");
 * // { ok: true, value: { kind: "pointer-events", value: "none" } }
 * ```
 *
 * @example
 * SVG values:
 * ```typescript
 * const result = parse("visiblePainted");
 * // { ok: true, value: { kind: "pointer-events", value: "visiblePainted" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events | MDN: pointer-events}
 * @see {@link https://www.w3.org/TR/css-ui-4/#pointer-events | W3C Spec}
 */
export function parse(css: string): Result<Type.PointerEvents, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected pointer-events value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name;

			const validKeywords = [
				"auto",
				"none",
				"visiblePainted",
				"visibleFill",
				"visibleStroke",
				"visible",
				"painted",
				"fill",
				"stroke",
				"all",
				"bounding-box",
			];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "pointer-events",
					value: keyword as Type.PointerEvents["value"],
				});
			}

			return err(`Invalid pointer-events keyword: ${keyword}`);
		}

		return err("Expected keyword for pointer-events");
	} catch (error) {
		return err(`Failed to parse pointer-events: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/interaction/user-select.test.ts ===
// b_path:: src/parse/interaction/user-select.test.ts
import { describe, expect, it } from "vitest";
import * as UserSelect from "./user-select";

describe("Parse.Interaction.UserSelect", () => {
	describe("valid keywords", () => {
		it("should parse 'auto'", () => {
			const result = UserSelect.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "user-select",
					value: "auto",
				});
			}
		});

		it("should parse 'text'", () => {
			const result = UserSelect.parse("text");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "user-select",
					value: "text",
				});
			}
		});

		it("should parse 'none'", () => {
			const result = UserSelect.parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "user-select",
					value: "none",
				});
			}
		});

		it("should parse 'contain'", () => {
			const result = UserSelect.parse("contain");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "user-select",
					value: "contain",
				});
			}
		});

		it("should parse 'all'", () => {
			const result = UserSelect.parse("all");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "user-select",
					value: "all",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse 'AUTO' (uppercase)", () => {
			const result = UserSelect.parse("AUTO");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("auto");
			}
		});

		it("should parse 'None' (mixed case)", () => {
			const result = UserSelect.parse("None");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("none");
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = UserSelect.parse("invalid");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid user-select keyword");
			}
		});

		it("should reject numeric value", () => {
			const result = UserSelect.parse("1");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = UserSelect.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = UserSelect.parse("none auto");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/interaction/user-select.ts ===
// b_path:: src/parse/interaction/user-select.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS user-select property value.
 *
 * Accepts keyword values: auto, text, none, contain, all.
 * Per CSS Basic User Interface Module Level 4 specification.
 *
 * @param css - CSS user-select value (e.g., "none", "auto", "text")
 * @returns Result with UserSelect IR or error message
 *
 * @example
 * Disable text selection:
 * ```typescript
 * const result = parse("none");
 * // { ok: true, value: { kind: "user-select", value: "none" } }
 * ```
 *
 * @example
 * Auto selection:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "user-select", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/user-select | MDN: user-select}
 * @see {@link https://www.w3.org/TR/css-ui-4/#propdef-user-select | W3C Spec}
 */
export function parse(css: string): Result<Type.UserSelect, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected user-select value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			const validKeywords = ["auto", "text", "none", "contain", "all"];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "user-select",
					value: keyword as Type.UserSelect["value"],
				});
			}

			return err(`Invalid user-select keyword: ${keyword}`);
		}

		return err("Expected keyword for user-select");
	} catch (error) {
		return err(`Failed to parse user-select: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/bottom.test.ts ===
// b_path:: src/parse/layout/bottom.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./bottom";

describe("Parse.Layout.Bottom", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: "auto",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses positive px", () => {
			const result = parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 10, unit: "px" },
				});
			}
		});

		it("parses negative px", () => {
			const result = parse("-10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: -10, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("1.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 1.5, unit: "rem" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("parses positive percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses negative percentage", () => {
			const result = parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: -25, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("10px 20px");
			expect(result.ok).toBe(false);
		});

		it("rejects unitless non-zero number", () => {
			const result = parse("10");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("accepts unitless zero", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "bottom",
					value: { value: 0, unit: "px" },
				});
			}
		});

		it("rejects invalid length type", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("handles parse exception", () => {
			const result = parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse bottom");
			}
		});
	});
});


=== File: src/parse/layout/bottom.ts ===
// b_path:: src/parse/layout/bottom.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS bottom property value.
 *
 * Accepts length-percentage values or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS bottom value (e.g., "10px", "50%", "auto")
 * @returns Result with Bottom IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("10px");
 * // { ok: true, value: { kind: "bottom", value: { value: 10, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "bottom", value: { value: 50, unit: "%" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "bottom", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/bottom | MDN: bottom}
 * @see {@link https://www.w3.org/TR/css-position-3/#insets | W3C Spec}
 */
export function parse(css: string): Result<Type.Bottom, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected bottom value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid bottom keyword: ${keyword}`);
			}
			return ok({
				kind: "bottom",
				value: "auto",
			});
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "bottom",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "bottom",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse bottom: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/box-sizing.failure.test.ts ===
// b_path:: src/parse/layout/box-sizing.failure.test.ts
// Auto-generated from scripts/test-generator/configs/box-sizing.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing
// - W3C: https://www.w3.org/TR/css-sizing-3/#box-sizing
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/box-sizing";

describe("parse/layout/box-sizing - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("padding-box");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid box-sizing keyword: padding-box");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("margin-box");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid box-sizing keyword: margin-box");
		});

		it("should reject non-standard keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid box-sizing keyword: auto");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword for box-sizing");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword for box-sizing");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("content-box, border-box");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 3 values");
		});
	});
});


=== File: src/parse/layout/box-sizing.test.ts ===
// b_path:: src/parse/layout/box-sizing.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/box-sizing.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing
// - W3C: https://www.w3.org/TR/css-sizing-3/#box-sizing
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/box-sizing";

describe("parse/layout/box-sizing - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse content-box keyword", () => {
			const result = Parser.parse("content-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "box-sizing",
				value: "content-box",
			});
		});

		it("should parse border-box keyword", () => {
			const result = Parser.parse("border-box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "box-sizing",
				value: "border-box",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase content-box", () => {
			const result = Parser.parse("CONTENT-BOX");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "box-sizing",
				value: "content-box",
			});
		});

		it("should parse mixed case border-box", () => {
			const result = Parser.parse("Border-Box");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "box-sizing",
				value: "border-box",
			});
		});
	});
});


=== File: src/parse/layout/box-sizing.ts ===
// b_path:: src/parse/layout/box-sizing.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS box-sizing property value.
 *
 * Accepts content-box or border-box keywords.
 * Per CSS Box Sizing Module Level 3 specification.
 *
 * @param css - CSS box-sizing value (e.g., "content-box", "border-box")
 * @returns Result with BoxSizing IR or error message
 *
 * @example
 * ```typescript
 * const result = parse("border-box");
 * // { ok: true, value: { kind: "box-sizing", value: "border-box" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing | MDN: box-sizing}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#box-sizing | W3C Spec}
 */
export function parse(css: string): Result<Type.BoxSizing, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected box-sizing value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "content-box" || keyword === "border-box") {
				return ok({
					kind: "box-sizing",
					value: keyword,
				});
			}

			return err(`Invalid box-sizing keyword: ${keyword}`);
		}

		return err("Expected keyword for box-sizing");
	} catch (error) {
		return err(`Failed to parse box-sizing: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/clear.failure.test.ts ===
// b_path:: src/parse/layout/clear.failure.test.ts
// Auto-generated from scripts/test-generator/configs/clear.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/clear";

describe("parse/layout/clear - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				'Invalid clear value: "". Expected: left, right, both, none, inline-start, or inline-end',
			);
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("center");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				'Invalid clear value: "center". Expected: left, right, both, none, inline-start, or inline-end',
			);
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("top");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				'Invalid clear value: "top". Expected: left, right, both, none, inline-start, or inline-end',
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				'Invalid clear value: "0". Expected: left, right, both, none, inline-start, or inline-end',
			);
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("none, left");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				'Invalid clear value: "none, left". Expected: left, right, both, none, inline-start, or inline-end',
			);
		});
	});
});


=== File: src/parse/layout/clear.test.ts ===
// b_path:: src/parse/layout/clear.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/clear.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/clear";

describe("parse/layout/clear - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "clear",
				value: "none",
			});
		});

		it("should parse left keyword", () => {
			const result = Parser.parse("left");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "clear",
				value: "left",
			});
		});

		it("should parse right keyword", () => {
			const result = Parser.parse("right");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "clear",
				value: "right",
			});
		});

		it("should parse both keyword", () => {
			const result = Parser.parse("both");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "clear",
				value: "both",
			});
		});
	});

	describe("valid-logical", () => {
		it("should parse inline-start keyword", () => {
			const result = Parser.parse("inline-start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "clear",
				value: "inline-start",
			});
		});

		it("should parse inline-end keyword", () => {
			const result = Parser.parse("inline-end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "clear",
				value: "inline-end",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase none", () => {
			const result = Parser.parse("NONE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "clear",
				value: "none",
			});
		});

		it("should parse mixed case left", () => {
			const result = Parser.parse("Left");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "clear",
				value: "left",
			});
		});
	});
});


=== File: src/parse/layout/clear.ts ===
// b_path:: src/parse/layout/clear.ts

import type { Clear } from "@/core/types";
import type { Result } from "../../core/result";

/**
 * Parse CSS clear value.
 *
 * Valid values:
 * - left: Clear past left floats
 * - right: Clear past right floats
 * - both: Clear past both left and right floats
 * - none: No clearing
 * - inline-start: Clear past floats on start side
 * - inline-end: Clear past floats on end side
 *
 * @param value - CSS clear value
 * @returns Result with Clear IR or error message
 *
 * @example
 * parse("both")  // Ok({ kind: "clear", value: "both" })
 * parse("left")  // Ok({ kind: "clear", value: "left" })
 * parse("none")  // Ok({ kind: "clear", value: "none" })
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/clear
 */
export function parse(value: string): Result<Clear, string> {
	const normalized = value.trim().toLowerCase();

	if (
		normalized === "left" ||
		normalized === "right" ||
		normalized === "both" ||
		normalized === "none" ||
		normalized === "inline-start" ||
		normalized === "inline-end"
	) {
		return {
			ok: true,
			value: {
				kind: "clear",
				value: normalized as Clear["value"],
			},
			error: undefined,
		};
	}

	return {
		ok: false,
		value: undefined,
		error: `Invalid clear value: "${value}". Expected: left, right, both, none, inline-start, or inline-end`,
	};
}


=== File: src/parse/layout/cursor.failure.test.ts ===
// b_path:: src/parse/layout/cursor.failure.test.ts
// Auto-generated from scripts/test-generator/configs/cursor.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
// - W3C: https://www.w3.org/TR/css-ui-4/#cursor
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/cursor";

describe("parse/layout/cursor - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid cursor keyword: invalid");
		});

		it("should reject non-standard keyword", () => {
			const result = Parser.parse("hand");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid cursor keyword: hand");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});
	});
});


=== File: src/parse/layout/cursor.test.ts ===
// b_path:: src/parse/layout/cursor.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/cursor.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
// - W3C: https://www.w3.org/TR/css-ui-4/#cursor
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/cursor";

describe("parse/layout/cursor - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse auto keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "auto",
			});
		});

		it("should parse default keyword", () => {
			const result = Parser.parse("default");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "default",
			});
		});

		it("should parse pointer keyword", () => {
			const result = Parser.parse("pointer");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "pointer",
			});
		});

		it("should parse text keyword", () => {
			const result = Parser.parse("text");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "text",
			});
		});

		it("should parse move keyword", () => {
			const result = Parser.parse("move");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "move",
			});
		});

		it("should parse wait keyword", () => {
			const result = Parser.parse("wait");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "wait",
			});
		});

		it("should parse help keyword", () => {
			const result = Parser.parse("help");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "help",
			});
		});

		it("should parse none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "none",
			});
		});
	});

	describe("valid-resize", () => {
		it("should parse n-resize keyword", () => {
			const result = Parser.parse("n-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "n-resize",
			});
		});

		it("should parse e-resize keyword", () => {
			const result = Parser.parse("e-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "e-resize",
			});
		});

		it("should parse s-resize keyword", () => {
			const result = Parser.parse("s-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "s-resize",
			});
		});

		it("should parse w-resize keyword", () => {
			const result = Parser.parse("w-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "w-resize",
			});
		});

		it("should parse ne-resize keyword", () => {
			const result = Parser.parse("ne-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "ne-resize",
			});
		});

		it("should parse nw-resize keyword", () => {
			const result = Parser.parse("nw-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "nw-resize",
			});
		});

		it("should parse se-resize keyword", () => {
			const result = Parser.parse("se-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "se-resize",
			});
		});

		it("should parse sw-resize keyword", () => {
			const result = Parser.parse("sw-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "sw-resize",
			});
		});

		it("should parse ew-resize keyword", () => {
			const result = Parser.parse("ew-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "ew-resize",
			});
		});

		it("should parse ns-resize keyword", () => {
			const result = Parser.parse("ns-resize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "ns-resize",
			});
		});
	});

	describe("valid-action", () => {
		it("should parse grab keyword", () => {
			const result = Parser.parse("grab");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "grab",
			});
		});

		it("should parse grabbing keyword", () => {
			const result = Parser.parse("grabbing");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "grabbing",
			});
		});

		it("should parse not-allowed keyword", () => {
			const result = Parser.parse("not-allowed");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "not-allowed",
			});
		});

		it("should parse zoom-in keyword", () => {
			const result = Parser.parse("zoom-in");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "zoom-in",
			});
		});

		it("should parse zoom-out keyword", () => {
			const result = Parser.parse("zoom-out");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "zoom-out",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase pointer", () => {
			const result = Parser.parse("POINTER");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "pointer",
			});
		});

		it("should parse mixed case move", () => {
			const result = Parser.parse("Move");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "cursor",
				value: "move",
			});
		});
	});
});


=== File: src/parse/layout/cursor.ts ===
// b_path:: src/parse/layout/cursor.ts
import * as csstree from "css-tree";
import { CURSOR_KEYWORDS } from "@/core/keywords/cursor-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS cursor property value.
 *
 * Accepts cursor keyword values.
 * Per CSS Basic User Interface Module Level 4 specification.
 *
 * @param css - CSS cursor value (e.g., "pointer", "default", "text", "move")
 * @returns Result with Cursor IR or error message
 *
 * @example
 * Pointer cursor:
 * ```typescript
 * const result = parse("pointer");
 * // { ok: true, value: { kind: "cursor", value: "pointer" } }
 * ```
 *
 * @example
 * Text cursor:
 * ```typescript
 * const result = parse("text");
 * // { ok: true, value: { kind: "cursor", value: "text" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor | MDN: cursor}
 * @see {@link https://www.w3.org/TR/css-ui-4/#cursor | W3C Spec}
 */
export function parse(css: string): Result<Type.Cursor, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!CURSOR_KEYWORDS.includes(keyword as Type.Cursor["value"])) {
			return err(`Invalid cursor keyword: ${keyword}`);
		}

		return ok({
			kind: "cursor",
			value: keyword as Type.Cursor["value"],
		});
	} catch (error) {
		return err(`Failed to parse cursor: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/display.failure.test.ts ===
// b_path:: src/parse/layout/display.failure.test.ts
// Auto-generated from scripts/test-generator/configs/display.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/display
// - W3C: https://www.w3.org/TR/css-display-3/
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/display";

describe("parse/layout/display - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject visibility value", () => {
			const result = Parser.parse("visible");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid display keyword: visible");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid display keyword: auto");
		});

		it("should reject non-standard keyword", () => {
			const result = Parser.parse("show");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid display keyword: show");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("block, inline");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 3 values");
		});
	});
});


=== File: src/parse/layout/display.test.ts ===
// b_path:: src/parse/layout/display.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/display.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/display
// - W3C: https://www.w3.org/TR/css-display-3/
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/display";

describe("parse/layout/display - valid cases", () => {
	describe("valid-outside", () => {
		it("should parse block keyword", () => {
			const result = Parser.parse("block");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "block",
			});
		});

		it("should parse inline keyword", () => {
			const result = Parser.parse("inline");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "inline",
			});
		});
	});

	describe("valid-box", () => {
		it("should parse none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "none",
			});
		});

		it("should parse contents keyword", () => {
			const result = Parser.parse("contents");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "contents",
			});
		});
	});

	describe("valid-inside", () => {
		it("should parse flex keyword", () => {
			const result = Parser.parse("flex");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "flex",
			});
		});

		it("should parse grid keyword", () => {
			const result = Parser.parse("grid");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "grid",
			});
		});

		it("should parse table keyword", () => {
			const result = Parser.parse("table");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "table",
			});
		});

		it("should parse flow-root keyword", () => {
			const result = Parser.parse("flow-root");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "flow-root",
			});
		});
	});

	describe("valid-legacy", () => {
		it("should parse inline-block keyword", () => {
			const result = Parser.parse("inline-block");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "inline-block",
			});
		});

		it("should parse inline-flex keyword", () => {
			const result = Parser.parse("inline-flex");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "inline-flex",
			});
		});

		it("should parse inline-grid keyword", () => {
			const result = Parser.parse("inline-grid");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "inline-grid",
			});
		});
	});

	describe("valid-internal", () => {
		it("should parse table-row keyword", () => {
			const result = Parser.parse("table-row");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "table-row",
			});
		});

		it("should parse table-cell keyword", () => {
			const result = Parser.parse("table-cell");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "table-cell",
			});
		});
	});

	describe("valid-list", () => {
		it("should parse list-item keyword", () => {
			const result = Parser.parse("list-item");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "list-item",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase flex", () => {
			const result = Parser.parse("FLEX");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "flex",
			});
		});

		it("should parse mixed case block", () => {
			const result = Parser.parse("Block");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "display",
				value: "block",
			});
		});
	});
});


=== File: src/parse/layout/display.ts ===
// b_path:: src/parse/layout/display.ts
import * as csstree from "css-tree";
import { DISPLAY_KEYWORDS } from "@/core/keywords/display-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS display property value.
 *
 * Accepts display keywords including box, inside, internal, legacy, and outside values.
 * Per CSS Display Module Level 3 specification.
 *
 * @param css - CSS display value (e.g., "flex", "block", "inline-block", "none")
 * @returns Result with Display IR or error message
 *
 * @example
 * Flex layout:
 * ```typescript
 * const result = parse("flex");
 * // { ok: true, value: { kind: "display", value: "flex" } }
 * ```
 *
 * @example
 * Hidden element:
 * ```typescript
 * const result = parse("none");
 * // { ok: true, value: { kind: "display", value: "none" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display | MDN: display}
 * @see {@link https://www.w3.org/TR/css-display-3/ | W3C Spec}
 */
export function parse(css: string): Result<Type.Display, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!DISPLAY_KEYWORDS.includes(keyword as Type.Display["value"])) {
			return err(`Invalid display keyword: ${keyword}`);
		}

		return ok({
			kind: "display",
			value: keyword as Type.Display["value"],
		});
	} catch (error) {
		return err(`Failed to parse display: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/float.failure.test.ts ===
// b_path:: src/parse/layout/float.failure.test.ts
// Auto-generated from scripts/test-generator/configs/float.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/float";

describe("parse/layout/float - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe('Invalid float value: "". Expected: left, right, none, inline-start, or inline-end');
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("center");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				'Invalid float value: "center". Expected: left, right, none, inline-start, or inline-end',
			);
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("both");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				'Invalid float value: "both". Expected: left, right, none, inline-start, or inline-end',
			);
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe('Invalid float value: "0". Expected: left, right, none, inline-start, or inline-end');
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("left, right");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				'Invalid float value: "left, right". Expected: left, right, none, inline-start, or inline-end',
			);
		});
	});
});


=== File: src/parse/layout/float.test.ts ===
// b_path:: src/parse/layout/float.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/float.ts
//
// ⚠️  No spec references found in source file
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/float";

describe("parse/layout/float - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "float",
				value: "none",
			});
		});

		it("should parse left keyword", () => {
			const result = Parser.parse("left");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "float",
				value: "left",
			});
		});

		it("should parse right keyword", () => {
			const result = Parser.parse("right");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "float",
				value: "right",
			});
		});
	});

	describe("valid-logical", () => {
		it("should parse inline-start keyword", () => {
			const result = Parser.parse("inline-start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "float",
				value: "inline-start",
			});
		});

		it("should parse inline-end keyword", () => {
			const result = Parser.parse("inline-end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "float",
				value: "inline-end",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase none", () => {
			const result = Parser.parse("NONE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "float",
				value: "none",
			});
		});

		it("should parse mixed case left", () => {
			const result = Parser.parse("Left");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "float",
				value: "left",
			});
		});
	});
});


=== File: src/parse/layout/float.ts ===
// b_path:: src/parse/layout/float.ts

import type { Float } from "@/core/types";
import type { Result } from "../../core/result";

/**
 * Parse CSS float value.
 *
 * Valid values:
 * - left: Float to the left side
 * - right: Float to the right side
 * - none: No floating
 * - inline-start: Float to start side of containing block
 * - inline-end: Float to end side of containing block
 *
 * @param value - CSS float value
 * @returns Result with Float IR or error message
 *
 * @example
 * parse("left")  // Ok({ kind: "float", value: "left" })
 * parse("right") // Ok({ kind: "float", value: "right" })
 * parse("none")  // Ok({ kind: "float", value: "none" })
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/float
 */
export function parse(value: string): Result<Float, string> {
	const normalized = value.trim().toLowerCase();

	if (
		normalized === "left" ||
		normalized === "right" ||
		normalized === "none" ||
		normalized === "inline-start" ||
		normalized === "inline-end"
	) {
		return {
			ok: true,
			value: {
				kind: "float",
				value: normalized as Float["value"],
			},
			error: undefined,
		};
	}

	return {
		ok: false,
		value: undefined,
		error: `Invalid float value: "${value}". Expected: left, right, none, inline-start, or inline-end`,
	};
}


=== File: src/parse/layout/height.test.ts ===
// b_path:: src/parse/layout/height.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./height";

describe("Parse.Layout.Height", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: "auto",
				});
			}
		});
	});

	describe("intrinsic sizing keywords", () => {
		it("parses 'min-content'", () => {
			const result = parse("min-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: "min-content",
				});
			}
		});

		it("parses 'max-content'", () => {
			const result = parse("max-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: "max-content",
				});
			}
		});

		it("parses 'fit-content'", () => {
			const result = parse("fit-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: "fit-content",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses px", () => {
			const result = parse("100px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: { value: 100, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: { value: 5, unit: "em" },
				});
			}
		});

		it("parses vh", () => {
			const result = parse("100vh");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: { value: 100, unit: "vh" },
				});
			}
		});

		it("parses unitless 0", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("percentage values", () => {
		it("parses percentage", () => {
			const result = parse("100%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "height",
					value: { value: 100, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("100px 50px");
			expect(result.ok).toBe(false);
		});

		it("rejects unitless non-zero number", () => {
			const result = parse("100");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("rejects invalid length type", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("handles parse exception", () => {
			const result = parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse height");
			}
		});
	});
});


=== File: src/parse/layout/height.ts ===
// b_path:: src/parse/layout/height.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS height property value.
 *
 * Accepts length-percentage values, auto keyword, or intrinsic sizing keywords.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @param css - CSS height value (e.g., "100px", "50%", "auto", "max-content")
 * @returns Result with Height IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("100px");
 * // { ok: true, value: { kind: "height", value: { value: 100, unit: "px" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "height", value: "auto" } }
 * ```
 *
 * @example
 * Intrinsic sizing:
 * ```typescript
 * const result = parse("max-content");
 * // { ok: true, value: { kind: "height", value: "max-content" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/height | MDN: height}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#width-height-keywords | W3C Spec}
 */
export function parse(css: string): Result<Type.Height, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected height value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			// Check for auto
			if (keyword === "auto") {
				return ok({
					kind: "height",
					value: "auto",
				});
			}

			// Check for intrinsic sizing keywords
			if (keyword === "min-content" || keyword === "max-content" || keyword === "fit-content") {
				return ok({
					kind: "height",
					value: keyword,
				});
			}

			return err(`Invalid height keyword: ${keyword}`);
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "height",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "height",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse height: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/index.ts ===
// b_path:: src/parse/layout/index.ts

export * as Bottom from "./bottom";
export * as BoxSizing from "./box-sizing";
export * as Cursor from "./cursor";
export * as Display from "./display";
export * as Height from "./height";
export * as Left from "./left";
export * as MarginBottom from "./margin-bottom";
export * as MarginLeft from "./margin-left";
export * as MarginRight from "./margin-right";
export * as MarginTop from "./margin-top";
export * as MaxHeight from "./max-height";
export * as MaxWidth from "./max-width";
export * as MinHeight from "./min-height";
export * as MinWidth from "./min-width";
export * as OverflowX from "./overflow-x";
export * as OverflowY from "./overflow-y";
export * as PaddingBottom from "./padding-bottom";
export * as PaddingLeft from "./padding-left";
export * as PaddingRight from "./padding-right";
export * as PaddingTop from "./padding-top";
export * as Position from "./position";
export * as Right from "./right";
export * as Top from "./top";
export * as Width from "./width";
export * as ZIndex from "./z-index";


=== File: src/parse/layout/layout.test.ts ===
// b_path:: src/parse/layout/layout.test.ts
import { describe, expect, it } from "vitest";
import * as Opacity from "@/parse/visual/opacity";
import * as Visibility from "@/parse/visual/visibility";
import * as Cursor from "./cursor";
import * as Display from "./display";

describe("Parse Layout - Cursor", () => {
	it("should parse pointer cursor", () => {
		const result = Cursor.parse("pointer");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "pointer" });
		}
	});

	it("should parse default cursor", () => {
		const result = Cursor.parse("default");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "default" });
		}
	});

	it("should parse text cursor", () => {
		const result = Cursor.parse("text");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "text" });
		}
	});

	it("should parse move cursor", () => {
		const result = Cursor.parse("move");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "move" });
		}
	});

	it("should parse grab cursor", () => {
		const result = Cursor.parse("grab");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "grab" });
		}
	});

	it("should parse grabbing cursor", () => {
		const result = Cursor.parse("grabbing");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "grabbing" });
		}
	});

	it("should parse not-allowed cursor", () => {
		const result = Cursor.parse("not-allowed");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "not-allowed" });
		}
	});

	it("should parse help cursor", () => {
		const result = Cursor.parse("help");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "help" });
		}
	});

	it("should parse wait cursor", () => {
		const result = Cursor.parse("wait");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "wait" });
		}
	});

	it("should parse crosshair cursor", () => {
		const result = Cursor.parse("crosshair");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "crosshair" });
		}
	});

	it("should parse zoom-in cursor", () => {
		const result = Cursor.parse("zoom-in");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "zoom-in" });
		}
	});

	it("should parse zoom-out cursor", () => {
		const result = Cursor.parse("zoom-out");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "cursor", value: "zoom-out" });
		}
	});

	it("should reject invalid cursor value", () => {
		const result = Cursor.parse("invalid");
		expect(result.ok).toBe(false);
	});
});

describe("Parse Layout - Display", () => {
	it("should parse flex display", () => {
		const result = Display.parse("flex");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "flex" });
		}
	});

	it("should parse block display", () => {
		const result = Display.parse("block");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "block" });
		}
	});

	it("should parse inline display", () => {
		const result = Display.parse("inline");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "inline" });
		}
	});

	it("should parse inline-block display", () => {
		const result = Display.parse("inline-block");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "inline-block" });
		}
	});

	it("should parse grid display", () => {
		const result = Display.parse("grid");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "grid" });
		}
	});

	it("should parse none display", () => {
		const result = Display.parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "none" });
		}
	});

	it("should parse table display", () => {
		const result = Display.parse("table");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "table" });
		}
	});

	it("should parse inline-flex display", () => {
		const result = Display.parse("inline-flex");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "inline-flex" });
		}
	});

	it("should parse inline-grid display", () => {
		const result = Display.parse("inline-grid");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "inline-grid" });
		}
	});

	it("should parse contents display", () => {
		const result = Display.parse("contents");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "contents" });
		}
	});

	it("should parse flow-root display", () => {
		const result = Display.parse("flow-root");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "display", value: "flow-root" });
		}
	});

	it("should reject invalid display value", () => {
		const result = Display.parse("invalid");
		expect(result.ok).toBe(false);
	});
});

describe("Parse Layout - Visibility", () => {
	it("should parse visible visibility", () => {
		const result = Visibility.parse("visible");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "visibility", value: "visible" });
		}
	});

	it("should parse hidden visibility", () => {
		const result = Visibility.parse("hidden");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "visibility", value: "hidden" });
		}
	});

	it("should parse collapse visibility", () => {
		const result = Visibility.parse("collapse");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "visibility", value: "collapse" });
		}
	});

	it("should reject invalid visibility value", () => {
		const result = Visibility.parse("invalid");
		expect(result.ok).toBe(false);
	});
});

describe("Parse Layout - Opacity", () => {
	it("should parse opacity 0", () => {
		const result = Opacity.parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0 });
		}
	});

	it("should parse opacity 1", () => {
		const result = Opacity.parse("1");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 1 });
		}
	});

	it("should parse opacity 0.5", () => {
		const result = Opacity.parse("0.5");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0.5 });
		}
	});

	it("should parse opacity percentage 50%", () => {
		const result = Opacity.parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0.5 });
		}
	});

	it("should parse opacity percentage 100%", () => {
		const result = Opacity.parse("100%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 1 });
		}
	});

	it("should parse opacity percentage 0%", () => {
		const result = Opacity.parse("0%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0 });
		}
	});

	it("should clamp opacity above 1", () => {
		const result = Opacity.parse("1.5");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 1 });
		}
	});

	it("should clamp opacity below 0", () => {
		const result = Opacity.parse("-0.5");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ kind: "opacity", value: 0 });
		}
	});

	it("should reject invalid opacity value", () => {
		const result = Opacity.parse("invalid");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/layout/left.test.ts ===
// b_path:: src/parse/layout/left.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./left";

describe("Parse.Layout.Left", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: "auto",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses positive px", () => {
			const result = parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 10, unit: "px" },
				});
			}
		});

		it("parses negative px", () => {
			const result = parse("-10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: -10, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("1.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 1.5, unit: "rem" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("parses positive percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses negative percentage", () => {
			const result = parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: -25, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("10px 20px");
			expect(result.ok).toBe(false);
		});

		it("rejects unitless non-zero number", () => {
			const result = parse("10");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("accepts unitless zero", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "left",
					value: { value: 0, unit: "px" },
				});
			}
		});

		it("rejects invalid length type", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("handles parse exception", () => {
			const result = parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse left");
			}
		});
	});
});


=== File: src/parse/layout/left.ts ===
// b_path:: src/parse/layout/left.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS left property value.
 *
 * Accepts length-percentage values or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS left value (e.g., "10px", "50%", "auto")
 * @returns Result with Left IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("10px");
 * // { ok: true, value: { kind: "left", value: { value: 10, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "left", value: { value: 50, unit: "%" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "left", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/left | MDN: left}
 * @see {@link https://www.w3.org/TR/css-position-3/#insets | W3C Spec}
 */
export function parse(css: string): Result<Type.Left, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected left value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid left keyword: ${keyword}`);
			}
			return ok({
				kind: "left",
				value: "auto",
			});
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "left",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "left",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse left: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/margin-bottom.test.ts ===
// b_path:: src/parse/layout/margin-bottom.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./margin-bottom";

describe("parse margin-bottom", () => {
	it("parses px values", () => {
		const result = parse("10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-bottom");
			expect(result.value.value).toEqual({ value: 10, unit: "px" });
		}
	});

	it("parses percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-bottom");
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("parses auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("auto");
		}
	});

	it("parses em values", () => {
		const result = parse("2em");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 2, unit: "em" });
		}
	});

	it("parses rem values", () => {
		const result = parse("1.5rem");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 1.5, unit: "rem" });
		}
	});

	it("parses zero without unit", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("parses negative values", () => {
		const result = parse("-10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: -10, unit: "px" });
		}
	});

	it("rejects invalid units", () => {
		const result = parse("10invalid");
		expect(result.ok).toBe(false);
	});

	it("rejects multiple values", () => {
		const result = parse("10px 20px");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects non-zero number without unit", () => {
		const result = parse("10");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/layout/margin-bottom.ts ===
// b_path:: src/parse/layout/margin-bottom.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS margin-bottom property value.
 *
 * Accepts length-percentage values or auto keyword.
 *
 * @param css - CSS margin-bottom value (e.g., "10px", "5%", "auto")
 * @returns Result with MarginBottom IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-bottom | MDN: margin-bottom}
 */
export function parse(css: string): Result<Type.MarginBottom, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected margin-bottom value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "auto") {
				return ok({
					kind: "margin-bottom",
					value: "auto",
				});
			}

			return err(`Invalid margin-bottom keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "margin-bottom",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "margin-bottom",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse margin-bottom: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/margin-left.test.ts ===
// b_path:: src/parse/layout/margin-left.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./margin-left";

describe("parse margin-left", () => {
	it("parses px values", () => {
		const result = parse("10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-left");
			expect(result.value.value).toEqual({ value: 10, unit: "px" });
		}
	});

	it("parses percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-left");
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("parses auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("auto");
		}
	});

	it("parses em values", () => {
		const result = parse("2em");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 2, unit: "em" });
		}
	});

	it("parses rem values", () => {
		const result = parse("1.5rem");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 1.5, unit: "rem" });
		}
	});

	it("parses zero without unit", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("parses negative values", () => {
		const result = parse("-10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: -10, unit: "px" });
		}
	});

	it("rejects invalid units", () => {
		const result = parse("10invalid");
		expect(result.ok).toBe(false);
	});

	it("rejects multiple values", () => {
		const result = parse("10px 20px");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects non-zero number without unit", () => {
		const result = parse("10");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/layout/margin-left.ts ===
// b_path:: src/parse/layout/margin-left.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS margin-left property value.
 *
 * Accepts length-percentage values or auto keyword.
 *
 * @param css - CSS margin-left value (e.g., "10px", "5%", "auto")
 * @returns Result with MarginLeft IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-left | MDN: margin-left}
 */
export function parse(css: string): Result<Type.MarginLeft, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected margin-left value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "auto") {
				return ok({
					kind: "margin-left",
					value: "auto",
				});
			}

			return err(`Invalid margin-left keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "margin-left",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "margin-left",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse margin-left: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/margin-right.test.ts ===
// b_path:: src/parse/layout/margin-right.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./margin-right";

describe("parse margin-right", () => {
	it("parses px values", () => {
		const result = parse("10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-right");
			expect(result.value.value).toEqual({ value: 10, unit: "px" });
		}
	});

	it("parses percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-right");
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("parses auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("auto");
		}
	});

	it("parses em values", () => {
		const result = parse("2em");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 2, unit: "em" });
		}
	});

	it("parses rem values", () => {
		const result = parse("1.5rem");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 1.5, unit: "rem" });
		}
	});

	it("parses zero without unit", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("parses negative values", () => {
		const result = parse("-10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: -10, unit: "px" });
		}
	});

	it("rejects invalid units", () => {
		const result = parse("10invalid");
		expect(result.ok).toBe(false);
	});

	it("rejects multiple values", () => {
		const result = parse("10px 20px");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects non-zero number without unit", () => {
		const result = parse("10");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/layout/margin-right.ts ===
// b_path:: src/parse/layout/margin-right.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS margin-right property value.
 *
 * Accepts length-percentage values or auto keyword.
 *
 * @param css - CSS margin-right value (e.g., "10px", "5%", "auto")
 * @returns Result with MarginRight IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-right | MDN: margin-right}
 */
export function parse(css: string): Result<Type.MarginRight, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected margin-right value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "auto") {
				return ok({
					kind: "margin-right",
					value: "auto",
				});
			}

			return err(`Invalid margin-right keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "margin-right",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "margin-right",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse margin-right: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/margin-top.test.ts ===
// b_path:: src/parse/layout/margin-top.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./margin-top";

describe("parse margin-top", () => {
	it("should parse pixel values", () => {
		const result = parse("10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-top");
			expect(result.value.value).toEqual({ value: 10, unit: "px" });
		}
	});

	it("should parse percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-top");
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("should parse auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-top");
			expect(result.value.value).toBe("auto");
		}
	});

	it("should parse unitless zero", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("margin-top");
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("should reject invalid keywords", () => {
		const result = parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("should reject multiple values", () => {
		const result = parse("10px 20px");
		expect(result.ok).toBe(false);
	});

	it("should reject unitless non-zero", () => {
		const result = parse("10");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("require a unit");
		}
	});

	it("should reject invalid value type", () => {
		const result = parse("rgb(255, 0, 0)");
		expect(result.ok).toBe(false);
	});

	it("should handle parse exception", () => {
		const result = parse("@@@");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Failed to parse margin-top");
		}
	});
});


=== File: src/parse/layout/margin-top.ts ===
// b_path:: src/parse/layout/margin-top.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS margin-top property value.
 *
 * Accepts length-percentage values or auto keyword.
 *
 * @param css - CSS margin-top value (e.g., "10px", "5%", "auto")
 * @returns Result with MarginTop IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/margin-top | MDN: margin-top}
 */
export function parse(css: string): Result<Type.MarginTop, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected margin-top value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "auto") {
				return ok({
					kind: "margin-top",
					value: "auto",
				});
			}

			return err(`Invalid margin-top keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "margin-top",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "margin-top",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse margin-top: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/max-height.test.ts ===
// b_path:: src/parse/layout/max-height.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./max-height";

describe("Parse.Layout.MaxHeight", () => {
	describe("none keyword", () => {
		it("parses 'none'", () => {
			const result = parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "max-height",
					value: "none",
				});
			}
		});
	});

	describe("intrinsic sizing keywords", () => {
		it("parses 'min-content'", () => {
			const result = parse("min-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "max-height",
					value: "min-content",
				});
			}
		});

		it("parses 'max-content'", () => {
			const result = parse("max-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "max-height",
					value: "max-content",
				});
			}
		});

		it("parses 'fit-content'", () => {
			const result = parse("fit-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "max-height",
					value: "fit-content",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses px", () => {
			const result = parse("500px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "max-height",
					value: { value: 500, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("10em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "max-height",
					value: { value: 10, unit: "em" },
				});
			}
		});

		it("parses vh", () => {
			const result = parse("100vh");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "max-height",
					value: { value: 100, unit: "vh" },
				});
			}
		});

		it("parses unitless 0", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("percentage values", () => {
		it("parses percentage", () => {
			const result = parse("75%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "max-height",
					value: { value: 75, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("100px 50px");
			expect(result.ok).toBe(false);
		});

		it("rejects unitless non-zero number", () => {
			const result = parse("100");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("rejects invalid length type", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("handles parse exception", () => {
			const result = parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse max-height");
			}
		});
	});
});


=== File: src/parse/layout/max-height.ts ===
// b_path:: src/parse/layout/max-height.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS max-height property value.
 *
 * Accepts length-percentage values, none keyword, or intrinsic sizing keywords.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @param css - CSS max-height value (e.g., "100px", "50%", "none", "max-content")
 * @returns Result with MaxHeight IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/max-height | MDN: max-height}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#max-size-properties | W3C Spec}
 */
export function parse(css: string): Result<Type.MaxHeight, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected max-height value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "none") {
				return ok({
					kind: "max-height",
					value: "none",
				});
			}

			if (keyword === "min-content" || keyword === "max-content" || keyword === "fit-content") {
				return ok({
					kind: "max-height",
					value: keyword,
				});
			}

			return err(`Invalid max-height keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "max-height",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "max-height",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse max-height: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/max-width.test.ts ===
// b_path:: src/parse/layout/max-width.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./max-width";

describe("parse max-width", () => {
	it("should parse pixel values", () => {
		const result = parse("500px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("max-width");
			expect(result.value.value).toEqual({ value: 500, unit: "px" });
		}
	});

	it("should parse percentage values", () => {
		const result = parse("80%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("max-width");
			expect(result.value.value).toEqual({ value: 80, unit: "%" });
		}
	});

	it("should parse none keyword", () => {
		const result = parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("max-width");
			expect(result.value.value).toBe("none");
		}
	});

	it("should parse min-content keyword", () => {
		const result = parse("min-content");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("max-width");
			expect(result.value.value).toBe("min-content");
		}
	});

	it("should parse max-content keyword", () => {
		const result = parse("max-content");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("max-width");
			expect(result.value.value).toBe("max-content");
		}
	});

	it("should reject auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(false);
	});

	it("should parse unitless zero", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("should reject unitless non-zero", () => {
		const result = parse("500");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("require a unit");
		}
	});

	it("should reject multiple values", () => {
		const result = parse("500px 300px");
		expect(result.ok).toBe(false);
	});

	it("should reject invalid value type", () => {
		const result = parse("rgb(255, 0, 0)");
		expect(result.ok).toBe(false);
	});

	it("should handle parse exception", () => {
		const result = parse("@@@");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Failed to parse max-width");
		}
	});
});


=== File: src/parse/layout/max-width.ts ===
// b_path:: src/parse/layout/max-width.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS max-width property value.
 *
 * Accepts length-percentage values, none keyword, or intrinsic sizing keywords.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @param css - CSS max-width value (e.g., "200px", "50%", "none", "min-content")
 * @returns Result with MaxWidth IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/max-width | MDN: max-width}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#max-size-properties | W3C Spec}
 */
export function parse(css: string): Result<Type.MaxWidth, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected max-width value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "none") {
				return ok({
					kind: "max-width",
					value: "none",
				});
			}

			if (keyword === "min-content" || keyword === "max-content" || keyword === "fit-content") {
				return ok({
					kind: "max-width",
					value: keyword,
				});
			}

			return err(`Invalid max-width keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "max-width",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "max-width",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse max-width: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/min-height.test.ts ===
// b_path:: src/parse/layout/min-height.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./min-height";

describe("Parse.Layout.MinHeight", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "min-height",
					value: "auto",
				});
			}
		});
	});

	describe("intrinsic sizing keywords", () => {
		it("parses 'min-content'", () => {
			const result = parse("min-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "min-height",
					value: "min-content",
				});
			}
		});

		it("parses 'max-content'", () => {
			const result = parse("max-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "min-height",
					value: "max-content",
				});
			}
		});

		it("parses 'fit-content'", () => {
			const result = parse("fit-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "min-height",
					value: "fit-content",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses px", () => {
			const result = parse("50px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "min-height",
					value: { value: 50, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "min-height",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses vh", () => {
			const result = parse("100vh");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "min-height",
					value: { value: 100, unit: "vh" },
				});
			}
		});

		it("parses unitless 0", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("percentage values", () => {
		it("parses percentage", () => {
			const result = parse("30%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "min-height",
					value: { value: 30, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("50px 25px");
			expect(result.ok).toBe(false);
		});

		it("rejects unitless non-zero number", () => {
			const result = parse("50");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("rejects invalid length type", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("handles parse exception", () => {
			const result = parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse min-height");
			}
		});
	});
});


=== File: src/parse/layout/min-height.ts ===
// b_path:: src/parse/layout/min-height.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS min-height property value.
 *
 * Accepts length-percentage values, auto keyword, or intrinsic sizing keywords.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @param css - CSS min-height value (e.g., "100px", "50%", "auto", "min-content")
 * @returns Result with MinHeight IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/min-height | MDN: min-height}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#min-size-properties | W3C Spec}
 */
export function parse(css: string): Result<Type.MinHeight, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected min-height value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "auto") {
				return ok({
					kind: "min-height",
					value: "auto",
				});
			}

			if (keyword === "min-content" || keyword === "max-content" || keyword === "fit-content") {
				return ok({
					kind: "min-height",
					value: keyword,
				});
			}

			return err(`Invalid min-height keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "min-height",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "min-height",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse min-height: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/min-width.test.ts ===
// b_path:: src/parse/layout/min-width.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./min-width";

describe("parse min-width", () => {
	it("should parse pixel values", () => {
		const result = parse("200px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("min-width");
			expect(result.value.value).toEqual({ value: 200, unit: "px" });
		}
	});

	it("should parse percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("min-width");
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("should parse auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("min-width");
			expect(result.value.value).toBe("auto");
		}
	});

	it("should parse min-content keyword", () => {
		const result = parse("min-content");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("min-width");
			expect(result.value.value).toBe("min-content");
		}
	});

	it("should parse max-content keyword", () => {
		const result = parse("max-content");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("min-width");
			expect(result.value.value).toBe("max-content");
		}
	});

	it("should parse fit-content keyword", () => {
		const result = parse("fit-content");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("min-width");
			expect(result.value.value).toBe("fit-content");
		}
	});

	it("should parse unitless zero", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("min-width");
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("should reject invalid keywords", () => {
		const result = parse("invalid");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/layout/min-width.ts ===
// b_path:: src/parse/layout/min-width.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS min-width property value.
 *
 * Accepts length-percentage values, auto keyword, or intrinsic sizing keywords.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @param css - CSS min-width value (e.g., "200px", "50%", "auto", "min-content")
 * @returns Result with MinWidth IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/min-width | MDN: min-width}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#min-size-properties | W3C Spec}
 */
export function parse(css: string): Result<Type.MinWidth, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected min-width value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "auto") {
				return ok({
					kind: "min-width",
					value: "auto",
				});
			}

			if (keyword === "min-content" || keyword === "max-content" || keyword === "fit-content") {
				return ok({
					kind: "min-width",
					value: keyword,
				});
			}

			return err(`Invalid min-width keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "min-width",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "min-width",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse min-width: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/overflow-x.failure.test.ts ===
// b_path:: src/parse/layout/overflow-x.failure.test.ts
// Auto-generated from scripts/test-generator/configs/overflow-x.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x
// - W3C: https://www.w3.org/TR/css-overflow-3/#overflow-properties
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/overflow-x";

describe("parse/layout/overflow-x - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid overflow-x keyword: none");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("show");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid overflow-x keyword: show");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});
	});
});


=== File: src/parse/layout/overflow-x.test.ts ===
// b_path:: src/parse/layout/overflow-x.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/overflow-x.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x
// - W3C: https://www.w3.org/TR/css-overflow-3/#overflow-properties
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/overflow-x";

describe("parse/layout/overflow-x - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse visible keyword", () => {
			const result = Parser.parse("visible");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-x",
				value: "visible",
			});
		});

		it("should parse hidden keyword", () => {
			const result = Parser.parse("hidden");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-x",
				value: "hidden",
			});
		});

		it("should parse scroll keyword", () => {
			const result = Parser.parse("scroll");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-x",
				value: "scroll",
			});
		});

		it("should parse auto keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-x",
				value: "auto",
			});
		});

		it("should parse clip keyword", () => {
			const result = Parser.parse("clip");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-x",
				value: "clip",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase hidden", () => {
			const result = Parser.parse("HIDDEN");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-x",
				value: "hidden",
			});
		});

		it("should parse mixed case scroll", () => {
			const result = Parser.parse("Scroll");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-x",
				value: "scroll",
			});
		});
	});
});


=== File: src/parse/layout/overflow-x.ts ===
// b_path:: src/parse/layout/overflow-x.ts
import * as csstree from "css-tree";
import { OVERFLOW_KEYWORDS } from "@/core/keywords/overflow-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS overflow-x property value.
 *
 * Accepts overflow keyword values for horizontal overflow behavior.
 * Per CSS Overflow Module Level 3 specification.
 *
 * @param css - CSS overflow-x value (e.g., "visible", "hidden", "scroll", "auto", "clip")
 * @returns Result with OverflowX IR or error message
 *
 * @example
 * Hidden overflow:
 * ```typescript
 * const result = parse("hidden");
 * // { ok: true, value: { kind: "overflow-x", value: "hidden" } }
 * ```
 *
 * @example
 * Scroll overflow:
 * ```typescript
 * const result = parse("scroll");
 * // { ok: true, value: { kind: "overflow-x", value: "scroll" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-x | MDN: overflow-x}
 * @see {@link https://www.w3.org/TR/css-overflow-3/#overflow-properties | W3C Spec}
 */
export function parse(css: string): Result<Type.OverflowX, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!OVERFLOW_KEYWORDS.includes(keyword as Type.OverflowX["value"])) {
			return err(`Invalid overflow-x keyword: ${keyword}`);
		}

		return ok({
			kind: "overflow-x",
			value: keyword as Type.OverflowX["value"],
		});
	} catch (error) {
		return err(`Failed to parse overflow-x: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/overflow-y.failure.test.ts ===
// b_path:: src/parse/layout/overflow-y.failure.test.ts
// Auto-generated from scripts/test-generator/configs/overflow-y.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y
// - W3C: https://www.w3.org/TR/css-overflow-3/#overflow-properties
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/overflow-y";

describe("parse/layout/overflow-y - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid overflow-y keyword: none");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("show");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid overflow-y keyword: show");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});
	});
});


=== File: src/parse/layout/overflow-y.test.ts ===
// b_path:: src/parse/layout/overflow-y.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/overflow-y.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y
// - W3C: https://www.w3.org/TR/css-overflow-3/#overflow-properties
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/overflow-y";

describe("parse/layout/overflow-y - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse visible keyword", () => {
			const result = Parser.parse("visible");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-y",
				value: "visible",
			});
		});

		it("should parse hidden keyword", () => {
			const result = Parser.parse("hidden");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-y",
				value: "hidden",
			});
		});

		it("should parse scroll keyword", () => {
			const result = Parser.parse("scroll");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-y",
				value: "scroll",
			});
		});

		it("should parse auto keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-y",
				value: "auto",
			});
		});

		it("should parse clip keyword", () => {
			const result = Parser.parse("clip");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-y",
				value: "clip",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase hidden", () => {
			const result = Parser.parse("HIDDEN");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-y",
				value: "hidden",
			});
		});

		it("should parse mixed case scroll", () => {
			const result = Parser.parse("Scroll");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "overflow-y",
				value: "scroll",
			});
		});
	});
});


=== File: src/parse/layout/overflow-y.ts ===
// b_path:: src/parse/layout/overflow-y.ts
import * as csstree from "css-tree";
import { OVERFLOW_KEYWORDS } from "@/core/keywords/overflow-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS overflow-y property value.
 *
 * Accepts overflow keyword values for vertical overflow behavior.
 * Per CSS Overflow Module Level 3 specification.
 *
 * @param css - CSS overflow-y value (e.g., "visible", "hidden", "scroll", "auto", "clip")
 * @returns Result with OverflowY IR or error message
 *
 * @example
 * Hidden overflow:
 * ```typescript
 * const result = parse("hidden");
 * // { ok: true, value: { kind: "overflow-y", value: "hidden" } }
 * ```
 *
 * @example
 * Auto overflow:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "overflow-y", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-y | MDN: overflow-y}
 * @see {@link https://www.w3.org/TR/css-overflow-3/#overflow-properties | W3C Spec}
 */
export function parse(css: string): Result<Type.OverflowY, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!OVERFLOW_KEYWORDS.includes(keyword as Type.OverflowY["value"])) {
			return err(`Invalid overflow-y keyword: ${keyword}`);
		}

		return ok({
			kind: "overflow-y",
			value: keyword as Type.OverflowY["value"],
		});
	} catch (error) {
		return err(`Failed to parse overflow-y: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/overflow.test.ts ===
// b_path:: src/parse/layout/overflow.test.ts

import { describe, expect, it } from "vitest";
import * as Overflow from "./overflow";

describe("parse/layout/overflow", () => {
	describe("valid values", () => {
		it("parses visible", () => {
			const result = Overflow.parse("visible");
			expect(result).toEqual({ ok: true, value: "visible", error: undefined });
		});

		it("parses hidden", () => {
			const result = Overflow.parse("hidden");
			expect(result).toEqual({ ok: true, value: "hidden", error: undefined });
		});

		it("parses clip", () => {
			const result = Overflow.parse("clip");
			expect(result).toEqual({ ok: true, value: "clip", error: undefined });
		});

		it("parses scroll", () => {
			const result = Overflow.parse("scroll");
			expect(result).toEqual({ ok: true, value: "scroll", error: undefined });
		});

		it("parses auto", () => {
			const result = Overflow.parse("auto");
			expect(result).toEqual({ ok: true, value: "auto", error: undefined });
		});
	});

	describe("normalization", () => {
		it("handles uppercase", () => {
			const result = Overflow.parse("HIDDEN");
			expect(result).toEqual({ ok: true, value: "hidden", error: undefined });
		});

		it("handles mixed case", () => {
			const result = Overflow.parse("Auto");
			expect(result).toEqual({ ok: true, value: "auto", error: undefined });
		});

		it("handles whitespace", () => {
			const result = Overflow.parse("  scroll  ");
			expect(result).toEqual({ ok: true, value: "scroll", error: undefined });
		});
	});

	describe("invalid values", () => {
		it("rejects invalid keyword", () => {
			const result = Overflow.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = Overflow.parse("");
			expect(result.ok).toBe(false);
		});

		it("rejects numeric value", () => {
			const result = Overflow.parse("10px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/layout/overflow.ts ===
// b_path:: src/parse/layout/overflow.ts

import type { Result } from "../../core/result";

/**
 * CSS overflow values (applies to both x and y axes)
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/overflow
 */
export type Overflow = "visible" | "hidden" | "clip" | "scroll" | "auto";

/**
 * Parse CSS overflow value.
 *
 * Valid values:
 * - visible: Content not clipped, may render outside box
 * - hidden: Content clipped, no scrollbars
 * - clip: Content hard-clipped at padding box
 * - scroll: Content clipped, scrollbars always shown
 * - auto: Content clipped, scrollbars if needed
 *
 * @param value - CSS overflow value
 * @returns Result with Overflow type or error message
 *
 * @example
 * parse("auto")    // Ok("auto")
 * parse("hidden")  // Ok("hidden")
 * parse("invalid") // Err(...)
 */
export function parse(value: string): Result<Overflow, string> {
	const normalized = value.trim().toLowerCase();

	if (
		normalized === "visible" ||
		normalized === "hidden" ||
		normalized === "clip" ||
		normalized === "scroll" ||
		normalized === "auto"
	) {
		return { ok: true, value: normalized, error: undefined };
	}

	return {
		ok: false,
		value: undefined,
		error: `Invalid overflow value: "${value}". Expected: visible, hidden, clip, scroll, or auto`,
	};
}


=== File: src/parse/layout/padding-bottom.test.ts ===
// b_path:: src/parse/layout/padding-bottom.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./padding-bottom";

describe("parse padding-bottom", () => {
	it("parses px values", () => {
		const result = parse("10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-bottom");
			expect(result.value.value).toEqual({ value: 10, unit: "px" });
		}
	});

	it("parses percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-bottom");
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("parses em values", () => {
		const result = parse("2em");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 2, unit: "em" });
		}
	});

	it("parses rem values", () => {
		const result = parse("1.5rem");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 1.5, unit: "rem" });
		}
	});

	it("parses zero without unit", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("rejects non-zero values without unit", () => {
		const result = parse("10");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("unit");
		}
	});

	it("rejects invalid values", () => {
		expect(parse("auto").ok).toBe(false);
		expect(parse("inherit").ok).toBe(false);
		expect(parse("red").ok).toBe(false);
	});

	it("rejects empty string", () => {
		expect(parse("").ok).toBe(false);
	});

	it("rejects multiple values", () => {
		const result = parse("10px 20px");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("single value");
		}
	});

	it("parses decimal values", () => {
		const result = parse("0.5rem");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value.value).toBe(0.5);
		}
	});

	it("parses different length units", () => {
		const units = ["cm", "mm", "in", "pt", "pc", "vh", "vw", "vmin", "vmax"];
		for (const unit of units) {
			const result = parse(`5${unit}`);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value.unit).toBe(unit);
			}
		}
	});
});


=== File: src/parse/layout/padding-bottom.ts ===
// b_path:: src/parse/layout/padding-bottom.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS padding-bottom property value.
 *
 * Accepts length-percentage values (non-negative).
 *
 * @param css - CSS padding-bottom value (e.g., "10px", "5%")
 * @returns Result with PaddingBottom IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-bottom | MDN: padding-bottom}
 */
export function parse(css: string): Result<Type.PaddingBottom, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected padding-bottom value");
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "padding-bottom",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "padding-bottom",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse padding-bottom: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/padding-left.test.ts ===
// b_path:: src/parse/layout/padding-left.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./padding-left";

describe("parse padding-left", () => {
	it("parses px values", () => {
		const result = parse("10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-left");
			expect(result.value.value).toEqual({ value: 10, unit: "px" });
		}
	});

	it("parses percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-left");
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("parses em values", () => {
		const result = parse("2em");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 2, unit: "em" });
		}
	});

	it("parses rem values", () => {
		const result = parse("1.5rem");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 1.5, unit: "rem" });
		}
	});

	it("parses zero without unit", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("parses vw viewport units", () => {
		const result = parse("10vw");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 10, unit: "vw" });
		}
	});

	it("parses vh viewport units", () => {
		const result = parse("5vh");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 5, unit: "vh" });
		}
	});

	it("rejects invalid units", () => {
		const result = parse("10invalid");
		expect(result.ok).toBe(false);
	});

	it("rejects multiple values", () => {
		const result = parse("10px 20px");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects non-zero number without unit", () => {
		const result = parse("10");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/layout/padding-left.ts ===
// b_path:: src/parse/layout/padding-left.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS padding-left property value.
 *
 * Accepts length-percentage values (non-negative).
 *
 * @param css - CSS padding-left value (e.g., "10px", "5%")
 * @returns Result with PaddingLeft IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-left | MDN: padding-left}
 */
export function parse(css: string): Result<Type.PaddingLeft, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected padding-left value");
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "padding-left",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "padding-left",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse padding-left: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/padding-right.test.ts ===
// b_path:: src/parse/layout/padding-right.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./padding-right";

describe("parse padding-right", () => {
	it("parses px values", () => {
		const result = parse("10px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-right");
			expect(result.value.value).toEqual({ value: 10, unit: "px" });
		}
	});

	it("parses percentage values", () => {
		const result = parse("50%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-right");
			expect(result.value.value).toEqual({ value: 50, unit: "%" });
		}
	});

	it("parses em values", () => {
		const result = parse("2em");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 2, unit: "em" });
		}
	});

	it("parses rem values", () => {
		const result = parse("1.5rem");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 1.5, unit: "rem" });
		}
	});

	it("parses zero without unit", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("parses vw viewport units", () => {
		const result = parse("10vw");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 10, unit: "vw" });
		}
	});

	it("parses vh viewport units", () => {
		const result = parse("5vh");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toEqual({ value: 5, unit: "vh" });
		}
	});

	it("rejects invalid units", () => {
		const result = parse("10invalid");
		expect(result.ok).toBe(false);
	});

	it("rejects multiple values", () => {
		const result = parse("10px 20px");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("rejects non-zero number without unit", () => {
		const result = parse("10");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/layout/padding-right.ts ===
// b_path:: src/parse/layout/padding-right.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS padding-right property value.
 *
 * Accepts length-percentage values (non-negative).
 *
 * @param css - CSS padding-right value (e.g., "10px", "5%")
 * @returns Result with PaddingRight IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-right | MDN: padding-right}
 */
export function parse(css: string): Result<Type.PaddingRight, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected padding-right value");
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "padding-right",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "padding-right",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse padding-right: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/padding-top.test.ts ===
// b_path:: src/parse/layout/padding-top.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./padding-top";

describe("parse padding-top", () => {
	it("should parse pixel values", () => {
		const result = parse("15px");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-top");
			expect(result.value.value).toEqual({ value: 15, unit: "px" });
		}
	});

	it("should parse percentage values", () => {
		const result = parse("10%");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-top");
			expect(result.value.value).toEqual({ value: 10, unit: "%" });
		}
	});

	it("should parse unitless zero", () => {
		const result = parse("0");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("padding-top");
			expect(result.value.value).toEqual({ value: 0, unit: "px" });
		}
	});

	it("should reject auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(false);
	});

	it("should reject invalid keywords", () => {
		const result = parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("should reject multiple values", () => {
		const result = parse("15px 20px");
		expect(result.ok).toBe(false);
	});

	it("should reject unitless non-zero", () => {
		const result = parse("15");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("require a unit");
		}
	});

	it("should reject invalid value type", () => {
		const result = parse("rgb(255, 0, 0)");
		expect(result.ok).toBe(false);
	});

	it("should handle parse exception", () => {
		const result = parse("@@@");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Failed to parse padding-top");
		}
	});
});


=== File: src/parse/layout/padding-top.ts ===
// b_path:: src/parse/layout/padding-top.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS padding-top property value.
 *
 * Accepts length-percentage values (non-negative).
 *
 * @param css - CSS padding-top value (e.g., "10px", "5%")
 * @returns Result with PaddingTop IR or error message
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/padding-top | MDN: padding-top}
 */
export function parse(css: string): Result<Type.PaddingTop, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected padding-top value");
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "padding-top",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "padding-top",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse padding-top: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/position.failure.test.ts ===
// b_path:: src/parse/layout/position.failure.test.ts
// Auto-generated from scripts/test-generator/configs/position.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/position
// - W3C: https://www.w3.org/TR/css-position-3/#position-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/position";

describe("parse/layout/position - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid position keyword: none");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid position keyword: auto");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});
	});
});


=== File: src/parse/layout/position.test.ts ===
// b_path:: src/parse/layout/position.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/position.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/position
// - W3C: https://www.w3.org/TR/css-position-3/#position-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/layout/position";

describe("parse/layout/position - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse static keyword", () => {
			const result = Parser.parse("static");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "position",
				value: "static",
			});
		});

		it("should parse relative keyword", () => {
			const result = Parser.parse("relative");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "position",
				value: "relative",
			});
		});

		it("should parse absolute keyword", () => {
			const result = Parser.parse("absolute");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "position",
				value: "absolute",
			});
		});

		it("should parse fixed keyword", () => {
			const result = Parser.parse("fixed");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "position",
				value: "fixed",
			});
		});

		it("should parse sticky keyword", () => {
			const result = Parser.parse("sticky");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "position",
				value: "sticky",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase relative", () => {
			const result = Parser.parse("RELATIVE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "position",
				value: "relative",
			});
		});

		it("should parse mixed case absolute", () => {
			const result = Parser.parse("Absolute");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "position",
				value: "absolute",
			});
		});
	});
});


=== File: src/parse/layout/position.ts ===
// b_path:: src/parse/layout/position.ts
import * as csstree from "css-tree";
import { POSITION_PROPERTY_KEYWORDS } from "@/core/keywords/position-property-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS position property value.
 *
 * Accepts position keyword values that control positioning scheme.
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS position value (e.g., "static", "relative", "absolute", "fixed", "sticky")
 * @returns Result with PositionProperty IR or error message
 *
 * @example
 * Absolute positioning:
 * ```typescript
 * const result = parse("absolute");
 * // { ok: true, value: { kind: "position", value: "absolute" } }
 * ```
 *
 * @example
 * Sticky positioning:
 * ```typescript
 * const result = parse("sticky");
 * // { ok: true, value: { kind: "position", value: "sticky" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position | MDN: position}
 * @see {@link https://www.w3.org/TR/css-position-3/#position-property | W3C Spec}
 */
export function parse(css: string): Result<Type.PositionProperty, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!POSITION_PROPERTY_KEYWORDS.includes(keyword as Type.PositionProperty["value"])) {
			return err(`Invalid position keyword: ${keyword}`);
		}

		return ok({
			kind: "position",
			value: keyword as Type.PositionProperty["value"],
		});
	} catch (error) {
		return err(`Failed to parse position: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/right.test.ts ===
// b_path:: src/parse/layout/right.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./right";

describe("Parse.Layout.Right", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: "auto",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses positive px", () => {
			const result = parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 10, unit: "px" },
				});
			}
		});

		it("parses negative px", () => {
			const result = parse("-10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: -10, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("1.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 1.5, unit: "rem" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("parses positive percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses negative percentage", () => {
			const result = parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: -25, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("10px 20px");
			expect(result.ok).toBe(false);
		});

		it("rejects unitless non-zero number", () => {
			const result = parse("10");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("accepts unitless zero", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "right",
					value: { value: 0, unit: "px" },
				});
			}
		});

		it("rejects invalid length type", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("handles parse exception", () => {
			const result = parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse right");
			}
		});
	});
});


=== File: src/parse/layout/right.ts ===
// b_path:: src/parse/layout/right.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS right property value.
 *
 * Accepts length-percentage values or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS right value (e.g., "10px", "50%", "auto")
 * @returns Result with Right IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("10px");
 * // { ok: true, value: { kind: "right", value: { value: 10, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "right", value: { value: 50, unit: "%" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "right", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/right | MDN: right}
 * @see {@link https://www.w3.org/TR/css-position-3/#insets | W3C Spec}
 */
export function parse(css: string): Result<Type.Right, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected right value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid right keyword: ${keyword}`);
			}
			return ok({
				kind: "right",
				value: "auto",
			});
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "right",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "right",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse right: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/top.test.ts ===
// b_path:: src/parse/layout/top.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./top";

describe("Parse.Layout.Top", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: "auto",
				});
			}
		});

		it("parses 'AUTO' (case insensitive)", () => {
			const result = parse("AUTO");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("auto");
			}
		});
	});

	describe("length values", () => {
		it("parses positive px", () => {
			const result = parse("10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 10, unit: "px" },
				});
			}
		});

		it("parses negative px", () => {
			const result = parse("-10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: -10, unit: "px" },
				});
			}
		});

		it("parses zero", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});

		it("parses em", () => {
			const result = parse("2em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 2, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("1.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 1.5, unit: "rem" },
				});
			}
		});

		it("parses vh", () => {
			const result = parse("50vh");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 50, unit: "vh" },
				});
			}
		});

		it("parses vw", () => {
			const result = parse("100vw");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 100, unit: "vw" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("parses positive percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses negative percentage", () => {
			const result = parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: -25, unit: "%" },
				});
			}
		});

		it("parses zero percentage", () => {
			const result = parse("0%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "%" });
			}
		});

		it("parses decimal percentage", () => {
			const result = parse("33.33%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "top",
					value: { value: 33.33, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("10px 20px");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid unit", () => {
			const result = parse("10xyz");
			expect(result.ok).toBe(false);
		});

		it("rejects empty string", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});

		it("rejects unitless non-zero", () => {
			const result = parse("10");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("rejects invalid value type", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("handles parse exception", () => {
			const result = parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse top");
			}
		});
	});
});


=== File: src/parse/layout/top.ts ===
// b_path:: src/parse/layout/top.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS top property value.
 *
 * Accepts length-percentage values or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS top value (e.g., "10px", "50%", "auto")
 * @returns Result with Top IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("10px");
 * // { ok: true, value: { kind: "top", value: { value: 10, unit: "px" } } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "top", value: { value: 50, unit: "%" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "top", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/top | MDN: top}
 * @see {@link https://www.w3.org/TR/css-position-3/#insets | W3C Spec}
 */
export function parse(css: string): Result<Type.Top, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected top value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid top keyword: ${keyword}`);
			}
			return ok({
				kind: "top",
				value: "auto",
			});
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "top",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "top",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse top: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/width.test.ts ===
// b_path:: src/parse/layout/width.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./width";

describe("Parse.Layout.Width", () => {
	describe("auto keyword", () => {
		it("parses 'auto'", () => {
			const result = parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: "auto",
				});
			}
		});
	});

	describe("intrinsic sizing keywords", () => {
		it("parses 'min-content'", () => {
			const result = parse("min-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: "min-content",
				});
			}
		});

		it("parses 'max-content'", () => {
			const result = parse("max-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: "max-content",
				});
			}
		});

		it("parses 'fit-content'", () => {
			const result = parse("fit-content");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: "fit-content",
				});
			}
		});
	});

	describe("length values", () => {
		it("parses px", () => {
			const result = parse("200px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 200, unit: "px" },
				});
			}
		});

		it("parses em", () => {
			const result = parse("10em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 10, unit: "em" },
				});
			}
		});

		it("parses rem", () => {
			const result = parse("2.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 2.5, unit: "rem" },
				});
			}
		});

		it("parses vw", () => {
			const result = parse("100vw");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 100, unit: "vw" },
				});
			}
		});

		it("parses unitless 0", () => {
			const result = parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("percentage values", () => {
		it("parses percentage", () => {
			const result = parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("parses decimal percentage", () => {
			const result = parse("33.33%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "width",
					value: { value: 33.33, unit: "%" },
				});
			}
		});
	});

	describe("error cases", () => {
		it("rejects invalid keyword", () => {
			const result = parse("inherit");
			expect(result.ok).toBe(false);
		});

		it("rejects multiple values", () => {
			const result = parse("100px 200px");
			expect(result.ok).toBe(false);
		});

		it("rejects negative values", () => {
			const result = parse("-100px");
			expect(result.ok).toBe(true); // CSS allows negative widths (they're clamped to 0)
		});

		it("rejects unitless non-zero", () => {
			const result = parse("100");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("rejects invalid value type", () => {
			const result = parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("handles parse exception", () => {
			const result = parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse width");
			}
		});
	});
});


=== File: src/parse/layout/width.ts ===
// b_path:: src/parse/layout/width.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS width property value.
 *
 * Accepts length-percentage values, auto keyword, or intrinsic sizing keywords.
 * Per CSS Sizing Module Level 3 specification.
 *
 * @param css - CSS width value (e.g., "200px", "50%", "auto", "min-content")
 * @returns Result with Width IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("200px");
 * // { ok: true, value: { kind: "width", value: { value: 200, unit: "px" } } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "width", value: "auto" } }
 * ```
 *
 * @example
 * Intrinsic sizing:
 * ```typescript
 * const result = parse("min-content");
 * // { ok: true, value: { kind: "width", value: "min-content" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/width | MDN: width}
 * @see {@link https://www.w3.org/TR/css-sizing-3/#width-height-keywords | W3C Spec}
 */
export function parse(css: string): Result<Type.Width, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected width value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			// Check for auto
			if (keyword === "auto") {
				return ok({
					kind: "width",
					value: "auto",
				});
			}

			// Check for intrinsic sizing keywords
			if (keyword === "min-content" || keyword === "max-content" || keyword === "fit-content") {
				return ok({
					kind: "width",
					value: keyword,
				});
			}

			return err(`Invalid width keyword: ${keyword}`);
		}

		// Handle unitless 0 (parsed as Number by csstree)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "width",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "width",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse width: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/layout/z-index.test.ts ===
// b_path:: src/parse/layout/z-index.test.ts
import { describe, expect, it } from "vitest";
import * as Parse from "@/parse";

describe("Parse.Layout.ZIndex", () => {
	describe("valid integer values", () => {
		it("should parse positive integer", () => {
			const result = Parse.Layout.ZIndex.parse("10");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: 10,
				});
			}
		});

		it("should parse negative integer", () => {
			const result = Parse.Layout.ZIndex.parse("-5");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: -5,
				});
			}
		});

		it("should parse zero", () => {
			const result = Parse.Layout.ZIndex.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: 0,
				});
			}
		});

		it("should parse large positive integer", () => {
			const result = Parse.Layout.ZIndex.parse("999");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: 999,
				});
			}
		});

		it("should parse large negative integer", () => {
			const result = Parse.Layout.ZIndex.parse("-999");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: -999,
				});
			}
		});
	});

	describe("auto keyword", () => {
		it("should parse 'auto'", () => {
			const result = Parse.Layout.ZIndex.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "z-index",
					value: "auto",
				});
			}
		});

		it("should parse 'AUTO' (case insensitive)", () => {
			const result = Parse.Layout.ZIndex.parse("AUTO");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("auto");
			}
		});
	});

	describe("invalid values", () => {
		it("should reject decimal/float values", () => {
			const result = Parse.Layout.ZIndex.parse("1.5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("must be an integer");
			}
		});

		it("should reject percentage", () => {
			const result = Parse.Layout.ZIndex.parse("50%");
			expect(result.ok).toBe(false);
		});

		it("should reject length units", () => {
			const result = Parse.Layout.ZIndex.parse("10px");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid keyword", () => {
			const result = Parse.Layout.ZIndex.parse("inherit");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid z-index keyword");
			}
		});

		it("should reject empty string", () => {
			const result = Parse.Layout.ZIndex.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = Parse.Layout.ZIndex.parse("10 20");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected single value");
			}
		});

		it("should handle parse exception", () => {
			const result = Parse.Layout.ZIndex.parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse z-index");
			}
		});
	});
});


=== File: src/parse/layout/z-index.ts ===
// b_path:: src/parse/layout/z-index.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS z-index property value.
 *
 * Accepts integer values (positive, negative, or zero) or the keyword "auto".
 * Per CSS Positioned Layout Module Level 3 specification.
 *
 * @param css - CSS z-index value (e.g., "10", "-5", "0", "auto")
 * @returns Result with ZIndex IR or error message
 *
 * @example
 * Positive integer:
 * ```typescript
 * const result = parse("10");
 * // { ok: true, value: { kind: "z-index", value: 10 } }
 * ```
 *
 * @example
 * Negative integer:
 * ```typescript
 * const result = parse("-5");
 * // { ok: true, value: { kind: "z-index", value: -5 } }
 * ```
 *
 * @example
 * Auto keyword:
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "z-index", value: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/z-index | MDN: z-index}
 * @see {@link https://www.w3.org/TR/css-position-3/#z-index | W3C Spec}
 */
export function parse(css: string): Result<Type.ZIndex, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected z-index value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			if (keyword !== "auto") {
				return err(`Invalid z-index keyword: ${keyword}`);
			}
			return ok({
				kind: "z-index",
				value: "auto",
			});
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);

			// Check if it's an integer
			if (!Number.isInteger(value)) {
				return err(`z-index must be an integer, got: ${value}`);
			}

			return ok({
				kind: "z-index",
				value,
			});
		}

		return err(`Expected integer or 'auto', got: ${node.type}`);
	} catch (error) {
		return err(`Failed to parse z-index: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/outline/color.test.ts ===
// b_path:: src/parse/outline/color.test.ts
import { describe, expect, it } from "vitest";
import * as OutlineColor from "./color";

describe("Parse.Border.Color", () => {
	describe("valid keywords", () => {
		it("should parse 'invert'", () => {
			const result = OutlineColor.parse("invert");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "invert",
				});
			}
		});

		it("should parse 'transparent'", () => {
			const result = OutlineColor.parse("transparent");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "transparent",
				});
			}
		});

		it("should parse 'currentcolor'", () => {
			const result = OutlineColor.parse("currentcolor");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "currentcolor",
				});
			}
		});

		it("should parse 'red'", () => {
			const result = OutlineColor.parse("red");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "red",
				});
			}
		});

		it("should parse 'blue'", () => {
			const result = OutlineColor.parse("blue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "blue",
				});
			}
		});

		it("should parse 'green'", () => {
			const result = OutlineColor.parse("green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "green",
				});
			}
		});

		it("should parse 'black'", () => {
			const result = OutlineColor.parse("black");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "black",
				});
			}
		});

		it("should parse 'white'", () => {
			const result = OutlineColor.parse("white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-color",
					color: "white",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = OutlineColor.parse("notacolor");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("color keyword");
			}
		});

		it("should reject length values", () => {
			const result = OutlineColor.parse("1px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OutlineColor.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OutlineColor.parse("red blue");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/color.ts ===
// b_path:: src/parse/outline/color.ts
import * as csstree from "css-tree";
import { ALL_NAMED_COLOR_KEYWORDS } from "@/core/keywords/color-value-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS outline-color property value.
 *
 * Accepts color keywords (currentcolor, transparent, named colors, invert).
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * Note: This parser currently handles color keywords only.
 * For full color support (rgb, hsl, hex, etc.), use the color parsers.
 *
 * @param css - CSS outline-color value (e.g., "red", "transparent", "invert")
 * @returns Result with OutlineColor IR or error message
 *
 * @example
 * Named color:
 * ```typescript
 * const result = parse("red");
 * // { ok: true, value: { kind: "outline-color", color: "red" } }
 * ```
 *
 * @example
 * Invert (outline-specific):
 * ```typescript
 * const result = parse("invert");
 * // { ok: true, value: { kind: "outline-color", color: "invert" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-color | MDN: outline-color}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-color | W3C Spec}
 */
export function parse(css: string): Result<Type.OutlineColorValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single outline-color value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty outline-color value");
		}

		if (node.type !== "Identifier") {
			return err(`Expected color keyword for outline-color, got: ${node.type}`);
		}

		const keyword = node.name.toLowerCase();

		// Check for 'invert' which is outline-specific
		if (keyword === "invert") {
			return ok({
				kind: "outline-color",
				color: "invert",
			});
		}

		// Check standard color keywords
		if (!ALL_NAMED_COLOR_KEYWORDS.includes(keyword as (typeof ALL_NAMED_COLOR_KEYWORDS)[number])) {
			return err(`Invalid color keyword: ${keyword}`);
		}

		return ok({
			kind: "outline-color",
			color: keyword as (typeof ALL_NAMED_COLOR_KEYWORDS)[number] | "invert",
		});
	} catch (e) {
		return err(`Failed to parse outline-color: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/outline/index.ts ===
// b_path:: src/parse/outline/index.ts

export * as Color from "./color";
export * as Offset from "./offset";
export { parse } from "./outline";
export * as Style from "./style";
export * as Width from "./width";


=== File: src/parse/outline/offset.test.ts ===
// b_path:: src/parse/outline/offset.test.ts
import { describe, expect, it } from "vitest";
import * as OutlineOffset from "./offset";

describe("Parse.Outline.Offset", () => {
	describe("valid lengths", () => {
		it("should parse '0' (unitless zero)", () => {
			const result = OutlineOffset.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '5px'", () => {
			const result = OutlineOffset.parse("5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 5, unit: "px" },
				});
			}
		});

		it("should parse '2.5em'", () => {
			const result = OutlineOffset.parse("2.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 2.5, unit: "em" },
				});
			}
		});

		it("should parse '0.5rem'", () => {
			const result = OutlineOffset.parse("0.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 0.5, unit: "rem" },
				});
			}
		});

		it("should parse '10pt'", () => {
			const result = OutlineOffset.parse("10pt");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: 10, unit: "pt" },
				});
			}
		});
	});

	describe("negative values", () => {
		it("should parse '-1px'", () => {
			const result = OutlineOffset.parse("-1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: -1, unit: "px" },
				});
			}
		});

		it("should parse '-2.5em'", () => {
			const result = OutlineOffset.parse("-2.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-offset",
					offset: { value: -2.5, unit: "em" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keywords", () => {
			const result = OutlineOffset.parse("auto");
			expect(result.ok).toBe(false);
		});

		it("should reject unitless non-zero", () => {
			const result = OutlineOffset.parse("5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless");
			}
		});

		it("should reject percentage values", () => {
			const result = OutlineOffset.parse("50%");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OutlineOffset.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OutlineOffset.parse("1px 2px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/offset.ts ===
// b_path:: src/parse/outline/offset.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { ABSOLUTE_LENGTH_UNITS, FONT_LENGTH_UNITS, VIEWPORT_LENGTH_UNITS } from "@/core/units";

/**
 * Parse CSS outline-offset property value.
 *
 * Accepts length values (can be negative unlike border/outline-width).
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param css - CSS outline-offset value (e.g., "5px", "-2px", "0.5em")
 * @returns Result with OutlineOffset IR or error message
 *
 * @example
 * Positive offset:
 * ```typescript
 * const result = parse("5px");
 * // { ok: true, value: { kind: "outline-offset", offset: { value: 5, unit: "px" } } }
 * ```
 *
 * @example
 * Negative offset:
 * ```typescript
 * const result = parse("-2px");
 * // { ok: true, value: { kind: "outline-offset", offset: { value: -2, unit: "px" } } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-offset | MDN: outline-offset}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-offset | W3C Spec}
 */
export function parse(css: string): Result<Type.OutlineOffsetValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single outline-offset value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty outline-offset value");
		}

		// Handle zero without unit
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value !== 0) {
				return err("Unitless values must be zero");
			}
			return ok({
				kind: "outline-offset",
				offset: {
					value: 0,
					unit: "px",
				},
			});
		}

		// Handle length (including negative values)
		if (node.type === "Dimension") {
			const value = Number.parseFloat(node.value);
			const unit = node.unit.toLowerCase();

			const allLengthUnits = [...ABSOLUTE_LENGTH_UNITS, ...FONT_LENGTH_UNITS, ...VIEWPORT_LENGTH_UNITS];
			if (!allLengthUnits.includes(unit as (typeof allLengthUnits)[number])) {
				return err(`Invalid length unit for outline-offset: ${unit}`);
			}

			return ok({
				kind: "outline-offset",
				offset: {
					value,
					unit: unit as (typeof allLengthUnits)[number],
				},
			});
		}

		return err(`Unexpected node type: ${node.type}`);
	} catch (e) {
		return err(`Failed to parse outline-offset: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/outline/outline.test.ts ===
// b_path:: src/parse/outline/outline.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./outline";

describe("parse outline dispatcher", () => {
	describe("dispatches to Width parser", () => {
		it("parses thin keyword", () => {
			const result = parse("thin");
			expect(result.ok).toBe(true);
		});

		it("parses length value", () => {
			const result = parse("3px");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Style parser", () => {
		it("parses solid", () => {
			const result = parse("solid");
			expect(result.ok).toBe(true);
		});

		it("parses dotted", () => {
			const result = parse("dotted");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Color parser", () => {
		it("parses named color", () => {
			const result = parse("blue");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Offset parser", () => {
		it("parses offset length", () => {
			const result = parse("2px");
			expect(result.ok).toBe(true);
		});
	});

	describe("error handling", () => {
		it("rejects invalid value", () => {
			const result = parse("invalid-outline-xyz");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues.length).toBeGreaterThan(0);
			}
		});

		it("rejects empty string", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/outline.ts ===
// b_path:: src/parse/outline/outline.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";

import * as Color from "./color";
import * as Offset from "./offset";
import * as Style from "./style";
import * as Width from "./width";

export function parse(value: string): ParseResult<unknown> {
	const widthResult = Width.parse(value);
	if (widthResult.ok) return toParseResult(widthResult);

	const styleResult = Style.parse(value);
	if (styleResult.ok) return toParseResult(styleResult);

	const colorResult = Color.parse(value);
	if (colorResult.ok) return toParseResult(colorResult);

	const offsetResult = Offset.parse(value);
	if (offsetResult.ok) return toParseResult(offsetResult);

	return parseErr("invalid-value", "Invalid outline property value", {
		suggestion: "Expected width, style, color, or offset",
	});
}


=== File: src/parse/outline/style.test.ts ===
// b_path:: src/parse/outline/style.test.ts
import { describe, expect, it } from "vitest";
import * as OutlineStyle from "./style";

describe("Parse.Border.Style", () => {
	describe("valid keywords", () => {
		it("should parse 'auto'", () => {
			const result = OutlineStyle.parse("auto");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "auto",
				});
			}
		});

		it("should parse 'none'", () => {
			const result = OutlineStyle.parse("none");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "none",
				});
			}
		});

		it("should parse 'hidden'", () => {
			const result = OutlineStyle.parse("hidden");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "hidden",
				});
			}
		});

		it("should parse 'dotted'", () => {
			const result = OutlineStyle.parse("dotted");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "dotted",
				});
			}
		});

		it("should parse 'dashed'", () => {
			const result = OutlineStyle.parse("dashed");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "dashed",
				});
			}
		});

		it("should parse 'solid'", () => {
			const result = OutlineStyle.parse("solid");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "solid",
				});
			}
		});

		it("should parse 'double'", () => {
			const result = OutlineStyle.parse("double");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "double",
				});
			}
		});

		it("should parse 'groove'", () => {
			const result = OutlineStyle.parse("groove");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "groove",
				});
			}
		});

		it("should parse 'ridge'", () => {
			const result = OutlineStyle.parse("ridge");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "ridge",
				});
			}
		});

		it("should parse 'inset'", () => {
			const result = OutlineStyle.parse("inset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "inset",
				});
			}
		});

		it("should parse 'outset'", () => {
			const result = OutlineStyle.parse("outset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-style",
					style: "outset",
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = OutlineStyle.parse("wavy");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("keyword");
			}
		});

		it("should reject length values", () => {
			const result = OutlineStyle.parse("1px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OutlineStyle.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OutlineStyle.parse("solid dashed");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/style.ts ===
// b_path:: src/parse/outline/style.ts
import * as csstree from "css-tree";
import { OUTLINE_STYLE_KEYWORDS } from "@/core/keywords/outline-style-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS outline-style property value.
 *
 * Accepts predefined style keywords including 'auto' (outline-specific).
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param css - CSS outline-style value (e.g., "solid", "dashed", "auto")
 * @returns Result with OutlineStyle IR or error message
 *
 * @example
 * Solid outline:
 * ```typescript
 * const result = parse("solid");
 * // { ok: true, value: { kind: "outline-style", style: "solid" } }
 * ```
 *
 * @example
 * Auto outline (browser-determined):
 * ```typescript
 * const result = parse("auto");
 * // { ok: true, value: { kind: "outline-style", style: "auto" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style | MDN: outline-style}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-style | W3C Spec}
 */
export function parse(css: string): Result<Type.OutlineStyleValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single outline-style value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty outline-style value");
		}

		if (node.type !== "Identifier") {
			return err(`Expected keyword for outline-style, got: ${node.type}`);
		}

		const keyword = node.name.toLowerCase();
		if (!OUTLINE_STYLE_KEYWORDS.includes(keyword as Type.OutlineStyle)) {
			return err(`Invalid outline-style keyword: ${keyword}`);
		}

		return ok({
			kind: "outline-style",
			style: keyword as Type.OutlineStyle,
		});
	} catch (e) {
		return err(`Failed to parse outline-style: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/outline/width.test.ts ===
// b_path:: src/parse/outline/width.test.ts
import { describe, expect, it } from "vitest";
import * as OutlineWidth from "./width";

describe("Parse.Outline.Width", () => {
	describe("valid keywords", () => {
		it("should parse 'thin'", () => {
			const result = OutlineWidth.parse("thin");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: "thin",
				});
			}
		});

		it("should parse 'medium'", () => {
			const result = OutlineWidth.parse("medium");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: "medium",
				});
			}
		});

		it("should parse 'thick'", () => {
			const result = OutlineWidth.parse("thick");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: "thick",
				});
			}
		});
	});

	describe("valid lengths", () => {
		it("should parse '0' (unitless zero)", () => {
			const result = OutlineWidth.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '1px'", () => {
			const result = OutlineWidth.parse("1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 1, unit: "px" },
				});
			}
		});

		it("should parse '2.5em'", () => {
			const result = OutlineWidth.parse("2.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 2.5, unit: "em" },
				});
			}
		});

		it("should parse '0.5rem'", () => {
			const result = OutlineWidth.parse("0.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 0.5, unit: "rem" },
				});
			}
		});

		it("should parse '10pt'", () => {
			const result = OutlineWidth.parse("10pt");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "outline-width",
					width: { value: 10, unit: "pt" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject negative values", () => {
			const result = OutlineWidth.parse("-1px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject invalid keywords", () => {
			const result = OutlineWidth.parse("large");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("keyword");
			}
		});

		it("should reject unitless non-zero", () => {
			const result = OutlineWidth.parse("5");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless");
			}
		});

		it("should reject percentage values", () => {
			const result = OutlineWidth.parse("50%");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OutlineWidth.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OutlineWidth.parse("1px 2px");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/outline/width.ts ===
// b_path:: src/parse/outline/width.ts
import * as csstree from "css-tree";
import { BORDER_WIDTH_KEYWORDS } from "@/core/keywords/border-width-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { ABSOLUTE_LENGTH_UNITS, FONT_LENGTH_UNITS, VIEWPORT_LENGTH_UNITS } from "@/core/units";

/**
 * Parse CSS outline-width property value.
 *
 * Accepts length values or predefined keywords (thin, medium, thick).
 * Per CSS Basic User Interface Module Level 3 specification.
 *
 * @param css - CSS outline-width value (e.g., "1px", "medium", "0.5em")
 * @returns Result with OutlineWidth IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("1px");
 * // { ok: true, value: { kind: "outline-width", width: { value: 1, unit: "px" } } }
 * ```
 *
 * @example
 * Keyword value:
 * ```typescript
 * const result = parse("medium");
 * // { ok: true, value: { kind: "outline-width", width: "medium" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-width | MDN: outline-width}
 * @see {@link https://www.w3.org/TR/css-ui-3/#outline-width | W3C Spec}
 */
export function parse(css: string): Result<Type.OutlineWidthValue, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();
		if (children.length !== 1) {
			return err("Expected single outline-width value");
		}

		const node = children[0];
		if (!node) {
			return err("Empty outline-width value");
		}

		// Handle keywords
		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			const keywordValue = keyword as "thin" | "medium" | "thick";
			if (BORDER_WIDTH_KEYWORDS.includes(keywordValue)) {
				return ok({
					kind: "outline-width",
					width: keywordValue,
				});
			}
			return err(`Invalid outline-width keyword: ${keyword}`);
		}

		// Handle length
		if (node.type === "Dimension") {
			const value = Number.parseFloat(node.value);
			const unit = node.unit.toLowerCase();

			const allLengthUnits = [...ABSOLUTE_LENGTH_UNITS, ...FONT_LENGTH_UNITS, ...VIEWPORT_LENGTH_UNITS];
			if (!allLengthUnits.includes(unit as (typeof allLengthUnits)[number])) {
				return err(`Invalid length unit for outline-width: ${unit}`);
			}

			if (value < 0) {
				return err(`outline-width must be non-negative, got: ${value}`);
			}

			return ok({
				kind: "outline-width",
				width: {
					value,
					unit: unit as (typeof allLengthUnits)[number],
				},
			});
		}

		// Handle zero without unit
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value !== 0) {
				return err("Unitless values must be zero");
			}
			return ok({
				kind: "outline-width",
				width: {
					value: 0,
					unit: "px",
				},
			});
		}

		return err(`Unexpected node type: ${node.type}`);
	} catch (e) {
		return err(`Failed to parse outline-width: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/position/index.ts ===
// b_path:: src/parse/position/index.ts

export * as Position from "./position";
export { parse, parse3D, parseList } from "./position";


=== File: src/parse/position/position.ts ===
// b_path:: src/parse/position/position.ts
import type * as csstree from "css-tree";
import { err, ok, type ParseResult, parseErr, parseOk, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse position value from CSS node.
 *
 * Handles both keyword positions (center, left, top, etc.) and length/percentage values.
 *
 * @param node - CSS AST node
 * @returns Result containing PositionValue IR or error message
 *
 * @internal
 */
function parsePositionValue(node: csstree.CssNode): Result<Type.PositionValue, string> {
	// Use shared utility that handles both keywords and length-percentage values
	return ParseUtils.parsePositionValueNode(node);
}

/**
 * Parse 2D position from CSS nodes.
 *
 * Handles CSS position syntax: [ [ left | center | right | top | bottom | <length-percentage> ] |
 *                             [ left | center | right ] && [ top | center | bottom ] |
 *                             [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] |
 *                             [ [ center | [ left | right ] <length-percentage>? ] &&
 *                               [ center | [ top | bottom ] <length-percentage>? ] ] ]
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @returns Result containing Position2D IR and next index, or error message
 *
 * @internal
 */
function parsePosition2DFromNodes(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Collect position values (1 or 2 values)
	const positionValues: Type.PositionValue[] = [];

	// Parse first value
	if (idx >= nodes.length) {
		return err("Expected position value");
	}

	const firstNode = nodes[idx];
	if (!firstNode) return err("Missing first position value");
	const firstValue = parsePositionValue(firstNode);
	if (!firstValue.ok) {
		return err(`Invalid first position value: ${firstValue.error}`);
	}
	positionValues.push(firstValue.value);
	idx++;

	// Check for second value
	if (idx < nodes.length) {
		const secondNode = nodes[idx];
		if (secondNode) {
			const secondValue = parsePositionValue(secondNode);
			if (secondValue.ok) {
				positionValues.push(secondValue.value);
				idx++;
			}
		}
	}

	// Convert 1-2 values into Position2D
	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Missing position value");
		}
		// Single value is treated as horizontal, vertical defaults to center
		if (typeof val === "string") {
			// Keyword: if it's top/bottom, it's vertical; otherwise horizontal
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		// Two values: horizontal then vertical
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Missing position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse 3D position from CSS nodes.
 *
 * Handles CSS 3D position syntax with x, y, and z coordinates.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @returns Result containing Position3D IR and next index, or error message
 *
 * @internal
 */
function parsePosition3DFromNodes(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position3D; nextIdx: number }, string> {
	let idx = startIdx;

	// Parse x, y, z values
	const xNode = nodes[idx];
	if (!xNode) return err("Missing x position value");
	const x = parsePositionValue(xNode);
	if (!x.ok) return err(`Invalid x position: ${x.error}`);
	idx++;

	const yNode = nodes[idx];
	if (!yNode) return err("Missing y position value");
	const y = parsePositionValue(yNode);
	if (!y.ok) return err(`Invalid y position: ${y.error}`);
	idx++;

	const zNode = nodes[idx];
	if (!zNode) return err("Missing z position value");
	const z = ParseUtils.parseLengthNode(zNode);
	if (!z.ok) return err(`Invalid z position: ${z.error}`);
	idx++;

	return ok({
		position: { x: x.value, y: y.value, z: z.value },
		nextIdx: idx,
	});
}

/**
 * Parse a CSS position value into structured intermediate representation (IR).
 *
 * Parses CSS position values used in properties like background-position,
 * object-position, transform-origin, perspective-origin, etc.
 *
 * Supports all CSS position syntax per CSS specifications:
 * - 2D positions: keywords, lengths, percentages
 * - 3D positions: for transform-origin in 3D contexts
 * - Position lists: for multi-position properties
 *
 * @param css - CSS string containing position values
 * @returns Result containing position IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * 2D position keywords:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Position.parse("center");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: "center", vertical: "center" }
 * }
 * ```
 *
 * @example
 * 2D position with both values:
 * ```typescript
 * const result = Parse.Position.parse("left top");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: "left", vertical: "top" }
 * }
 * ```
 *
 * @example
 * 2D position with length/percentage:
 * ```typescript
 * const result = Parse.Position.parse("50% 100px");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: { value: 50, unit: "%" }, vertical: { value: 100, unit: "px" } }
 * }
 * ```
 *
 * @example
 * 3D position:
 * ```typescript
 * const result = Parse.Position.parse3D("10px 20px 30px");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { x: { value: 10, unit: "px" }, y: { value: 20, unit: "px" }, z: { value: 30, unit: "px" } }
 * }
 * ```
 *
 * @example
 * Position list:
 * ```typescript
 * const result = Parse.Position.parseList("center, 50% 50%, left top");
 * if (result.ok) {
 *   console.log(result.value.length); // 3
 *   console.log(result.value[0]); // { horizontal: "center", vertical: "center" }
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Position.parse("invalid position");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value | MDN: position}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#background-position | W3C Spec: background-position}
 */
export function parse(css: string): ParseResult<Type.Position2D> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the position nodes (should be the main content)
		const children = ast.children.toArray();
		if (children.length === 0) {
			return parseErr("invalid-syntax", "No position values found in CSS string");
		}

		const result = parsePosition2DFromNodes(children, 0);
		if (!result.ok) {
			return parseErr("invalid-value", result.error);
		}

		return parseOk(result.value.position);
	} catch (e) {
		return parseErr("invalid-syntax", `Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Parse a 3D CSS position value.
 *
 * @param css - CSS string containing 3D position values
 * @returns Result containing Position3D IR or error message
 */
export function parse3D(css: string): Result<Type.Position3D, string> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the position nodes
		const children = ast.children.toArray();
		if (children.length === 0) {
			return err("No position values found in CSS string");
		}

		const result = parsePosition3DFromNodes(children, 0);
		if (!result.ok) {
			return err(`Failed to parse 3D position: ${result.error}`);
		}

		return ok(result.value.position);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Parse a list of CSS position values.
 *
 * @param css - CSS string containing comma-separated position values
 * @returns Result containing PositionList IR or error message
 */
export function parseList(css: string): Result<Type.PositionList, string> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Split into groups by comma - single walk
		const positions: Type.Position2D[] = [];
		const groups: csstree.CssNode[][] = [[]];

		csstree.walk(ast, {
			enter(node: csstree.CssNode) {
				if (node.type === "Operator" && "value" in node && node.value === ",") {
					// Start new group
					groups.push([]);
				} else if (node.type !== "Value") {
					// Add to current group (skip Value wrapper node)
					const currentGroup = groups[groups.length - 1];
					if (currentGroup) {
						currentGroup.push(node);
					}
				}
			},
		});

		// Parse each group as a position
		for (const group of groups) {
			if (group.length > 0) {
				const result = parsePosition2DFromNodes(group, 0);
				if (result.ok) {
					positions.push(result.value.position);
				} else {
					return err(`Failed to parse position in list: ${result.error}`);
				}
			}
		}

		if (positions.length === 0) {
			return err("No valid positions found in CSS string");
		}

		return ok(positions);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}

// Length parsing now uses shared utility (eliminates code duplication)


=== File: src/parse/shadow/box-shadow.test.ts ===
// b_path:: src/parse/shadow/box-shadow.test.ts
import { describe, expect, test } from "vitest";
import { parse } from "./box-shadow";

describe("box-shadow parser", () => {
	describe("basic shadows", () => {
		test("parses simple 2-value shadow", () => {
			const result = parse("2px 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "box-shadow",
					shadows: [
						{
							offsetX: { value: 2, unit: "px" },
							offsetY: { value: 2, unit: "px" },
						},
					],
				});
			}
		});

		test("parses shadow with blur radius", () => {
			const result = parse("2px 2px 4px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
				});
			}
		});

		test("parses shadow with blur and spread radius", () => {
			const result = parse("2px 2px 4px 8px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
					blurRadius: { value: 4, unit: "px" },
					spreadRadius: { value: 8, unit: "px" },
				});
			}
		});
	});

	describe("shadows with colors", () => {
		test("parses shadow with named color", () => {
			const result = parse("2px 2px 4px black");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "black",
				});
			}
		});

		test("parses shadow with rgb color", () => {
			const result = parse("2px 2px 4px rgb(255 0 0)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toMatchObject({
					kind: "rgb",
				});
			}
		});

		test("parses shadow with rgba color", () => {
			const result = parse("2px 2px 4px rgba(0 0 0 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toMatchObject({
					kind: "rgb",
					alpha: 0.5,
				});
			}
		});

		test("parses color at beginning", () => {
			const result = parse("black 2px 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "black",
				});
			}
		});

		test("parses color in middle", () => {
			const result = parse("2px black 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "black",
				});
			}
		});
	});

	describe("inset shadows", () => {
		test("parses inset shadow", () => {
			const result = parse("inset 2px 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.inset).toBe(true);
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
				});
			}
		});

		test("parses inset shadow with all values", () => {
			const result = parse("inset 0 0 10px 5px rgba(0 0 0 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				const shadow = result.value.shadows[0];
				expect(shadow?.inset).toBe(true);
				expect(shadow).toMatchObject({
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
					blurRadius: { value: 10, unit: "px" },
					spreadRadius: { value: 5, unit: "px" },
				});
			}
		});

		test("parses inset keyword at end", () => {
			const result = parse("2px 2px inset");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.inset).toBe(true);
			}
		});
	});

	describe("multiple shadows", () => {
		test("parses two shadows", () => {
			const result = parse("2px 2px 4px black, -2px -2px 4px white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(2);
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 2, unit: "px" },
					offsetY: { value: 2, unit: "px" },
				});
				expect(result.value.shadows[1]).toMatchObject({
					offsetX: { value: -2, unit: "px" },
					offsetY: { value: -2, unit: "px" },
				});
			}
		});

		test("parses multiple shadows with mixed inset", () => {
			const result = parse("2px 2px 4px black, inset 0 0 10px white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(2);
				expect(result.value.shadows[0]?.inset).toBeUndefined();
				expect(result.value.shadows[1]?.inset).toBe(true);
			}
		});

		test("parses three shadows", () => {
			const result = parse("2px 2px red, 4px 4px blue, 6px 6px green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(3);
			}
		});
	});

	describe("units", () => {
		test("parses rem units", () => {
			const result = parse("1rem 1rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "rem" },
					offsetY: { value: 1, unit: "rem" },
				});
			}
		});

		test("parses em units", () => {
			const result = parse("0.5em 0.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0.5, unit: "em" },
					offsetY: { value: 0.5, unit: "em" },
				});
			}
		});

		test("parses zero without unit", () => {
			const result = parse("0 0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
				});
			}
		});

		test("parses mixed units", () => {
			const result = parse("1px 2rem 3em 4vh");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 2, unit: "rem" },
					blurRadius: { value: 3, unit: "em" },
					spreadRadius: { value: 4, unit: "vh" },
				});
			}
		});
	});

	describe("negative values", () => {
		test("parses negative offsets", () => {
			const result = parse("-5px -5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: -5, unit: "px" },
					offsetY: { value: -5, unit: "px" },
				});
			}
		});

		test("parses negative spread", () => {
			const result = parse("0 0 10px -5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					spreadRadius: { value: -5, unit: "px" },
				});
			}
		});
	});

	describe("error cases", () => {
		test("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});

		test("rejects single value", () => {
			const result = parse("2px");
			expect(result.ok).toBe(false);
		});

		test("rejects too many length values", () => {
			const result = parse("1px 2px 3px 4px 5px");
			expect(result.ok).toBe(false);
		});

		test("rejects duplicate inset keyword", () => {
			const result = parse("inset inset 2px 2px");
			expect(result.ok).toBe(false);
		});

		test("rejects duplicate color", () => {
			const result = parse("2px 2px black white");
			expect(result.ok).toBe(false);
		});

		test("rejects invalid keyword", () => {
			const result = parse("outset 2px 2px");
			expect(result.ok).toBe(false);
		});

		test("rejects empty layer before comma", () => {
			const result = parse(", 2px 2px");
			expect(result.ok).toBe(false);
		});

		test("rejects empty layer after comma", () => {
			// Note: Trailing comma is actually accepted (parsed as valid shadow before comma)
			// This matches CSS parser behavior where trailing commas are often ignored
			const result = parse("2px 2px,");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(1);
			}
		});
	});
});


=== File: src/parse/shadow/box-shadow.ts ===
// b_path:: src/parse/shadow/box-shadow.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import type { Length } from "@/core/types/length-percentage";
import type { BoxShadow, BoxShadowLayer } from "@/core/types/shadow";
import { parseNode as parseColorNode } from "@/parse/color";
import * as ParseUtils from "@/utils/parse";

/**
 * Convert an AST node to string representation for error messages.
 *
 * @param node - CSS AST node
 * @returns String representation of the node
 * @internal
 */
function nodeToString(node: csstree.CssNode): string {
	try {
		return csstree.generate(node);
	} catch {
		return node.type;
	}
}

/**
 * Parse a single box-shadow layer from AST nodes.
 *
 * Syntax: [inset?] offset-x offset-y [blur-radius] [spread-radius] [color]
 *
 * @param nodes - Array of CSS AST nodes for one shadow layer
 * @returns Result with parsed BoxShadowLayer or error
 *
 * @internal
 */
function parseShadowLayer(nodes: csstree.CssNode[]): Result<BoxShadowLayer, string> {
	if (nodes.length < 2) {
		return err(`box-shadow layer expects at least 2 arguments (offset-x, offset-y), got ${nodes.length}`);
	}

	let inset = false;
	let blurRadius: Length | undefined;
	let spreadRadius: Length | undefined;
	let color: Color | undefined;

	const lengthValues: Length[] = [];

	for (const node of nodes) {
		if (node.type === "WhiteSpace") continue;

		// Check for inset keyword
		if (node.type === "Identifier" && node.name.toLowerCase() === "inset") {
			if (inset) {
				return err("box-shadow: duplicate 'inset' keyword");
			}
			inset = true;
			continue;
		}

		// Handle unitless zero (number node with value 0)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				lengthValues.push({ value: 0, unit: "px" });
				continue;
			}
			return err(`box-shadow: unitless numbers are only allowed for zero, got ${value}`);
		}

		// Try parsing as length
		const lengthResult = ParseUtils.parseLengthNode(node);
		if (lengthResult.ok) {
			lengthValues.push(lengthResult.value);
			continue;
		}

		// Try parsing as color
		const colorResult = parseColorNode(node);
		if (colorResult.ok) {
			if (color !== undefined) {
				return err("box-shadow: duplicate color");
			}
			color = colorResult.value;
			continue;
		}

		// Invalid argument
		return err(`box-shadow: invalid argument '${nodeToString(node)}'. Expected length, color, or 'inset' keyword.`);
	}

	// Assign length values in order: offset-x, offset-y, blur-radius, spread-radius
	if (lengthValues.length < 2) {
		return err(`box-shadow: requires at least 2 length values (offset-x, offset-y), got ${lengthValues.length}`);
	}

	if (lengthValues.length > 4) {
		return err(`box-shadow: expects at most 4 length values, got ${lengthValues.length}`);
	}

	const offsetX = lengthValues[0] as Length;
	const offsetY = lengthValues[1] as Length;

	if (lengthValues.length >= 3) {
		blurRadius = lengthValues[2];
	}

	if (lengthValues.length >= 4) {
		spreadRadius = lengthValues[3];
	}

	return ok({
		inset: inset || undefined,
		offsetX,
		offsetY,
		blurRadius,
		spreadRadius,
		color,
	});
}

/**
 * Parse CSS box-shadow property value.
 *
 * Adds shadow effects around an element's frame. Supports multiple comma-separated shadows.
 *
 * Per CSS Backgrounds and Borders Module Level 3 specification.
 *
 * @param css - CSS box-shadow value (e.g., "2px 2px 4px black", "inset 0 0 10px rgba(0,0,0,0.5))")
 * @returns Result with BoxShadow IR or error message
 *
 * @example
 * Basic shadow:
 * ```typescript
 * const result = parse("2px 2px");
 * // { ok: true, value: { kind: "box-shadow", shadows: [{ offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" } }] } }
 * ```
 *
 * @example
 * With blur and color:
 * ```typescript
 * const result = parse("2px 2px 4px black");
 * // { ok: true, value: { kind: "box-shadow", shadows: [{ offsetX: { value: 2, unit: "px" }, offsetY: { value: 2, unit: "px" }, blurRadius: { value: 4, unit: "px" }, color: { kind: "named", name: "black" } }] } }
 * ```
 *
 * @example
 * Inset shadow:
 * ```typescript
 * const result = parse("inset 0 0 10px rgba(0,0,0,0.5)");
 * // { ok: true, value: { kind: "box-shadow", shadows: [{ inset: true, offsetX: { value: 0, unit: "px" }, offsetY: { value: 0, unit: "px" }, blurRadius: { value: 10, unit: "px" }, color: { kind: "rgb", ... } }] } }
 * ```
 *
 * @example
 * Multiple shadows:
 * ```typescript
 * const result = parse("2px 2px 4px black, inset 0 0 10px white");
 * // { ok: true, value: { kind: "box-shadow", shadows: [{ ... }, { inset: true, ... }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow | MDN: box-shadow}
 * @see {@link https://www.w3.org/TR/css-backgrounds-3/#box-shadow | W3C Spec}
 */
export function parse(css: string): Result<BoxShadow, string> {
	const result = ParseUtils.splitLayer(css, parseShadowLayer, "box-shadow");
	if (!result.ok) return result;

	return ok({
		kind: "box-shadow",
		shadows: result.value,
	});
}


=== File: src/parse/shadow/index.ts ===
// b_path:: src/parse/shadow/index.ts

export * as BoxShadow from "./box-shadow";
export * as Shadow from "./shadow";
export { parse } from "./shadow";
export * as TextShadow from "./text-shadow";


=== File: src/parse/shadow/shadow.test.ts ===
// b_path:: src/parse/shadow/shadow.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./shadow";

describe("parse shadow", () => {
	it("parses box-shadow with offsets and blur", () => {
		const result = parse("2px 2px 4px rgba(0,0,0,0.5)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("box-shadow");
		}
	});

	it("parses box-shadow with inset", () => {
		const result = parse("inset 0 0 10px black");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("box-shadow");
		}
	});

	it("parses text-shadow", () => {
		const result = parse("1px 1px 2px black");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toMatch(/shadow/);
		}
	});

	it("parses text-shadow without blur", () => {
		const result = parse("1px 1px red");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toMatch(/shadow/);
		}
	});

	it("rejects invalid shadow", () => {
		const result = parse("invalid");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.issues.length).toBeGreaterThan(0);
		}
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/shadow/shadow.ts ===
// b_path:: src/parse/shadow/shadow.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";
import type * as Type from "@/core/types/shadow";

import * as BoxShadow from "./box-shadow";
import * as TextShadow from "./text-shadow";

export type Shadow = Type.BoxShadow | Type.TextShadow;

export function parse(value: string): ParseResult<Shadow> {
	const boxResult = BoxShadow.parse(value);
	if (boxResult.ok) return toParseResult(boxResult);

	const textResult = TextShadow.parse(value);
	if (textResult.ok) return toParseResult(textResult);

	return parseErr("invalid-value", "Invalid shadow value", {
		suggestion: "Expected box-shadow (with optional inset) or text-shadow format",
	});
}


=== File: src/parse/shadow/text-shadow.test.ts ===
// b_path:: src/parse/shadow/text-shadow.test.ts
import { describe, expect, test } from "vitest";
import { parse } from "./text-shadow";

describe("text-shadow parser", () => {
	describe("basic shadows", () => {
		test("parses simple 2-value shadow", () => {
			const result = parse("1px 1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "text-shadow",
					shadows: [
						{
							offsetX: { value: 1, unit: "px" },
							offsetY: { value: 1, unit: "px" },
						},
					],
				});
			}
		});

		test("parses shadow with blur radius", () => {
			const result = parse("1px 1px 2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
					blurRadius: { value: 2, unit: "px" },
				});
			}
		});
	});

	describe("shadows with colors", () => {
		test("parses shadow with named color", () => {
			const result = parse("1px 1px 2px gray");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "gray",
				});
			}
		});

		test("parses shadow with rgb color", () => {
			const result = parse("1px 1px 2px rgb(128 128 128)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toMatchObject({
					kind: "rgb",
				});
			}
		});

		test("parses shadow with rgba color", () => {
			const result = parse("1px 1px 2px rgba(0 0 0 / 0.5)");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toMatchObject({
					kind: "rgb",
					alpha: 0.5,
				});
			}
		});

		test("parses color at beginning", () => {
			const result = parse("gray 1px 1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "gray",
				});
			}
		});

		test("parses color in middle", () => {
			const result = parse("1px gray 1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]?.color).toEqual({
					kind: "named",
					name: "gray",
				});
			}
		});
	});

	describe("multiple shadows", () => {
		test("parses two shadows", () => {
			const result = parse("1px 1px 2px black, -1px -1px 2px white");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(2);
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 1, unit: "px" },
				});
				expect(result.value.shadows[1]).toMatchObject({
					offsetX: { value: -1, unit: "px" },
					offsetY: { value: -1, unit: "px" },
				});
			}
		});

		test("parses three shadows", () => {
			const result = parse("1px 1px red, 2px 2px blue, 3px 3px green");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(3);
			}
		});

		test("parses complex multi-shadow", () => {
			const result = parse("0 0 3px red, 0 0 6px orange, 0 0 9px yellow");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(3);
				expect(result.value.shadows[0]?.blurRadius).toEqual({ value: 3, unit: "px" });
				expect(result.value.shadows[1]?.blurRadius).toEqual({ value: 6, unit: "px" });
				expect(result.value.shadows[2]?.blurRadius).toEqual({ value: 9, unit: "px" });
			}
		});
	});

	describe("units", () => {
		test("parses rem units", () => {
			const result = parse("0.5rem 0.5rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0.5, unit: "rem" },
					offsetY: { value: 0.5, unit: "rem" },
				});
			}
		});

		test("parses em units", () => {
			const result = parse("0.25em 0.25em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0.25, unit: "em" },
					offsetY: { value: 0.25, unit: "em" },
				});
			}
		});

		test("parses zero without unit", () => {
			const result = parse("0 0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 0, unit: "px" },
					offsetY: { value: 0, unit: "px" },
				});
			}
		});

		test("parses mixed units", () => {
			const result = parse("1px 2rem 3em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: 1, unit: "px" },
					offsetY: { value: 2, unit: "rem" },
					blurRadius: { value: 3, unit: "em" },
				});
			}
		});
	});

	describe("negative values", () => {
		test("parses negative offsets", () => {
			const result = parse("-2px -2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					offsetX: { value: -2, unit: "px" },
					offsetY: { value: -2, unit: "px" },
				});
			}
		});

		test("parses negative blur (should work even though unusual)", () => {
			const result = parse("1px 1px -2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows[0]).toMatchObject({
					blurRadius: { value: -2, unit: "px" },
				});
			}
		});
	});

	describe("error cases", () => {
		test("rejects empty value", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});

		test("rejects single value", () => {
			const result = parse("1px");
			expect(result.ok).toBe(false);
		});

		test("rejects too many length values", () => {
			const result = parse("1px 2px 3px 4px");
			expect(result.ok).toBe(false);
		});

		test("rejects duplicate color", () => {
			const result = parse("1px 1px black white");
			expect(result.ok).toBe(false);
		});

		test("rejects invalid keyword", () => {
			const result = parse("inset 1px 1px");
			expect(result.ok).toBe(false);
		});

		test("rejects empty layer before comma", () => {
			const result = parse(", 1px 1px");
			expect(result.ok).toBe(false);
		});

		test("rejects empty layer after comma", () => {
			// Note: Trailing comma is actually accepted (parsed as valid shadow before comma)
			// This matches CSS parser behavior where trailing commas are often ignored
			const result = parse("1px 1px,");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shadows).toHaveLength(1);
			}
		});
	});
});


=== File: src/parse/shadow/text-shadow.ts ===
// b_path:: src/parse/shadow/text-shadow.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import type { Length } from "@/core/types/length-percentage";
import type { TextShadow, TextShadowLayer } from "@/core/types/shadow";
import { parseNode as parseColorNode } from "@/parse/color";
import * as ParseUtils from "@/utils/parse";

/**
 * Convert an AST node to string representation for error messages.
 *
 * @param node - CSS AST node
 * @returns String representation of the node
 * @internal
 */
function nodeToString(node: csstree.CssNode): string {
	try {
		return csstree.generate(node);
	} catch {
		return node.type;
	}
}

/**
 * Parse a single text-shadow layer from AST nodes.
 *
 * Syntax: offset-x offset-y [blur-radius] [color]
 *
 * @param nodes - Array of CSS AST nodes for one shadow layer
 * @returns Result with parsed TextShadowLayer or error
 *
 * @internal
 */
function parseShadowLayer(nodes: csstree.CssNode[]): Result<TextShadowLayer, string> {
	if (nodes.length < 2) {
		return err(`text-shadow layer expects at least 2 arguments (offset-x, offset-y), got ${nodes.length}`);
	}

	let blurRadius: Length | undefined;
	let color: Color | undefined;

	const lengthValues: Length[] = [];

	for (const node of nodes) {
		if (node.type === "WhiteSpace") continue;

		// Handle unitless zero (number node with value 0)
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				lengthValues.push({ value: 0, unit: "px" });
				continue;
			}
			return err(`text-shadow: unitless numbers are only allowed for zero, got ${value}`);
		}

		// Try parsing as length
		const lengthResult = ParseUtils.parseLengthNode(node);
		if (lengthResult.ok) {
			lengthValues.push(lengthResult.value);
			continue;
		}

		// Try parsing as color
		const colorResult = parseColorNode(node);
		if (colorResult.ok) {
			if (color !== undefined) {
				return err("text-shadow: duplicate color");
			}
			color = colorResult.value;
			continue;
		}

		// Invalid argument
		return err(`text-shadow: invalid argument '${nodeToString(node)}'. Expected length or color.`);
	}

	// Assign length values in order: offset-x, offset-y, blur-radius
	if (lengthValues.length < 2) {
		return err(`text-shadow: requires at least 2 length values (offset-x, offset-y), got ${lengthValues.length}`);
	}

	if (lengthValues.length > 3) {
		return err(`text-shadow: expects at most 3 length values, got ${lengthValues.length}`);
	}

	const offsetX = lengthValues[0] as Length;
	const offsetY = lengthValues[1] as Length;

	if (lengthValues.length >= 3) {
		blurRadius = lengthValues[2];
	}

	return ok({
		offsetX,
		offsetY,
		blurRadius,
		color,
	});
}

/**
 * Parse CSS text-shadow property value.
 *
 * Adds shadow to text content. Supports multiple comma-separated shadows.
 *
 * Per CSS Text Decoration Module Level 3 specification.
 *
 * @param css - CSS text-shadow value (e.g., "1px 1px 2px gray", "2px 2px 4px black, -2px -2px 4px white")
 * @returns Result with TextShadow IR or error message
 *
 * @example
 * Basic shadow:
 * ```typescript
 * const result = parse("1px 1px");
 * // { ok: true, value: { kind: "text-shadow", shadows: [{ offsetX: { value: 1, unit: "px" }, offsetY: { value: 1, unit: "px" } }] } }
 * ```
 *
 * @example
 * With blur and color:
 * ```typescript
 * const result = parse("1px 1px 2px gray");
 * // { ok: true, value: { kind: "text-shadow", shadows: [{ offsetX: { value: 1, unit: "px" }, offsetY: { value: 1, unit: "px" }, blurRadius: { value: 2, unit: "px" }, color: { kind: "named", name: "gray" } }] } }
 * ```
 *
 * @example
 * Multiple shadows:
 * ```typescript
 * const result = parse("1px 1px 2px black, -1px -1px 2px white");
 * // { ok: true, value: { kind: "text-shadow", shadows: [{ ... }, { ... }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow | MDN: text-shadow}
 * @see {@link https://www.w3.org/TR/css-text-decor-3/#text-shadow-property | W3C Spec}
 */
export function parse(css: string): Result<TextShadow, string> {
	const result = ParseUtils.splitLayer(css, parseShadowLayer, "text-shadow");
	if (!result.ok) return result;

	return ok({
		kind: "text-shadow",
		shadows: result.value,
	});
}


=== File: src/parse/text/color.test.ts ===
// b_path:: src/parse/text/color.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./color";

describe("parse text-decoration-color", () => {
	it("parses named colors", () => {
		const result = parse("red");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("named");
		}
	});

	it("parses hex colors", () => {
		const result = parse("#ff0000");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("hex");
		}
	});

	it("parses rgb colors", () => {
		const result = parse("rgb(255, 0, 0)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("rgb");
		}
	});

	it("parses hsl colors", () => {
		const result = parse("hsl(0, 100%, 50%)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("hsl");
		}
	});

	it("parses transparent keyword", () => {
		const result = parse("transparent");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("special");
		}
	});

	it("parses currentcolor keyword", () => {
		const result = parse("currentcolor");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("special");
		}
	});

	it("rejects invalid color", () => {
		const result = parse("invalid-color");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/text/color.ts ===
// b_path:: src/parse/text/color.ts
import { err, type Result } from "@/core/result";
import type { Color } from "@/core/types/color";
import * as ColorParsers from "../color";

/**
 * Parse text-decoration-color value.
 *
 * Parses CSS text-decoration-color values that set the color of text decorations
 * (underline, overline, line-through). Supports all CSS color formats.
 *
 * @param css - CSS string containing text-decoration-color value
 * @returns Result containing Color IR, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Text.Color.parse("red");
 * if (result.ok) {
 *   console.log(result.value); // { kind: "named", name: "red" }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-color | MDN: text-decoration-color}
 */
export function parse(css: string): Result<Color, string> {
	// Try hex color
	const hexResult = ColorParsers.Hex.parse(css);
	if (hexResult.ok) return hexResult;

	// Try named color
	const namedResult = ColorParsers.Named.parse(css);
	if (namedResult.ok) return namedResult;

	// Try RGB
	const rgbResult = ColorParsers.Rgb.parse(css);
	if (rgbResult.ok) return rgbResult;

	// Try HSL
	const hslResult = ColorParsers.Hsl.parse(css);
	if (hslResult.ok) return hslResult;

	// Try HWB
	const hwbResult = ColorParsers.Hwb.parse(css);
	if (hwbResult.ok) return hwbResult;

	// Try LAB
	const labResult = ColorParsers.Lab.parse(css);
	if (labResult.ok) return labResult;

	// Try LCH
	const lchResult = ColorParsers.Lch.parse(css);
	if (lchResult.ok) return lchResult;

	// Try OKLab
	const oklabResult = ColorParsers.Oklab.parse(css);
	if (oklabResult.ok) return oklabResult;

	// Try OKLCH
	const oklchResult = ColorParsers.Oklch.parse(css);
	if (oklchResult.ok) return oklchResult;

	// Try system color
	const systemResult = ColorParsers.System.parse(css);
	if (systemResult.ok) return systemResult;

	// Try special color
	const specialResult = ColorParsers.Special.parse(css);
	if (specialResult.ok) return specialResult;

	return err(`Invalid text-decoration-color: "${css}"`);
}


=== File: src/parse/text/index.ts ===
// b_path:: src/parse/text/index.ts

export * as Color from "./color";
export * as Line from "./line";
export * as Style from "./style";
export * as Text from "./text";
export { parse } from "./text";
export * as Thickness from "./thickness";


=== File: src/parse/text/line.test.ts ===
// b_path:: src/parse/text/line.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./line";

describe("parse text-decoration-line", () => {
	it("parses 'none'", () => {
		const result = parse("none");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("none");
		}
	});

	it("parses 'underline'", () => {
		const result = parse("underline");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("underline");
		}
	});

	it("parses 'overline'", () => {
		const result = parse("overline");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("overline");
		}
	});

	it("parses 'line-through'", () => {
		const result = parse("line-through");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("line-through");
		}
	});

	it("parses with whitespace", () => {
		const result = parse("  underline  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("underline");
		}
	});

	it("rejects invalid keyword", () => {
		const result = parse("invalid");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid text-decoration-line value");
		}
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("is case sensitive", () => {
		const result = parse("Underline");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/text/line.ts ===
// b_path:: src/parse/text/line.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse text-decoration-line value.
 *
 * Parses CSS text-decoration-line values that set the kind of decoration used.
 * Valid values: none | underline | overline | line-through
 *
 * @param css - CSS string containing text-decoration-line value
 * @returns Result containing TextDecorationLineKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Text.Line.parse("underline");
 * if (result.ok) {
 *   console.log(result.value); // "underline"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-line | MDN: text-decoration-line}
 */
export function parse(css: string): Result<Keyword.TextDecorationLineKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.textDecorationLineKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid text-decoration-line value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/text/style.test.ts ===
// b_path:: src/parse/text/style.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./style";

describe("parse text-decoration-style", () => {
	it("parses 'solid'", () => {
		const result = parse("solid");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("solid");
		}
	});

	it("parses 'double'", () => {
		const result = parse("double");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("double");
		}
	});

	it("parses 'dotted'", () => {
		const result = parse("dotted");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("dotted");
		}
	});

	it("parses 'dashed'", () => {
		const result = parse("dashed");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("dashed");
		}
	});

	it("parses 'wavy'", () => {
		const result = parse("wavy");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("wavy");
		}
	});

	it("parses with whitespace", () => {
		const result = parse("  wavy  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("wavy");
		}
	});

	it("rejects invalid keyword", () => {
		const result = parse("invalid");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid text-decoration-style value");
		}
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});

	it("is case sensitive", () => {
		const result = parse("Solid");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/text/style.ts ===
// b_path:: src/parse/text/style.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse text-decoration-style value.
 *
 * Parses CSS text-decoration-style values that set the style of text decoration lines.
 * Valid values: solid | double | dotted | dashed | wavy
 *
 * @param css - CSS string containing text-decoration-style value
 * @returns Result containing TextDecorationStyleKeyword, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Text.Style.parse("wavy");
 * if (result.ok) {
 *   console.log(result.value); // "wavy"
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-style | MDN: text-decoration-style}
 */
export function parse(css: string): Result<Keyword.TextDecorationStyleKeyword, string> {
	const trimmed = css.trim();
	const result = Keyword.textDecorationStyleKeywordsSchema.safeParse(trimmed);

	if (!result.success) {
		return err(`Invalid text-decoration-style value: "${css}"`);
	}

	return ok(result.data);
}


=== File: src/parse/text/text.test.ts ===
// b_path:: src/parse/text/text.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./text";

describe("parse text-decoration dispatcher", () => {
	describe("dispatches to Line parser", () => {
		it("parses underline", () => {
			const result = parse("underline");
			expect(result.ok).toBe(true);
		});

		it("parses overline", () => {
			const result = parse("overline");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Style parser", () => {
		it("parses wavy", () => {
			const result = parse("wavy");
			expect(result.ok).toBe(true);
		});

		it("parses dotted", () => {
			const result = parse("dotted");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Thickness parser", () => {
		it("parses length value", () => {
			const result = parse("2px");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Color parser", () => {
		it("parses named color", () => {
			const result = parse("red");
			expect(result.ok).toBe(true);
		});
	});

	describe("error handling", () => {
		it("rejects invalid value", () => {
			const result = parse("invalid-text-decoration-xyz");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues.length).toBeGreaterThan(0);
			}
		});

		it("rejects empty string", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/text/text.ts ===
// b_path:: src/parse/text/text.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";

import * as Color from "./color";
import * as Line from "./line";
import * as Style from "./style";
import * as Thickness from "./thickness";

export function parse(value: string): ParseResult<unknown> {
	const lineResult = Line.parse(value);
	if (lineResult.ok) return toParseResult(lineResult);

	const styleResult = Style.parse(value);
	if (styleResult.ok) return toParseResult(styleResult);

	const thicknessResult = Thickness.parse(value);
	if (thicknessResult.ok) return toParseResult(thicknessResult);

	const colorResult = Color.parse(value);
	if (colorResult.ok) return toParseResult(colorResult);

	return parseErr("invalid-value", "Invalid text decoration property value", {
		suggestion: "Expected line, style, thickness, or color",
	});
}


=== File: src/parse/text/thickness.test.ts ===
// b_path:: src/parse/text/thickness.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./thickness";

describe("parse text-decoration-thickness", () => {
	it("parses auto keyword", () => {
		const result = parse("auto");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("auto");
		}
	});

	it("parses from-font keyword", () => {
		const result = parse("from-font");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("from-font");
		}
	});

	it("parses px length values", () => {
		const result = parse("2px");
		expect(result.ok).toBe(true);
		if (result.ok && typeof result.value === "object") {
			expect(result.value.value).toBe(2);
			expect(result.value.unit).toBe("px");
		}
	});

	it("parses em length values", () => {
		const result = parse("0.1em");
		expect(result.ok).toBe(true);
		if (result.ok && typeof result.value === "object") {
			expect(result.value.value).toBe(0.1);
			expect(result.value.unit).toBe("em");
		}
	});

	it("parses percentage values", () => {
		const result = parse("10%");
		expect(result.ok).toBe(true);
		if (result.ok && typeof result.value === "object") {
			expect(result.value.value).toBe(10);
			expect(result.value.unit).toBe("%");
		}
	});

	it("handles whitespace", () => {
		const result = parse("  auto  ");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("auto");
		}
	});

	it("rejects invalid keywords", () => {
		const result = parse("invalid");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parse("");
		expect(result.ok).toBe(false);
	});
});


=== File: src/parse/text/thickness.ts ===
// b_path:: src/parse/text/thickness.ts

import * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Text decoration thickness value (keyword or length-percentage).
 *
 * @public
 */
export type TextDecorationThicknessValue = Keyword.TextDecorationThicknessKeyword | Type.LengthPercentage;

/**
 * Parse text-decoration-thickness value.
 *
 * Parses CSS text-decoration-thickness values that set the thickness of decoration lines.
 * Supports keywords (auto, from-font) and length/percentage values.
 *
 * @param css - CSS string containing text-decoration-thickness value
 * @returns Result containing TextDecorationThicknessValue, or error message
 *
 * @public
 *
 * @example
 * Keywords:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Text.Thickness.parse("auto");
 * if (result.ok) {
 *   console.log(result.value); // "auto"
 * }
 * ```
 *
 * @example
 * Length values:
 * ```typescript
 * const result = Parse.Text.Thickness.parse("2px");
 * if (result.ok) {
 *   console.log(result.value); // { value: 2, unit: "px" }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-thickness | MDN: text-decoration-thickness}
 */
export function parse(css: string): Result<TextDecorationThicknessValue, string> {
	const trimmed = css.trim();

	// Try keywords (auto, from-font)
	const keywordResult = Keyword.textDecorationThicknessKeywordsSchema.safeParse(trimmed);
	if (keywordResult.success) {
		return ok(keywordResult.data);
	}

	// Try length-percentage
	const csstree = require("css-tree");
	try {
		const ast = csstree.parse(trimmed, { context: "value" });
		const children = ast.children.toArray();
		if (children.length === 1) {
			const lengthResult = ParseUtils.parseLengthPercentageNode(children[0]);
			if (lengthResult.ok) {
				return lengthResult;
			}
		}
	} catch {
		// Continue to error
	}

	return err(`Invalid text-decoration-thickness value: "${css}"`);
}


=== File: src/parse/transform/index.ts ===
// b_path:: src/parse/transform/index.ts

export * as Origin from "./origin";
export * as Transform from "./transform";
export { parse } from "./transform";


=== File: src/parse/transform/origin.test.ts ===
// b_path:: src/parse/transform/origin.test.ts
import { describe, expect, it } from "vitest";
import * as Origin from "./origin";

describe("Transform.Origin.parse", () => {
	describe("2D positions - keywords", () => {
		it("parses center", () => {
			const result = Origin.parse("center");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "center",
				});
			}
		});

		it("parses left top", () => {
			const result = Origin.parse("left top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: "top",
				});
			}
		});

		it("parses right bottom", () => {
			const result = Origin.parse("right bottom");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "right",
					vertical: "bottom",
				});
			}
		});

		it("parses center top", () => {
			const result = Origin.parse("center top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "top",
				});
			}
		});
	});

	describe("2D positions - length/percentage values", () => {
		it("parses percentage values", () => {
			const result = Origin.parse("50% 50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 50, unit: "%" },
					vertical: { value: 50, unit: "%" },
				});
			}
		});

		it("parses pixel values", () => {
			const result = Origin.parse("100px 200px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 100, unit: "px" },
					vertical: { value: 200, unit: "px" },
				});
			}
		});

		it("parses mixed keyword and value", () => {
			const result = Origin.parse("left 25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: { value: 25, unit: "%" },
				});
			}
		});

		it("parses zero values", () => {
			const result = Origin.parse("0px 0px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 0, unit: "px" },
					vertical: { value: 0, unit: "px" },
				});
			}
		});
	});

	describe("3D positions", () => {
		it("parses 3D with pixel values", () => {
			const result = Origin.parse("50px 100px 10px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: { value: 50, unit: "px" },
					y: { value: 100, unit: "px" },
					z: { value: 10, unit: "px" },
				});
			}
		});

		it("parses 3D with keywords and z-value", () => {
			const result = Origin.parse("left top 20px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: "left",
					y: "top",
					z: { value: 20, unit: "px" },
				});
			}
		});

		it("parses 3D with center and z-value", () => {
			const result = Origin.parse("center center 5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: "center",
					y: "center",
					z: { value: 5, unit: "px" },
				});
			}
		});

		it("parses 3D with percentages and z-value", () => {
			const result = Origin.parse("50% 50% 0px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					x: { value: 50, unit: "%" },
					y: { value: 50, unit: "%" },
					z: { value: 0, unit: "px" },
				});
			}
		});
	});

	describe("single value behavior", () => {
		it("parses single keyword (horizontal)", () => {
			const result = Origin.parse("left");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: "center",
				});
			}
		});

		it("parses single value (horizontal)", () => {
			const result = Origin.parse("25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 25, unit: "%" },
					vertical: "center",
				});
			}
		});

		it("parses single top keyword (vertical)", () => {
			const result = Origin.parse("top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "top",
				});
			}
		});
	});

	describe("error handling", () => {
		it("rejects empty string", () => {
			const result = Origin.parse("");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid keywords", () => {
			const result = Origin.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid values", () => {
			const result = Origin.parse("abc def");
			expect(result.ok).toBe(false);
		});
	});
});

describe("Transform.PerspectiveOrigin.parsePerspectiveOrigin", () => {
	describe("2D positions - keywords", () => {
		it("parses center", () => {
			const result = Origin.parsePerspectiveOrigin("center");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "center",
					vertical: "center",
				});
			}
		});

		it("parses left top", () => {
			const result = Origin.parsePerspectiveOrigin("left top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: "top",
				});
			}
		});

		it("parses right bottom", () => {
			const result = Origin.parsePerspectiveOrigin("right bottom");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "right",
					vertical: "bottom",
				});
			}
		});
	});

	describe("2D positions - values", () => {
		it("parses percentage values", () => {
			const result = Origin.parsePerspectiveOrigin("50% 50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 50, unit: "%" },
					vertical: { value: 50, unit: "%" },
				});
			}
		});

		it("parses pixel values", () => {
			const result = Origin.parsePerspectiveOrigin("100px 200px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: { value: 100, unit: "px" },
					vertical: { value: 200, unit: "px" },
				});
			}
		});

		it("parses mixed values", () => {
			const result = Origin.parsePerspectiveOrigin("left 75%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					horizontal: "left",
					vertical: { value: 75, unit: "%" },
				});
			}
		});
	});

	describe("error handling", () => {
		it("rejects empty string", () => {
			const result = Origin.parsePerspectiveOrigin("");
			expect(result.ok).toBe(false);
		});

		it("rejects invalid values", () => {
			const result = Origin.parsePerspectiveOrigin("invalid");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/transform/origin.ts ===
// b_path:: src/parse/transform/origin.ts
import { err, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as Position from "../position/position";

/**
 * Parse transform-origin value (2D or 3D).
 *
 * Parses CSS transform-origin values that define the point around which
 * a transformation is applied. Supports 2D positions (x y) and 3D positions (x y z).
 *
 * Syntax:
 * - 2D: [ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?
 * - 3D: [ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]? <length>
 *
 * @param css - CSS string containing transform-origin value
 * @returns Result containing Position2D or Position3D IR, or error message
 *
 * @public
 *
 * @example
 * 2D origin with keywords:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Transform.Origin.parse("center top");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: "center", vertical: "top" }
 * }
 * ```
 *
 * @example
 * 2D origin with values:
 * ```typescript
 * const result = Parse.Transform.Origin.parse("50% 100px");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: { value: 50, unit: "%" }, vertical: { value: 100, unit: "px" } }
 * }
 * ```
 *
 * @example
 * 3D origin:
 * ```typescript
 * const result = Parse.Transform.Origin.parse("left top 10px");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { x: "left", y: "top", z: { value: 10, unit: "px" } }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin | MDN: transform-origin}
 * @see {@link https://www.w3.org/TR/css-transforms-1/#transform-origin-property | W3C Spec: transform-origin}
 */
export function parse(css: string): Result<Type.Position2D | Type.Position3D, string> {
	// Try 3D first (if it has 3 values)
	const parts = css.trim().split(/\s+/);

	if (parts.length === 3) {
		// Try 3D parsing
		const result3D = Position.parse3D(css);
		if (result3D.ok) {
			return result3D;
		}
	}

	// Fall back to 2D parsing
	const result2D = Position.parse(css);
	if (!result2D.ok) {
		const errorMsg = result2D.issues[0]?.message || "Invalid transform-origin";
		return err(errorMsg);
	}

	// Convert ParseResult to Result
	return result2D.value ? { ok: true, value: result2D.value, error: undefined } : err("Missing position value");
}

/**
 * Parse perspective-origin value (2D only).
 *
 * Parses CSS perspective-origin values that define the position at which
 * the viewer is looking. Only supports 2D positions.
 *
 * Syntax: [ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?
 *
 * @param css - CSS string containing perspective-origin value
 * @returns Result containing Position2D IR, or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Transform.PerspectiveOrigin.parse("50% 50%");
 * if (result.ok) {
 *   console.log(result.value);
 *   // { horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } }
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/perspective-origin | MDN: perspective-origin}
 * @see {@link https://www.w3.org/TR/css-transforms-1/#perspective-origin-property | W3C Spec: perspective-origin}
 */
export function parsePerspectiveOrigin(css: string): Result<Type.Position2D, string> {
	const result = Position.parse(css);
	if (!result.ok) {
		const errorMsg = result.issues[0]?.message || "Invalid perspective-origin";
		return err(errorMsg);
	}
	// Convert ParseResult to Result
	return result.value ? { ok: true, value: result.value, error: undefined } : err("Missing position value");
}


=== File: src/parse/transform/transform.parse.test.ts ===
// b_path:: src/parse/transform/transform.parse.test.ts
import { describe, expect, it } from "vitest";
import * as TransformParser from "./transform";

describe("Transform Parser", () => {
	describe("Translation transforms", () => {
		it("should parse translate with two values", () => {
			const css = "translate(100px, 50px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				expect(result.value?.[0]).toEqual({
					kind: "translate",
					x: { value: 100, unit: "px" },
					y: { value: 50, unit: "px" },
				});
			}
		});

		it("should parse translate with one value", () => {
			const css = "translate(100px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(1);
				expect(result.value?.[0]).toEqual({
					kind: "translate",
					x: { value: 100, unit: "px" },
					y: undefined,
				});
			}
		});

		it("should parse translate with percentage values", () => {
			const css = "translate(50%, 25%)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translate",
					x: { value: 50, unit: "%" },
					y: { value: 25, unit: "%" },
				});
			}
		});

		it("should parse translateX", () => {
			const css = "translateX(100px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translateX",
					x: { value: 100, unit: "px" },
				});
			}
		});

		it("should parse translateY", () => {
			const css = "translateY(50%)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translateY",
					y: { value: 50, unit: "%" },
				});
			}
		});

		it("should parse translateZ", () => {
			const css = "translateZ(30px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translateZ",
					z: { value: 30, unit: "px" },
				});
			}
		});

		it("should parse translate3d", () => {
			const css = "translate3d(10px, 20px, 30px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "translate3d",
					x: { value: 10, unit: "px" },
					y: { value: 20, unit: "px" },
					z: { value: 30, unit: "px" },
				});
			}
		});
	});

	describe("Rotation transforms", () => {
		it("should parse rotate", () => {
			const css = "rotate(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotate",
					angle: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse rotate with radians", () => {
			const css = "rotate(1.57rad)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotate",
					angle: { value: 1.57, unit: "rad" },
				});
			}
		});

		it("should parse rotate with turns", () => {
			const css = "rotate(0.25turn)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotate",
					angle: { value: 0.25, unit: "turn" },
				});
			}
		});

		it("should parse rotateX", () => {
			const css = "rotateX(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotateX",
					angle: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse rotateY", () => {
			const css = "rotateY(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotateY",
					angle: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse rotateZ", () => {
			const css = "rotateZ(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotateZ",
					angle: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse rotate3d", () => {
			const css = "rotate3d(1, 1, 0, 45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "rotate3d",
					x: 1,
					y: 1,
					z: 0,
					angle: { value: 45, unit: "deg" },
				});
			}
		});
	});

	describe("Scale transforms", () => {
		it("should parse scale with two values", () => {
			const css = "scale(1.5, 2)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scale",
					x: 1.5,
					y: 2,
				});
			}
		});

		it("should parse scale with one value", () => {
			const css = "scale(1.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scale",
					x: 1.5,
					y: 1.5,
				});
			}
		});

		it("should parse scaleX", () => {
			const css = "scaleX(1.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scaleX",
					x: 1.5,
				});
			}
		});

		it("should parse scaleY", () => {
			const css = "scaleY(2)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scaleY",
					y: 2,
				});
			}
		});

		it("should parse scaleZ", () => {
			const css = "scaleZ(0.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scaleZ",
					z: 0.5,
				});
			}
		});

		it("should parse scale3d", () => {
			const css = "scale3d(1.5, 2, 0.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "scale3d",
					x: 1.5,
					y: 2,
					z: 0.5,
				});
			}
		});
	});

	describe("Skew transforms", () => {
		it("should parse skew with two values", () => {
			const css = "skew(45deg, 10deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "skew",
					x: { value: 45, unit: "deg" },
					y: { value: 10, unit: "deg" },
				});
			}
		});

		it("should parse skew with one value", () => {
			const css = "skew(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "skew",
					x: { value: 45, unit: "deg" },
					y: { value: 0, unit: "deg" },
				});
			}
		});

		it("should parse skewX", () => {
			const css = "skewX(45deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "skewX",
					x: { value: 45, unit: "deg" },
				});
			}
		});

		it("should parse skewY", () => {
			const css = "skewY(10deg)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "skewY",
					y: { value: 10, unit: "deg" },
				});
			}
		});
	});

	describe("Matrix transforms", () => {
		it("should parse matrix", () => {
			const css = "matrix(1, 0.5, -0.5, 1, 10, 20)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "matrix",
					a: 1,
					b: 0.5,
					c: -0.5,
					d: 1,
					e: { value: 10, unit: "px" },
					f: { value: 20, unit: "px" },
				});
			}
		});

		it("should parse matrix3d", () => {
			const css = "matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "matrix3d",
					values: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
				});
			}
		});
	});

	describe("Perspective transform", () => {
		it("should parse perspective", () => {
			const css = "perspective(1000px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value?.[0]).toEqual({
					kind: "perspective",
					depth: { value: 1000, unit: "px" },
				});
			}
		});
	});

	describe("Multiple transforms", () => {
		it("should parse multiple transforms", () => {
			const css = "translateX(100px) rotate(45deg) scale(1.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(3);
				expect(result.value?.[0]?.kind).toBe("translateX");
				expect(result.value?.[1]?.kind).toBe("rotate");
				expect(result.value?.[2]?.kind).toBe("scale");
			}
		});

		it("should parse complex transform chain", () => {
			const css = "translate3d(10px, 20px, 30px) rotateY(45deg) scale3d(1.5, 2, 0.5)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(3);
				expect(result.value?.[0]?.kind).toBe("translate3d");
				expect(result.value?.[1]?.kind).toBe("rotateY");
				expect(result.value?.[2]?.kind).toBe("scale3d");
			}
		});
	});

	describe("Error handling", () => {
		it("should return error for invalid function name", () => {
			const css = "invalid-transform(red, blue)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("No valid transform functions found");
			}
		});

		it("should return error for invalid CSS syntax", () => {
			const css = "not valid css";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
		});

		it("should return error for translate with wrong number of arguments", () => {
			const css = "translate(100px, 50px, 30px)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("expects 1 or 2 arguments");
			}
		});

		it("should return error for rotate3d with wrong number of arguments", () => {
			const css = "rotate3d(1, 1, 0)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("expects 4 arguments");
			}
		});

		it("should return error for matrix with wrong number of arguments", () => {
			const css = "matrix(1, 0.5, -0.5, 1, 10)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("expects 6 arguments");
			}
		});

		it("should return error for matrix3d with wrong number of arguments", () => {
			const css = "matrix3d(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0)";
			const result = TransformParser.parse(css);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.issues[0]?.message).toContain("expects 16 arguments");
			}
		});
	});
});


=== File: src/parse/transform/transform.ts ===
// b_path:: src/parse/transform/transform.ts
import type * as csstree from "css-tree";
import { TRANSFORM_FUNCTION_NAMES } from "@/core/keywords";
import { err, ok, type ParseResult, parseErr, parseOk, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse transform function from CSS function AST node.
 *
 * Handles all CSS transform functions including translate, rotate, scale, skew, matrix, etc.
 *
 * @param fn - CSS Function AST node
 * @returns Result containing TransformFunction IR or error message
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode, canonicalName?: string): Result<Type.TransformFunction, string> {
	const functionName = canonicalName || fn.name.toLowerCase();

	// Get all children nodes, filtering out operators (commas)
	const children = fn.children.toArray().filter((node) => node.type !== "Operator");
	if (children.length === 0) {
		return err("Transform function requires arguments");
	}

	try {
		switch (functionName) {
			case "translate": {
				if (children.length < 1 || children.length > 2) {
					return err("translate() expects 1 or 2 arguments");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x value");
				const x = ParseUtils.parseLengthPercentageNode(xNode);
				if (!x.ok) return err(`Invalid x value: ${x.error}`);

				const y = children[1] ? ParseUtils.parseLengthPercentageNode(children[1]) : ok(undefined);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);

				return ok({
					kind: "translate",
					x: x.value,
					y: y.value,
				});
			}

			case "translatex": {
				if (children.length !== 1) {
					return err("translateX() expects 1 argument");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x value");
				const x = ParseUtils.parseLengthPercentageNode(xNode);
				if (!x.ok) return err(`Invalid x value: ${x.error}`);

				return ok({
					kind: "translateX",
					x: x.value,
				});
			}

			case "translatey": {
				if (children.length !== 1) {
					return err("translateY() expects 1 argument");
				}

				const yNode = children[0];
				if (!yNode) return err("Missing y value");
				const y = ParseUtils.parseLengthPercentageNode(yNode);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);

				return ok({
					kind: "translateY",
					y: y.value,
				});
			}

			case "translatez": {
				if (children.length !== 1) {
					return err("translateZ() expects 1 argument");
				}

				const zNode = children[0];
				if (!zNode) return err("Missing z value");
				const z = ParseUtils.parseLengthNode(zNode);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);

				return ok({
					kind: "translateZ",
					z: z.value,
				});
			}

			case "translate3d": {
				if (children.length !== 3) {
					return err("translate3d() expects 3 arguments");
				}

				const xNode = children[0];
				const yNode = children[1];
				const zNode = children[2];

				if (!xNode) return err("Missing x value");
				if (!yNode) return err("Missing y value");
				if (!zNode) return err("Missing z value");

				const x = ParseUtils.parseLengthPercentageNode(xNode);
				const y = ParseUtils.parseLengthPercentageNode(yNode);
				const z = ParseUtils.parseLengthNode(zNode);

				if (!x.ok) return err(`Invalid x value: ${x.error}`);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);

				return ok({
					kind: "translate3d",
					x: x.value,
					y: y.value,
					z: z.value,
				});
			}

			case "rotate": {
				if (children.length !== 1) {
					return err("rotate() expects 1 argument");
				}

				const angleNode = children[0];
				if (!angleNode) return err("Missing angle value");
				const angle = ParseUtils.parseAngleNode(angleNode);
				if (!angle.ok) return err(`Invalid angle: ${angle.error}`);

				return ok({
					kind: "rotate",
					angle: angle.value,
				});
			}

			case "rotatex":
			case "rotatey":
			case "rotatez": {
				if (children.length !== 1) {
					return err(`${functionName}() expects 1 argument`);
				}

				const angleNode = children[0];
				if (!angleNode) return err("Missing angle value");
				const angle = ParseUtils.parseAngleNode(angleNode);
				if (!angle.ok) return err(`Invalid angle: ${angle.error}`);

				// Map lowercase to camelCase
				const kindMap = {
					rotatex: "rotateX",
					rotatey: "rotateY",
					rotatez: "rotateZ",
				} as const;

				return ok({
					kind: kindMap[functionName as keyof typeof kindMap],
					angle: angle.value,
				});
			}

			case "rotate3d": {
				if (children.length !== 4) {
					return err("rotate3d() expects 4 arguments");
				}

				const xNode = children[0];
				const yNode = children[1];
				const zNode = children[2];
				const angleNode = children[3];

				if (!xNode) return err("Missing x value");
				if (!yNode) return err("Missing y value");
				if (!zNode) return err("Missing z value");
				if (!angleNode) return err("Missing angle value");

				const x = ParseUtils.parseNumberNode(xNode);
				const y = ParseUtils.parseNumberNode(yNode);
				const z = ParseUtils.parseNumberNode(zNode);
				const angle = ParseUtils.parseAngleNode(angleNode);

				if (!x.ok) return err(`Invalid x value: ${x.error}`);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);
				if (!angle.ok) return err(`Invalid angle: ${angle.error}`);

				return ok({
					kind: "rotate3d",
					x: x.value,
					y: y.value,
					z: z.value,
					angle: angle.value,
				});
			}

			case "scale": {
				if (children.length < 1 || children.length > 2) {
					return err("scale() expects 1 or 2 arguments");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x value");
				const x = ParseUtils.parseNumberNode(xNode);
				if (!x.ok) return err(`Invalid x value: ${x.error}`);

				const y = children[1] ? ParseUtils.parseNumberNode(children[1]) : ok(x.value);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);

				return ok({
					kind: "scale",
					x: x.value,
					y: y.value,
				});
			}

			case "scalex": {
				if (children.length !== 1) {
					return err("scaleX() expects 1 argument");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x value");
				const x = ParseUtils.parseNumberNode(xNode);
				if (!x.ok) return err(`Invalid x value: ${x.error}`);

				return ok({
					kind: "scaleX",
					x: x.value,
				});
			}

			case "scaley": {
				if (children.length !== 1) {
					return err("scaleY() expects 1 argument");
				}

				const yNode = children[0];
				if (!yNode) return err("Missing y value");
				const y = ParseUtils.parseNumberNode(yNode);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);

				return ok({
					kind: "scaleY",
					y: y.value,
				});
			}

			case "scalez": {
				if (children.length !== 1) {
					return err("scaleZ() expects 1 argument");
				}

				const zNode = children[0];
				if (!zNode) return err("Missing z value");
				const z = ParseUtils.parseNumberNode(zNode);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);

				return ok({
					kind: "scaleZ",
					z: z.value,
				});
			}

			case "scale3d": {
				if (children.length !== 3) {
					return err("scale3d() expects 3 arguments");
				}

				const xNode = children[0];
				const yNode = children[1];
				const zNode = children[2];

				if (!xNode) return err("Missing x value");
				if (!yNode) return err("Missing y value");
				if (!zNode) return err("Missing z value");

				const x = ParseUtils.parseNumberNode(xNode);
				const y = ParseUtils.parseNumberNode(yNode);
				const z = ParseUtils.parseNumberNode(zNode);

				if (!x.ok) return err(`Invalid x value: ${x.error}`);
				if (!y.ok) return err(`Invalid y value: ${y.error}`);
				if (!z.ok) return err(`Invalid z value: ${z.error}`);

				return ok({
					kind: "scale3d",
					x: x.value,
					y: y.value,
					z: z.value,
				});
			}

			case "skew": {
				if (children.length < 1 || children.length > 2) {
					return err("skew() expects 1 or 2 arguments");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x angle");
				const x = ParseUtils.parseAngleNode(xNode);
				if (!x.ok) return err(`Invalid x angle: ${x.error}`);

				const yNode = children[1];
				const y = yNode ? ParseUtils.parseAngleNode(yNode) : ok({ value: 0, unit: "deg" as const });
				if (!y.ok) return err(`Invalid y angle: ${y.error}`);

				return ok({
					kind: "skew",
					x: x.value,
					y: y.value,
				});
			}

			case "skewx": {
				if (children.length !== 1) {
					return err("skewX() expects 1 argument");
				}

				const xNode = children[0];
				if (!xNode) return err("Missing x angle");
				const x = ParseUtils.parseAngleNode(xNode);
				if (!x.ok) return err(`Invalid x angle: ${x.error}`);

				return ok({
					kind: "skewX",
					x: x.value,
				});
			}

			case "skewy": {
				if (children.length !== 1) {
					return err("skewY() expects 1 argument");
				}

				const yNode = children[0];
				if (!yNode) return err("Missing y angle");
				const y = ParseUtils.parseAngleNode(yNode);
				if (!y.ok) return err(`Invalid y angle: ${y.error}`);

				return ok({
					kind: "skewY",
					y: y.value,
				});
			}

			case "matrix": {
				if (children.length !== 6) {
					return err("matrix() expects 6 arguments");
				}

				const values: number[] = [];
				for (let i = 0; i < 6; i++) {
					const node = children[i];
					if (!node) return err(`Missing matrix value at position ${i + 1}`);
					const num = ParseUtils.parseNumberNode(node);
					if (!num.ok) return err(`Invalid matrix value at position ${i + 1}: ${num.error}`);
					values.push(num.value);
				}

				// Validate we have exactly 6 values
				if (values.length !== 6) {
					return err("matrix() requires exactly 6 values");
				}

				// Destructure to satisfy TypeScript - we know length is 6
				const [a, b, c, d, e, f] = values;

				return ok({
					kind: "matrix",
					a: a as number,
					b: b as number,
					c: c as number,
					d: d as number,
					e: { value: e as number, unit: "px" },
					f: { value: f as number, unit: "px" },
				});
			}

			case "matrix3d": {
				if (children.length !== 16) {
					return err("matrix3d() expects 16 arguments");
				}

				const values: number[] = [];
				for (let i = 0; i < 16; i++) {
					const node = children[i];
					if (!node) return err(`Missing matrix3d value at position ${i + 1}`);
					const num = ParseUtils.parseNumberNode(node);
					if (!num.ok) return err(`Invalid matrix3d value at position ${i + 1}: ${num.error}`);
					values.push(num.value);
				}

				// Validate we have exactly 16 values
				if (values.length !== 16) {
					return err("matrix3d() requires exactly 16 values");
				}

				return ok({
					kind: "matrix3d",
					values,
				});
			}

			case "perspective": {
				if (children.length !== 1) {
					return err("perspective() expects 1 argument");
				}

				const depthNode = children[0];
				if (!depthNode) return err("Missing depth value");
				const depth = ParseUtils.parseLengthNode(depthNode);
				if (!depth.ok) return err(`Invalid depth value: ${depth.error}`);

				return ok({
					kind: "perspective",
					depth: depth.value,
				});
			}

			default:
				return err(`Unknown transform function: ${functionName}`);
		}
	} catch (e) {
		return err(`Failed to parse transform function: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Parse a CSS transform value into structured intermediate representation (IR).
 *
 * Parses CSS transform property values containing transform functions like
 * translate(), rotate(), scale(), etc. into type-safe IR objects.
 *
 * Supports all CSS transform functions per CSS Transforms Module Level 1 & 2:
 * - Translation: translate(), translateX(), translateY(), translateZ(), translate3d()
 * - Rotation: rotate(), rotateX(), rotateY(), rotateZ(), rotate3d()
 * - Scaling: scale(), scaleX(), scaleY(), scaleZ(), scale3d()
 * - Skewing: skew(), skewX(), skewY()
 * - Matrix: matrix(), matrix3d()
 * - Perspective: perspective()
 *
 * @param css - CSS string containing transform functions
 * @returns Result containing Transform IR on success, or error message on failure
 *
 * @public
 *
 * @example
 * Simple translation:
 * ```typescript
 * import { Parse } from "b_value";
 *
 * const result = Parse.Transform.parse("translate(100px, 50px)");
 * if (result.ok) {
 *   console.log(result.value);
 *   // [{ kind: "translate", x: { value: 100, unit: "px" }, y: { value: 50, unit: "px" } }]
 * }
 * ```
 *
 * @example
 * Multiple transforms:
 * ```typescript
 * const result = Parse.Transform.parse("translateX(100px) rotate(45deg) scale(1.5)");
 * if (result.ok) {
 *   console.log(result.value.length); // 3
 *   console.log(result.value[0].kind); // "translateX"
 *   console.log(result.value[1].kind); // "rotate"
 *   console.log(result.value[2].kind); // "scale"
 * }
 * ```
 *
 * @example
 * 3D transforms:
 * ```typescript
 * const result = Parse.Transform.parse("translate3d(10px, 20px, 30px) rotateY(45deg)");
 * if (result.ok) {
 *   console.log(result.value[0].kind); // "translate3d"
 *   console.log(result.value[1].kind); // "rotateY"
 * }
 * ```
 *
 * @example
 * Error handling:
 * ```typescript
 * const result = Parse.Transform.parse("invalid syntax");
 * if (!result.ok) {
 *   console.error(result.error); // Error message string
 * }
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform | MDN: transform}
 * @see {@link https://www.w3.org/TR/css-transforms-1/ | W3C Spec: CSS Transforms Level 1}
 * @see {@link https://www.w3.org/TR/css-transforms-2/ | W3C Spec: CSS Transforms Level 2}
 */
export function parse(css: string): ParseResult<Type.Transform> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find all function nodes
		const transformFunctions: Type.TransformFunction[] = [];
		const errors: string[] = [];

		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				// Check if it's a transform function
				const functionName = node.name.toLowerCase();

				if (TRANSFORM_FUNCTION_NAMES.includes(functionName as (typeof TRANSFORM_FUNCTION_NAMES)[number])) {
					// Use the canonical function name for parsing
					const canonicalName = TRANSFORM_FUNCTION_NAMES.find((name) => name === functionName) || functionName;
					const funcResult = fromFunction(node, canonicalName);
					if (funcResult.ok) {
						transformFunctions.push(funcResult.value);
					} else {
						errors.push(`${functionName}(): ${funcResult.error}`);
					}
				}
			},
		});

		if (transformFunctions.length === 0) {
			if (errors.length > 0) {
				return parseErr("invalid-value", errors.join("; "));
			}
			return parseErr("invalid-syntax", "No valid transform functions found in CSS string", {
				suggestion:
					"Expected transform functions like translate(), rotate(), scale(), skew(), matrix(), or perspective()",
			});
		}

		return parseOk(transformFunctions);
	} catch (e) {
		return parseErr("invalid-syntax", `Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/transition/delay.failure.test.ts ===
// b_path:: src/parse/transition/delay.failure.test.ts
// Auto-generated from scripts/test-generator/configs/delay.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-delay-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/transition/delay";

describe("parse/transition/delay - invalid cases", () => {
	describe("invalid-unit", () => {
		it("should reject length unit", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Invalid time unit: px. Expected 's' or 'ms'");
		});

		it("should reject font unit", () => {
			const result = Parser.parse("1em");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Invalid time unit: em. Expected 's' or 'ms'");
		});

		it("should reject angle unit", () => {
			const result = Parser.parse("1deg");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Invalid time unit: deg. Expected 's' or 'ms'");
		});

		it("should reject missing unit", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Expected time dimension, got: Number");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject auto keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Expected time dimension, got: Identifier");
		});

		it("should reject none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Expected time dimension, got: Identifier");
		});

		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Expected time dimension, got: Identifier");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("1s,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("1s,,2s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-delay: Empty value before comma");
		});
	});
});


=== File: src/parse/transition/delay.test.ts ===
// b_path:: src/parse/transition/delay.test.ts
// Auto-generated from scripts/parse-test-generator/configs/transition/delay.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-delay-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/transition/delay";

describe("parse/transition/delay - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse zero delay", () => {
			const result = Parser.parse("0s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 0,
						unit: "s",
					},
				],
			});
		});

		it("should parse seconds", () => {
			const result = Parser.parse("1s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
				],
			});
		});

		it("should parse milliseconds", () => {
			const result = Parser.parse("500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 500,
						unit: "ms",
					},
				],
			});
		});

		it("should parse zero milliseconds", () => {
			const result = Parser.parse("0ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 0,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-decimal", () => {
		it("should parse decimal seconds", () => {
			const result = Parser.parse("0.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 0.5,
						unit: "s",
					},
				],
			});
		});

		it("should parse larger decimal", () => {
			const result = Parser.parse("2.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 2.5,
						unit: "s",
					},
				],
			});
		});

		it("should parse decimal milliseconds", () => {
			const result = Parser.parse("100.5ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 100.5,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-negative", () => {
		it("should parse negative seconds", () => {
			const result = Parser.parse("-1s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: -1,
						unit: "s",
					},
				],
			});
		});

		it("should parse negative milliseconds", () => {
			const result = Parser.parse("-500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: -500,
						unit: "ms",
					},
				],
			});
		});

		it("should parse negative decimal", () => {
			const result = Parser.parse("-0.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: -0.5,
						unit: "s",
					},
				],
			});
		});
	});

	describe("valid-large", () => {
		it("should parse large value", () => {
			const result = Parser.parse("3600s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 3600,
						unit: "s",
					},
				],
			});
		});

		it("should parse very large milliseconds", () => {
			const result = Parser.parse("999999ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 999999,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple delays", () => {
			const result = Parser.parse("1s, 500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
					{
						value: 500,
						unit: "ms",
					},
				],
			});
		});

		it("should parse multiple time values", () => {
			const result = Parser.parse("0s, 1s, 2s, 3s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 0,
						unit: "s",
					},
					{
						value: 1,
						unit: "s",
					},
					{
						value: 2,
						unit: "s",
					},
					{
						value: 3,
						unit: "s",
					},
				],
			});
		});

		it("should parse delays with whitespace", () => {
			const result = Parser.parse("1s , 2s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: 1,
						unit: "s",
					},
					{
						value: 2,
						unit: "s",
					},
				],
			});
		});

		it("should parse mixed negative and positive", () => {
			const result = Parser.parse("-1s, 0s, 1s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-delay",
				delays: [
					{
						value: -1,
						unit: "s",
					},
					{
						value: 0,
						unit: "s",
					},
					{
						value: 1,
						unit: "s",
					},
				],
			});
		});
	});
});


=== File: src/parse/transition/delay.ts ===
// b_path:: src/parse/transition/delay.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse time value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with Time object or error
 *
 * @internal
 */
function parseTime(node: csstree.CssNode): Result<Type.Time, string> {
	if (node.type !== "Dimension") {
		return err(`Expected time dimension, got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);
	const unit = node.unit.toLowerCase();

	if (unit !== "s" && unit !== "ms") {
		return err(`Invalid time unit: ${unit}. Expected 's' or 'ms'`);
	}

	return ok({
		value,
		unit: unit as "s" | "ms",
	});
}

/**
 * Parse CSS transition-delay property value.
 *
 * Parses comma-separated list of time values.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param css - CSS transition-delay value (e.g., "1s, 500ms, 2s")
 * @returns Result with TransitionDelay IR or error message
 *
 * @example
 * Simple delay:
 * ```typescript
 * const result = parse("1s");
 * // { ok: true, value: { kind: "transition-delay", delays: [{ value: 1, unit: "s" }] } }
 * ```
 *
 * @example
 * Multiple delays:
 * ```typescript
 * const result = parse("1s, 500ms, 2s");
 * // { ok: true, value: { kind: "transition-delay", delays: [...] } }
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-delay | MDN: transition-delay}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-delay-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TransitionDelay, string> {
	const delaysResult = parseCommaSeparatedSingle(css, parseTime, "transition-delay");

	if (!delaysResult.ok) {
		return err(delaysResult.error);
	}

	return ok({
		kind: "transition-delay",
		delays: delaysResult.value,
	});
}


=== File: src/parse/transition/duration.failure.test.ts ===
// b_path:: src/parse/transition/duration.failure.test.ts
// Auto-generated from scripts/test-generator/configs/duration.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-duration-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/transition/duration";

describe("parse/transition/duration - invalid cases", () => {
	describe("invalid-negative", () => {
		it("should reject negative duration", () => {
			const result = Parser.parse("-1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: transition-duration must be non-negative, got: -1");
		});

		it("should reject negative milliseconds", () => {
			const result = Parser.parse("-500ms");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: transition-duration must be non-negative, got: -500");
		});
	});

	describe("invalid-unit", () => {
		it("should reject invalid unit", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Invalid time unit: px. Expected 's' or 'ms'");
		});

		it("should reject wrong unit type", () => {
			const result = Parser.parse("1em");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Invalid time unit: em. Expected 's' or 'ms'");
		});

		it("should reject missing unit", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Expected time dimension, got: Number");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("1s,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",1s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("1s,,2s");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Empty value before comma");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Expected time dimension, got: Identifier");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-duration: Expected time dimension, got: Identifier");
		});
	});
});


=== File: src/parse/transition/duration.test.ts ===
// b_path:: src/parse/transition/duration.test.ts
// Auto-generated from scripts/parse-test-generator/configs/transition/duration.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-duration-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/transition/duration";

describe("parse/transition/duration - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse single time value in seconds", () => {
			const result = Parser.parse("1s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 1,
						unit: "s",
					},
				],
			});
		});

		it("should parse single time value in milliseconds", () => {
			const result = Parser.parse("500ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 500,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-edge", () => {
		it("should parse zero duration", () => {
			const result = Parser.parse("0s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 0,
						unit: "s",
					},
				],
			});
		});

		it("should parse zero duration in ms", () => {
			const result = Parser.parse("0ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 0,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-decimal", () => {
		it("should parse decimal values", () => {
			const result = Parser.parse("0.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 0.5,
						unit: "s",
					},
				],
			});
		});

		it("should parse decimal seconds", () => {
			const result = Parser.parse("2.5s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 2.5,
						unit: "s",
					},
				],
			});
		});

		it("should parse decimal milliseconds", () => {
			const result = Parser.parse("100.5ms");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 100.5,
						unit: "ms",
					},
				],
			});
		});
	});

	describe("valid-large", () => {
		it("should parse large values", () => {
			const result = Parser.parse("3600s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 3600,
						unit: "s",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple time values", () => {
			const result = Parser.parse("1s, 2s, 3s, 4s");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-duration",
				durations: [
					{
						value: 1,
						unit: "s",
					},
					{
						value: 2,
						unit: "s",
					},
					{
						value: 3,
						unit: "s",
					},
					{
						value: 4,
						unit: "s",
					},
				],
			});
		});
	});
});


=== File: src/parse/transition/duration.ts ===
// b_path:: src/parse/transition/duration.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse duration value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with Time object or error
 *
 * @internal
 */
function parseDuration(node: csstree.CssNode): Result<Type.Time, string> {
	if (node.type !== "Dimension") {
		return err(`Expected time dimension, got: ${node.type}`);
	}

	const value = Number.parseFloat(node.value);
	const unit = node.unit.toLowerCase();

	if (unit !== "s" && unit !== "ms") {
		return err(`Invalid time unit: ${unit}. Expected 's' or 'ms'`);
	}

	if (value < 0) {
		return err(`transition-duration must be non-negative, got: ${value}`);
	}

	return ok({
		value,
		unit: unit as "s" | "ms",
	});
}

/**
 * Parse CSS transition-duration property value.
 *
 * Parses comma-separated list of time values.
 * Time values must be non-negative.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param css - CSS transition-duration value (e.g., "1s, 500ms")
 * @returns Result with TransitionDuration IR or error message
 *
 * @example
 * Simple duration:
 * ```typescript
 * const result = parse("1s");
 * // { ok: true, value: { kind: "transition-duration", durations: [{ value: 1, unit: "s" }] } }
 * ```
 *
 * @example
 * Multiple durations:
 * ```typescript
 * const result = parse("1s, 500ms");
 * // { ok: true, value: { kind: "transition-duration", durations: [...] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-duration | MDN: transition-duration}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-duration-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TransitionDuration, string> {
	const durationsResult = parseCommaSeparatedSingle(css, parseDuration, "transition-duration");

	if (!durationsResult.ok) {
		return err(durationsResult.error);
	}

	return ok({
		kind: "transition-duration",
		durations: durationsResult.value,
	});
}


=== File: src/parse/transition/index.ts ===
// b_path:: src/parse/transition/index.ts

export * as Delay from "./delay";
export * as Duration from "./duration";
export * as Property from "./property";
export * as TimingFunction from "./timing-function";
export * as Transition from "./transition";
export { parse } from "./transition";


=== File: src/parse/transition/property.failure.test.ts ===
// b_path:: src/parse/transition/property.failure.test.ts
// Auto-generated from scripts/parse-test-generator/configs/transition/property.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-property-property
import { describe, it } from "vitest";

/**
 * Parse failure tests for transition-property
 *
 * NOTE: This property has NO parse failure test cases.
 *
 * Reason: transition-property accepts lenient input:
 * - Basic syntax validation is handled by css-tree parser
 * - The property accepts any valid CSS syntax that css-tree can parse
 * - There are no additional semantic constraints to validate
 *
 * Per CSS specification, this property's grammar accepts a wide range
 * of valid inputs, making it impossible to construct invalid CSS strings
 * that would pass css-tree validation but fail in our parser.
 *
 * Invalid IR structures are tested in generate failure tests instead.
 *
 * @see Generate failure tests: src/generate/transition/property.failure.test.ts
 */
describe("parse/transition/property - invalid cases", () => {
	it("no-op: property has lenient parsing (see documentation above)", () => {
		// This test exists to document why there are no failure test cases.
		// The property parser accepts any input that css-tree validates.
	});
});


=== File: src/parse/transition/property.test.ts ===
// b_path:: src/parse/transition/property.test.ts
// Auto-generated from scripts/parse-test-generator/configs/transition/property.ts
//
// Spec references:
// - OTHER: https://github.com/mdn/data/blob/main/css/properties.json
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-property-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/transition/property";

describe("parse/transition/property - valid cases", () => {
	describe("valid-keyword", () => {
		it("should parse none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "none",
					},
				],
			});
		});

		it("should parse all keyword", () => {
			const result = Parser.parse("all");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "all",
					},
				],
			});
		});

		it("should parse none keyword (uppercase)", () => {
			const result = Parser.parse("NONE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "none",
					},
				],
			});
		});

		it("should parse all keyword (uppercase)", () => {
			const result = Parser.parse("ALL");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "all",
					},
				],
			});
		});
	});

	describe("valid-basic", () => {
		it("should parse single property", () => {
			const result = Parser.parse("opacity");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "opacity",
					},
				],
			});
		});

		it("should parse single property (transform)", () => {
			const result = Parser.parse("transform");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "transform",
					},
				],
			});
		});

		it("should parse hyphenated property name", () => {
			const result = Parser.parse("background-color");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "background-color",
					},
				],
			});
		});

		it("should parse property name (uppercase)", () => {
			const result = Parser.parse("OPACITY");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "OPACITY",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple properties", () => {
			const result = Parser.parse("opacity, transform");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "opacity",
					},
					{
						type: "identifier",
						value: "transform",
					},
				],
			});
		});

		it("should parse three properties", () => {
			const result = Parser.parse("opacity, transform, background-color");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "opacity",
					},
					{
						type: "identifier",
						value: "transform",
					},
					{
						type: "identifier",
						value: "background-color",
					},
				],
			});
		});

		it("should parse multiple properties (no spaces)", () => {
			const result = Parser.parse("width,height,opacity");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "width",
					},
					{
						type: "identifier",
						value: "height",
					},
					{
						type: "identifier",
						value: "opacity",
					},
				],
			});
		});

		it("should parse multiple properties (extra spaces)", () => {
			const result = Parser.parse("opacity,  transform,   background-color");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "opacity",
					},
					{
						type: "identifier",
						value: "transform",
					},
					{
						type: "identifier",
						value: "background-color",
					},
				],
			});
		});
	});

	describe("valid-custom", () => {
		it("should parse custom property", () => {
			const result = Parser.parse("--custom-property");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "--custom-property",
					},
				],
			});
		});

		it("should parse multiple custom properties", () => {
			const result = Parser.parse("--my-color, --my-size");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-property",
				properties: [
					{
						type: "identifier",
						value: "--my-color",
					},
					{
						type: "identifier",
						value: "--my-size",
					},
				],
			});
		});
	});
});


=== File: src/parse/transition/property.ts ===
// b_path:: src/parse/transition/property.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";

/**
 * Parse property value from AST node.
 *
 * @param node - CSS tree node to parse
 * @returns Result with TransitionProperty property object or error
 *
 * @internal
 */
function parseProperty(node: csstree.CssNode): Result<Type.TransitionProperty["properties"][number], string> {
	if (node.type !== "Identifier") {
		return err(`Expected identifier, got: ${node.type}`);
	}

	const value = node.name.toLowerCase();

	if (value === "none") {
		return ok({ type: "none" });
	}

	if (value === "all") {
		return ok({ type: "all" });
	}

	// CSS property name (identifier)
	return ok({ type: "identifier", value: node.name });
}

/**
 * Parse CSS transition-property property value.
 *
 * Parses comma-separated list of property names, 'all', or 'none'.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param css - CSS transition-property value (e.g., "opacity, transform")
 * @returns Result with TransitionProperty IR or error message
 *
 * @example
 * Single property:
 * ```typescript
 * const result = parse("opacity");
 * // { ok: true, value: { kind: "transition-property", properties: [{ type: "identifier", value: "opacity" }] } }
 * ```
 *
 * @example
 * Multiple properties:
 * ```typescript
 * const result = parse("opacity, transform");
 * // { ok: true, value: { kind: "transition-property", properties: [...] } }
 * ```
 *
 * @example
 * Keyword:
 * ```typescript
 * const result = parse("all");
 * // { ok: true, value: { kind: "transition-property", properties: [{ type: "all" }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://github.com/mdn/data/blob/main/css/properties.json | MDN Data}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-property | MDN: transition-property}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-property-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TransitionProperty, string> {
	const propertiesResult = parseCommaSeparatedSingle(css, parseProperty, "transition-property");

	if (!propertiesResult.ok) {
		return err(propertiesResult.error);
	}

	return ok({
		kind: "transition-property",
		properties: propertiesResult.value,
	});
}


=== File: src/parse/transition/timing-function.failure.test.ts ===
// b_path:: src/parse/transition/timing-function.failure.test.ts
// Auto-generated from scripts/test-generator/configs/timing-function.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/transition/timing-function";

describe("parse/transition/timing-function - invalid cases", () => {
	describe("invalid-bezier", () => {
		it("should reject bezier X1 out of range", () => {
			const result = Parser.parse("cubic-bezier(-1, 0, 1, 1)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"transition-timing-function: cubic-bezier validation failed: x1 Too small: expected number to be >=0",
			);
		});

		it("should reject bezier X2 out of range", () => {
			const result = Parser.parse("cubic-bezier(0, 0, 2, 1)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"transition-timing-function: cubic-bezier validation failed: x2 Too big: expected number to be <=1",
			);
		});

		it("should reject bezier X2 above 1", () => {
			const result = Parser.parse("cubic-bezier(0.5, 0, 1.5, 1)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe(
				"transition-timing-function: cubic-bezier validation failed: x2 Too big: expected number to be <=1",
			);
		});

		it("should reject bezier missing arguments", () => {
			const result = Parser.parse("cubic-bezier(0, 0)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: cubic-bezier requires exactly 4 numbers, got 2");
		});

		it("should reject bezier too many arguments", () => {
			const result = Parser.parse("cubic-bezier(0, 0, 1, 1, 0)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: cubic-bezier requires exactly 4 numbers, got 5");
		});
	});

	describe("invalid-steps", () => {
		it("should reject zero steps", () => {
			const result = Parser.parse("steps(0)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: steps() requires a positive integer, got 0");
		});

		it("should reject negative steps", () => {
			const result = Parser.parse("steps(-1)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: steps() requires a positive integer, got -1");
		});

		it("should reject fractional steps", () => {
			const result = Parser.parse("steps(1.5)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: steps() requires a positive integer, got 1.5");
		});

		it("should reject steps missing argument", () => {
			const result = Parser.parse("steps()");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: steps() requires a step count");
		});

		it("should reject steps invalid position", () => {
			const result = Parser.parse("steps(2, invalid)");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: Invalid step position keyword: invalid");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: Invalid easing keyword: invalid");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: Invalid easing keyword: none");
		});
	});

	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: Empty value");
		});
	});

	describe("invalid-comma", () => {
		it("should reject trailing comma", () => {
			const result = Parser.parse("ease,");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: Empty value");
		});

		it("should reject leading comma", () => {
			const result = Parser.parse(",ease");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: Empty value before comma");
		});

		it("should reject double comma", () => {
			const result = Parser.parse("ease,,linear");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("transition-timing-function: Empty value before comma");
		});
	});
});


=== File: src/parse/transition/timing-function.test.ts ===
// b_path:: src/parse/transition/timing-function.test.ts
// Auto-generated from scripts/parse-test-generator/configs/transition/timing-function.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function
// - W3C: https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/transition/timing-function";

describe("parse/transition/timing-function - valid cases", () => {
	describe("valid-keyword", () => {
		it("should parse ease keyword", () => {
			const result = Parser.parse("ease");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["ease"],
			});
		});

		it("should parse linear keyword", () => {
			const result = Parser.parse("linear");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["linear"],
			});
		});

		it("should parse ease-in keyword", () => {
			const result = Parser.parse("ease-in");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["ease-in"],
			});
		});

		it("should parse ease-out keyword", () => {
			const result = Parser.parse("ease-out");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["ease-out"],
			});
		});

		it("should parse ease-in-out keyword", () => {
			const result = Parser.parse("ease-in-out");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["ease-in-out"],
			});
		});

		it("should parse step-start keyword", () => {
			const result = Parser.parse("step-start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["step-start"],
			});
		});

		it("should parse step-end keyword", () => {
			const result = Parser.parse("step-end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["step-end"],
			});
		});

		it("should parse case insensitive keyword", () => {
			const result = Parser.parse("EASE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["ease"],
			});
		});
	});

	describe("valid-bezier", () => {
		it("should parse basic bezier", () => {
			const result = Parser.parse("cubic-bezier(0, 0, 1, 1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0,
						y1: 0,
						x2: 1,
						y2: 1,
					},
				],
			});
		});

		it("should parse custom bezier", () => {
			const result = Parser.parse("cubic-bezier(0.42, 0, 0.58, 1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0.42,
						y1: 0,
						x2: 0.58,
						y2: 1,
					},
				],
			});
		});

		it("should parse bezier with Y outside 0-1", () => {
			const result = Parser.parse("cubic-bezier(0, -2, 1, 3)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0,
						y1: -2,
						x2: 1,
						y2: 3,
					},
				],
			});
		});

		it("should parse ease bezier values", () => {
			const result = Parser.parse("cubic-bezier(0.25, 0.1, 0.25, 1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 0.25,
						y1: 0.1,
						x2: 0.25,
						y2: 1,
					},
				],
			});
		});

		it("should parse reverse bezier", () => {
			const result = Parser.parse("cubic-bezier(1, 0, 0, 1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "cubic-bezier",
						x1: 1,
						y1: 0,
						x2: 0,
						y2: 1,
					},
				],
			});
		});
	});

	describe("valid-steps", () => {
		it("should parse single step", () => {
			const result = Parser.parse("steps(1)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 1,
					},
				],
			});
		});

		it("should parse multiple steps", () => {
			const result = Parser.parse("steps(4)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 4,
					},
				],
			});
		});

		it("should parse steps with jump-start", () => {
			const result = Parser.parse("steps(4, jump-start)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 4,
						position: "jump-start",
					},
				],
			});
		});

		it("should parse steps with jump-end", () => {
			const result = Parser.parse("steps(10, jump-end)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 10,
						position: "jump-end",
					},
				],
			});
		});

		it("should parse steps with jump-none", () => {
			const result = Parser.parse("steps(5, jump-none)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 5,
						position: "jump-none",
					},
				],
			});
		});

		it("should parse steps with jump-both", () => {
			const result = Parser.parse("steps(3, jump-both)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 3,
						position: "jump-both",
					},
				],
			});
		});

		it("should parse steps with legacy start", () => {
			const result = Parser.parse("steps(2, start)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 2,
						position: "start",
					},
				],
			});
		});

		it("should parse steps with legacy end", () => {
			const result = Parser.parse("steps(2, end)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					{
						type: "steps",
						steps: 2,
						position: "end",
					},
				],
			});
		});
	});

	describe("valid-list", () => {
		it("should parse multiple keywords", () => {
			const result = Parser.parse("ease, linear");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["ease", "linear"],
			});
		});

		it("should parse mixed functions", () => {
			const result = Parser.parse("ease-in, cubic-bezier(0, 0, 1, 1), steps(2)");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: [
					"ease-in",
					{
						type: "cubic-bezier",
						x1: 0,
						y1: 0,
						x2: 1,
						y2: 1,
					},
					{
						type: "steps",
						steps: 2,
					},
				],
			});
		});

		it("should parse list with whitespace", () => {
			const result = Parser.parse("ease , linear");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "transition-timing-function",
				functions: ["ease", "linear"],
			});
		});
	});
});


=== File: src/parse/transition/timing-function.ts ===
// b_path:: src/parse/transition/timing-function.ts
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseCommaSeparatedSingle } from "@/utils/parse/comma-separated";
import { parseEasingFunction } from "@/utils/parse/easing";

/**
 * Parse CSS transition-timing-function property value.
 *
 * Parses comma-separated list of easing functions.
 *
 * Per CSS Transitions Level 1 specification.
 *
 * @param css - CSS transition-timing-function value (e.g., "ease-in, cubic-bezier(0.1, 0.7, 1.0, 0.1)")
 * @returns Result with TransitionTimingFunction IR or error message
 *
 * @example
 * Keyword:
 * ```typescript
 * const result = parse("ease-in");
 * // { ok: true, value: { kind: "transition-timing-function", functions: ["ease-in"] } }
 * ```
 *
 * @example
 * Cubic bezier:
 * ```typescript
 * const result = parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)");
 * // { ok: true, value: { kind: "transition-timing-function", functions: [{ type: "cubic-bezier", x1: 0.1, ... }] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function | MDN: transition-timing-function}
 * @see {@link https://www.w3.org/TR/css-transitions-1/#transition-timing-function-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TransitionTimingFunction, string> {
	const functionsResult = parseCommaSeparatedSingle(css, parseEasingFunction, "transition-timing-function");

	if (!functionsResult.ok) {
		return err(functionsResult.error);
	}

	return ok({
		kind: "transition-timing-function",
		functions: functionsResult.value,
	});
}


=== File: src/parse/transition/transition.test.ts ===
// b_path:: src/parse/transition/transition.test.ts
import { describe, expect, it } from "vitest";
import { parse } from "./transition";

describe("parse transition dispatcher", () => {
	describe("dispatches to Duration parser", () => {
		it("parses seconds", () => {
			const result = parse("1s");
			expect(result.ok).toBe(true);
		});

		it("parses milliseconds", () => {
			const result = parse("500ms");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Delay parser", () => {
		it("parses delay value", () => {
			const result = parse("200ms");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to TimingFunction parser", () => {
		it("parses ease", () => {
			const result = parse("ease");
			expect(result.ok).toBe(true);
		});

		it("parses linear", () => {
			const result = parse("linear");
			expect(result.ok).toBe(true);
		});

		it("parses ease-in", () => {
			const result = parse("ease-in");
			expect(result.ok).toBe(true);
		});
	});

	describe("dispatches to Property parser", () => {
		it("parses property name", () => {
			const result = parse("opacity");
			expect(result.ok).toBe(true);
		});

		it("parses all keyword", () => {
			const result = parse("all");
			expect(result.ok).toBe(true);
		});
	});

	describe("error handling", () => {
		it("parses property names as valid", () => {
			// Property parser accepts CSS property names
			const result = parse("transform");
			expect(result.ok).toBe(true);
		});

		it("rejects empty string", () => {
			const result = parse("");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/transition/transition.ts ===
// b_path:: src/parse/transition/transition.ts

import { type ParseResult, parseErr, toParseResult } from "@/core/result";
import type * as Type from "@/core/types/transition";

import * as Delay from "./delay";
import * as Duration from "./duration";
import * as Property from "./property";
import * as TimingFunction from "./timing-function";

export type Transition =
	| Type.TransitionDelay
	| Type.TransitionDuration
	| Type.TransitionProperty
	| Type.TransitionTimingFunction;

export function parse(value: string): ParseResult<Transition> {
	const durationResult = Duration.parse(value);
	if (durationResult.ok) return toParseResult(durationResult);

	const delayResult = Delay.parse(value);
	if (delayResult.ok) return toParseResult(delayResult);

	const timingResult = TimingFunction.parse(value);
	if (timingResult.ok) return toParseResult(timingResult);

	const propertyResult = Property.parse(value);
	if (propertyResult.ok) return toParseResult(propertyResult);

	return parseErr("invalid-value", "Invalid transition property value", {
		suggestion: "Expected duration (1s, 500ms), delay, timing-function, or property name",
	});
}


=== File: src/parse/typography/font-family.test.ts ===
// b_path:: src/parse/typography/font-family.test.ts
import { describe, expect, it } from "vitest";
import * as FontFamily from "./font-family";

describe("Parse.Typography.FontFamily", () => {
	describe("single font family", () => {
		it("should parse single identifier", () => {
			const result = FontFamily.parse("Arial");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "font-family",
					families: ["Arial"],
				});
			}
		});

		it("should parse generic family", () => {
			const result = FontFamily.parse("sans-serif");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.families).toEqual(["sans-serif"]);
			}
		});

		it("should parse quoted family name", () => {
			const result = FontFamily.parse('"Times New Roman"');
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.families).toEqual(["Times New Roman"]);
			}
		});

		it("should parse single-quoted family name", () => {
			const result = FontFamily.parse("'Courier New'");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.families).toEqual(["Courier New"]);
			}
		});

		it("should parse multi-word unquoted family", () => {
			const result = FontFamily.parse("Helvetica Neue");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.families).toEqual(["Helvetica Neue"]);
			}
		});
	});

	describe("multiple font families", () => {
		it("should parse comma-separated list", () => {
			const result = FontFamily.parse("Arial, sans-serif");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.families).toEqual(["Arial", "sans-serif"]);
			}
		});

		it("should parse with quoted names", () => {
			const result = FontFamily.parse('"Times New Roman", Times, serif');
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.families).toEqual(["Times New Roman", "Times", "serif"]);
			}
		});

		it("should parse multiple generic families", () => {
			const result = FontFamily.parse("Georgia, Times, serif");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.families).toEqual(["Georgia", "Times", "serif"]);
			}
		});

		it("should handle spaces around commas", () => {
			const result = FontFamily.parse("Arial , Helvetica , sans-serif");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.families).toEqual(["Arial", "Helvetica", "sans-serif"]);
			}
		});
	});

	describe("all generic family keywords", () => {
		it("should parse 'serif'", () => {
			const result = FontFamily.parse("serif");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.families).toEqual(["serif"]);
		});

		it("should parse 'monospace'", () => {
			const result = FontFamily.parse("monospace");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.families).toEqual(["monospace"]);
		});

		it("should parse 'cursive'", () => {
			const result = FontFamily.parse("cursive");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.families).toEqual(["cursive"]);
		});

		it("should parse 'fantasy'", () => {
			const result = FontFamily.parse("fantasy");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.families).toEqual(["fantasy"]);
		});
	});

	describe("error cases", () => {
		it("should reject empty string", () => {
			const result = FontFamily.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject only commas", () => {
			const result = FontFamily.parse(",,,");
			expect(result.ok).toBe(false);
		});

		it("should handle parse exceptions", () => {
			const result = FontFamily.parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse font-family");
			}
		});

		it("should reject invalid CSS value types", () => {
			const result = FontFamily.parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/typography/font-family.ts ===
// b_path:: src/parse/typography/font-family.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS font-family property value.
 *
 * Accepts comma-separated list of font family names and/or generic family keywords.
 * Per CSS Fonts Module Level 4 specification.
 *
 * @param css - CSS font-family value (e.g., "Arial, sans-serif", "'Times New Roman', serif")
 * @returns Result with FontFamily IR or error message
 *
 * @example
 * Single family:
 * ```typescript
 * const result = parse("Arial");
 * // { ok: true, value: { kind: "font-family", families: ["Arial"] } }
 * ```
 *
 * @example
 * Multiple families:
 * ```typescript
 * const result = parse("Arial, sans-serif");
 * // { ok: true, value: { kind: "font-family", families: ["Arial", "sans-serif"] } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-family | MDN: font-family}
 * @see {@link https://www.w3.org/TR/css-fonts-4/#font-family-prop | W3C Spec}
 */
export function parse(css: string): Result<Type.FontFamily, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const families: string[] = [];
		let currentFamily: string[] = [];

		for (const node of ast.children) {
			if (node.type === "Operator" && node.value === ",") {
				if (currentFamily.length > 0) {
					families.push(currentFamily.join(" "));
					currentFamily = [];
				}
				continue;
			}

			if (node.type === "Identifier") {
				currentFamily.push(node.name);
			} else if (node.type === "String") {
				// Remove quotes from string values
				const unquoted = node.value.replace(/^["']|["']$/g, "");
				currentFamily.push(unquoted);
			} else if (node.type === "WhiteSpace") {
			}
		}

		// Add last family
		if (currentFamily.length > 0) {
			families.push(currentFamily.join(" "));
		}

		if (families.length === 0) {
			return err("Expected at least one font family");
		}

		return ok({
			kind: "font-family",
			families,
		});
	} catch (error) {
		return err(`Failed to parse font-family: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/font-size.test.ts ===
// b_path:: src/parse/typography/font-size.test.ts
import { describe, expect, it } from "vitest";
import * as FontSize from "./font-size";

describe("Parse.Typography.FontSize", () => {
	describe("absolute size keywords", () => {
		it("should parse 'xx-small'", () => {
			const result = FontSize.parse("xx-small");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "font-size",
					value: "xx-small",
				});
			}
		});

		it("should parse 'x-small'", () => {
			const result = FontSize.parse("x-small");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("x-small");
		});

		it("should parse 'small'", () => {
			const result = FontSize.parse("small");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("small");
		});

		it("should parse 'medium'", () => {
			const result = FontSize.parse("medium");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("medium");
		});

		it("should parse 'large'", () => {
			const result = FontSize.parse("large");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("large");
		});

		it("should parse 'x-large'", () => {
			const result = FontSize.parse("x-large");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("x-large");
		});

		it("should parse 'xx-large'", () => {
			const result = FontSize.parse("xx-large");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("xx-large");
		});

		it("should parse 'xxx-large'", () => {
			const result = FontSize.parse("xxx-large");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("xxx-large");
		});
	});

	describe("relative size keywords", () => {
		it("should parse 'larger'", () => {
			const result = FontSize.parse("larger");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("larger");
		});

		it("should parse 'smaller'", () => {
			const result = FontSize.parse("smaller");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("smaller");
		});
	});

	describe("length values", () => {
		it("should parse pixel values", () => {
			const result = FontSize.parse("16px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 16, unit: "px" });
			}
		});

		it("should parse em values", () => {
			const result = FontSize.parse("1.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 1.5, unit: "em" });
			}
		});

		it("should parse rem values", () => {
			const result = FontSize.parse("2rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 2, unit: "rem" });
			}
		});
	});

	describe("percentage values", () => {
		it("should parse percentage values", () => {
			const result = FontSize.parse("120%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 120, unit: "%" });
			}
		});
	});

	describe("error cases", () => {
		it("should reject invalid values", () => {
			const result = FontSize.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = FontSize.parse("16px 20px");
			expect(result.ok).toBe(false);
		});

		it("should parse unitless zero", () => {
			const result = FontSize.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should reject unitless non-zero", () => {
			const result = FontSize.parse("16");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("require a unit");
			}
		});

		it("should reject invalid value type", () => {
			const result = FontSize.parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("should handle parse exception", () => {
			const result = FontSize.parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse font-size");
			}
		});
	});
});


=== File: src/parse/typography/font-size.ts ===
// b_path:: src/parse/typography/font-size.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS font-size property value.
 *
 * Accepts length, percentage, or keyword values.
 * Per CSS Fonts Module Level 4 specification.
 *
 * @param css - CSS font-size value (e.g., "16px", "1.2em", "larger", "small")
 * @returns Result with FontSize IR or error message
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("16px");
 * // { ok: true, value: { kind: "font-size", value: { value: 16, unit: "px" } } }
 * ```
 *
 * @example
 * Keyword value:
 * ```typescript
 * const result = parse("medium");
 * // { ok: true, value: { kind: "font-size", value: "medium" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size | MDN: font-size}
 * @see {@link https://www.w3.org/TR/css-fonts-4/#font-size-prop | W3C Spec}
 */
export function parse(css: string): Result<Type.FontSize, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected font-size value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			// Absolute size keywords
			const absoluteSizes = ["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"];
			// Relative size keywords
			const relativeSizes = ["larger", "smaller"];

			if (absoluteSizes.includes(keyword) || relativeSizes.includes(keyword)) {
				return ok({
					kind: "font-size",
					value: keyword as Type.FontSize["value"],
				});
			}

			return err(`Invalid font-size keyword: ${keyword}`);
		}

		// Handle unitless 0
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			if (value === 0) {
				return ok({
					kind: "font-size",
					value: { value: 0, unit: "px" },
				});
			}
			return err("Length values require a unit (except for 0)");
		}

		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "font-size",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse font-size: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/font-style.failure.test.ts ===
// b_path:: src/parse/typography/font-style.failure.test.ts
// Auto-generated from scripts/test-generator/configs/font-style.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
// - W3C: https://www.w3.org/TR/css-fonts-4/#font-style-prop
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/typography/font-style";

describe("parse/typography/font-style - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("bold");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid font-style keyword: bold");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword for font-style");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword for font-style");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("normal italic");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/typography/font-style.test.ts ===
// b_path:: src/parse/typography/font-style.test.ts
// Auto-generated from scripts/parse-test-generator/configs/typography/font-style.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/font-style
// - W3C: https://www.w3.org/TR/css-fonts-4/#font-style-prop
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/typography/font-style";

describe("parse/typography/font-style - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse normal keyword", () => {
			const result = Parser.parse("normal");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "font-style",
				value: "normal",
			});
		});

		it("should parse italic keyword", () => {
			const result = Parser.parse("italic");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "font-style",
				value: "italic",
			});
		});

		it("should parse oblique keyword", () => {
			const result = Parser.parse("oblique");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "font-style",
				value: "oblique",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase italic", () => {
			const result = Parser.parse("ITALIC");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "font-style",
				value: "italic",
			});
		});
	});
});


=== File: src/parse/typography/font-style.ts ===
// b_path:: src/parse/typography/font-style.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS font-style property value.
 *
 * Accepts keyword values: normal, italic, oblique.
 * Per CSS Fonts Module Level 4 specification.
 *
 * @param css - CSS font-style value (e.g., "normal", "italic", "oblique")
 * @returns Result with FontStyle IR or error message
 *
 * @example
 * Normal font style:
 * ```typescript
 * const result = parse("normal");
 * // { ok: true, value: { kind: "font-style", value: "normal" } }
 * ```
 *
 * @example
 * Italic font style:
 * ```typescript
 * const result = parse("italic");
 * // { ok: true, value: { kind: "font-style", value: "italic" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style | MDN: font-style}
 * @see {@link https://www.w3.org/TR/css-fonts-4/#font-style-prop | W3C Spec}
 */
export function parse(css: string): Result<Type.FontStyle, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected font-style value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			const validKeywords = ["normal", "italic", "oblique"];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "font-style",
					value: keyword as Type.FontStyle["value"],
				});
			}

			return err(`Invalid font-style keyword: ${keyword}`);
		}

		return err("Expected keyword for font-style");
	} catch (error) {
		return err(`Failed to parse font-style: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/font-weight.test.ts ===
// b_path:: src/parse/typography/font-weight.test.ts
import { describe, expect, it } from "vitest";
import * as FontWeight from "./font-weight";

describe("Parse.Typography.FontWeight", () => {
	describe("keyword values", () => {
		it("should parse 'normal'", () => {
			const result = FontWeight.parse("normal");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "font-weight",
					value: "normal",
				});
			}
		});

		it("should parse 'bold'", () => {
			const result = FontWeight.parse("bold");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("bold");
		});

		it("should parse 'bolder'", () => {
			const result = FontWeight.parse("bolder");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("bolder");
		});

		it("should parse 'lighter'", () => {
			const result = FontWeight.parse("lighter");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe("lighter");
		});
	});

	describe("numeric values", () => {
		it("should parse standard weights", () => {
			const weights = [100, 200, 300, 400, 500, 600, 700, 800, 900];
			for (const weight of weights) {
				const result = FontWeight.parse(String(weight));
				expect(result.ok).toBe(true);
				if (result.ok) expect(result.value.value).toBe(weight);
			}
		});

		it("should parse variable font weights", () => {
			const result = FontWeight.parse("350");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe(350);
		});

		it("should parse weight 1", () => {
			const result = FontWeight.parse("1");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe(1);
		});

		it("should parse weight 1000", () => {
			const result = FontWeight.parse("1000");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe(1000);
		});
	});

	describe("error cases", () => {
		it("should reject invalid keyword", () => {
			const result = FontWeight.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("should reject weight out of range (< 1)", () => {
			const result = FontWeight.parse("0");
			expect(result.ok).toBe(false);
		});

		it("should reject weight out of range (> 1000)", () => {
			const result = FontWeight.parse("1001");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = FontWeight.parse("400 500");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid value type", () => {
			const result = FontWeight.parse("10px");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected number or keyword");
			}
		});

		it("should handle parse exception", () => {
			const result = FontWeight.parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse font-weight");
			}
		});
	});
});


=== File: src/parse/typography/font-weight.ts ===
// b_path:: src/parse/typography/font-weight.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS font-weight property value.
 *
 * Accepts numeric values (100-900) or keyword values.
 * Per CSS Fonts Module Level 4 specification.
 *
 * @param css - CSS font-weight value (e.g., "400", "bold", "normal")
 * @returns Result with FontWeight IR or error message
 *
 * @example
 * Numeric value:
 * ```typescript
 * const result = parse("400");
 * // { ok: true, value: { kind: "font-weight", value: 400 } }
 * ```
 *
 * @example
 * Keyword value:
 * ```typescript
 * const result = parse("bold");
 * // { ok: true, value: { kind: "font-weight", value: "bold" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight | MDN: font-weight}
 * @see {@link https://www.w3.org/TR/css-fonts-4/#font-weight-prop | W3C Spec}
 */
export function parse(css: string): Result<Type.FontWeight, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected font-weight value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			const validKeywords = ["normal", "bold", "bolder", "lighter"];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "font-weight",
					value: keyword as Type.FontWeight["value"],
				});
			}

			return err(`Invalid font-weight keyword: ${keyword}`);
		}

		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);

			// font-weight accepts 1-1000 in CSS Fonts 4
			if (value >= 1 && value <= 1000) {
				return ok({
					kind: "font-weight",
					value: value,
				});
			}

			return err(`font-weight must be between 1 and 1000, got ${value}`);
		}

		return err("Expected number or keyword for font-weight");
	} catch (error) {
		return err(`Failed to parse font-weight: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/index.ts ===
// b_path:: src/parse/typography/index.ts

export * as FontFamily from "./font-family";
export * as FontSize from "./font-size";
export * as FontStyle from "./font-style";
export * as FontWeight from "./font-weight";
export * as LetterSpacing from "./letter-spacing";
export * as LineHeight from "./line-height";
export * as OverflowWrap from "./overflow-wrap";
export * as TextAlign from "./text-align";
export * as TextTransform from "./text-transform";
export * as VerticalAlign from "./vertical-align";
export * as WordBreak from "./word-break";


=== File: src/parse/typography/letter-spacing.test.ts ===
// b_path:: src/parse/typography/letter-spacing.test.ts
import { describe, expect, it } from "vitest";
import * as LetterSpacing from "./letter-spacing";

describe("Parse.Typography.LetterSpacing", () => {
	describe("valid keywords", () => {
		it("should parse 'normal'", () => {
			const result = LetterSpacing.parse("normal");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "letter-spacing",
					value: "normal",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse 'NORMAL' (uppercase)", () => {
			const result = LetterSpacing.parse("NORMAL");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("normal");
			}
		});

		it("should parse 'Normal' (mixed case)", () => {
			const result = LetterSpacing.parse("Normal");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("normal");
			}
		});
	});

	describe("length values", () => {
		it("should parse '0' (zero)", () => {
			const result = LetterSpacing.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "letter-spacing",
					value: { value: 0, unit: "px" },
				});
			}
		});

		it("should parse '0.1em'", () => {
			const result = LetterSpacing.parse("0.1em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "letter-spacing",
					value: { value: 0.1, unit: "em" },
				});
			}
		});

		it("should parse '2px'", () => {
			const result = LetterSpacing.parse("2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "letter-spacing",
					value: { value: 2, unit: "px" },
				});
			}
		});

		it("should parse negative value '-1px'", () => {
			const result = LetterSpacing.parse("-1px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "letter-spacing",
					value: { value: -1, unit: "px" },
				});
			}
		});

		it("should parse '0.05rem'", () => {
			const result = LetterSpacing.parse("0.05rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "letter-spacing",
					value: { value: 0.05, unit: "rem" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("should parse '10%'", () => {
			const result = LetterSpacing.parse("10%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "letter-spacing",
					value: { value: 10, unit: "%" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = LetterSpacing.parse("auto");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid letter-spacing keyword");
			}
		});

		it("should reject empty string", () => {
			const result = LetterSpacing.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = LetterSpacing.parse("2px 4px");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid value type", () => {
			const result = LetterSpacing.parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected length or 'normal'");
			}
		});

		it("should handle parse exception", () => {
			const result = LetterSpacing.parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse letter-spacing");
			}
		});
	});
});


=== File: src/parse/typography/letter-spacing.ts ===
// b_path:: src/parse/typography/letter-spacing.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseLengthPercentageNode } from "@/utils/parse/nodes/length";

/**
 * Parse CSS letter-spacing property value.
 *
 * Accepts length values or the normal keyword.
 * Per CSS Text Module Level 3 specification.
 *
 * @param css - CSS letter-spacing value (e.g., "normal", "0.1em", "2px")
 * @returns Result with LetterSpacing IR or error message
 *
 * @example
 * Normal letter spacing:
 * ```typescript
 * const result = parse("normal");
 * // { ok: true, value: { kind: "letter-spacing", value: "normal" } }
 * ```
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("0.1em");
 * // { ok: true, value: { kind: "letter-spacing", value: { value: 0.1, unit: "em" } } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing | MDN: letter-spacing}
 * @see {@link https://www.w3.org/TR/css-text-3/#letter-spacing-property | W3C Spec}
 */
export function parse(css: string): Result<Type.LetterSpacing, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected letter-spacing value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "normal") {
				return ok({
					kind: "letter-spacing",
					value: "normal",
				});
			}

			return err(`Invalid letter-spacing keyword: ${keyword}`);
		}

		const lengthResult = parseLengthPercentageNode(node);
		if (lengthResult.ok) {
			return ok({
				kind: "letter-spacing",
				value: lengthResult.value,
			});
		}

		return err("Expected length or 'normal' for letter-spacing");
	} catch (error) {
		return err(`Failed to parse letter-spacing: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/line-height.test.ts ===
// b_path:: src/parse/typography/line-height.test.ts
import { describe, expect, it } from "vitest";
import * as LineHeight from "./line-height";

describe("Parse.Typography.LineHeight", () => {
	describe("keyword values", () => {
		it("should parse 'normal'", () => {
			const result = LineHeight.parse("normal");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "line-height",
					value: "normal",
				});
			}
		});
	});

	describe("unitless numbers", () => {
		it("should parse integer", () => {
			const result = LineHeight.parse("1");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe(1);
		});

		it("should parse decimal", () => {
			const result = LineHeight.parse("1.5");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe(1.5);
		});

		it("should parse small number", () => {
			const result = LineHeight.parse("0.8");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe(0.8);
		});

		it("should parse large number", () => {
			const result = LineHeight.parse("2.5");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe(2.5);
		});

		it("should parse zero", () => {
			const result = LineHeight.parse("0");
			expect(result.ok).toBe(true);
			if (result.ok) expect(result.value.value).toBe(0);
		});
	});

	describe("length values", () => {
		it("should parse pixel values", () => {
			const result = LineHeight.parse("20px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse em values", () => {
			const result = LineHeight.parse("1.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 1.5, unit: "em" });
			}
		});

		it("should parse rem values", () => {
			const result = LineHeight.parse("2rem");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 2, unit: "rem" });
			}
		});
	});

	describe("percentage values", () => {
		it("should parse percentage", () => {
			const result = LineHeight.parse("120%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 120, unit: "%" });
			}
		});

		it("should parse large percentage", () => {
			const result = LineHeight.parse("150%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toEqual({ value: 150, unit: "%" });
			}
		});
	});

	describe("error cases", () => {
		it("should reject invalid keyword", () => {
			const result = LineHeight.parse("invalid");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = LineHeight.parse("1.5 20px");
			expect(result.ok).toBe(false);
		});

		it("should reject invalid value type", () => {
			const result = LineHeight.parse("rgb(255, 0, 0)");
			expect(result.ok).toBe(false);
		});

		it("should handle parse exception", () => {
			const result = LineHeight.parse("@@@");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Failed to parse line-height");
			}
		});
	});
});


=== File: src/parse/typography/line-height.ts ===
// b_path:: src/parse/typography/line-height.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as ParseUtils from "@/utils/parse";

/**
 * Parse CSS line-height property value.
 *
 * Accepts length, percentage, number, or normal keyword.
 * Per CSS Inline Layout Module Level 3 specification.
 *
 * @param css - CSS line-height value (e.g., "1.5", "20px", "normal")
 * @returns Result with LineHeight IR or error message
 *
 * @example
 * Unitless number:
 * ```typescript
 * const result = parse("1.5");
 * // { ok: true, value: { kind: "line-height", value: 1.5 } }
 * ```
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("20px");
 * // { ok: true, value: { kind: "line-height", value: { value: 20, unit: "px" } } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/line-height | MDN: line-height}
 * @see {@link https://www.w3.org/TR/css-inline-3/#line-height-property | W3C Spec}
 */
export function parse(css: string): Result<Type.LineHeight, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected line-height value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			if (keyword === "normal") {
				return ok({
					kind: "line-height",
					value: "normal",
				});
			}

			return err(`Invalid line-height keyword: ${keyword}`);
		}

		// Unitless number
		if (node.type === "Number") {
			const value = Number.parseFloat(node.value);
			return ok({
				kind: "line-height",
				value: value,
			});
		}

		// Length or percentage
		const lengthResult = ParseUtils.parseLengthPercentageNode(node);
		if (!lengthResult.ok) {
			return err(lengthResult.error);
		}

		return ok({
			kind: "line-height",
			value: lengthResult.value,
		});
	} catch (error) {
		return err(`Failed to parse line-height: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/overflow-wrap.test.ts ===
// b_path:: src/parse/typography/overflow-wrap.test.ts
import { describe, expect, it } from "vitest";
import * as OverflowWrap from "./overflow-wrap";

describe("Parse.Typography.OverflowWrap", () => {
	describe("valid keywords", () => {
		it("should parse 'normal'", () => {
			const result = OverflowWrap.parse("normal");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-wrap",
					value: "normal",
				});
			}
		});

		it("should parse 'break-word'", () => {
			const result = OverflowWrap.parse("break-word");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-wrap",
					value: "break-word",
				});
			}
		});

		it("should parse 'anywhere'", () => {
			const result = OverflowWrap.parse("anywhere");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "overflow-wrap",
					value: "anywhere",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse 'BREAK-WORD' (uppercase)", () => {
			const result = OverflowWrap.parse("BREAK-WORD");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("break-word");
			}
		});

		it("should parse 'Anywhere' (mixed case)", () => {
			const result = OverflowWrap.parse("Anywhere");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("anywhere");
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = OverflowWrap.parse("break-all");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid overflow-wrap keyword");
			}
		});

		it("should reject numeric value", () => {
			const result = OverflowWrap.parse("12px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = OverflowWrap.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = OverflowWrap.parse("normal anywhere");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/typography/overflow-wrap.ts ===
// b_path:: src/parse/typography/overflow-wrap.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS overflow-wrap property value.
 *
 * Accepts keyword values.
 * Per CSS Text Module Level 3 specification.
 *
 * @param css - CSS overflow-wrap value (e.g., "normal", "break-word", "anywhere")
 * @returns Result with OverflowWrap IR or error message
 *
 * @example
 * Break word:
 * ```typescript
 * const result = parse("break-word");
 * // { ok: true, value: { kind: "overflow-wrap", value: "break-word" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap | MDN: overflow-wrap}
 * @see {@link https://www.w3.org/TR/css-text-3/#overflow-wrap-property | W3C Spec}
 */
export function parse(css: string): Result<Type.OverflowWrap, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected overflow-wrap value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			const validKeywords = ["normal", "break-word", "anywhere"];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "overflow-wrap",
					value: keyword as Type.OverflowWrap["value"],
				});
			}

			return err(`Invalid overflow-wrap keyword: ${keyword}`);
		}

		return err("Expected keyword for overflow-wrap");
	} catch (error) {
		return err(`Failed to parse overflow-wrap: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/text-align.failure.test.ts ===
// b_path:: src/parse/typography/text-align.failure.test.ts
// Auto-generated from scripts/test-generator/configs/text-align.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/text-align
// - W3C: https://www.w3.org/TR/css-text-3/#text-align-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/typography/text-align";

describe("parse/typography/text-align - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("middle");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid text-align keyword: middle");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword for text-align");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword for text-align");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("left center");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/typography/text-align.test.ts ===
// b_path:: src/parse/typography/text-align.test.ts
// Auto-generated from scripts/parse-test-generator/configs/typography/text-align.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/text-align
// - W3C: https://www.w3.org/TR/css-text-3/#text-align-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/typography/text-align";

describe("parse/typography/text-align - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse left keyword", () => {
			const result = Parser.parse("left");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-align",
				value: "left",
			});
		});

		it("should parse right keyword", () => {
			const result = Parser.parse("right");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-align",
				value: "right",
			});
		});

		it("should parse center keyword", () => {
			const result = Parser.parse("center");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-align",
				value: "center",
			});
		});

		it("should parse justify keyword", () => {
			const result = Parser.parse("justify");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-align",
				value: "justify",
			});
		});
	});

	describe("valid-logical", () => {
		it("should parse start keyword", () => {
			const result = Parser.parse("start");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-align",
				value: "start",
			});
		});

		it("should parse end keyword", () => {
			const result = Parser.parse("end");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-align",
				value: "end",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase center", () => {
			const result = Parser.parse("CENTER");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-align",
				value: "center",
			});
		});
	});
});


=== File: src/parse/typography/text-align.ts ===
// b_path:: src/parse/typography/text-align.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS text-align property value.
 *
 * Accepts alignment keywords.
 * Per CSS Text Module Level 3 specification.
 *
 * @param css - CSS text-align value (e.g., "left", "center", "right", "justify")
 * @returns Result with TextAlign IR or error message
 *
 * @example
 * ```typescript
 * const result = parse("center");
 * // { ok: true, value: { kind: "text-align", value: "center" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-align | MDN: text-align}
 * @see {@link https://www.w3.org/TR/css-text-3/#text-align-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TextAlign, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected text-align value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			const validKeywords = ["left", "right", "center", "justify", "start", "end"];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "text-align",
					value: keyword as Type.TextAlign["value"],
				});
			}

			return err(`Invalid text-align keyword: ${keyword}`);
		}

		return err("Expected keyword for text-align");
	} catch (error) {
		return err(`Failed to parse text-align: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/text-transform.failure.test.ts ===
// b_path:: src/parse/typography/text-transform.failure.test.ts
// Auto-generated from scripts/test-generator/configs/text-transform.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform
// - W3C: https://www.w3.org/TR/css-text-3/#text-transform-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/typography/text-transform";

describe("parse/typography/text-transform - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("title-case");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid text-transform keyword: title-case");
		});
	});

	describe("invalid-type", () => {
		it("should reject numeric value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword for text-transform");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("10px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword for text-transform");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("uppercase lowercase");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 2 values");
		});
	});
});


=== File: src/parse/typography/text-transform.test.ts ===
// b_path:: src/parse/typography/text-transform.test.ts
// Auto-generated from scripts/parse-test-generator/configs/typography/text-transform.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform
// - W3C: https://www.w3.org/TR/css-text-3/#text-transform-property
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/typography/text-transform";

describe("parse/typography/text-transform - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse none keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-transform",
				value: "none",
			});
		});

		it("should parse capitalize keyword", () => {
			const result = Parser.parse("capitalize");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-transform",
				value: "capitalize",
			});
		});

		it("should parse uppercase keyword", () => {
			const result = Parser.parse("uppercase");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-transform",
				value: "uppercase",
			});
		});

		it("should parse lowercase keyword", () => {
			const result = Parser.parse("lowercase");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-transform",
				value: "lowercase",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase uppercase", () => {
			const result = Parser.parse("UPPERCASE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "text-transform",
				value: "uppercase",
			});
		});
	});
});


=== File: src/parse/typography/text-transform.ts ===
// b_path:: src/parse/typography/text-transform.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS text-transform property value.
 *
 * Accepts keyword values.
 * Per CSS Text Module Level 3 specification.
 *
 * @param css - CSS text-transform value (e.g., "none", "uppercase", "capitalize")
 * @returns Result with TextTransform IR or error message
 *
 * @example
 * Uppercase:
 * ```typescript
 * const result = parse("uppercase");
 * // { ok: true, value: { kind: "text-transform", value: "uppercase" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform | MDN: text-transform}
 * @see {@link https://www.w3.org/TR/css-text-3/#text-transform-property | W3C Spec}
 */
export function parse(css: string): Result<Type.TextTransform, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected text-transform value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			const validKeywords = ["none", "capitalize", "uppercase", "lowercase", "full-width", "full-size-kana"];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "text-transform",
					value: keyword as Type.TextTransform["value"],
				});
			}

			return err(`Invalid text-transform keyword: ${keyword}`);
		}

		return err("Expected keyword for text-transform");
	} catch (error) {
		return err(`Failed to parse text-transform: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/vertical-align.test.ts ===
// b_path:: src/parse/typography/vertical-align.test.ts
import { describe, expect, it } from "vitest";
import * as VerticalAlign from "./vertical-align";

describe("Parse.Typography.VerticalAlign", () => {
	describe("valid keywords", () => {
		it("should parse 'baseline'", () => {
			const result = VerticalAlign.parse("baseline");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: "baseline",
				});
			}
		});

		it("should parse 'sub'", () => {
			const result = VerticalAlign.parse("sub");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: "sub",
				});
			}
		});

		it("should parse 'super'", () => {
			const result = VerticalAlign.parse("super");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: "super",
				});
			}
		});

		it("should parse 'text-top'", () => {
			const result = VerticalAlign.parse("text-top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: "text-top",
				});
			}
		});

		it("should parse 'text-bottom'", () => {
			const result = VerticalAlign.parse("text-bottom");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: "text-bottom",
				});
			}
		});

		it("should parse 'middle'", () => {
			const result = VerticalAlign.parse("middle");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: "middle",
				});
			}
		});

		it("should parse 'top'", () => {
			const result = VerticalAlign.parse("top");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: "top",
				});
			}
		});

		it("should parse 'bottom'", () => {
			const result = VerticalAlign.parse("bottom");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: "bottom",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse 'MIDDLE' (uppercase)", () => {
			const result = VerticalAlign.parse("MIDDLE");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("middle");
			}
		});

		it("should parse 'Baseline' (mixed case)", () => {
			const result = VerticalAlign.parse("Baseline");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("baseline");
			}
		});
	});

	describe("length values", () => {
		it("should parse '5px'", () => {
			const result = VerticalAlign.parse("5px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: { value: 5, unit: "px" },
				});
			}
		});

		it("should parse '0.5em'", () => {
			const result = VerticalAlign.parse("0.5em");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: { value: 0.5, unit: "em" },
				});
			}
		});

		it("should parse negative value '-2px'", () => {
			const result = VerticalAlign.parse("-2px");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: { value: -2, unit: "px" },
				});
			}
		});
	});

	describe("percentage values", () => {
		it("should parse '50%'", () => {
			const result = VerticalAlign.parse("50%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: { value: 50, unit: "%" },
				});
			}
		});

		it("should parse negative percentage '-25%'", () => {
			const result = VerticalAlign.parse("-25%");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "vertical-align",
					value: { value: -25, unit: "%" },
				});
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = VerticalAlign.parse("center");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid vertical-align keyword");
			}
		});

		it("should reject empty string", () => {
			const result = VerticalAlign.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = VerticalAlign.parse("middle top");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/typography/vertical-align.ts ===
// b_path:: src/parse/typography/vertical-align.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseLengthPercentageNode } from "@/utils/parse/nodes/length";

/**
 * Parse CSS vertical-align property value.
 *
 * Accepts keyword values, length, or percentage.
 * Per CSS Inline Layout Module Level 3 specification.
 *
 * @param css - CSS vertical-align value (e.g., "baseline", "middle", "5px", "50%")
 * @returns Result with VerticalAlign IR or error message
 *
 * @example
 * Keyword value:
 * ```typescript
 * const result = parse("middle");
 * // { ok: true, value: { kind: "vertical-align", value: "middle" } }
 * ```
 *
 * @example
 * Length value:
 * ```typescript
 * const result = parse("5px");
 * // { ok: true, value: { kind: "vertical-align", value: { value: 5, unit: "px" } } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align | MDN: vertical-align}
 * @see {@link https://www.w3.org/TR/css-inline-3/#propdef-vertical-align | W3C Spec}
 */
export function parse(css: string): Result<Type.VerticalAlign, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected vertical-align value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			const validKeywords = ["baseline", "sub", "super", "text-top", "text-bottom", "middle", "top", "bottom"];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "vertical-align",
					value: keyword as Type.VerticalAlign["value"],
				});
			}

			return err(`Invalid vertical-align keyword: ${keyword}`);
		}

		const lengthResult = parseLengthPercentageNode(node);
		if (lengthResult.ok) {
			return ok({
				kind: "vertical-align",
				value: lengthResult.value,
			});
		}

		return err("Expected keyword, length, or percentage for vertical-align");
	} catch (error) {
		return err(`Failed to parse vertical-align: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/typography/word-break.test.ts ===
// b_path:: src/parse/typography/word-break.test.ts
import { describe, expect, it } from "vitest";
import * as WordBreak from "./word-break";

describe("Parse.Typography.WordBreak", () => {
	describe("valid keywords", () => {
		it("should parse 'normal'", () => {
			const result = WordBreak.parse("normal");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "word-break",
					value: "normal",
				});
			}
		});

		it("should parse 'break-all'", () => {
			const result = WordBreak.parse("break-all");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "word-break",
					value: "break-all",
				});
			}
		});

		it("should parse 'keep-all'", () => {
			const result = WordBreak.parse("keep-all");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "word-break",
					value: "keep-all",
				});
			}
		});

		it("should parse 'break-word'", () => {
			const result = WordBreak.parse("break-word");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual({
					kind: "word-break",
					value: "break-word",
				});
			}
		});
	});

	describe("case insensitivity", () => {
		it("should parse 'BREAK-ALL' (uppercase)", () => {
			const result = WordBreak.parse("BREAK-ALL");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("break-all");
			}
		});

		it("should parse 'Keep-All' (mixed case)", () => {
			const result = WordBreak.parse("Keep-All");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.value).toBe("keep-all");
			}
		});
	});

	describe("invalid values", () => {
		it("should reject invalid keyword", () => {
			const result = WordBreak.parse("wrap");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid word-break keyword");
			}
		});

		it("should reject numeric value", () => {
			const result = WordBreak.parse("12px");
			expect(result.ok).toBe(false);
		});

		it("should reject empty string", () => {
			const result = WordBreak.parse("");
			expect(result.ok).toBe(false);
		});

		it("should reject multiple values", () => {
			const result = WordBreak.parse("normal break-all");
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/parse/typography/word-break.ts ===
// b_path:: src/parse/typography/word-break.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS word-break property value.
 *
 * Accepts keyword values.
 * Per CSS Text Module Level 3 specification.
 *
 * @param css - CSS word-break value (e.g., "normal", "break-all", "keep-all")
 * @returns Result with WordBreak IR or error message
 *
 * @example
 * Break all:
 * ```typescript
 * const result = parse("break-all");
 * // { ok: true, value: { kind: "word-break", value: "break-all" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/word-break | MDN: word-break}
 * @see {@link https://www.w3.org/TR/css-text-3/#word-break-property | W3C Spec}
 */
export function parse(css: string): Result<Type.WordBreak, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected word-break value");
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();

			const validKeywords = ["normal", "break-all", "keep-all", "break-word"];

			if (validKeywords.includes(keyword)) {
				return ok({
					kind: "word-break",
					value: keyword as Type.WordBreak["value"],
				});
			}

			return err(`Invalid word-break keyword: ${keyword}`);
		}

		return err("Expected keyword for word-break");
	} catch (error) {
		return err(`Failed to parse word-break: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/visual/background-blend-mode.failure.test.ts ===
// b_path:: src/parse/visual/background-blend-mode.failure.test.ts
// Auto-generated from scripts/test-generator/configs/background-blend-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode
// - W3C: https://www.w3.org/TR/compositing-1/#background-blend-mode
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/background-blend-mode";

describe("parse/visual/background-blend-mode - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid background-blend-mode: invalid");
		});

		it("should reject non-standard keyword", () => {
			const result = Parser.parse("blend");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid background-blend-mode: blend");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Dimension");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("multiply, screen");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 3 values");
		});
	});
});


=== File: src/parse/visual/background-blend-mode.test.ts ===
// b_path:: src/parse/visual/background-blend-mode.test.ts
// Auto-generated from scripts/parse-test-generator/configs/visual/background-blend-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode
// - W3C: https://www.w3.org/TR/compositing-1/#background-blend-mode
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/background-blend-mode";

describe("parse/visual/background-blend-mode - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse normal blend mode", () => {
			const result = Parser.parse("normal");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "normal",
			});
		});

		it("should parse multiply blend mode", () => {
			const result = Parser.parse("multiply");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "multiply",
			});
		});

		it("should parse screen blend mode", () => {
			const result = Parser.parse("screen");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "screen",
			});
		});

		it("should parse overlay blend mode", () => {
			const result = Parser.parse("overlay");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "overlay",
			});
		});

		it("should parse darken blend mode", () => {
			const result = Parser.parse("darken");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "darken",
			});
		});

		it("should parse lighten blend mode", () => {
			const result = Parser.parse("lighten");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "lighten",
			});
		});
	});

	describe("valid-advanced", () => {
		it("should parse color-dodge blend mode", () => {
			const result = Parser.parse("color-dodge");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "color-dodge",
			});
		});

		it("should parse color-burn blend mode", () => {
			const result = Parser.parse("color-burn");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "color-burn",
			});
		});

		it("should parse hard-light blend mode", () => {
			const result = Parser.parse("hard-light");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "hard-light",
			});
		});

		it("should parse soft-light blend mode", () => {
			const result = Parser.parse("soft-light");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "soft-light",
			});
		});

		it("should parse difference blend mode", () => {
			const result = Parser.parse("difference");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "difference",
			});
		});

		it("should parse exclusion blend mode", () => {
			const result = Parser.parse("exclusion");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "exclusion",
			});
		});
	});

	describe("valid-color", () => {
		it("should parse hue blend mode", () => {
			const result = Parser.parse("hue");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "hue",
			});
		});

		it("should parse saturation blend mode", () => {
			const result = Parser.parse("saturation");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "saturation",
			});
		});

		it("should parse color blend mode", () => {
			const result = Parser.parse("color");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "color",
			});
		});

		it("should parse luminosity blend mode", () => {
			const result = Parser.parse("luminosity");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "luminosity",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase multiply", () => {
			const result = Parser.parse("MULTIPLY");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "multiply",
			});
		});

		it("should parse mixed case screen", () => {
			const result = Parser.parse("Screen");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "background-blend-mode",
				mode: "screen",
			});
		});
	});
});


=== File: src/parse/visual/background-blend-mode.ts ===
// b_path:: src/parse/visual/background-blend-mode.ts

import * as csstree from "css-tree";
import { BLEND_MODE_KEYWORDS } from "@/core/keywords/blend-mode-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS background-blend-mode property value.
 *
 * Accepts blend mode keywords like multiply, screen, overlay, etc.
 * Per CSS Compositing and Blending Level 1 specification.
 *
 * @param css - CSS background-blend-mode value (e.g., "multiply", "screen")
 * @returns Result with BackgroundBlendMode IR or error message
 *
 * @example
 * Blend mode value:
 * ```typescript
 * const result = parse("multiply");
 * // { ok: true, value: { kind: "background-blend-mode", mode: "multiply" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-blend-mode | MDN: background-blend-mode}
 * @see {@link https://www.w3.org/TR/compositing-1/#background-blend-mode | W3C Spec}
 */
export function parse(css: string): Result<Type.BackgroundBlendMode, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!BLEND_MODE_KEYWORDS.includes(keyword as Type.BackgroundBlendMode["mode"])) {
			return err(`Invalid background-blend-mode: ${keyword}`);
		}

		return ok({
			kind: "background-blend-mode",
			mode: keyword as Type.BackgroundBlendMode["mode"],
		});
	} catch (error) {
		return err(`Failed to parse background-blend-mode: ${error instanceof Error ? error.message : String(error)}`);
	}
}

// Legacy export for backward compatibility
export const parseBackgroundBlendMode = parse;


=== File: src/parse/visual/index.ts ===
// b_path:: src/parse/visual/index.ts
export * as BackgroundBlendMode from "./background-blend-mode";
export * as MixBlendMode from "./mix-blend-mode";
export * as Opacity from "./opacity";
export * as Visibility from "./visibility";


=== File: src/parse/visual/mix-blend-mode.failure.test.ts ===
// b_path:: src/parse/visual/mix-blend-mode.failure.test.ts
// Auto-generated from scripts/test-generator/configs/mix-blend-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode
// - W3C: https://www.w3.org/TR/compositing-1/#mix-blend-mode
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/mix-blend-mode";

describe("parse/visual/mix-blend-mode - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("invalid");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid mix-blend-mode: invalid");
		});

		it("should reject non-standard keyword", () => {
			const result = Parser.parse("blend");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid mix-blend-mode: blend");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Dimension");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("multiply, screen");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 3 values");
		});
	});
});


=== File: src/parse/visual/mix-blend-mode.test.ts ===
// b_path:: src/parse/visual/mix-blend-mode.test.ts
// Auto-generated from scripts/parse-test-generator/configs/visual/mix-blend-mode.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode
// - W3C: https://www.w3.org/TR/compositing-1/#mix-blend-mode
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/mix-blend-mode";

describe("parse/visual/mix-blend-mode - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse normal blend mode", () => {
			const result = Parser.parse("normal");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "normal",
			});
		});

		it("should parse multiply blend mode", () => {
			const result = Parser.parse("multiply");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "multiply",
			});
		});

		it("should parse screen blend mode", () => {
			const result = Parser.parse("screen");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "screen",
			});
		});

		it("should parse overlay blend mode", () => {
			const result = Parser.parse("overlay");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "overlay",
			});
		});

		it("should parse darken blend mode", () => {
			const result = Parser.parse("darken");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "darken",
			});
		});

		it("should parse lighten blend mode", () => {
			const result = Parser.parse("lighten");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "lighten",
			});
		});
	});

	describe("valid-advanced", () => {
		it("should parse color-dodge blend mode", () => {
			const result = Parser.parse("color-dodge");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "color-dodge",
			});
		});

		it("should parse color-burn blend mode", () => {
			const result = Parser.parse("color-burn");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "color-burn",
			});
		});

		it("should parse hard-light blend mode", () => {
			const result = Parser.parse("hard-light");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "hard-light",
			});
		});

		it("should parse soft-light blend mode", () => {
			const result = Parser.parse("soft-light");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "soft-light",
			});
		});

		it("should parse difference blend mode", () => {
			const result = Parser.parse("difference");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "difference",
			});
		});

		it("should parse exclusion blend mode", () => {
			const result = Parser.parse("exclusion");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "exclusion",
			});
		});
	});

	describe("valid-color", () => {
		it("should parse hue blend mode", () => {
			const result = Parser.parse("hue");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "hue",
			});
		});

		it("should parse saturation blend mode", () => {
			const result = Parser.parse("saturation");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "saturation",
			});
		});

		it("should parse color blend mode", () => {
			const result = Parser.parse("color");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "color",
			});
		});

		it("should parse luminosity blend mode", () => {
			const result = Parser.parse("luminosity");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "luminosity",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase multiply", () => {
			const result = Parser.parse("MULTIPLY");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "multiply",
			});
		});

		it("should parse mixed case screen", () => {
			const result = Parser.parse("Screen");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "mix-blend-mode",
				mode: "screen",
			});
		});
	});
});


=== File: src/parse/visual/mix-blend-mode.ts ===
// b_path:: src/parse/visual/mix-blend-mode.ts

import * as csstree from "css-tree";
import { BLEND_MODE_KEYWORDS } from "@/core/keywords/blend-mode-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS mix-blend-mode property value.
 *
 * Accepts blend mode keywords like multiply, screen, overlay, etc.
 * Per CSS Compositing and Blending Level 1 specification.
 *
 * @param css - CSS mix-blend-mode value (e.g., "screen", "overlay")
 * @returns Result with MixBlendMode IR or error message
 *
 * @example
 * Blend mode value:
 * ```typescript
 * const result = parse("screen");
 * // { ok: true, value: { kind: "mix-blend-mode", mode: "screen" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode | MDN: mix-blend-mode}
 * @see {@link https://www.w3.org/TR/compositing-1/#mix-blend-mode | W3C Spec}
 */
export function parse(css: string): Result<Type.MixBlendMode, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!BLEND_MODE_KEYWORDS.includes(keyword as Type.MixBlendMode["mode"])) {
			return err(`Invalid mix-blend-mode: ${keyword}`);
		}

		return ok({
			kind: "mix-blend-mode",
			mode: keyword as Type.MixBlendMode["mode"],
		});
	} catch (error) {
		return err(`Failed to parse mix-blend-mode: ${error instanceof Error ? error.message : String(error)}`);
	}
}

// Legacy export for backward compatibility
export const parseMixBlendMode = parse;


=== File: src/parse/visual/opacity.failure.test.ts ===
// b_path:: src/parse/visual/opacity.failure.test.ts
// Auto-generated from scripts/test-generator/configs/opacity.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
// - W3C: https://www.w3.org/TR/css-color-4/#transparency
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/opacity";

describe("parse/visual/opacity - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-unit", () => {
		it("should reject invalid unit", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected number or percentage, got: Dimension");
		});

		it("should reject wrong unit type", () => {
			const result = Parser.parse("1em");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected number or percentage, got: Dimension");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected number or percentage, got: Identifier");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected number or percentage, got: Identifier");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("0.5, 1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 3 values");
		});
	});
});


=== File: src/parse/visual/opacity.parse.failure.test.ts ===
// b_path:: src/parse/visual/opacity.parse.failure.test.ts
// Auto-generated from scripts/test-generator/configs/opacity.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
// - W3C: https://www.w3.org/TR/css-color-4/#transparency
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/opacity";

describe("parse/visual/opacity - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-unit", () => {
		it("should reject invalid unit", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected number or percentage, got: Dimension");
		});

		it("should reject wrong unit type", () => {
			const result = Parser.parse("1em");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected number or percentage, got: Dimension");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected number or percentage, got: Identifier");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected number or percentage, got: Identifier");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("0.5, 1");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 3 values");
		});
	});
});


=== File: src/parse/visual/opacity.parse.test.ts ===
// b_path:: src/parse/visual/opacity.parse.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/opacity.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
// - W3C: https://www.w3.org/TR/css-color-4/#transparency
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/opacity";

describe("parse/visual/opacity - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse fully transparent", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0,
			});
		});

		it("should parse fully opaque", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 1,
			});
		});

		it("should parse 50% transparent", () => {
			const result = Parser.parse("0.5");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.5,
			});
		});
	});

	describe("valid-decimal", () => {
		it("should parse 25% transparent", () => {
			const result = Parser.parse("0.25");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.25,
			});
		});

		it("should parse 75% transparent", () => {
			const result = Parser.parse("0.75");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.75,
			});
		});

		it("should parse decimal without leading zero", () => {
			const result = Parser.parse(".5");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.5,
			});
		});
	});

	describe("valid-percentage", () => {
		it("should parse 0% opacity", () => {
			const result = Parser.parse("0%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0,
			});
		});

		it("should parse 100% opacity", () => {
			const result = Parser.parse("100%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 1,
			});
		});

		it("should parse 50% opacity", () => {
			const result = Parser.parse("50%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.5,
			});
		});

		it("should parse decimal percentage", () => {
			const result = Parser.parse("25.5%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.255,
			});
		});
	});

	describe("valid-clamp", () => {
		it("should parse negative clamped to 0", () => {
			const result = Parser.parse("-1");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0,
			});
		});

		it("should parse greater than 1 clamped to 1", () => {
			const result = Parser.parse("2");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 1,
			});
		});

		it("should parse percentage over 100 clamped", () => {
			const result = Parser.parse("150%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 1,
			});
		});

		it("should parse negative percentage clamped", () => {
			const result = Parser.parse("-50%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0,
			});
		});
	});
});


=== File: src/parse/visual/opacity.test.ts ===
// b_path:: src/parse/visual/opacity.test.ts
// Auto-generated from scripts/parse-test-generator/configs/visual/opacity.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
// - W3C: https://www.w3.org/TR/css-color-4/#transparency
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/opacity";

describe("parse/visual/opacity - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse fully transparent", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0,
			});
		});

		it("should parse fully opaque", () => {
			const result = Parser.parse("1");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 1,
			});
		});

		it("should parse 50% transparent", () => {
			const result = Parser.parse("0.5");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.5,
			});
		});
	});

	describe("valid-decimal", () => {
		it("should parse 25% transparent", () => {
			const result = Parser.parse("0.25");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.25,
			});
		});

		it("should parse 75% transparent", () => {
			const result = Parser.parse("0.75");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.75,
			});
		});

		it("should parse decimal without leading zero", () => {
			const result = Parser.parse(".5");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.5,
			});
		});
	});

	describe("valid-percentage", () => {
		it("should parse 0% opacity", () => {
			const result = Parser.parse("0%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0,
			});
		});

		it("should parse 100% opacity", () => {
			const result = Parser.parse("100%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 1,
			});
		});

		it("should parse 50% opacity", () => {
			const result = Parser.parse("50%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.5,
			});
		});

		it("should parse decimal percentage", () => {
			const result = Parser.parse("25.5%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0.255,
			});
		});
	});

	describe("valid-clamp", () => {
		it("should parse negative clamped to 0", () => {
			const result = Parser.parse("-1");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0,
			});
		});

		it("should parse greater than 1 clamped to 1", () => {
			const result = Parser.parse("2");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 1,
			});
		});

		it("should parse percentage over 100 clamped", () => {
			const result = Parser.parse("150%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 1,
			});
		});

		it("should parse negative percentage clamped", () => {
			const result = Parser.parse("-50%");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "opacity",
				value: 0,
			});
		});
	});
});


=== File: src/parse/visual/opacity.ts ===
// b_path:: src/parse/visual/opacity.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS opacity property value.
 *
 * Accepts number (0-1) or percentage (0%-100%) values.
 * Values are clamped to the range [0, 1].
 *
 * @param css - CSS opacity value (e.g., "0.5", "50%", "1")
 * @returns Result with Opacity IR or error message
 *
 * @example
 * Number value:
 * ```typescript
 * const result = parse("0.5");
 * // { ok: true, value: { kind: "opacity", value: 0.5 } }
 * ```
 *
 * @example
 * Percentage value:
 * ```typescript
 * const result = parse("50%");
 * // { ok: true, value: { kind: "opacity", value: 0.5 } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/opacity | MDN: opacity}
 * @see {@link https://www.w3.org/TR/css-color-4/#transparency | W3C Spec}
 */
export function parse(css: string): Result<Type.Opacity, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node) {
			return err("Expected opacity value");
		}

		let value: number;

		if (node.type === "Number") {
			value = Number.parseFloat(node.value);
		} else if (node.type === "Percentage") {
			value = Number.parseFloat(node.value) / 100;
		} else {
			return err(`Expected number or percentage, got: ${node.type}`);
		}

		// Clamp value to [0, 1]
		value = Math.max(0, Math.min(1, value));

		return ok({
			kind: "opacity",
			value,
		});
	} catch (error) {
		return err(`Failed to parse opacity: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/parse/visual/visibility.failure.test.ts ===
// b_path:: src/parse/visual/visibility.failure.test.ts
// Auto-generated from scripts/test-generator/configs/visibility.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/visibility
// - W3C: https://www.w3.org/TR/css-display-3/#visibility
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/visibility";

describe("parse/visual/visibility - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid visibility keyword: auto");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid visibility keyword: none");
		});

		it("should reject non-standard keyword", () => {
			const result = Parser.parse("show");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid visibility keyword: show");
		});

		it("should reject display value", () => {
			const result = Parser.parse("block");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid visibility keyword: block");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Dimension");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("visible, hidden");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 3 values");
		});
	});
});


=== File: src/parse/visual/visibility.parse.failure.test.ts ===
// b_path:: src/parse/visual/visibility.parse.failure.test.ts
// Auto-generated from scripts/test-generator/configs/visibility.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/visibility
// - W3C: https://www.w3.org/TR/css-display-3/#visibility
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/visibility";

describe("parse/visual/visibility - invalid cases", () => {
	describe("invalid-empty", () => {
		it("should reject empty value", () => {
			const result = Parser.parse("");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 0 values");
		});
	});

	describe("invalid-keyword", () => {
		it("should reject invalid keyword", () => {
			const result = Parser.parse("auto");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid visibility keyword: auto");
		});

		it("should reject wrong keyword", () => {
			const result = Parser.parse("none");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid visibility keyword: none");
		});

		it("should reject non-standard keyword", () => {
			const result = Parser.parse("show");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid visibility keyword: show");
		});

		it("should reject display value", () => {
			const result = Parser.parse("block");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Invalid visibility keyword: block");
		});
	});

	describe("invalid-type", () => {
		it("should reject number value", () => {
			const result = Parser.parse("0");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Number");
		});

		it("should reject dimension value", () => {
			const result = Parser.parse("1px");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected keyword identifier, got: Dimension");
		});
	});

	describe("invalid-multiple", () => {
		it("should reject multiple values", () => {
			const result = Parser.parse("visible, hidden");
			expect(result.ok).toBe(false);
			if (result.ok) return;
			expect(result.error).toBe("Expected single value, got 3 values");
		});
	});
});


=== File: src/parse/visual/visibility.parse.test.ts ===
// b_path:: src/parse/visual/visibility.parse.test.ts
// Auto-generated from scripts/parse-test-generator/configs/layout/visibility.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/visibility
// - W3C: https://www.w3.org/TR/css-display-3/#visibility
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/visibility";

describe("parse/visual/visibility - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse visible keyword", () => {
			const result = Parser.parse("visible");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "visible",
			});
		});

		it("should parse hidden keyword", () => {
			const result = Parser.parse("hidden");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "hidden",
			});
		});

		it("should parse collapse keyword", () => {
			const result = Parser.parse("collapse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "collapse",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase visible", () => {
			const result = Parser.parse("VISIBLE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "visible",
			});
		});

		it("should parse mixed case hidden", () => {
			const result = Parser.parse("Hidden");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "hidden",
			});
		});

		it("should parse uppercase collapse", () => {
			const result = Parser.parse("COLLAPSE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "collapse",
			});
		});
	});
});


=== File: src/parse/visual/visibility.test.ts ===
// b_path:: src/parse/visual/visibility.test.ts
// Auto-generated from scripts/parse-test-generator/configs/visual/visibility.ts
//
// Spec references:
// - MDN: https://developer.mozilla.org/en-US/docs/Web/CSS/visibility
// - W3C: https://www.w3.org/TR/css-display-3/#visibility
import { describe, expect, it } from "vitest";
import * as Parser from "@/parse/visual/visibility";

describe("parse/visual/visibility - valid cases", () => {
	describe("valid-basic", () => {
		it("should parse visible keyword", () => {
			const result = Parser.parse("visible");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "visible",
			});
		});

		it("should parse hidden keyword", () => {
			const result = Parser.parse("hidden");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "hidden",
			});
		});

		it("should parse collapse keyword", () => {
			const result = Parser.parse("collapse");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "collapse",
			});
		});
	});

	describe("valid-case", () => {
		it("should parse uppercase visible", () => {
			const result = Parser.parse("VISIBLE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "visible",
			});
		});

		it("should parse mixed case hidden", () => {
			const result = Parser.parse("Hidden");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "hidden",
			});
		});

		it("should parse uppercase collapse", () => {
			const result = Parser.parse("COLLAPSE");
			expect(result.ok).toBe(true);
			if (!result.ok) return;
			expect(result.value).toEqual({
				kind: "visibility",
				value: "collapse",
			});
		});
	});
});


=== File: src/parse/visual/visibility.ts ===
// b_path:: src/parse/visual/visibility.ts
import * as csstree from "css-tree";
import { VISIBILITY_KEYWORDS } from "@/core/keywords/visibility-keywords";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";

/**
 * Parse CSS visibility property value.
 *
 * Accepts visibility keywords: visible, hidden, collapse.
 * Per CSS Display Module Level 3 specification.
 *
 * @param css - CSS visibility value (e.g., "visible", "hidden", "collapse")
 * @returns Result with Visibility IR or error message
 *
 * @example
 * Visible element:
 * ```typescript
 * const result = parse("visible");
 * // { ok: true, value: { kind: "visibility", value: "visible" } }
 * ```
 *
 * @example
 * Hidden element:
 * ```typescript
 * const result = parse("hidden");
 * // { ok: true, value: { kind: "visibility", value: "hidden" } }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/visibility | MDN: visibility}
 * @see {@link https://www.w3.org/TR/css-display-3/#visibility | W3C Spec}
 */
export function parse(css: string): Result<Type.Visibility, string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err("Expected Value node");
		}

		const children = ast.children.toArray();

		if (children.length !== 1) {
			return err(`Expected single value, got ${children.length} values`);
		}

		const node = children[0];
		if (!node || node.type !== "Identifier") {
			return err(`Expected keyword identifier, got: ${node?.type || "nothing"}`);
		}

		const keyword = node.name.toLowerCase();

		if (!VISIBILITY_KEYWORDS.includes(keyword as Type.Visibility["value"])) {
			return err(`Invalid visibility keyword: ${keyword}`);
		}

		return ok({
			kind: "visibility",
			value: keyword as Type.Visibility["value"],
		});
	} catch (error) {
		return err(`Failed to parse visibility: ${error instanceof Error ? error.message : String(error)}`);
	}
}


=== File: src/utils/ast/functions.ts ===
// b_path:: src/utils/ast/functions.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";

/**
 * Find a function node by name in a CSS AST.
 *
 * Walks the AST to find the first function node with the specified name.
 * Function name matching is case-insensitive to match CSS spec behavior.
 * Commonly used pattern across all parsers.
 *
 * @param ast - CSS AST to search
 * @param functionNames - Function name(s) to search for (case-insensitive)
 * @returns Result containing FunctionNode or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { findFunctionNode } from "@/utils/ast/functions";
 *
 * const result = findFunctionNode(ast, ["linear-gradient", "repeating-linear-gradient"]);
 * if (result.ok) {
 *   console.log(result.value.name); // "linear-gradient"
 * }
 * ```
 */
export function findFunctionNode(
	ast: csstree.CssNode,
	functionNames: string | string[],
): Result<csstree.FunctionNode, string> {
	const names = Array.isArray(functionNames) ? functionNames : [functionNames];
	const lowerNames = names.map((name) => name.toLowerCase());
	let foundNode: csstree.FunctionNode | null = null;

	try {
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (lowerNames.includes(node.name.toLowerCase())) {
					foundNode = node;
					// Stop traversal once found
					return false;
				}
			},
		});

		if (!foundNode) {
			return err(`No function found with name(s): ${names.join(", ")}`);
		}

		return ok(foundNode);
	} catch (e) {
		return err(`Failed to search AST: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Parse comma-separated values from a CSS AST.
 *
 * Handles the common pattern of parsing comma-separated arguments
 * in CSS functions like gradients, transforms, etc.
 *
 * @param ast - CSS AST to parse
 * @returns Array of CSS node arrays, split by commas
 *
 * @public
 *
 * @example
 * ```typescript
 * import { parseCommaSeparatedValues } from "@/utils/ast/functions";
 *
 * const groups = parseCommaSeparatedValues(ast);
 * console.log(groups.length); // Number of comma-separated groups
 * console.log(groups[0]); // First group of nodes
 * ```
 */
export function parseCommaSeparatedValues(ast: csstree.CssNode): csstree.CssNode[][] {
	const groups: csstree.CssNode[][] = [[]];

	csstree.walk(ast, {
		enter(node: csstree.CssNode) {
			if (node.type === "Operator" && "value" in node && node.value === ",") {
				// Start new group
				groups.push([]);
			} else if (node.type !== "Value") {
				// Add to current group (skip Value wrapper node)
				const currentGroup = groups[groups.length - 1];
				if (currentGroup) {
					currentGroup.push(node);
				}
			}
		},
	});

	return groups;
}

/**
 * Parse function arguments from a function node.
 *
 * Extracts the arguments from a CSS function, filtering out operators.
 * Commonly used pattern in all function parsers.
 *
 * @param fn - CSS Function AST node
 * @returns Array of CSS nodes representing function arguments
 *
 * @public
 *
 * @example
 * ```typescript
 * import { parseFunctionArguments } from "@/utils/ast/functions";
 *
 * const args = parseFunctionArguments(functionNode);
 * console.log(args.length); // Number of arguments
 * console.log(args[0].type); // Type of first argument
 * ```
 */
export function parseFunctionArguments(fn: csstree.FunctionNode): csstree.CssNode[] {
	return fn.children.toArray().filter((node) => node.type !== "Operator");
}

/**
 * Parse CSS string into AST with error handling.
 *
 * Common pattern for parsing CSS strings with proper error handling.
 *
 * @param css - CSS string to parse
 * @param context - CSS parsing context ("value", "declaration", etc.)
 * @returns Result containing CSS AST or error message
 *
 * @public
 */
export function parseCssString(
	css: string,
	context: "value" | "declaration" = "value",
): Result<csstree.CssNode, string> {
	try {
		const ast = csstree.parse(css, { context });
		return ok(ast);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/utils/ast/index.ts ===
// b_path:: src/utils/ast/index.ts

export * from "./functions";
export * from "./split-by-comma";


=== File: src/utils/ast/split-by-comma.test.ts ===
// b_path:: src/utils/ast/split-by-comma.test.ts
import * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { isCommaAt, skipComma, splitNodesByComma } from "./split-by-comma";

describe("splitNodesByComma", () => {
	it("splits simple comma-separated values", () => {
		const ast = csstree.parse("red, blue, green", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(1);
		expect(groups[2]).toHaveLength(1);
	});

	it("handles multi-node groups", () => {
		const ast = csstree.parse("red, blue 50%, green", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(2);
		expect(groups[2]).toHaveLength(1);
	});

	it("handles single value (no commas)", () => {
		const ast = csstree.parse("red", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(1);
		expect(groups[0]).toHaveLength(1);
	});

	it("handles empty input", () => {
		const groups = splitNodesByComma([]);

		expect(groups).toHaveLength(0);
	});

	it("handles startIndex option", () => {
		const ast = csstree.parse("45deg, red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		// Find the comma after 45deg
		const firstCommaIdx = nodes.findIndex((n) => n.type === "Operator" && "value" in n && n.value === ",");

		// Start after first comma
		const groups = splitNodesByComma(nodes, {
			startIndex: firstCommaIdx + 1,
		});

		expect(groups).toHaveLength(2);
	});

	it("rejects empty groups by default", () => {
		const ast = csstree.parse("red,, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(2);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(1);
	});

	it("allows empty groups when requested", () => {
		const ast = csstree.parse("red,, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes, { allowEmpty: true });

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(0);
		expect(groups[2]).toHaveLength(1);
	});

	it("handles trailing comma (creates empty group if allowEmpty)", () => {
		const ast = csstree.parse("red, blue,", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const withoutEmpty = splitNodesByComma(nodes);
		expect(withoutEmpty).toHaveLength(2);

		const withEmpty = splitNodesByComma(nodes, { allowEmpty: true });
		expect(withEmpty).toHaveLength(3);
		expect(withEmpty[2]).toHaveLength(0);
	});

	it("handles whitespace nodes by default", () => {
		const ast = csstree.parse("red  ,  blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(2);
		expect(groups[0]).toHaveLength(1);
		expect(groups[1]).toHaveLength(1);
	});

	it("handles complex multi-value groups", () => {
		const ast = csstree.parse("1px 2px 3px, 4px 5px, 6px", {
			context: "value",
		});
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(3);
		expect(groups[1]).toHaveLength(2);
		expect(groups[2]).toHaveLength(1);
	});

	it("handles percentage and length mixed", () => {
		const ast = csstree.parse("50% 0%, 100% 50%, 0% 100%", {
			context: "value",
		});
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const groups = splitNodesByComma(nodes);

		expect(groups).toHaveLength(3);
		expect(groups[0]).toHaveLength(2);
		expect(groups[1]).toHaveLength(2);
		expect(groups[2]).toHaveLength(2);
	});
});

describe("isCommaAt", () => {
	it("returns true for comma at index", () => {
		const ast = csstree.parse("red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const commaIndex = nodes.findIndex((n) => n.type === "Operator" && "value" in n && n.value === ",");

		expect(isCommaAt(nodes, commaIndex)).toBe(true);
	});

	it("returns false for non-comma node", () => {
		const ast = csstree.parse("red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(isCommaAt(nodes, 0)).toBe(false);
	});

	it("returns false for out of bounds index", () => {
		const ast = csstree.parse("red", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(isCommaAt(nodes, 999)).toBe(false);
	});

	it("returns false for negative index", () => {
		const ast = csstree.parse("red", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(isCommaAt(nodes, -1)).toBe(false);
	});

	it("returns false for empty array", () => {
		expect(isCommaAt([], 0)).toBe(false);
	});
});

describe("skipComma", () => {
	it("skips comma and returns next index", () => {
		const ast = csstree.parse("red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		const commaIndex = nodes.findIndex((n) => n.type === "Operator" && "value" in n && n.value === ",");

		expect(skipComma(nodes, commaIndex)).toBe(commaIndex + 1);
	});

	it("returns same index if not comma", () => {
		const ast = csstree.parse("red, blue", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(skipComma(nodes, 0)).toBe(0);
	});

	it("handles out of bounds index", () => {
		const ast = csstree.parse("red", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		expect(skipComma(nodes, 999)).toBe(999);
	});

	it("handles empty array", () => {
		expect(skipComma([], 0)).toBe(0);
	});

	it("can chain multiple skipComma calls", () => {
		const ast = csstree.parse("red, blue, green", { context: "value" });
		const nodes = ast.type === "Value" ? ast.children.toArray() : [];

		let idx = 0;
		// Skip to first value
		idx = nodes.findIndex((n) => n.type === "Identifier");
		expect(idx).toBeGreaterThanOrEqual(0);

		// Find first comma
		idx = nodes.findIndex((n, i) => i > idx && n.type === "Operator" && "value" in n && n.value === ",");
		// Skip it
		idx = skipComma(nodes, idx);

		// Should be at blue now (or whitespace before it)
		const nextIdentifier = nodes[idx];
		expect(nextIdentifier?.type === "Identifier" || nextIdentifier?.type === "WhiteSpace").toBe(true);
	});
});


=== File: src/utils/ast/split-by-comma.ts ===
// b_path:: src/utils/ast/split-by-comma.ts
import type * as csstree from "css-tree";

export interface SplitByCommaOptions {
	/** Start index in nodes array (default: 0) */
	startIndex?: number;

	/** Allow empty groups between commas (default: false) */
	allowEmpty?: boolean;

	/** Skip whitespace nodes (default: true) */
	trimWhitespace?: boolean;
}

/**
 * Split array of AST nodes by comma operators.
 *
 * Used for parsing comma-separated function arguments.
 * Returns array of node groups, where each group is the nodes between commas.
 *
 * @param nodes - Array of AST nodes to split
 * @param options - Parsing options
 * @returns Array of node groups (each group is nodes between commas)
 *
 * @example
 * ```typescript
 * // For polygon(50% 0%, 100% 50%, 0% 100%)
 * const functionNode = findFunctionNode(ast, "polygon");
 * const children = functionNode.children.toArray();
 * const groups = splitNodesByComma(children);
 * // Returns: [[50%, 0%], [100%, 50%], [0%, 100%]]
 * ```
 *
 * @example
 * ```typescript
 * // For linear-gradient(45deg, red, blue 50%, green)
 * // After parsing direction, start from index 2
 * const groups = splitNodesByComma(children, { startIndex: 2 });
 * // Returns: [[red], [blue, 50%], [green]]
 * ```
 *
 * @internal
 */
export function splitNodesByComma(nodes: csstree.CssNode[], options: SplitByCommaOptions = {}): csstree.CssNode[][] {
	const { startIndex = 0, allowEmpty = false, trimWhitespace = true } = options;

	const groups: csstree.CssNode[][] = [];
	let currentGroup: csstree.CssNode[] = [];

	for (let i = startIndex; i < nodes.length; i++) {
		const node = nodes[i];
		if (!node) continue;

		// Skip whitespace nodes if requested
		if (trimWhitespace && node.type === "WhiteSpace") {
			continue;
		}

		// Check for comma operator
		if (node.type === "Operator" && "value" in node && node.value === ",") {
			// End current group
			if (currentGroup.length > 0 || allowEmpty) {
				groups.push(currentGroup);
				currentGroup = [];
			}
		} else {
			currentGroup.push(node);
		}
	}

	// Push final group
	if (currentGroup.length > 0 || allowEmpty) {
		groups.push(currentGroup);
	}

	return groups;
}

/**
 * Check if a comma exists at the given index.
 *
 * Helper for optional comma checking in function parsers.
 *
 * @param nodes - Array of AST nodes
 * @param index - Index to check
 * @returns True if node at index is a comma operator
 *
 * @internal
 */
export function isCommaAt(nodes: csstree.CssNode[], index: number): boolean {
	const node = nodes[index];
	return Boolean(node && node.type === "Operator" && "value" in node && node.value === ",");
}

/**
 * Skip comma at index if present, return next index.
 *
 * Helper for optional comma handling in function parsers.
 *
 * @param nodes - Array of AST nodes
 * @param index - Current index
 * @returns Index after comma if present, otherwise same index
 *
 * @example
 * ```typescript
 * let idx = 5;
 * idx = skipComma(children, idx); // Skips comma if at index 5
 * ```
 *
 * @internal
 */
export function skipComma(nodes: csstree.CssNode[], index: number): number {
	return isCommaAt(nodes, index) ? index + 1 : index;
}


=== File: src/utils/generate/color.test.ts ===
// b_path:: src/utils/generate/color.test.ts
import { describe, expect, it } from "vitest";
import type { Color } from "@/core/types/color";
import { generateColor } from "./color";

describe("generateColor", () => {
	it("generates hex color", () => {
		const color: Color = { kind: "hex", value: "#ff0000" };
		expect(generateColor(color)).toBe("#ff0000");
	});

	it("generates named color", () => {
		const color: Color = { kind: "named", name: "red" };
		expect(generateColor(color)).toBe("red");
	});

	it("generates rgb color", () => {
		const color: Color = { kind: "rgb", r: 255, g: 0, b: 0 };
		expect(generateColor(color)).toBe("rgb(255 0 0)");
	});

	it("generates rgb color with alpha", () => {
		const color: Color = { kind: "rgb", r: 255, g: 0, b: 0, alpha: 0.5 };
		expect(generateColor(color)).toBe("rgb(255 0 0 / 0.5)");
	});

	it("generates hsl color", () => {
		const color: Color = { kind: "hsl", h: 0, s: 100, l: 50 };
		expect(generateColor(color)).toBe("hsl(0 100% 50%)");
	});

	it("generates hsl color with alpha", () => {
		const color: Color = { kind: "hsl", h: 0, s: 100, l: 50, alpha: 0.8 };
		expect(generateColor(color)).toBe("hsl(0 100% 50% / 0.8)");
	});

	it("generates hwb color", () => {
		const color: Color = { kind: "hwb", h: 120, w: 0, b: 0 };
		expect(generateColor(color)).toBe("hwb(120 0% 0%)");
	});

	it("generates lab color", () => {
		const color: Color = { kind: "lab", l: 50, a: 0, b: 0 };
		expect(generateColor(color)).toBe("lab(50 0 0)");
	});

	it("generates lch color", () => {
		const color: Color = { kind: "lch", l: 50, c: 50, h: 180 };
		expect(generateColor(color)).toBe("lch(50 50 180)");
	});

	it("generates oklab color", () => {
		const color: Color = { kind: "oklab", l: 0.5, a: 0.1, b: -0.1 };
		expect(generateColor(color)).toBe("oklab(0.5 0.1 -0.1)");
	});

	it("generates oklch color", () => {
		const color: Color = { kind: "oklch", l: 0.5, c: 0.1, h: 90 };
		expect(generateColor(color)).toBe("oklch(0.5 0.1 90)");
	});

	it("generates system color", () => {
		const color: Color = { kind: "system", keyword: "ButtonFace" };
		expect(generateColor(color)).toBe("ButtonFace");
	});

	it("generates special color currentColor", () => {
		const color: Color = { kind: "special", keyword: "currentcolor" };
		expect(generateColor(color)).toBe("currentcolor");
	});

	it("generates special color transparent", () => {
		const color: Color = { kind: "special", keyword: "transparent" };
		expect(generateColor(color)).toBe("transparent");
	});

	it("generates color() function", () => {
		const color: Color = {
			kind: "color",
			colorSpace: "srgb",
			channels: [1, 0, 0],
		};
		expect(generateColor(color)).toBe("color(srgb 1 0 0)");
	});

	it("generates color() function with alpha", () => {
		const color: Color = {
			kind: "color",
			colorSpace: "display-p3",
			channels: [1, 0, 0],
			alpha: 0.5,
		};
		expect(generateColor(color)).toBe("color(display-p3 1 0 0 / 0.5)");
	});

	it("returns empty string when generator fails", () => {
		// biome-ignore lint/suspicious/noExplicitAny: Testing error handling
		const color = { kind: "hex" } as any;
		expect(generateColor(color)).toBe("");
	});

	it("handles all color kinds in switch statement", () => {
		const colorKinds: Color["kind"][] = [
			"hex",
			"named",
			"rgb",
			"hsl",
			"hwb",
			"lab",
			"lch",
			"oklab",
			"oklch",
			"system",
			"special",
			"color",
		];

		for (const kind of colorKinds) {
			let color: Color;
			switch (kind) {
				case "hex":
					color = { kind: "hex", value: "#000" };
					break;
				case "named":
					color = { kind: "named", name: "black" };
					break;
				case "rgb":
					color = { kind: "rgb", r: 0, g: 0, b: 0 };
					break;
				case "hsl":
					color = { kind: "hsl", h: 0, s: 0, l: 0 };
					break;
				case "hwb":
					color = { kind: "hwb", h: 0, w: 0, b: 0 };
					break;
				case "lab":
					color = { kind: "lab", l: 0, a: 0, b: 0 };
					break;
				case "lch":
					color = { kind: "lch", l: 0, c: 0, h: 0 };
					break;
				case "oklab":
					color = { kind: "oklab", l: 0, a: 0, b: 0 };
					break;
				case "oklch":
					color = { kind: "oklch", l: 0, c: 0, h: 0 };
					break;
				case "system":
					color = { kind: "system", keyword: "Canvas" };
					break;
				case "special":
					color = { kind: "special", keyword: "transparent" };
					break;
				case "color":
					color = { kind: "color", colorSpace: "srgb", channels: [0, 0, 0] };
					break;
			}
			expect(generateColor(color)).toBeTruthy();
		}
	});
});


=== File: src/utils/generate/color.ts ===
// b_path:: src/utils/generate/color.ts

import type { GenerateResult } from "@/core/result";
import type { Color } from "@/core/types/color";
import * as ColorGenerate from "@/generate/color";

/**
 * Generate CSS from any Color IR format.
 *
 * Convenience helper that dispatches to appropriate color generator
 * based on the color's kind field.
 *
 * @param color - Color IR to convert
 * @returns CSS color string
 *
 * @internal
 */
export function generateColor(color: Color): string {
	let result: GenerateResult;
	switch (color.kind) {
		case "hex":
			result = ColorGenerate.Hex.generate(color);
			break;
		case "named":
			result = ColorGenerate.Named.generate(color);
			break;
		case "rgb":
			result = ColorGenerate.Rgb.generate(color);
			break;
		case "hsl":
			result = ColorGenerate.Hsl.generate(color);
			break;
		case "hwb":
			result = ColorGenerate.Hwb.generate(color);
			break;
		case "lab":
			result = ColorGenerate.Lab.generate(color);
			break;
		case "lch":
			result = ColorGenerate.Lch.generate(color);
			break;
		case "oklab":
			result = ColorGenerate.Oklab.generate(color);
			break;
		case "oklch":
			result = ColorGenerate.Oklch.generate(color);
			break;
		case "system":
			result = ColorGenerate.System.generate(color);
			break;
		case "special":
			result = ColorGenerate.Special.generate(color);
			break;
		case "color":
			result = ColorGenerate.ColorFunction.generate(color);
			break;
	}
	return result.ok ? result.value : "";
}


=== File: src/utils/generate/index.ts ===
// b_path:: src/utils/generate/index.ts

export * from "./validation";
export * from "./values";


=== File: src/utils/generate/url.test.ts ===
// b_path:: src/utils/generate/url.test.ts
import { describe, expect, it } from "vitest";
import { urlToCss } from "./url";

describe("urlToCss", () => {
	it("should generate url() with ID reference", () => {
		expect(urlToCss({ kind: "url", value: "#clip-shape" })).toBe("url(#clip-shape)");
		expect(urlToCss({ kind: "url", value: "#gradient-1" })).toBe("url(#gradient-1)");
	});

	it("should generate url() with external path", () => {
		expect(urlToCss({ kind: "url", value: "image.png" })).toBe("url(image.png)");
		expect(urlToCss({ kind: "url", value: "/images/bg.jpg" })).toBe("url(/images/bg.jpg)");
	});

	it("should generate url() with absolute URL", () => {
		expect(urlToCss({ kind: "url", value: "https://example.com/image.png" })).toBe(
			"url(https://example.com/image.png)",
		);
	});

	it("should generate url() with data URI", () => {
		expect(urlToCss({ kind: "url", value: "data:image/svg+xml,..." })).toBe("url(data:image/svg+xml,...)");
	});

	it("should handle empty value", () => {
		expect(urlToCss({ kind: "url", value: "" })).toBe("url()");
	});

	it("should handle special characters", () => {
		expect(urlToCss({ kind: "url", value: "image name with spaces.png" })).toBe("url(image name with spaces.png)");
	});
});


=== File: src/utils/generate/url.ts ===
// b_path:: src/utils/generate/url.ts

import type { Url } from "@/core/types/url";

/**
 * Generate CSS url() function.
 *
 * Shared utility for generating URL references across different CSS properties.
 *
 * @param value - Url IR value
 * @returns CSS string like "url(#id)"
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/url_function}
 *
 * @example
 * ```typescript
 * import { urlToCss } from "@/utils/generate/url";
 *
 * const css = urlToCss({ kind: "url", value: "#clip-shape" });
 * // "url(#clip-shape)"
 * ```
 *
 * @public
 */
export function urlToCss(value: Url): string {
	return `url(${value.value})`;
}


=== File: src/utils/generate/validation.ts ===
// b_path:: src/utils/generate/validation.ts

import type { z } from "zod";
import type { Issue } from "@/core/result";

// Use Zod v4 core types (not deprecated)
type ZodIssue = z.core.$ZodIssue;
type ZodError = z.ZodError;
type ZodIssueInvalidUnion = z.core.$ZodIssueInvalidUnion;

/**
 * Format a path array into a human-readable string.
 *
 * Converts an array path (e.g., from Zod validation) into dot notation
 * with bracket notation for array indices.
 *
 * @param path - Array of path segments (strings and numbers)
 * @returns Formatted path string
 *
 * @example
 * ```typescript
 * formatPath(["durations", 0, "unit"]) // "durations[0].unit"
 * formatPath(["value"]) // "value"
 * formatPath([]) // ""
 * ```
 *
 * @public
 */
export function formatPath(path: (string | number)[]): string {
	if (path.length === 0) return "";

	return path.reduce<string>((acc, segment, i) => {
		if (typeof segment === "number") return `${acc}[${segment}]`;
		if (i === 0) return String(segment);
		return `${acc}.${segment}`;
	}, "");
}

/**
 * Convert Zod validation errors to b_value Issue format.
 *
 * Zod creates deeply nested error structures for unions and complex schemas.
 * This recursively traverses the error tree and extracts actionable error messages
 * with path context for pinpointing the exact location of validation failures.
 *
 * Features:
 * - Recursively traverses union errors to collect all failures
 * - Includes path context in error messages (e.g., "durations[0].unit: ...")
 * - Preserves path array for programmatic access
 * - Adds Zod error code as metadata for advanced filtering
 * - Filters out generic "Invalid input" messages
 *
 * @param zodError - Zod validation error from safeParse()
 * @returns Array of Issue objects with detailed error information and path context
 *
 * @example
 * ```typescript
 * import { zodErrorToIssues } from "@/utils/generate";
 * import { animationDurationSchema } from "@/core/types/animation";
 *
 * const validation = animationDurationSchema.safeParse(input);
 * if (!validation.success) {
 *   const issues = zodErrorToIssues(validation.error);
 *   // issues[0].message: "durations[0].unit: Invalid input: expected \"s\""
 *   // issues[0].path: ["durations", 0, "unit"]
 *   // issues[0].metadata.zodCode: "invalid_literal"
 *   return { ok: false, issues };
 * }
 * ```
 *
 * @public
 */
export function zodErrorToIssues(zodError: ZodError): Issue[] {
	const issues: Issue[] = [];

	function traverse(zodIssues: readonly ZodIssue[], parentPath: (string | number)[] = []): void {
		for (const zodIssue of zodIssues) {
			if (zodIssue.code === "invalid_union") {
				const unionIssue = zodIssue as ZodIssueInvalidUnion;

				// If union has a custom message (not generic "Invalid input"), use it and DON'T traverse
				if (zodIssue.message !== "Invalid input") {
					const relativePath = zodIssue.path.filter(
						(p): p is string | number => typeof p === "string" || typeof p === "number",
					);
					const fullPath = [...parentPath, ...relativePath];
					const pathStr = formatPath(fullPath);
					const message = pathStr ? `${pathStr}: ${zodIssue.message}` : zodIssue.message;

					issues.push({
						code: "invalid-ir",
						severity: "error",
						message,
						path: fullPath,
						metadata: {
							zodCode: zodIssue.code,
						},
					});
					// Don't traverse into union branches - custom message is sufficient
					continue;
				}

				// Generic union error - traverse into all branches to collect specific errors
				const unionPath = [
					...parentPath,
					...zodIssue.path.filter((p): p is string | number => typeof p === "string" || typeof p === "number"),
				];

				if (Array.isArray(unionIssue.errors)) {
					for (const errorGroup of unionIssue.errors) {
						if (Array.isArray(errorGroup)) {
							traverse(errorGroup, unionPath);
						}
					}
				}
			} else {
				// Skip generic "Invalid input" messages without path details
				if (zodIssue.message === "Invalid input" && zodIssue.path.length === 0) {
					continue;
				}

				// Convert path to (string | number)[] - filter out symbols if present
				const relativePath = zodIssue.path.filter(
					(p): p is string | number => typeof p === "string" || typeof p === "number",
				);
				const fullPath = [...parentPath, ...relativePath];
				const pathStr = formatPath(fullPath);
				const message = pathStr ? `${pathStr}: ${zodIssue.message}` : zodIssue.message;

				issues.push({
					code: "invalid-ir",
					severity: "error",
					message,
					path: fullPath,
					metadata: {
						zodCode: zodIssue.code,
					},
				});
			}
		}
	}

	traverse(zodError.issues);

	// Fallback if no specific errors found
	if (issues.length === 0) {
		issues.push({
			code: "invalid-ir",
			severity: "error",
			message: "Invalid IR structure",
		});
	}

	return issues;
}


=== File: src/utils/generate/values.test.ts ===
// b_path:: src/utils/generate/values.test.ts
import { describe, expect, it } from "vitest";
import {
	angleToCss,
	borderRadiusToCss,
	joinCssValues,
	joinCssValuesWithSpaces,
	lengthPercentageToCss,
	lengthToCss,
	numberToCss,
	positionValueToCss,
} from "./values";

describe("positionValueToCss", () => {
	it("should convert keyword position values", () => {
		expect(positionValueToCss("center")).toBe("center");
		expect(positionValueToCss("top")).toBe("top");
		expect(positionValueToCss("left")).toBe("left");
		expect(positionValueToCss("right")).toBe("right");
		expect(positionValueToCss("bottom")).toBe("bottom");
	});

	it("should convert length position values", () => {
		expect(positionValueToCss({ value: 100, unit: "px" })).toBe("100px");
		expect(positionValueToCss({ value: 50, unit: "%" })).toBe("50%");
		expect(positionValueToCss({ value: 0, unit: "px" })).toBe("0px");
		expect(positionValueToCss({ value: 2.5, unit: "rem" })).toBe("2.5rem");
	});

	it("should handle negative values", () => {
		expect(positionValueToCss({ value: -10, unit: "px" })).toBe("-10px");
		expect(positionValueToCss({ value: -5, unit: "%" })).toBe("-5%");
	});
});

describe("lengthToCss", () => {
	it("should convert length values", () => {
		expect(lengthToCss({ value: 10, unit: "px" })).toBe("10px");
		expect(lengthToCss({ value: 2.5, unit: "rem" })).toBe("2.5rem");
		expect(lengthToCss({ value: 100, unit: "vh" })).toBe("100vh");
		expect(lengthToCss({ value: 0, unit: "px" })).toBe("0px");
	});

	it("should handle negative values", () => {
		expect(lengthToCss({ value: -5, unit: "px" })).toBe("-5px");
		expect(lengthToCss({ value: -1.5, unit: "em" })).toBe("-1.5em");
	});

	it("should handle decimal values", () => {
		expect(lengthToCss({ value: 0.5, unit: "em" })).toBe("0.5em");
		expect(lengthToCss({ value: 12.345, unit: "px" })).toBe("12.345px");
	});
});

describe("lengthPercentageToCss", () => {
	it("should convert length values", () => {
		expect(lengthPercentageToCss({ value: 10, unit: "px" })).toBe("10px");
		expect(lengthPercentageToCss({ value: 2.5, unit: "rem" })).toBe("2.5rem");
	});

	it("should convert percentage values", () => {
		expect(lengthPercentageToCss({ value: 50, unit: "%" })).toBe("50%");
		expect(lengthPercentageToCss({ value: 100, unit: "%" })).toBe("100%");
		expect(lengthPercentageToCss({ value: 0, unit: "%" })).toBe("0%");
	});

	it("should handle negative values", () => {
		expect(lengthPercentageToCss({ value: -10, unit: "px" })).toBe("-10px");
		expect(lengthPercentageToCss({ value: -25, unit: "%" })).toBe("-25%");
	});
});

describe("angleToCss", () => {
	it("should convert angle values in degrees", () => {
		expect(angleToCss({ value: 45, unit: "deg" })).toBe("45deg");
		expect(angleToCss({ value: 90, unit: "deg" })).toBe("90deg");
		expect(angleToCss({ value: 0, unit: "deg" })).toBe("0deg");
	});

	it("should convert angle values in radians", () => {
		expect(angleToCss({ value: Math.PI, unit: "rad" })).toBe(`${Math.PI}rad`);
		expect(angleToCss({ value: 1.5708, unit: "rad" })).toBe("1.5708rad");
	});

	it("should convert angle values in gradians", () => {
		expect(angleToCss({ value: 100, unit: "grad" })).toBe("100grad");
		expect(angleToCss({ value: 200, unit: "grad" })).toBe("200grad");
	});

	it("should convert angle values in turns", () => {
		expect(angleToCss({ value: 0.5, unit: "turn" })).toBe("0.5turn");
		expect(angleToCss({ value: 1, unit: "turn" })).toBe("1turn");
	});

	it("should handle negative angles", () => {
		expect(angleToCss({ value: -45, unit: "deg" })).toBe("-45deg");
		expect(angleToCss({ value: -0.25, unit: "turn" })).toBe("-0.25turn");
	});
});

describe("numberToCss", () => {
	it("should convert integers", () => {
		expect(numberToCss(0)).toBe("0");
		expect(numberToCss(1)).toBe("1");
		expect(numberToCss(100)).toBe("100");
		expect(numberToCss(999)).toBe("999");
	});

	it("should convert decimals", () => {
		expect(numberToCss(0.5)).toBe("0.5");
		expect(numberToCss(1.25)).toBe("1.25");
		expect(numberToCss(Math.PI)).toBe(String(Math.PI));
	});

	it("should handle negative numbers", () => {
		expect(numberToCss(-1)).toBe("-1");
		expect(numberToCss(-0.5)).toBe("-0.5");
		expect(numberToCss(-100)).toBe("-100");
	});

	it("should handle zero", () => {
		expect(numberToCss(0)).toBe("0");
		expect(numberToCss(-0)).toBe("0");
	});
});

describe("joinCssValues", () => {
	it("should join values with comma and space", () => {
		expect(joinCssValues(["red", "blue", "green"])).toBe("red, blue, green");
		expect(joinCssValues(["1px", "2px", "3px"])).toBe("1px, 2px, 3px");
	});

	it("should handle single value", () => {
		expect(joinCssValues(["red"])).toBe("red");
	});

	it("should handle empty array", () => {
		expect(joinCssValues([])).toBe("");
	});

	it("should handle complex values", () => {
		expect(joinCssValues(["linear-gradient(red, blue)", "url(image.png)", "#fff"])).toBe(
			"linear-gradient(red, blue), url(image.png), #fff",
		);
	});
});

describe("joinCssValuesWithSpaces", () => {
	it("should join values with spaces", () => {
		expect(joinCssValuesWithSpaces(["10px", "20px", "30px"])).toBe("10px 20px 30px");
		expect(joinCssValuesWithSpaces(["red", "blue"])).toBe("red blue");
	});

	it("should handle single value", () => {
		expect(joinCssValuesWithSpaces(["10px"])).toBe("10px");
	});

	it("should handle empty array", () => {
		expect(joinCssValuesWithSpaces([])).toBe("");
	});

	it("should handle keyword values", () => {
		expect(joinCssValuesWithSpaces(["none", "repeat", "scroll"])).toBe("none repeat scroll");
	});
});

describe("borderRadiusToCss", () => {
	it("should optimize to 1 value when all corners equal", () => {
		const radius = {
			topLeft: { value: 5, unit: "px" as const },
			topRight: { value: 5, unit: "px" as const },
			bottomRight: { value: 5, unit: "px" as const },
			bottomLeft: { value: 5, unit: "px" as const },
		};
		expect(borderRadiusToCss(radius)).toBe("5px");
	});

	it("should optimize to 2 values when diagonals same", () => {
		const radius = {
			topLeft: { value: 5, unit: "px" as const },
			topRight: { value: 10, unit: "px" as const },
			bottomRight: { value: 5, unit: "px" as const },
			bottomLeft: { value: 10, unit: "px" as const },
		};
		expect(borderRadiusToCss(radius)).toBe("5px 10px");
	});

	it("should optimize to 3 values when top-right equals bottom-left", () => {
		const radius = {
			topLeft: { value: 5, unit: "px" as const },
			topRight: { value: 10, unit: "px" as const },
			bottomRight: { value: 15, unit: "px" as const },
			bottomLeft: { value: 10, unit: "px" as const },
		};
		expect(borderRadiusToCss(radius)).toBe("5px 10px 15px");
	});

	it("should use 4 values when all different", () => {
		const radius = {
			topLeft: { value: 5, unit: "px" as const },
			topRight: { value: 10, unit: "px" as const },
			bottomRight: { value: 15, unit: "px" as const },
			bottomLeft: { value: 20, unit: "px" as const },
		};
		expect(borderRadiusToCss(radius)).toBe("5px 10px 15px 20px");
	});

	it("should handle percentage values", () => {
		const radius = {
			topLeft: { value: 50, unit: "%" as const },
			topRight: { value: 50, unit: "%" as const },
			bottomRight: { value: 50, unit: "%" as const },
			bottomLeft: { value: 50, unit: "%" as const },
		};
		expect(borderRadiusToCss(radius)).toBe("50%");
	});

	it("should handle mixed units", () => {
		const radius = {
			topLeft: { value: 5, unit: "px" as const },
			topRight: { value: 10, unit: "%" as const },
			bottomRight: { value: 5, unit: "px" as const },
			bottomLeft: { value: 10, unit: "%" as const },
		};
		expect(borderRadiusToCss(radius)).toBe("5px 10%");
	});

	it("should handle zero values", () => {
		const radius = {
			topLeft: { value: 0, unit: "px" as const },
			topRight: { value: 0, unit: "px" as const },
			bottomRight: { value: 0, unit: "px" as const },
			bottomLeft: { value: 0, unit: "px" as const },
		};
		expect(borderRadiusToCss(radius)).toBe("0px");
	});

	it("should handle decimal values", () => {
		const radius = {
			topLeft: { value: 2.5, unit: "rem" as const },
			topRight: { value: 2.5, unit: "rem" as const },
			bottomRight: { value: 2.5, unit: "rem" as const },
			bottomLeft: { value: 2.5, unit: "rem" as const },
		};
		expect(borderRadiusToCss(radius)).toBe("2.5rem");
	});
});


=== File: src/utils/generate/values.ts ===
// b_path:: src/utils/generate/values.ts
import type * as Type from "@/core/types";

/**
 * Generate CSS value string from PositionValue IR.
 *
 * Handles both keyword and length/percentage position values.
 * Common pattern used across position and transform generation.
 *
 * @param value - PositionValue IR object
 * @returns CSS value string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { positionValueToCss } from "@/utils/generate/values";
 *
 * console.log(positionValueToCss("center")); // "center"
 * console.log(positionValueToCss({ value: 50, unit: "%" })); // "50%"
 * console.log(positionValueToCss({ value: 100, unit: "px" })); // "100px"
 * ```
 */
export function positionValueToCss(value: Type.PositionValue): string {
	if (typeof value === "string") {
		return value;
	}
	return `${value.value}${value.unit}`;
}

/**
 * Generate CSS value string from Length IR.
 *
 * @param length - Length IR object
 * @returns CSS length string
 *
 * @public
 */
export function lengthToCss(length: Type.Length): string {
	return `${length.value}${length.unit}`;
}

/**
 * Generate CSS value string from LengthPercentage IR.
 *
 * @param lengthPercentage - LengthPercentage IR object
 * @returns CSS length-percentage string
 *
 * @public
 */
export function lengthPercentageToCss(lengthPercentage: Type.LengthPercentage): string {
	return `${lengthPercentage.value}${lengthPercentage.unit}`;
}

/**
 * Generate CSS value string from Angle IR.
 *
 * @param angle - Angle IR object
 * @returns CSS angle string
 *
 * @public
 */
export function angleToCss(angle: Type.Angle): string {
	return `${angle.value}${angle.unit}`;
}

/**
 * Generate CSS value string from number.
 *
 * @param number - Number value
 * @returns CSS number string
 *
 * @public
 */
export function numberToCss(number: number): string {
	return String(number);
}

/**
 * Join an array of CSS value strings with commas and spaces.
 *
 * Common pattern for generating comma-separated CSS values.
 *
 * @param values - Array of CSS value strings
 * @returns Joined CSS string
 *
 * @public
 *
 * @example
 * ```typescript
 * import { joinCssValues } from "@/utils/generate/values";
 *
 * const values = ["red", "blue", "green"];
 * console.log(joinCssValues(values)); // "red, blue, green"
 * ```
 */
export function joinCssValues(values: string[]): string {
	return values.join(", ");
}

/**
 * Join an array of CSS value strings with spaces.
 *
 * Common pattern for generating space-separated CSS values.
 *
 * @param values - Array of CSS value strings
 * @returns Joined CSS string
 *
 * @public
 */
export function joinCssValuesWithSpaces(values: string[]): string {
	return values.join(" ");
}

/**
 * Generate border-radius CSS in shortest form.
 *
 * Converts 4-corner border-radius values to shortest CSS representation:
 * - All equal → 1 value
 * - Diagonals same → 2 values
 * - Top-right/bottom-left same → 3 values
 * - All different → 4 values
 *
 * Used by clip-path shapes (inset, rect, xywh) for 'round' clause.
 *
 * @param radius - Border radius with 4 corner values
 * @returns CSS border-radius string in shortest form
 *
 * @public
 *
 * @example
 * All corners equal:
 * ```typescript
 * const radius = {
 *   topLeft: { value: 5, unit: "px" },
 *   topRight: { value: 5, unit: "px" },
 *   bottomRight: { value: 5, unit: "px" },
 *   bottomLeft: { value: 5, unit: "px" }
 * };
 * borderRadiusToCss(radius); // "5px"
 * ```
 *
 * @example
 * Diagonals same:
 * ```typescript
 * const radius = {
 *   topLeft: { value: 5, unit: "px" },
 *   topRight: { value: 10, unit: "px" },
 *   bottomRight: { value: 5, unit: "px" },
 *   bottomLeft: { value: 10, unit: "px" }
 * };
 * borderRadiusToCss(radius); // "5px 10px"
 * ```
 */
export function borderRadiusToCss(radius: {
	topLeft: Type.LengthPercentage;
	topRight: Type.LengthPercentage;
	bottomRight: Type.LengthPercentage;
	bottomLeft: Type.LengthPercentage;
}): string {
	const tl = lengthPercentageToCss(radius.topLeft);
	const tr = lengthPercentageToCss(radius.topRight);
	const br = lengthPercentageToCss(radius.bottomRight);
	const bl = lengthPercentageToCss(radius.bottomLeft);

	// Check for optimization opportunities
	if (tl === tr && tr === br && br === bl) {
		// All equal: 1 value
		return tl;
	}

	if (tl === br && tr === bl) {
		// Diagonals same: 2 values
		return `${tl} ${tr}`;
	}

	if (tr === bl) {
		// Top-right/bottom-left same: 3 values
		return `${tl} ${tr} ${br}`;
	}

	// All different: 4 values
	return `${tl} ${tr} ${br} ${bl}`;
}


=== File: src/utils/index.ts ===
// b_path:: src/utils/index.ts

export * as Ast from "./ast";
export * as Generate from "./generate";
export * as Parse from "./parse";


=== File: src/utils/parse/color-components.test.ts ===
// b_path:: src/utils/parse/color-components.test.ts

import * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { parseAlpha, parseHue, parseLightness, parsePercentage } from "./color-components";

describe("parseAlpha", () => {
	it("parses number in valid range (0-1)", () => {
		const ast = csstree.parse("0.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(0.5);
	});

	it("parses percentage (0%-100%)", () => {
		const ast = csstree.parse("50%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(0.5);
	});

	it("rejects number out of range without clamp", () => {
		const ast = csstree.parse("1.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node);
		expect(result.ok).toBe(false);
	});

	it("clamps number out of range with clamp option", () => {
		const ast = csstree.parse("1.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node, { clamp: true });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(1);
	});

	it("clamps percentage with clamp option", () => {
		const ast = csstree.parse("150%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseAlpha(node, { clamp: true });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(1);
	});
});

describe("parseHue", () => {
	it("parses unitless number as degrees", () => {
		const ast = csstree.parse("120", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(120);
	});

	it("parses angle in degrees", () => {
		const ast = csstree.parse("180deg", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(180);
	});

	it("parses angle in radians", () => {
		const ast = csstree.parse("3.14159rad", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBeCloseTo(180, 0);
	});

	it("parses angle in turns", () => {
		const ast = csstree.parse("0.5turn", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(180);
	});

	it("normalizes hue with wrapping (negative)", () => {
		const ast = csstree.parse("-30", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(330);
	});

	it("normalizes hue with wrapping (>360)", () => {
		const ast = csstree.parse("400", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseHue(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(40);
	});
});

describe("parseLightness", () => {
	it("parses number in 0-100 range", () => {
		const ast = csstree.parse("50", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-100");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(50);
	});

	it("parses number in 0-1 range", () => {
		const ast = csstree.parse("0.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-1");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(0.5);
	});

	it("parses percentage and converts to 0-100 range", () => {
		const ast = csstree.parse("50%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-100");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(50);
	});

	it("parses percentage and converts to 0-1 range", () => {
		const ast = csstree.parse("50%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-1");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(0.5);
	});

	it("clamps value to 0-100 range", () => {
		const ast = csstree.parse("150", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-100");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(100);
	});

	it("clamps value to 0-1 range", () => {
		const ast = csstree.parse("1.5", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parseLightness(node, "0-1");
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(1);
	});
});

describe("parsePercentage", () => {
	it("parses valid percentage", () => {
		const ast = csstree.parse("75%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parsePercentage(node);
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(75);
	});

	it("rejects out of range percentage without clamp", () => {
		const ast = csstree.parse("150%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parsePercentage(node);
		expect(result.ok).toBe(false);
	});

	it("clamps percentage with clamp option", () => {
		const ast = csstree.parse("150%", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parsePercentage(node, { clamp: true });
		expect(result.ok).toBe(true);
		if (result.ok) expect(result.value).toBe(100);
	});

	it("rejects non-percentage node", () => {
		const ast = csstree.parse("50", { context: "value" }) as csstree.Value;
		const node = ast.children.first;
		if (!node) throw new Error("Failed to parse");
		const result = parsePercentage(node);
		expect(result.ok).toBe(false);
	});
});


=== File: src/utils/parse/color-components.ts ===
// b_path:: src/utils/parse/color-components.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import * as ParseUtils from "./nodes";

/**
 * Options for parsing alpha values.
 */
export interface ParseAlphaOptions {
	/**
	 * If true, clamp values to 0-1 range instead of returning errors.
	 * Default: false (return errors for out-of-range values)
	 */
	clamp?: boolean;
}

/**
 * Parse an alpha (transparency) value from a CSS AST node.
 *
 * Accepts:
 * - Number: 0-1 range
 * - Percentage: 0%-100% (converted to 0-1)
 *
 * @param node - CSS AST node to parse
 * @param options - Parsing options (clamping behavior)
 * @returns Result containing alpha value (0-1) or error message
 *
 * @example
 * ```typescript
 * import { parseAlpha } from "@/utils/parse/color-components";
 *
 * // Number (0-1)
 * const alpha1 = parseAlpha(numberNode);
 * // => { ok: true, value: 0.5 }
 *
 * // Percentage (0%-100%)
 * const alpha2 = parseAlpha(percentageNode);
 * // => { ok: true, value: 0.5 }
 *
 * // With clamping
 * const alpha3 = parseAlpha(invalidNode, { clamp: true });
 * // => { ok: true, value: 1 } // clamped from 1.5
 * ```
 *
 * @public
 */
export function parseAlpha(node: csstree.CssNode, options?: ParseAlphaOptions): Result<number, string> {
	const clamp = options?.clamp ?? false;

	// Try parsing as number (0-1)
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		const value = numResult.value;

		if (clamp) {
			return ok(Math.max(0, Math.min(1, value)));
		}

		if (value < 0 || value > 1) {
			return err(`Alpha value must be between 0 and 1, got ${value}`);
		}
		return ok(value);
	}

	// Try parsing as percentage (0%-100%)
	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value for alpha");
		}

		// Convert percentage to 0-1 range
		const alphaValue = value / 100;

		if (clamp) {
			return ok(Math.max(0, Math.min(1, alphaValue)));
		}

		if (value < 0 || value > 100) {
			return err(`Alpha percentage must be between 0% and 100%, got ${value}%`);
		}
		return ok(alphaValue);
	}

	return err(`Expected number or percentage for alpha, got ${node.type}`);
}

/**
 * Parse a hue value from a CSS AST node.
 *
 * Accepts:
 * - Number: Unitless degrees
 * - Dimension: Angle with unit (deg, rad, grad, turn)
 *
 * Hue is normalized to 0-360 degrees range with wrapping.
 *
 * @param node - CSS AST node to parse
 * @returns Result containing hue value (0-360 degrees) or error message
 *
 * @example
 * ```typescript
 * import { parseHue } from "@/utils/parse/color-components";
 *
 * // Unitless number (defaults to degrees)
 * const hue1 = parseHue(numberNode);
 * // => { ok: true, value: 120 }
 *
 * // Angle with unit
 * const hue2 = parseHue(angleNode);
 * // => { ok: true, value: 180 } // converted from 0.5turn
 *
 * // Wrapping (negative values)
 * const hue3 = parseHue(negativeNode);
 * // => { ok: true, value: 330 } // -30 wraps to 330
 * ```
 *
 * @public
 */
export function parseHue(node: csstree.CssNode): Result<number, string> {
	// Unitless number (defaults to degrees)
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		return ok(normalizeHue(numResult.value));
	}

	// Angle with unit
	if (node.type === "Dimension") {
		const angleResult = ParseUtils.parseAngleNode(node);
		if (!angleResult.ok) {
			return err(angleResult.error);
		}

		const angle = angleResult.value;
		// Convert to degrees
		let degrees: number;
		switch (angle.unit) {
			case "deg":
				degrees = angle.value;
				break;
			case "rad":
				degrees = (angle.value * 180) / Math.PI;
				break;
			case "grad":
				degrees = (angle.value * 360) / 400;
				break;
			case "turn":
				degrees = angle.value * 360;
				break;
			default:
				return err(`Unsupported angle unit: ${angle.unit}`);
		}

		return ok(normalizeHue(degrees));
	}

	return err(`Expected number or angle for hue, got ${node.type}`);
}

/**
 * Normalize hue to 0-360 degrees range with wrapping.
 *
 * @param hue - Hue value in degrees
 * @returns Normalized hue (0-360)
 *
 * @internal
 */
function normalizeHue(hue: number): number {
	// Wrap to 0-360 range
	const normalized = hue % 360;
	// Handle negative values
	const positive = normalized < 0 ? normalized + 360 : normalized;
	// Ensure positive zero (avoid -0)
	return positive === 0 ? 0 : positive;
}

/**
 * Range specification for lightness values.
 */
export type LightnessRange = "0-1" | "0-100";

/**
 * Parse a lightness value from a CSS AST node.
 *
 * Accepts:
 * - Number: Unitless value in specified range
 * - Percentage: 0%-100% (converted to specified range)
 *
 * Values are clamped to the specified range.
 *
 * @param node - CSS AST node to parse
 * @param range - Expected range for lightness ("0-1" or "0-100")
 * @returns Result containing lightness value (clamped) or error message
 *
 * @example
 * ```typescript
 * import { parseLightness } from "@/utils/parse/color-components";
 *
 * // Number in 0-100 range (for LAB/LCH)
 * const lightness1 = parseLightness(numberNode, "0-100");
 * // => { ok: true, value: 50 }
 *
 * // Number in 0-1 range (for OKLab/OKLCH)
 * const lightness2 = parseLightness(numberNode, "0-1");
 * // => { ok: true, value: 0.5 }
 *
 * // Percentage (converts to range)
 * const lightness3 = parseLightness(percentageNode, "0-100");
 * // => { ok: true, value: 50 } // from 50%
 * ```
 *
 * @public
 */
export function parseLightness(node: csstree.CssNode, range: LightnessRange): Result<number, string> {
	const maxValue = range === "0-1" ? 1 : 100;

	// Try percentage first
	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value for lightness");
		}
		// Convert percentage to range and clamp
		const lightness = (value / 100) * maxValue;
		return ok(Math.max(0, Math.min(maxValue, lightness)));
	}

	// Try number
	if (node.type === "Number") {
		const numResult = ParseUtils.parseNumberNode(node);
		if (!numResult.ok) {
			return err(numResult.error);
		}
		// Clamp to range
		return ok(Math.max(0, Math.min(maxValue, numResult.value)));
	}

	return err(`Expected number or percentage for lightness, got ${node.type}`);
}

/**
 * Options for parsing percentage values.
 */
export interface ParsePercentageOptions {
	/**
	 * If true, clamp values to 0-100 range instead of returning errors.
	 * Default: false (return errors for out-of-range values)
	 */
	clamp?: boolean;
}

/**
 * Parse a percentage value from a CSS AST node.
 *
 * Accepts:
 * - Percentage: 0%-100%
 *
 * @param node - CSS AST node to parse
 * @param options - Parsing options (clamping behavior)
 * @returns Result containing percentage value (0-100) or error message
 *
 * @example
 * ```typescript
 * import { parsePercentage } from "@/utils/parse/color-components";
 *
 * // Valid percentage
 * const pct1 = parsePercentage(percentageNode);
 * // => { ok: true, value: 50 }
 *
 * // With clamping
 * const pct2 = parsePercentage(invalidNode, { clamp: true });
 * // => { ok: true, value: 100 } // clamped from 150
 * ```
 *
 * @public
 */
export function parsePercentage(node: csstree.CssNode, options?: ParsePercentageOptions): Result<number, string> {
	const clamp = options?.clamp ?? false;

	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value");
		}

		if (clamp) {
			return ok(Math.max(0, Math.min(100, value)));
		}

		if (value < 0 || value > 100) {
			return err(`Percentage must be between 0% and 100%, got ${value}%`);
		}
		return ok(value);
	}

	return err(`Expected percentage, got ${node.type}`);
}


=== File: src/utils/parse/color.ts ===
// b_path:: src/utils/parse/color.ts
// // b_path:: src/utils/parse/color.ts

// TODO: LLM -> Let's chat about this -> READ next 5 lines only

// import type { Result } from "@/core/result";
// import type { Color } from "@/core/types/color";
// import * as ColorParse from "@/parse/color"; <-- We should not be importing from parse here

// /**
//  * Parse a CSS color value with auto-detection of format.
//  *
//  * Convenience helper that dispatches to appropriate color parser
//  * based on input format detection.
//  *
//  * @param input - CSS color string
//  * @returns Result containing parsed Color IR or error message
//  *
//  * @internal
//  */
// export function parseColor(input: string): Result<Color, string> {
// 	const trimmed = input.trim();

// 	// Try hex - starts with #
// 	if (trimmed.startsWith("#")) {
// 		return ColorParse.Hex.parse(trimmed);
// 	}

// 	// Try function syntax - contains (
// 	if (trimmed.includes("(")) {
// 		const lower = trimmed.toLowerCase();

// 		// Check function name prefix
// 		if (lower.startsWith("rgb(") || lower.startsWith("rgba(")) {
// 			return ColorParse.Rgb.parse(trimmed);
// 		}
// 		if (lower.startsWith("hsl(") || lower.startsWith("hsla(")) {
// 			return ColorParse.Hsl.parse(trimmed);
// 		}
// 		if (lower.startsWith("hwb(")) {
// 			return ColorParse.Hwb.parse(trimmed);
// 		}
// 		if (lower.startsWith("lab(")) {
// 			return ColorParse.Lab.parse(trimmed);
// 		}
// 		if (lower.startsWith("lch(")) {
// 			return ColorParse.Lch.parse(trimmed);
// 		}
// 		if (lower.startsWith("oklab(")) {
// 			return ColorParse.Oklab.parse(trimmed);
// 		}
// 		if (lower.startsWith("oklch(")) {
// 			return ColorParse.Oklch.parse(trimmed);
// 		}
// 	}

// 	// Try special keywords - transparent, currentcolor
// 	const lower = trimmed.toLowerCase();
// 	if (lower === "transparent" || lower === "currentcolor") {
// 		return ColorParse.Special.parse(trimmed);
// 	}

// 	// Try system color keywords
// 	const systemResult = ColorParse.System.parse(trimmed);
// 	if (systemResult.ok) {
// 		return systemResult;
// 	}

// 	// Try named colors - fallback
// 	return ColorParse.Named.parse(trimmed);
// }


=== File: src/utils/parse/comma-separated.test.ts ===
// b_path:: src/utils/parse/comma-separated.test.ts

import type * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { err, ok, type Result } from "@/core/result";
import { parseCommaSeparatedSingle } from "./comma-separated";

function mockIdentifierParser(node: csstree.CssNode): Result<string, string> {
	if (node.type !== "Identifier") {
		return err(`Expected Identifier, got ${node.type}`);
	}
	return ok(node.name);
}

function mockNumberParser(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		return ok(Number.parseFloat(node.value));
	}
	if (node.type === "Dimension" && node.unit === "px") {
		return ok(Number.parseFloat(node.value));
	}
	return err(`Expected number or dimension, got ${node.type}`);
}

describe("parseCommaSeparatedSingle", () => {
	describe("Basic Functionality", () => {
		it("parses single value", () => {
			const result = parseCommaSeparatedSingle("value", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["value"],
			});
		});

		it("parses two comma-separated values", () => {
			const result = parseCommaSeparatedSingle("first, second", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["first", "second"],
			});
		});

		it("parses three comma-separated values", () => {
			const result = parseCommaSeparatedSingle("one, two, three", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["one", "two", "three"],
			});
		});

		it("parses many comma-separated values", () => {
			const result = parseCommaSeparatedSingle("a, b, c, d, e, f, g", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toHaveLength(7);
				expect(result.value).toEqual(["a", "b", "c", "d", "e", "f", "g"]);
			}
		});
	});

	describe("Whitespace Handling", () => {
		it("handles values with no spaces around commas", () => {
			const result = parseCommaSeparatedSingle("first,second,third", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["first", "second", "third"],
			});
		});

		it("handles values with multiple spaces around commas", () => {
			const result = parseCommaSeparatedSingle("first  ,  second  ,  third", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["first", "second", "third"],
			});
		});

		it("handles values with tabs and newlines", () => {
			const result = parseCommaSeparatedSingle("first\t,\nsecond\t,\nthird", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["first", "second", "third"],
			});
		});
	});

	describe("Different Value Types", () => {
		it("parses numeric values", () => {
			const result = parseCommaSeparatedSingle("1, 2, 3", mockNumberParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: [1, 2, 3],
			});
		});

		it("parses dimension values", () => {
			const result = parseCommaSeparatedSingle("10px, 20px, 30px", mockNumberParser, "test-property");

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toEqual([10, 20, 30]);
			}
		});

		it("parses mixed identifiers", () => {
			const result = parseCommaSeparatedSingle("ease, linear, ease-in-out", mockIdentifierParser, "test-property");

			expect(result).toEqual({
				ok: true,
				value: ["ease", "linear", "ease-in-out"],
			});
		});
	});

	describe("Error Cases", () => {
		it("rejects empty string", () => {
			const result = parseCommaSeparatedSingle("", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("test-property");
			}
		});

		it("rejects empty value before comma", () => {
			const result = parseCommaSeparatedSingle(", second", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Empty value");
			}
		});

		it("rejects empty value after comma", () => {
			const result = parseCommaSeparatedSingle("first, ", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Empty value");
			}
		});

		it("rejects empty value between commas", () => {
			const result = parseCommaSeparatedSingle("first, , third", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Empty value");
			}
		});

		it("propagates parser errors", () => {
			const result = parseCommaSeparatedSingle("123, 456", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected Identifier");
			}
		});

		it("includes property name in error messages", () => {
			const result = parseCommaSeparatedSingle(", invalid", mockIdentifierParser, "my-custom-property");

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("my-custom-property");
			}
		});
	});

	describe("Edge Cases", () => {
		it("handles single comma (two empty values)", () => {
			const result = parseCommaSeparatedSingle(",", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
		});

		it("handles multiple consecutive commas", () => {
			const result = parseCommaSeparatedSingle("first,,third", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
		});

		it("handles only whitespace", () => {
			const result = parseCommaSeparatedSingle("   ", mockIdentifierParser, "test-property");

			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/utils/parse/comma-separated.ts ===
// b_path:: src/utils/parse/comma-separated.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse comma-separated list where each item is a single AST node.
 *
 * This helper handles the common pattern of splitting comma-separated values
 * where each item between commas is exactly one value (not a complex expression).
 *
 * Examples:
 * - animation-name: fade, slide, bounce
 * - transition-property: opacity, transform
 * - animation-delay: 1s, 500ms, 2s
 * - background-image: linear-gradient(...), url(img.png)
 *
 * @param css - CSS value string to parse
 * @param itemParser - Function to parse each individual item node
 * @param propertyName - Property name for error messages
 * @returns Result with array of parsed items or error
 *
 * @example
 * ```typescript
 * const result = parseCommaSeparatedSingle(
 *   "fade, slide, bounce",
 *   (node) => parseAnimationName(node),
 *   "animation-name"
 * );
 * // result.value = [{ type: "identifier", value: "fade" }, ...]
 * ```
 *
 * @internal
 */
export function parseCommaSeparatedSingle<T>(
	css: string,
	itemParser: (node: csstree.CssNode) => Result<T, string>,
	propertyName: string,
): Result<T[], string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err(`${propertyName}: Expected Value node`);
		}

		const children = ast.children.toArray();

		const results: T[] = [];
		let currentNodes: csstree.CssNode[] = [];

		for (const node of children) {
			if (node.type === "Operator" && "value" in node && node.value === ",") {
				if (currentNodes.length === 1 && currentNodes[0]) {
					const itemResult = itemParser(currentNodes[0]);
					if (!itemResult.ok) {
						return err(`${propertyName}: ${itemResult.error}`);
					}
					results.push(itemResult.value);
					currentNodes = [];
				} else if (currentNodes.length === 0) {
					return err(`${propertyName}: Empty value before comma`);
				} else {
					return err(`${propertyName}: Expected single value between commas, got ${currentNodes.length} values`);
				}
			} else {
				currentNodes.push(node);
			}
		}

		if (currentNodes.length === 1 && currentNodes[0]) {
			const itemResult = itemParser(currentNodes[0]);
			if (!itemResult.ok) {
				return err(`${propertyName}: ${itemResult.error}`);
			}
			results.push(itemResult.value);
		} else if (currentNodes.length === 0) {
			return err(`${propertyName}: Empty value`);
		} else {
			return err(`${propertyName}: Expected single value, got ${currentNodes.length} values`);
		}

		if (results.length === 0) {
			return err(`${propertyName}: Requires at least one value`);
		}

		return ok(results);
	} catch (e) {
		return err(`Failed to parse ${propertyName}: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/utils/parse/comma.test.ts ===
// b_path:: src/utils/parse/comma.test.ts

import * as csstree from "css-tree";
import { describe, expect, test } from "vitest";
import { err, ok } from "@/core/result";
import { splitLayer, splitValue } from "./comma";

describe("splitValue", () => {
	test("parses single value", () => {
		const result = splitValue("fade", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(1);
			expect(result.value[0]?.name).toBe("fade");
		}
	});

	test("parses multiple values", () => {
		const result = splitValue("fade, slide, bounce", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(3);
			expect(result.value[0]?.name).toBe("fade");
			expect(result.value[1]?.name).toBe("slide");
			expect(result.value[2]?.name).toBe("bounce");
		}
	});

	test("parses function values", () => {
		const result = splitValue("url(a.png), url(b.png)", (node) => ok({ value: csstree.generate(node) }), "test");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.value).toBe("url(a.png)");
			expect(result.value[1]?.value).toBe("url(b.png)");
		}
	});

	test("CRITICAL: handles nested commas in function values", () => {
		const result = splitValue(
			"linear-gradient(red, blue), url(a.png)",
			(node) => ok({ value: csstree.generate(node) }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Should be 2 values, NOT 3!
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.value).toContain("linear-gradient");
			expect(result.value[0]?.value).toContain("red");
			expect(result.value[0]?.value).toContain("blue");
			expect(result.value[1]?.value).toBe("url(a.png)");
		}
	});

	test("handles values with whitespace", () => {
		const result = splitValue("  fade  ,  slide  ", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
		}
	});

	test("errors on empty value", () => {
		const result = splitValue("fade, , slide", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Empty value");
		}
	});

	test("errors on multiple nodes between commas", () => {
		const result = splitValue("fade slide, bounce", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Expected single value");
		}
	});

	test("errors on trailing comma", () => {
		const result = splitValue("fade, slide,", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Empty value");
		}
	});

	test("errors on leading comma", () => {
		const result = splitValue(", fade, slide", (node) => ok({ name: csstree.generate(node) }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Empty value");
		}
	});

	test("propagates parser errors", () => {
		const result = splitValue("fade, slide", () => err("custom error"), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("custom error");
		}
	});
});

describe("splitLayer", () => {
	test("parses single layer with multiple tokens", () => {
		const result = splitLayer(
			"2px 2px red",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(1);
			expect(result.value[0]?.count).toBe(3);
		}
	});

	test("parses multiple layers", () => {
		const result = splitLayer(
			"2px 2px red, 3px 3px blue",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.count).toBe(3);
			expect(result.value[1]?.count).toBe(3);
		}
	});

	test("CRITICAL: handles nested function commas in layer", () => {
		const result = splitLayer(
			"drop-shadow(1px 2px red), 3px 3px blue",
			(nodes) => ok({ nodeCount: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			// Should be 2 layers, NOT 3!
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.nodeCount).toBe(1); // drop-shadow function
			expect(result.value[1]?.nodeCount).toBe(3); // 3px 3px blue
		}
	});

	test("handles layers with different token counts", () => {
		const result = splitLayer(
			"2px, 3px 3px 5px red",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
			expect(result.value[0]?.count).toBe(1); // First layer: 1 token
			expect(result.value[1]?.count).toBe(4); // Second layer: 4 tokens
		}
	});

	test("handles layers with whitespace", () => {
		const result = splitLayer(
			"  2px 2px  ,  3px 3px  ",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(2);
		}
	});

	test("errors on empty layer", () => {
		const result = splitLayer("2px 2px, , 3px 3px", (nodes) => ok({ count: nodes.length }), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Empty layer");
		}
	});

	test("allows trailing comma (matches CSS parser behavior)", () => {
		const result = splitLayer(
			"2px 2px,",
			(nodes) => ok({ count: nodes.filter((n) => n.type !== "WhiteSpace").length }),
			"test",
		);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toHaveLength(1);
		}
	});

	test("propagates parser errors", () => {
		const result = splitLayer("2px 2px, 3px 3px", () => err("layer error"), "test");
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("layer error");
		}
	});
});


=== File: src/utils/parse/comma.ts ===
// b_path:: src/utils/parse/comma.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";

/**
 * Split comma-separated VALUES where each value is a complete independent item.
 *
 * A "value" can be:
 * - A keyword: fade, slide, bounce
 * - A function: url(...), linear-gradient(...)
 * - A complex expression: calc(100% - 20px)
 *
 * Use for properties where commas separate independent complete values.
 * These represent parallel behaviors, fallbacks, or multiple targets.
 *
 * Examples:
 * - animation-name: fade, slide, bounce
 * - background-image: url(a.png), linear-gradient(red, blue)
 * - transition-property: opacity, transform
 * - font-family: Arial, "Times New Roman", sans-serif
 *
 * @param css - CSS value string
 * @param valueParser - Parser for each complete value (receives single node)
 * @param propertyName - Property name for error messages
 * @returns Result with array of parsed values or error
 *
 * @example
 * ```typescript
 * const result = splitValue(
 *   "fade, slide, bounce",
 *   (node) => parseAnimationName(node),
 *   "animation-name"
 * );
 * // result.value = [{ type: "identifier", value: "fade" }, ...]
 * ```
 *
 * @public
 */
export function splitValue<T>(
	css: string,
	valueParser: (node: csstree.CssNode) => Result<T, string>,
	propertyName: string,
): Result<T[], string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err(`${propertyName}: Expected Value node`);
		}

		const children = ast.children.toArray();
		const results: T[] = [];
		let currentNodes: csstree.CssNode[] = [];

		for (const node of children) {
			if (node.type === "Operator" && "value" in node && node.value === ",") {
				// Found value separator
				if (currentNodes.length === 1 && currentNodes[0]) {
					const valueResult = valueParser(currentNodes[0]);
					if (!valueResult.ok) {
						return err(`${propertyName}: ${valueResult.error}`);
					}
					results.push(valueResult.value);
					currentNodes = [];
				} else if (currentNodes.length === 0) {
					return err(`${propertyName}: Empty value before comma`);
				} else {
					return err(`${propertyName}: Expected single value between commas, got ${currentNodes.length} nodes`);
				}
			} else {
				currentNodes.push(node);
			}
		}

		// Process last value
		if (currentNodes.length === 1 && currentNodes[0]) {
			const valueResult = valueParser(currentNodes[0]);
			if (!valueResult.ok) {
				return err(`${propertyName}: ${valueResult.error}`);
			}
			results.push(valueResult.value);
		} else if (currentNodes.length === 0) {
			return err(`${propertyName}: Empty value`);
		} else {
			return err(`${propertyName}: Expected single value, got ${currentNodes.length} nodes`);
		}

		if (results.length === 0) {
			return err(`${propertyName}: Requires at least one value`);
		}

		return ok(results);
	} catch (e) {
		return err(`Failed to parse ${propertyName}: ${e instanceof Error ? e.message : String(e)}`);
	}
}

/**
 * Split comma-separated LAYERS where each layer has multiple components.
 *
 * A "layer" is a comma-separated group of tokens that together form one
 * visual layer/effect. Each layer is parsed as a unit with multiple components.
 *
 * Use for properties where commas separate layers in actual rendering order.
 * These represent layered visual effects that stack on top of each other.
 *
 * Examples:
 * - box-shadow: 2px 2px 5px red, 3px 3px blue
 * - text-shadow: 1px 1px red, 2px 2px blue
 * - background: url(a.png) center / cover, linear-gradient(red, blue)
 * - filter: drop-shadow(1px 1px red), blur(5px)
 *
 * @param css - CSS value string
 * @param layerParser - Parser for each layer (receives array of nodes for one layer)
 * @param propertyName - Property name for error messages
 * @returns Result with array of parsed layers or error
 *
 * @example
 * ```typescript
 * const result = splitLayer(
 *   "2px 2px 5px red, 3px 3px blue",
 *   (nodes) => parseShadowLayer(nodes),
 *   "box-shadow"
 * );
 * // result.value = [{ offsetX: ..., offsetY: ..., ... }, { ... }]
 * ```
 *
 * @public
 */
export function splitLayer<T>(
	css: string,
	layerParser: (nodes: csstree.CssNode[]) => Result<T, string>,
	propertyName: string,
): Result<T[], string> {
	try {
		const ast = csstree.parse(css, { context: "value" });

		if (ast.type !== "Value") {
			return err(`${propertyName}: Expected Value node`);
		}

		const children = ast.children.toArray();
		const results: T[] = [];
		let currentNodes: csstree.CssNode[] = [];

		for (const node of children) {
			if (node.type === "Operator" && "value" in node && node.value === ",") {
				// Found layer separator
				if (currentNodes.length > 0) {
					const layerResult = layerParser(currentNodes);
					if (!layerResult.ok) {
						return err(`${propertyName}: ${layerResult.error}`);
					}
					results.push(layerResult.value);
					currentNodes = [];
				} else {
					return err(`${propertyName}: Empty layer before comma`);
				}
			} else {
				currentNodes.push(node);
			}
		}

		// Process last layer (allow trailing comma - it's valid CSS)
		if (currentNodes.length > 0) {
			const layerResult = layerParser(currentNodes);
			if (!layerResult.ok) {
				return err(`${propertyName}: ${layerResult.error}`);
			}
			results.push(layerResult.value);
		}

		if (results.length === 0) {
			return err(`${propertyName}: Requires at least one layer`);
		}

		return ok(results);
	} catch (e) {
		return err(`Failed to parse ${propertyName}: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/utils/parse/easing/easing-function.test.ts ===
// b_path:: src/utils/parse/easing/easing-function.test.ts
import * as csstree from "css-tree";
import { describe, expect, test } from "vitest";
import { parseEasingFunction } from "./easing-function";

describe("parseEasingFunction", () => {
	describe("keywords", () => {
		test("parses ease", () => {
			const ast = csstree.parse("ease", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({ ok: true, value: "ease" });
		});

		test("parses ease-in", () => {
			const ast = csstree.parse("ease-in", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({ ok: true, value: "ease-in" });
		});

		test("parses linear", () => {
			const ast = csstree.parse("linear", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({ ok: true, value: "linear" });
		});

		test("rejects invalid keyword", () => {
			const ast = csstree.parse("invalid", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("cubic-bezier", () => {
		test("parses cubic-bezier with 4 numbers", () => {
			const ast = csstree.parse("cubic-bezier(0.1, 0.7, 1.0, 0.1)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "cubic-bezier",
					x1: 0.1,
					y1: 0.7,
					x2: 1.0,
					y2: 0.1,
				},
			});
		});

		test("rejects cubic-bezier with wrong number of args", () => {
			const ast = csstree.parse("cubic-bezier(0.1, 0.7)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("steps", () => {
		test("parses steps with count only", () => {
			const ast = csstree.parse("steps(4)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "steps",
					steps: 4,
					position: undefined,
				},
			});
		});

		test("parses steps with count and position", () => {
			const ast = csstree.parse("steps(4, jump-start)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "steps",
					steps: 4,
					position: "jump-start",
				},
			});
		});

		test("rejects steps with non-integer", () => {
			const ast = csstree.parse("steps(4.5)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});

		test("rejects steps with zero", () => {
			const ast = csstree.parse("steps(0)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("linear function", () => {
		test("parses linear with single stop", () => {
			const ast = csstree.parse("linear(0)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "linear",
					stops: [{ output: 0 }],
				},
			});
		});

		test("parses linear with stop and input", () => {
			const ast = csstree.parse("linear(0 0%, 1 100%)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "linear",
					stops: [
						{ output: 0, input: 0 },
						{ output: 1, input: 1 },
					],
				},
			});
		});

		test("parses linear with multiple stops", () => {
			const ast = csstree.parse("linear(0, 0.5, 1)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result).toEqual({
				ok: true,
				value: {
					type: "linear",
					stops: [{ output: 0 }, { output: 0.5 }, { output: 1 }],
				},
			});
		});

		test("rejects linear with no stops", () => {
			const ast = csstree.parse("linear()", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("unknown function", () => {
		test("rejects unknown function", () => {
			const ast = csstree.parse("unknown(1, 2, 3)", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unknown easing function");
			}
		});
	});

	describe("invalid node type", () => {
		test("rejects number node", () => {
			const ast = csstree.parse("42", { context: "value" });
			if (ast.type !== "Value") throw new Error("Expected Value node");
			const node = ast.children.first;
			if (!node) throw new Error("Expected node");
			const result = parseEasingFunction(node);
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected easing function or keyword");
			}
		});
	});
});


=== File: src/utils/parse/easing/easing-function.ts ===
// b_path:: src/utils/parse/easing/easing-function.ts
import type * as csstree from "css-tree";
import { EASING_KEYWORD_KEYWORDS, STEP_POSITION_KEYWORDS } from "@/core/keywords/animation";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { cubicBezierSchema } from "@/core/types/animation";

/**
 * Parse cubic-bezier() function from AST node.
 *
 * @param node - CSS tree Function node
 * @returns Result with CubicBezier object or error
 *
 * @internal
 */
function parseCubicBezier(node: csstree.FunctionNode): Result<Type.CubicBezier, string> {
	const children = node.children.toArray();
	const numbers: number[] = [];

	for (const child of children) {
		if (child.type === "Number") {
			numbers.push(Number.parseFloat(child.value));
		} else if (child.type === "Operator" && "value" in child && child.value === ",") {
		} else {
			return err(`Invalid node in cubic-bezier: ${child.type}`);
		}
	}

	if (numbers.length !== 4) {
		return err(`cubic-bezier requires exactly 4 numbers, got ${numbers.length}`);
	}

	const [x1, y1, x2, y2] = numbers;

	const candidate = {
		type: "cubic-bezier" as const,
		x1: x1 as number,
		y1: y1 as number,
		x2: x2 as number,
		y2: y2 as number,
	};

	// Validate against schema (x values must be in [0, 1])
	const validation = cubicBezierSchema.safeParse(candidate);
	if (!validation.success) {
		const issue = validation.error.issues[0];
		return err(`cubic-bezier validation failed: ${issue?.path.join(".")} ${issue?.message}`);
	}

	return ok(candidate);
}

/**
 * Parse steps() function from AST node.
 *
 * @param node - CSS tree Function node
 * @returns Result with Steps object or error
 *
 * @internal
 */
function parseSteps(node: csstree.FunctionNode): Result<Type.Steps, string> {
	const children = node.children.toArray();
	let steps: number | undefined;
	let position: Type.Steps["position"] | undefined;

	for (const child of children) {
		if (child.type === "Number") {
			const value = Number.parseFloat(child.value);
			if (value <= 0 || !Number.isInteger(value)) {
				return err(`steps() requires a positive integer, got ${value}`);
			}
			steps = value;
		} else if (child.type === "Identifier") {
			const keyword = child.name.toLowerCase();
			if (STEP_POSITION_KEYWORDS.includes(keyword as (typeof STEP_POSITION_KEYWORDS)[number])) {
				position = keyword as Type.Steps["position"];
			} else {
				return err(`Invalid step position keyword: ${keyword}`);
			}
		} else if (child.type === "Operator" && "value" in child && child.value === ",") {
		} else {
			return err(`Invalid node in steps(): ${child.type}`);
		}
	}

	if (steps === undefined) {
		return err("steps() requires a step count");
	}

	return ok({
		type: "steps",
		steps,
		position,
	});
}

/**
 * Parse linear() function from AST node.
 *
 * @param node - CSS tree Function node
 * @returns Result with LinearEasing object or error
 *
 * @internal
 */
function parseLinear(node: csstree.FunctionNode): Result<Type.LinearEasing, string> {
	const children = node.children.toArray();
	const stops: Type.LinearStop[] = [];
	let currentOutput: number | undefined;
	let currentInput: number | undefined;

	for (let i = 0; i < children.length; i++) {
		const child = children[i];

		if (child?.type === "Number") {
			const value = Number.parseFloat(child.value);

			// Check if next node is a percentage (input value)
			const nextNode = children[i + 1];
			if (nextNode?.type === "Percentage") {
				currentOutput = value;
				currentInput = Number.parseFloat(nextNode.value) / 100;
				i++; // Skip the percentage node in next iteration

				stops.push({
					output: currentOutput,
					input: currentInput,
				});
				currentOutput = undefined;
				currentInput = undefined;
			} else {
				// Just an output value without input
				stops.push({
					output: value,
				});
			}
		} else if (child?.type === "Operator" && "value" in child && child.value === ",") {
		} else if (child?.type !== "WhiteSpace") {
			return err(`Invalid node in linear(): ${child?.type}`);
		}
	}

	if (stops.length === 0) {
		return err("linear() requires at least one stop");
	}

	return ok({
		type: "linear",
		stops,
	});
}

/**
 * Parse easing function from AST node.
 *
 * Supports keywords (ease, ease-in, etc.) and functions (cubic-bezier, steps, linear).
 *
 * @param node - CSS tree node to parse
 * @returns Result with EasingFunction or error
 *
 * @public
 */
export function parseEasingFunction(node: csstree.CssNode): Result<Type.EasingFunction, string> {
	// Keyword
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();
		if (EASING_KEYWORD_KEYWORDS.includes(keyword as (typeof EASING_KEYWORD_KEYWORDS)[number])) {
			return ok(keyword as (typeof EASING_KEYWORD_KEYWORDS)[number]);
		}
		return err(`Invalid easing keyword: ${keyword}`);
	}

	// Function
	if (node.type === "Function") {
		const name = node.name.toLowerCase();

		if (name === "cubic-bezier") {
			return parseCubicBezier(node);
		}

		if (name === "steps") {
			return parseSteps(node);
		}

		if (name === "linear") {
			return parseLinear(node);
		}

		return err(`Unknown easing function: ${name}`);
	}

	return err(`Expected easing function or keyword, got: ${node.type}`);
}


=== File: src/utils/parse/easing/index.ts ===
// b_path:: src/utils/parse/easing/index.ts
export * from "./easing-function";


=== File: src/utils/parse/index.ts ===
// b_path:: src/utils/parse/index.ts

/**
 * Parsing utilities for CSS values and AST nodes.
 *
 * Re-exports utilities from:
 * - **nodes**: AST node parsing (length, angle, position, etc.)
 * - **color-components**: Color value parsing helpers
 * - **comma**: Comma-separated value splitting
 * - **easing**: Timing function parsing
 * - **url**: URL value parsing
 *
 * @module utils/parse
 */

export * from "./color-components";
export * from "./comma";
export * from "./comma-separated";
export * from "./easing";
export * from "./nodes";
export * from "./url";

// export * from "./nodes/angle";
// export * from "./nodes/border-radius";
// export * from "./nodes/length";
// export * from "./nodes/number";
// export * from "./nodes/position";
// export * from "./nodes/radial";


=== File: src/utils/parse/nodes.test.ts ===
// b_path:: src/utils/parse/nodes.test.ts

import * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { parseCornerValues, parseTRBLLengthPercentage } from "./nodes";

/**
 * Helper to create CSS nodes from a string
 */
function parseNodes(css: string): csstree.CssNode[] {
	const ast = csstree.parse(css, { context: "value" });
	const nodes: csstree.CssNode[] = [];
	csstree.walk(ast, (node) => {
		if (node.type === "Dimension" || node.type === "Percentage" || node.type === "Number") {
			nodes.push(node);
		}
	});
	return nodes;
}

describe("parseTRBLLengthPercentage", () => {
	describe("valid inputs", () => {
		it("should parse single value (all sides)", () => {
			const nodes = parseNodes("10px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse two values (vertical | horizontal)", () => {
			const nodes = parseNodes("10px 20px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse three values (top | horizontal | bottom)", () => {
			const nodes = parseNodes("10px 20px 30px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should parse four values (TRBL)", () => {
			const nodes = parseNodes("10px 20px 30px 40px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 40, unit: "px" });
			}
		});

		it("should handle mixed units", () => {
			const nodes = parseNodes("10px 50% 2em 0");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 50, unit: "%" });
				expect(result.value.bottom).toEqual({ value: 2, unit: "em" });
				expect(result.value.left).toEqual({ value: 0, unit: "px" });
			}
		});

		it("should handle unitless zero", () => {
			const nodes = parseNodes("0 10px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
			}
		});
	});

	describe("invalid inputs", () => {
		it("should reject empty array", () => {
			const result = parseTRBLLengthPercentage([]);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 1-4");
			}
		});

		it("should reject more than 4 values", () => {
			const nodes = parseNodes("1px 2px 3px 4px 5px");
			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 1-4");
			}
		});

		it("should reject unitless non-zero", () => {
			const ast = csstree.parse("10 20px", { context: "value" });
			const nodes: csstree.CssNode[] = [];
			csstree.walk(ast, (node) => {
				if (node.type === "Number" || node.type === "Dimension") {
					nodes.push(node);
				}
			});

			const result = parseTRBLLengthPercentage(nodes);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Unitless values must be zero");
			}
		});
	});
});

describe("parseCornerValues", () => {
	describe("valid inputs", () => {
		it("should parse single value (all corners)", () => {
			const nodes = parseNodes("5px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("should parse two values (diagonal corners)", () => {
			const nodes = parseNodes("5px 10px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 5, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse three values", () => {
			const nodes = parseNodes("5px 10px 15px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 15, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 10, unit: "px" });
			}
		});

		it("should parse four values (all corners)", () => {
			const nodes = parseNodes("5px 10px 15px 20px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 15, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 20, unit: "px" });
			}
		});

		it("should handle unitless zero", () => {
			const nodes = parseNodes("0");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 0, unit: "px" });
			}
		});
	});

	describe("invalid inputs", () => {
		it("should reject negative values", () => {
			const nodes = parseNodes("-5px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("non-negative");
			}
		});

		it("should reject empty array", () => {
			const result = parseCornerValues([]);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 1-4");
			}
		});

		it("should reject more than 4 values", () => {
			const nodes = parseNodes("1px 2px 3px 4px 5px");
			const result = parseCornerValues(nodes);

			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Expected 1-4");
			}
		});
	});
});


=== File: src/utils/parse/nodes/angle.test.ts ===
// b_path:: src/utils/parse/nodes/angle.test.ts
import { describe, expect, it } from "vitest";
import { parseAngleNode } from "./angle";

describe("parseAngleNode", () => {
	it("parses degrees", () => {
		const node = { type: "Dimension" as const, value: "45", unit: "deg" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ value: 45, unit: "deg" });
		}
	});

	it("parses radians", () => {
		const node = { type: "Dimension" as const, value: "1.57", unit: "rad" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ value: 1.57, unit: "rad" });
		}
	});

	it("parses gradians", () => {
		const node = { type: "Dimension" as const, value: "100", unit: "grad" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ value: 100, unit: "grad" });
		}
	});

	it("parses turns", () => {
		const node = { type: "Dimension" as const, value: "0.5", unit: "turn" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ value: 0.5, unit: "turn" });
		}
	});

	it("parses zero", () => {
		const node = { type: "Dimension" as const, value: "0", unit: "deg" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ value: 0, unit: "deg" });
		}
	});

	it("parses negative angles", () => {
		const node = { type: "Dimension" as const, value: "-45", unit: "deg" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toEqual({ value: -45, unit: "deg" });
		}
	});

	it("rejects invalid unit", () => {
		const node = { type: "Dimension" as const, value: "45", unit: "px" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid angle unit");
		}
	});

	it("rejects non-dimension node", () => {
		const node = { type: "Number" as const, value: "45" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Expected angle dimension");
		}
	});

	it("rejects NaN value", () => {
		const node = { type: "Dimension" as const, value: "abc", unit: "deg" };
		const result = parseAngleNode(node);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Invalid angle value");
		}
	});
});


=== File: src/utils/parse/nodes/angle.ts ===
// b_path:: src/utils/parse/nodes/angle.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as Unit from "@/core/units";

/**
 * Angle value parsing utilities.
 *
 * This module handles:
 * - CSS angle values (deg, rad, grad, turn)
 * - Unit validation and conversion
 *
 * @module utils/parse/nodes/angle
 */

/**
 * Parse a CSS dimension node into an Angle IR.
 *
 * Handles all CSS angle units using core unit definitions.
 *
 * @param node - CSS AST dimension node
 * @returns Result containing Angle IR or error message
 *
 * @public
 */
export function parseAngleNode(node: csstree.CssNode): Result<Type.Angle, string> {
	if (node.type === "Dimension") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid angle value");
		}

		// Use core unit validation
		if (!Unit.ANGLE_UNITS.includes(node.unit as (typeof Unit.ANGLE_UNITS)[number])) {
			return err(`Invalid angle unit: ${node.unit}`);
		}

		return ok({ value, unit: node.unit as (typeof Unit.ANGLE_UNITS)[number] });
	}
	return err("Expected angle dimension");
}


=== File: src/utils/parse/nodes/border-radius.test.ts ===
// b_path:: src/utils/parse/nodes/border-radius.test.ts
import type * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { parseCornerValues, parseRoundBorderRadius, parseTRBLLengthPercentage } from "./border-radius";

describe("parseTRBLLengthPercentage", () => {
	const createDimension = (value: string, unit: string): csstree.Dimension => ({
		type: "Dimension",
		loc: undefined,
		value,
		unit,
	});

	const createPercentage = (value: string): csstree.Percentage => ({
		type: "Percentage",
		loc: undefined,
		value,
	});

	const createNumber = (value: string): csstree.NumberNode => ({
		type: "Number",
		loc: undefined,
		value,
	});

	describe("1 value - all sides", () => {
		it("expands single value to all sides", () => {
			const nodes = [createDimension("10", "px")];
			const result = parseTRBLLengthPercentage(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 10, unit: "px" });
			}
		});

		it("handles percentage", () => {
			const nodes = [createPercentage("50")];
			const result = parseTRBLLengthPercentage(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 50, unit: "%" });
			}
		});
	});

	describe("2 values - vertical | horizontal", () => {
		it("expands to top/bottom and left/right", () => {
			const nodes = [createDimension("10", "px"), createDimension("20", "px")];
			const result = parseTRBLLengthPercentage(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 10, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});
	});

	describe("3 values - top | horizontal | bottom", () => {
		it("expands correctly", () => {
			const nodes = [createDimension("10", "px"), createDimension("20", "px"), createDimension("30", "px")];
			const result = parseTRBLLengthPercentage(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 20, unit: "px" });
			}
		});
	});

	describe("4 values - clockwise TRBL", () => {
		it("assigns all four values", () => {
			const nodes = [
				createDimension("10", "px"),
				createDimension("20", "px"),
				createDimension("30", "px"),
				createDimension("40", "px"),
			];
			const result = parseTRBLLengthPercentage(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 10, unit: "px" });
				expect(result.value.right).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottom).toEqual({ value: 30, unit: "px" });
				expect(result.value.left).toEqual({ value: 40, unit: "px" });
			}
		});
	});

	describe("unitless zero", () => {
		it("accepts unitless zero", () => {
			const nodes = [createNumber("0")];
			const result = parseTRBLLengthPercentage(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.top).toEqual({ value: 0, unit: "px" });
			}
		});

		it("rejects unitless non-zero", () => {
			const nodes = [createNumber("10")];
			const result = parseTRBLLengthPercentage(nodes);
			expect(result.ok).toBe(false);
		});
	});

	describe("validation", () => {
		it("rejects empty array", () => {
			const result = parseTRBLLengthPercentage([]);
			expect(result.ok).toBe(false);
		});

		it("rejects more than 4 values", () => {
			const nodes = [
				createDimension("10", "px"),
				createDimension("20", "px"),
				createDimension("30", "px"),
				createDimension("40", "px"),
				createDimension("50", "px"),
			];
			const result = parseTRBLLengthPercentage(nodes);
			expect(result.ok).toBe(false);
		});
	});
});

describe("parseCornerValues", () => {
	const createDimension = (value: string, unit: string): csstree.Dimension => ({
		type: "Dimension",
		loc: undefined,
		value,
		unit,
	});

	const createPercentage = (value: string): csstree.Percentage => ({
		type: "Percentage",
		loc: undefined,
		value,
	});

	const createNumber = (value: string): csstree.NumberNode => ({
		type: "Number",
		loc: undefined,
		value,
	});

	describe("1 value - all corners", () => {
		it("expands single value to all corners", () => {
			const nodes = [createDimension("10", "px")];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 10, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 10, unit: "px" });
			}
		});
	});

	describe("2 values - diagonal pairing", () => {
		it("expands to TL/BR and TR/BL", () => {
			const nodes = [createDimension("10", "px"), createDimension("20", "px")];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 10, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 10, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 20, unit: "px" });
			}
		});
	});

	describe("3 values - TL | TR/BL | BR", () => {
		it("expands correctly", () => {
			const nodes = [createDimension("10", "px"), createDimension("20", "px"), createDimension("30", "px")];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 10, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 30, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 20, unit: "px" });
			}
		});
	});

	describe("4 values - clockwise from TL", () => {
		it("assigns all four corners", () => {
			const nodes = [
				createDimension("10", "px"),
				createDimension("20", "px"),
				createDimension("30", "px"),
				createDimension("40", "px"),
			];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 10, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 20, unit: "px" });
				expect(result.value.bottomRight).toEqual({ value: 30, unit: "px" });
				expect(result.value.bottomLeft).toEqual({ value: 40, unit: "px" });
			}
		});
	});

	describe("non-negative validation", () => {
		it("accepts zero", () => {
			const nodes = [createNumber("0")];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(true);
		});

		it("rejects negative values", () => {
			const nodes = [createDimension("-10", "px")];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(false);
		});

		it("accepts positive values", () => {
			const nodes = [createDimension("10", "px")];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(true);
		});
	});

	describe("validation", () => {
		it("rejects empty array", () => {
			const result = parseCornerValues([]);
			expect(result.ok).toBe(false);
		});

		it("rejects more than 4 values", () => {
			const nodes = [
				createDimension("10", "px"),
				createDimension("20", "px"),
				createDimension("30", "px"),
				createDimension("40", "px"),
				createDimension("50", "px"),
			];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(false);
		});
	});

	describe("mixed units", () => {
		it("handles mix of lengths and percentages", () => {
			const nodes = [createDimension("10", "px"), createPercentage("20")];
			const result = parseCornerValues(nodes);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.topLeft).toEqual({ value: 10, unit: "px" });
				expect(result.value.topRight).toEqual({ value: 20, unit: "%" });
			}
		});
	});
});

describe("parseRoundBorderRadius", () => {
	const createDimension = (value: string, unit: string): csstree.Dimension => ({
		type: "Dimension",
		loc: undefined,
		value,
		unit,
	});

	const createIdentifier = (name: string): csstree.Identifier => ({
		type: "Identifier",
		loc: undefined,
		name,
	});

	describe("no 'round' keyword", () => {
		it("returns no border-radius", () => {
			const args = [createDimension("10", "px"), createDimension("20", "px")];
			const result = parseRoundBorderRadius(args);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.roundIndex).toBe(-1);
				expect(result.value.borderRadius).toBeUndefined();
			}
		});
	});

	describe("with 'round' keyword", () => {
		it("parses single border-radius value", () => {
			const args = [createDimension("10", "px"), createIdentifier("round"), createDimension("5", "px")];
			const result = parseRoundBorderRadius(args);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.roundIndex).toBe(1);
				expect(result.value.borderRadius).toBeDefined();
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
			}
		});

		it("parses multiple border-radius values", () => {
			const args = [
				createDimension("10", "px"),
				createIdentifier("round"),
				createDimension("5", "px"),
				createDimension("10", "px"),
			];
			const result = parseRoundBorderRadius(args);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.roundIndex).toBe(1);
				expect(result.value.borderRadius?.topLeft).toEqual({ value: 5, unit: "px" });
				expect(result.value.borderRadius?.topRight).toEqual({ value: 10, unit: "px" });
			}
		});

		it("handles case-insensitive 'round'", () => {
			const args = [createDimension("10", "px"), createIdentifier("ROUND"), createDimension("5", "px")];
			const result = parseRoundBorderRadius(args);
			expect(result.ok).toBe(true);
		});
	});

	describe("validation", () => {
		it("rejects 'round' without values", () => {
			const args = [createDimension("10", "px"), createIdentifier("round")];
			const result = parseRoundBorderRadius(args);
			expect(result.ok).toBe(false);
		});

		it("rejects invalid border-radius values", () => {
			const args = [createDimension("10", "px"), createIdentifier("round"), createDimension("-5", "px")];
			const result = parseRoundBorderRadius(args);
			expect(result.ok).toBe(false);
		});
	});

	describe("edge cases", () => {
		it("handles empty args array", () => {
			const result = parseRoundBorderRadius([]);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.roundIndex).toBe(-1);
			}
		});

		it("finds 'round' at different positions", () => {
			const args = [
				createDimension("10", "px"),
				createDimension("20", "px"),
				createDimension("30", "px"),
				createIdentifier("round"),
				createDimension("5", "px"),
			];
			const result = parseRoundBorderRadius(args);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.roundIndex).toBe(3);
			}
		});
	});
});


=== File: src/utils/parse/nodes/border-radius.ts ===
// b_path:: src/utils/parse/nodes/border-radius.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseLengthPercentageNode } from "./length";

/**
 * Parse CSS 4-value syntax (top, right, bottom, left).
 *
 * Accepts 1-4 length-percentage values following CSS 4-value expansion:
 * - 1 value: all sides
 * - 2 values: vertical | horizontal
 * - 3 values: top | horizontal | bottom
 * - 4 values: top | right | bottom | left (clockwise)
 *
 * Commonly used by margin, padding, inset(), scroll-margin, etc.
 *
 * @param nodes - Array of 1-4 CSS nodes
 * @returns Result with TRBL values or error
 *
 * @example
 * ```typescript
 * // Parse "10px 20px"
 * const result = parseTRBLLengthPercentage([node1, node2]);
 * // { top: 10px, right: 20px, bottom: 10px, left: 20px }
 * ```
 */
export function parseTRBLLengthPercentage(nodes: csstree.CssNode[]): Result<
	{
		top: Type.LengthPercentage;
		right: Type.LengthPercentage;
		bottom: Type.LengthPercentage;
		left: Type.LengthPercentage;
	},
	string
> {
	// Validate count
	if (nodes.length < 1 || nodes.length > 4) {
		return err(`Expected 1-4 length-percentage values, got ${nodes.length}`);
	}

	// Parse all values
	const values: Type.LengthPercentage[] = [];
	for (const node of nodes) {
		// Handle unitless zero
		if (node.type === "Number") {
			const val = Number.parseFloat(node.value);
			if (val !== 0) {
				return err("Unitless values must be zero");
			}
			values.push({ value: 0, unit: "px" });
			continue;
		}

		// Parse length-percentage
		const result = parseLengthPercentageNode(node);
		if (!result.ok) {
			return err(result.error);
		}
		values.push(result.value);
	}

	// Expand per CSS 4-value syntax
	switch (values.length) {
		case 1:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				top: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				right: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottom: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				left: values[0]!,
			});
		case 2:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				top: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				right: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottom: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				left: values[1]!,
			});
		case 3:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				top: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				right: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottom: values[2]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				left: values[1]!,
			});
		case 4:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				top: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				right: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottom: values[2]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				left: values[3]!,
			});
		default:
			return err("Invalid number of values");
	}
}

/**
 * Parse CSS corner values using TRBL expansion rules.
 *
 * This function parses 1-4 length-percentage values and expands them to
 * all 4 corners using the same expansion logic as CSS box model properties.
 * It is used by clip-path shapes (inset, rect, xywh) for border-radius values
 * after the 'round' keyword.
 *
 * **IMPORTANT**: This is NOT a CSS property parser. It parses multi-value
 * syntax used WITHIN other values. The actual border-radius property parser
 * is in `src/parse/border/radius.ts` and only accepts single values (longhand).
 *
 * Expansion rules (same as margin/padding):
 * - 1 value: all corners
 * - 2 values: (top-left/bottom-right) (top-right/bottom-left)
 * - 3 values: top-left (top-right/bottom-left) bottom-right
 * - 4 values: top-left top-right bottom-right bottom-left (clockwise from top-left)
 *
 * @param nodes - Array of 1-4 CSS nodes (length-percentage values, non-negative)
 * @returns Result with 4 corner values or error
 *
 * @example
 * Used in clip-path shapes:
 * ```typescript
 * // inset(10px round 5px 10px)
 * //                  ^^^^^^^^ these nodes
 * const result = parseCornerValues(radiusNodes);
 * // { topLeft: 5px, topRight: 10px, bottomRight: 5px, bottomLeft: 10px }
 * ```
 *
 * @public
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape/inset | MDN: inset()}
 */
export function parseCornerValues(nodes: csstree.CssNode[]): Result<
	{
		topLeft: Type.LengthPercentage;
		topRight: Type.LengthPercentage;
		bottomRight: Type.LengthPercentage;
		bottomLeft: Type.LengthPercentage;
	},
	string
> {
	// Validate count
	if (nodes.length < 1 || nodes.length > 4) {
		return err(`Expected 1-4 border-radius values, got ${nodes.length}`);
	}

	// Parse all values
	const values: Type.LengthPercentage[] = [];
	for (const node of nodes) {
		// Handle unitless zero
		if (node.type === "Number") {
			const val = Number.parseFloat(node.value);
			if (val !== 0) {
				return err("Unitless values must be zero");
			}
			values.push({ value: 0, unit: "px" });
			continue;
		}

		// Parse length-percentage
		const result = parseLengthPercentageNode(node);
		if (!result.ok) {
			return err(result.error);
		}

		// Validate non-negative
		if (result.value.value < 0) {
			return err("border-radius values must be non-negative");
		}

		values.push(result.value);
	}

	// Expand per CSS 4-value syntax (clockwise from top-left)
	switch (values.length) {
		case 1:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topLeft: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topRight: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomRight: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomLeft: values[0]!,
			});
		case 2:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topLeft: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topRight: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomRight: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomLeft: values[1]!,
			});
		case 3:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topLeft: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topRight: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomRight: values[2]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomLeft: values[1]!,
			});
		case 4:
			return ok({
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topLeft: values[0]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				topRight: values[1]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomRight: values[2]!,
				// biome-ignore lint/style/noNonNullAssertion: length validated by switch
				bottomLeft: values[3]!,
			});
		default:
			return err("Invalid number of values");
	}
}

/**
 * Parse optional 'round <border-radius>' clause from function arguments.
 *
 * Finds 'round' keyword and parses subsequent border-radius values.
 * Used by inset(), rect(), and xywh() shape functions.
 *
 * @param args - Function arguments (may contain 'round' keyword)
 * @returns Result with roundIndex and optional borderRadius
 *
 * @example
 * Basic usage:
 * ```typescript
 * // args = [10px, 20px, 'round', 5px, 10px]
 * const result = parseRoundBorderRadius(args);
 * // { roundIndex: 2, borderRadius: { topLeft: {...}, ... } }
 * ```
 *
 * @example
 * No 'round' keyword:
 * ```typescript
 * // args = [10px, 20px, 30px, 40px]
 * const result = parseRoundBorderRadius(args);
 * // { roundIndex: -1, borderRadius: undefined }
 * ```
 *
 * @example
 * Error case:
 * ```typescript
 * // args = [10px, 'round'] // no radius values!
 * const result = parseRoundBorderRadius(args);
 * // err("Expected border-radius values after 'round' keyword")
 * ```
 *
 * @public
 */
export function parseRoundBorderRadius(args: csstree.CssNode[]): Result<
	{
		roundIndex: number;
		borderRadius?: {
			topLeft: Type.LengthPercentage;
			topRight: Type.LengthPercentage;
			bottomRight: Type.LengthPercentage;
			bottomLeft: Type.LengthPercentage;
		};
	},
	string
> {
	// Find 'round' keyword position
	const roundIndex = args.findIndex((node) => node.type === "Identifier" && node.name.toLowerCase() === "round");

	// No 'round' keyword found - valid case
	if (roundIndex === -1) {
		return ok({ roundIndex: -1 });
	}

	// Get border-radius values (everything after 'round')
	const radiusNodes = args.slice(roundIndex + 1);

	// Must have at least one radius value
	if (radiusNodes.length === 0) {
		return err("Expected border-radius values after 'round' keyword");
	}

	// Parse border-radius using existing utility
	const radiusResult = parseCornerValues(radiusNodes);
	if (!radiusResult.ok) {
		return err(`Invalid border-radius: ${radiusResult.error}`);
	}

	return ok({
		roundIndex,
		borderRadius: radiusResult.value,
	});
}


=== File: src/utils/parse/nodes/index.ts ===
// b_path:: src/utils/parse/nodes/index.ts

/**
 * Node parsing utilities organized by domain.
 *
 * This module exports parsing utilities for CSS AST nodes,
 * organized into focused sub-modules by value type:
 *
 * - **angle**: Angle value parsing (deg, rad, grad, turn)
 * - **border-radius**: TRBL, corner values, and round keyword parsing
 * - **length**: Length, percentage, and length-percentage parsing
 * - **number**: Number and identifier keyword parsing
 * - **position**: 2D position value parsing (x/y coordinates)
 * - **radial**: Radial size parsing for circle/ellipse shapes
 *
 * Each module provides focused utilities for its domain, keeping
 * files small (<320 lines) and maintainable.
 *
 * @module utils/parse/nodes
 */

export * from "./angle";
export * from "./border-radius";
export * from "./length";
export * from "./number";
export * from "./position";
export * from "./radial";


=== File: src/utils/parse/nodes/length.test.ts ===
// b_path:: src/utils/parse/nodes/length.test.ts
import type * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { parseLengthNode, parseLengthPercentageNode, parseNumberNode } from "./length";

describe("parseLengthNode", () => {
	it("parses valid pixel dimension", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "10",
			unit: "px",
		};
		const result = parseLengthNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(10);
			expect(result.value.unit).toBe("px");
		}
	});

	it("parses absolute length units", () => {
		const units = ["px", "cm", "mm", "in", "pt", "pc"];
		for (const unit of units) {
			const node: csstree.Dimension = {
				type: "Dimension",
				loc: undefined,
				value: "10",
				unit,
			};
			const result = parseLengthNode(node);
			expect(result.ok).toBe(true);
		}
	});

	it("parses font-relative length units", () => {
		const units = ["em", "rem", "ex", "ch"];
		for (const unit of units) {
			const node: csstree.Dimension = {
				type: "Dimension",
				loc: undefined,
				value: "2",
				unit,
			};
			const result = parseLengthNode(node);
			expect(result.ok).toBe(true);
		}
	});

	it("parses viewport length units", () => {
		const units = ["vw", "vh", "vmin", "vmax"];
		for (const unit of units) {
			const node: csstree.Dimension = {
				type: "Dimension",
				loc: undefined,
				value: "50",
				unit,
			};
			const result = parseLengthNode(node);
			expect(result.ok).toBe(true);
		}
	});

	it("rejects invalid length unit", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "10",
			unit: "invalid",
		};
		const result = parseLengthNode(node);
		expect(result.ok).toBe(false);
	});

	it("rejects NaN value", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "notanumber",
			unit: "px",
		};
		const result = parseLengthNode(node);
		expect(result.ok).toBe(false);
	});

	it("rejects non-dimension node", () => {
		const node: csstree.Identifier = {
			type: "Identifier",
			loc: undefined,
			name: "auto",
		};
		const result = parseLengthNode(node);
		expect(result.ok).toBe(false);
	});

	it("handles decimal values", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "10.5",
			unit: "px",
		};
		const result = parseLengthNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(10.5);
		}
	});

	it("handles negative values", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "-10",
			unit: "px",
		};
		const result = parseLengthNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(-10);
		}
	});
});

describe("parseLengthPercentageNode", () => {
	it("parses length dimension", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "10",
			unit: "px",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(10);
			expect(result.value.unit).toBe("px");
		}
	});

	it("parses percentage", () => {
		const node: csstree.Percentage = {
			type: "Percentage",
			loc: undefined,
			value: "50",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(50);
			expect(result.value.unit).toBe("%");
		}
	});

	it("parses unitless zero", () => {
		const node: csstree.NumberNode = {
			type: "Number",
			loc: undefined,
			value: "0",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(0);
			expect(result.value.unit).toBe("px");
		}
	});

	it("rejects unitless non-zero", () => {
		const node: csstree.NumberNode = {
			type: "Number",
			loc: undefined,
			value: "10",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(false);
	});

	it("rejects invalid length unit", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "10",
			unit: "invalid",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(false);
	});

	it("rejects NaN length value", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "notanumber",
			unit: "px",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(false);
	});

	it("rejects NaN percentage value", () => {
		const node: csstree.Percentage = {
			type: "Percentage",
			loc: undefined,
			value: "notanumber",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(false);
	});

	it("rejects unsupported node type", () => {
		const node: csstree.Identifier = {
			type: "Identifier",
			loc: undefined,
			name: "auto",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(false);
	});

	it("handles negative length", () => {
		const node: csstree.Dimension = {
			type: "Dimension",
			loc: undefined,
			value: "-10",
			unit: "px",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(-10);
		}
	});

	it("handles negative percentage", () => {
		const node: csstree.Percentage = {
			type: "Percentage",
			loc: undefined,
			value: "-50",
		};
		const result = parseLengthPercentageNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe(-50);
		}
	});
});

describe("parseNumberNode", () => {
	it("parses valid number", () => {
		const node: csstree.NumberNode = {
			type: "Number",
			loc: undefined,
			value: "10",
		};
		const result = parseNumberNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe(10);
		}
	});

	it("parses decimal number", () => {
		const node: csstree.NumberNode = {
			type: "Number",
			loc: undefined,
			value: "10.5",
		};
		const result = parseNumberNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe(10.5);
		}
	});

	it("parses negative number", () => {
		const node: csstree.NumberNode = {
			type: "Number",
			loc: undefined,
			value: "-10",
		};
		const result = parseNumberNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe(-10);
		}
	});

	it("parses zero", () => {
		const node: csstree.NumberNode = {
			type: "Number",
			loc: undefined,
			value: "0",
		};
		const result = parseNumberNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe(0);
		}
	});

	it("rejects NaN value", () => {
		const node: csstree.NumberNode = {
			type: "Number",
			loc: undefined,
			value: "notanumber",
		};
		const result = parseNumberNode(node);
		expect(result.ok).toBe(false);
	});

	it("rejects non-number node", () => {
		const node: csstree.Identifier = {
			type: "Identifier",
			loc: undefined,
			name: "auto",
		};
		const result = parseNumberNode(node);
		expect(result.ok).toBe(false);
	});
});


=== File: src/utils/parse/nodes/length.ts ===
// b_path:: src/utils/parse/nodes/length.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import * as Unit from "@/core/units";

/**
 * Length and percentage value parsing utilities.
 *
 * This module handles:
 * - CSS length values (px, em, rem, vh, vw, etc.)
 * - Percentage values
 * - Unitless zero
 * - LengthPercentage union types
 * - Numeric values
 *
 * @module utils/parse/nodes/length
 */

/**
 * Parse a CSS dimension node into a Length IR.
 *
 * Handles all CSS length units using core unit definitions.
 * Replaces hardcoded unit arrays with centralized core units.
 *
 * @param node - CSS AST dimension node
 * @returns Result containing Length IR or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import { parseLengthNode } from "@/utils/parse/nodes/length";
 *
 * const result = parseLengthNode(dimensionNode);
 * if (result.ok) {
 *   console.log(result.value); // { value: 100, unit: "px" }
 * }
 * ```
 */
export function parseLengthNode(node: csstree.CssNode): Result<Type.Length, string> {
	if (node.type === "Dimension") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid length value");
		}

		// Use core unit validation
		const allLengthUnits = [...Unit.ABSOLUTE_LENGTH_UNITS, ...Unit.FONT_LENGTH_UNITS, ...Unit.VIEWPORT_LENGTH_UNITS];

		if (!allLengthUnits.includes(node.unit as (typeof allLengthUnits)[number])) {
			return err(`Invalid length unit: ${node.unit}`);
		}

		return ok({
			value,
			unit: node.unit as (typeof allLengthUnits)[number],
		});
	}
	return err("Expected length dimension");
}

/**
 * Parse a CSS dimension or percentage node into a LengthPercentage IR.
 *
 * Handles both length units and percentage values using core definitions.
 *
 * @param node - CSS AST node (dimension or percentage)
 * @returns Result containing LengthPercentage IR or error message
 *
 * @public
 */
export function parseLengthPercentageNode(node: csstree.CssNode): Result<Type.LengthPercentage, string> {
	// Handle unitless zero
	if (node.type === "Number") {
		const val = Number.parseFloat(node.value);
		if (val !== 0) {
			return err("Unitless values must be zero");
		}
		return ok({ value: 0, unit: "px" });
	}

	if (node.type === "Dimension") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid length value");
		}

		// Use core unit validation for length units
		const allLengthUnits = [...Unit.ABSOLUTE_LENGTH_UNITS, ...Unit.FONT_LENGTH_UNITS, ...Unit.VIEWPORT_LENGTH_UNITS];

		if (!allLengthUnits.includes(node.unit as (typeof allLengthUnits)[number])) {
			return err(`Invalid length unit: ${node.unit}`);
		}

		return ok({
			value,
			unit: node.unit as (typeof allLengthUnits)[number],
		});
	}

	if (node.type === "Percentage") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid percentage value");
		}
		return ok({ value, unit: Unit.PERCENTAGE_UNIT });
	}

	return err("Expected length or percentage");
}

/**
 * Parse a CSS number node into a number.
 *
 * @param node - CSS AST number node
 * @returns Result containing number or error message
 *
 * @public
 */
export function parseNumberNode(node: csstree.CssNode): Result<number, string> {
	if (node.type === "Number") {
		const value = Number.parseFloat(node.value);
		if (Number.isNaN(value)) {
			return err("Invalid number value");
		}
		return ok(value);
	}
	return err("Expected number");
}


=== File: src/utils/parse/nodes/number.test.ts ===
// b_path:: src/utils/parse/nodes/number.test.ts
import { describe, expect, it } from "vitest";
import { parseIdentifierNode } from "./number";

describe("parseIdentifierNode", () => {
	it("parses identifier node", () => {
		const node = { type: "Identifier" as const, name: "MyValue" };
		const result = parseIdentifierNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("myvalue");
		}
	});

	it("converts to lowercase", () => {
		const node = { type: "Identifier" as const, name: "CamelCase" };
		const result = parseIdentifierNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("camelcase");
		}
	});

	it("handles simple identifier", () => {
		const node = { type: "Identifier" as const, name: "auto" };
		const result = parseIdentifierNode(node);
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value).toBe("auto");
		}
	});

	it("rejects non-identifier node", () => {
		const node = { type: "Number" as const, value: "123" };
		const result = parseIdentifierNode(node);
		expect(result.ok).toBe(false);
		if (!result.ok) {
			expect(result.error).toContain("Expected identifier");
		}
	});

	it("rejects string node", () => {
		const node = { type: "String" as const, value: "test" };
		const result = parseIdentifierNode(node);
		expect(result.ok).toBe(false);
	});
});


=== File: src/utils/parse/nodes/number.ts ===
// b_path:: src/utils/parse/nodes/number.ts
/**
 * Number and identifier parsing utilities.
 *
 * This module handles:
 * - CSS identifier nodes
 * - Keyword extraction
 * - String values
 *
 * @module utils/parse/nodes/number
 */

// b_path:: src/utils/parse/nodes/number.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";

/**
 * Parse a CSS identifier node into a string.
 *
 * @param node - CSS AST identifier node
 * @returns Result containing string or error message
 *
 * @public
 */
export function parseIdentifierNode(node: csstree.CssNode): Result<string, string> {
	if (node.type === "Identifier") {
		return ok(node.name.toLowerCase());
	}
	return err("Expected identifier");
}


=== File: src/utils/parse/nodes/position.test.ts ===
// b_path:: src/utils/parse/nodes/position.test.ts
import type * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { parseAtPosition, parsePosition2D, parsePositionValueNode } from "./position";

describe("parsePositionValueNode", () => {
	const createIdentifier = (name: string): csstree.Identifier => ({
		type: "Identifier",
		loc: undefined,
		name,
	});

	const createDimension = (value: string, unit: string): csstree.Dimension => ({
		type: "Dimension",
		loc: undefined,
		value,
		unit,
	});

	const createPercentage = (value: string): csstree.Percentage => ({
		type: "Percentage",
		loc: undefined,
		value,
	});

	describe("keywords", () => {
		it("parses center keyword", () => {
			const node = createIdentifier("center");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("center");
			}
		});

		it("parses left keyword", () => {
			const node = createIdentifier("left");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("left");
			}
		});

		it("parses right keyword", () => {
			const node = createIdentifier("right");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("right");
			}
		});

		it("parses top keyword", () => {
			const node = createIdentifier("top");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("top");
			}
		});

		it("parses bottom keyword", () => {
			const node = createIdentifier("bottom");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("bottom");
			}
		});

		it("handles case-insensitive keywords", () => {
			const node = createIdentifier("CENTER");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(true);
		});

		it("rejects invalid keyword", () => {
			const node = createIdentifier("invalid");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(false);
		});
	});

	describe("length values", () => {
		it("parses length dimension", () => {
			const node = createDimension("10", "px");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(10);
				expect(result.value.unit).toBe("px");
			}
		});

		it("parses percentage", () => {
			const node = createPercentage("50");
			const result = parsePositionValueNode(node);
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(50);
				expect(result.value.unit).toBe("%");
			}
		});
	});
});

describe("parsePosition2D", () => {
	const createIdentifier = (name: string): csstree.Identifier => ({
		type: "Identifier",
		loc: undefined,
		name,
	});

	const createDimension = (value: string, unit: string): csstree.Dimension => ({
		type: "Dimension",
		loc: undefined,
		value,
		unit,
	});

	const createPercentage = (value: string): csstree.Percentage => ({
		type: "Percentage",
		loc: undefined,
		value,
	});

	describe("single value", () => {
		it("defaults horizontal keyword to vertical center", () => {
			const nodes = [createIdentifier("left")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position.horizontal).toBe("left");
				expect(result.value.position.vertical).toBe("center");
				expect(result.value.nextIdx).toBe(1);
			}
		});

		it("defaults vertical keyword to horizontal center", () => {
			const nodes = [createIdentifier("top")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position.horizontal).toBe("center");
				expect(result.value.position.vertical).toBe("top");
				expect(result.value.nextIdx).toBe(1);
			}
		});

		it("handles bottom keyword", () => {
			const nodes = [createIdentifier("bottom")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position.vertical).toBe("bottom");
			}
		});

		it("defaults length value to horizontal", () => {
			const nodes = [createDimension("10", "px")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position.vertical).toBe("center");
			}
		});

		it("defaults center to horizontal center", () => {
			const nodes = [createIdentifier("center")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position.horizontal).toBe("center");
				expect(result.value.position.vertical).toBe("center");
			}
		});
	});

	describe("two values", () => {
		it("parses horizontal and vertical keywords", () => {
			const nodes = [createIdentifier("left"), createIdentifier("top")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position.horizontal).toBe("left");
				expect(result.value.position.vertical).toBe("top");
				expect(result.value.nextIdx).toBe(2);
			}
		});

		it("parses length values", () => {
			const nodes = [createDimension("10", "px"), createDimension("20", "px")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				const h = result.value.position.horizontal;
				const v = result.value.position.vertical;
				if (typeof h === "object" && typeof v === "object") {
					expect(h.value).toBe(10);
					expect(v.value).toBe(20);
				}
			}
		});

		it("parses mixed keyword and length", () => {
			const nodes = [createIdentifier("center"), createDimension("20", "px")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
		});

		it("parses percentages", () => {
			const nodes = [createPercentage("50"), createPercentage("75")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
		});
	});

	describe("start index", () => {
		it("parses from non-zero start index", () => {
			const nodes = [createIdentifier("invalid"), createIdentifier("center"), createIdentifier("top")];
			const result = parsePosition2D(nodes, 1);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position.horizontal).toBe("center");
				expect(result.value.position.vertical).toBe("top");
				expect(result.value.nextIdx).toBe(3);
			}
		});
	});

	describe("validation", () => {
		it("rejects empty array", () => {
			const result = parsePosition2D([], 0);
			expect(result.ok).toBe(false);
		});

		it("rejects out-of-bounds start index", () => {
			const nodes = [createIdentifier("center")];
			const result = parsePosition2D(nodes, 5);
			expect(result.ok).toBe(false);
		});

		it("stops parsing after 2 values", () => {
			const nodes = [createIdentifier("left"), createIdentifier("top"), createIdentifier("center")];
			const result = parsePosition2D(nodes, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.nextIdx).toBe(2);
			}
		});
	});
});

describe("parseAtPosition", () => {
	const createIdentifier = (name: string): csstree.Identifier => ({
		type: "Identifier",
		loc: undefined,
		name,
	});

	const createDimension = (value: string, unit: string): csstree.Dimension => ({
		type: "Dimension",
		loc: undefined,
		value,
		unit,
	});

	describe("no 'at' keyword", () => {
		it("returns no position when 'at' not found", () => {
			const children = [createDimension("50", "px"), createDimension("100", "px")];
			const result = parseAtPosition(children, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position).toBeUndefined();
				expect(result.value.nextIdx).toBe(0);
			}
		});

		it("handles empty array", () => {
			const result = parseAtPosition([], 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position).toBeUndefined();
				expect(result.value.nextIdx).toBe(0);
			}
		});

		it("handles out-of-bounds start index", () => {
			const children = [createIdentifier("center")];
			const result = parseAtPosition(children, 5);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position).toBeUndefined();
			}
		});
	});

	describe("with 'at' keyword", () => {
		it("parses position after 'at'", () => {
			const children = [createIdentifier("at"), createIdentifier("center"), createIdentifier("top")];
			const result = parseAtPosition(children, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position).toBeDefined();
				expect(result.value.position?.horizontal).toBe("center");
				expect(result.value.position?.vertical).toBe("top");
				expect(result.value.nextIdx).toBe(3);
			}
		});

		it("handles case-insensitive 'at'", () => {
			const children = [createIdentifier("AT"), createIdentifier("center")];
			const result = parseAtPosition(children, 0);
			expect(result.ok).toBe(true);
		});

		it("parses 'at' from non-zero index", () => {
			const children = [createDimension("50", "px"), createIdentifier("at"), createIdentifier("left")];
			const result = parseAtPosition(children, 1);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position).toBeDefined();
				expect(result.value.nextIdx).toBe(3);
			}
		});

		it("parses single position value after 'at'", () => {
			const children = [createIdentifier("at"), createIdentifier("center")];
			const result = parseAtPosition(children, 0);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position).toBeDefined();
			}
		});

		it("parses length values after 'at'", () => {
			const children = [createIdentifier("at"), createDimension("10", "px"), createDimension("20", "px")];
			const result = parseAtPosition(children, 0);
			expect(result.ok).toBe(true);
		});
	});

	describe("validation", () => {
		it("rejects 'at' without position", () => {
			const children = [createIdentifier("at")];
			const result = parseAtPosition(children, 0);
			expect(result.ok).toBe(false);
		});

		it("rejects 'at' at end of array", () => {
			const children = [createDimension("50", "px"), createIdentifier("at")];
			const result = parseAtPosition(children, 1);
			expect(result.ok).toBe(false);
		});
	});
});


=== File: src/utils/parse/nodes/position.ts ===
// b_path:: src/utils/parse/nodes/position.ts
/**
 * Position value parsing utilities.
 *
 * This module handles:
 * - CSS position values (background-position, object-position, etc.)
 * - 2D position parsing (x, y coordinates)
 * - Position keywords (top, bottom, left, right, center)
 * - "at" keyword position parsing (for clip-path, gradients)
 *
 * @module utils/parse/nodes/position
 */

// b_path:: src/utils/parse/nodes/position.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseLengthPercentageNode } from "./length";

/**
 * Parse a CSS value node into a PositionValue IR.
 *
 * Handles keywords, lengths, and percentages for position values.
 *
 * @param node - CSS AST node
 * @returns Result containing PositionValue IR or error message
 *
 * @public
 */
export function parsePositionValueNode(node: csstree.CssNode): Result<Type.PositionValue, string> {
	// Check for keyword first
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();
		// Position keywords
		if (["center", "left", "right", "top", "bottom"].includes(keyword)) {
			return ok(keyword as Type.PositionValue);
		}
		return err(`Invalid position keyword: ${keyword}`);
	}

	// Try parsing as length-percentage
	const lengthResult = parseLengthPercentageNode(node);
	if (lengthResult.ok) {
		return lengthResult;
	}

	return err("Expected position keyword, length, or percentage");
}

/**
 * Parse 2D position from CSS nodes.
 *
 * Handles CSS position syntax with 1-2 values.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @returns Result containing Position2D IR and next index, or error message
 *
 * @example
 * ```typescript
 * // Parse "center top"
 * const result = parsePosition2D([centerNode, topNode], 0);
 * // { position: { horizontal: "center", vertical: "top" }, nextIdx: 2 }
 * ```
 *
 * @public
 */
export function parsePosition2D(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	const positionValues: Type.PositionValue[] = [];

	if (idx >= nodes.length) {
		return err("Expected position value");
	}

	const firstNode = nodes[idx];
	if (!firstNode) return err("Missing first position value");
	const firstValue = parsePositionValueNode(firstNode);
	if (!firstValue.ok) {
		return err(`Invalid first position value: ${firstValue.error}`);
	}
	positionValues.push(firstValue.value);
	idx++;

	if (idx < nodes.length) {
		const secondNode = nodes[idx];
		if (secondNode) {
			const secondValue = parsePositionValueNode(secondNode);
			if (secondValue.ok) {
				positionValues.push(secondValue.value);
				idx++;
			}
		}
	}

	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Missing position value");
		}
		if (typeof val === "string") {
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Missing position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse optional position prefixed by 'at' keyword.
 *
 * Used by circle(), ellipse(), radial-gradient(), etc.
 *
 * Handles:
 * - No 'at' keyword: Returns { nextIdx } (no position parsed)
 * - 'at' keyword present: Parses following position, returns { position, nextIdx }
 * - 'at' without position: Error
 *
 * @param children - Array of CSS nodes
 * @param startIdx - Index to start parsing (should point at potential 'at' keyword)
 * @returns Result with optional position and nextIdx, or error
 *
 * @example
 * No 'at' keyword:
 * ```typescript
 * // children = [50px, 100px] // no 'at' keyword
 * const result = parseAtPosition(children, 0);
 * // ok({ nextIdx: 0 }) - no position parsed
 * ```
 *
 * @example
 * With 'at' and position:
 * ```typescript
 * // children = ['at', 'center', 'top']
 * const result = parseAtPosition(children, 0);
 * // ok({ position: { horizontal: "center", vertical: "top" }, nextIdx: 3 })
 * ```
 *
 * @example
 * Error case:
 * ```typescript
 * // children = [50px, 'at'] // no position values!
 * const result = parseAtPosition(children, 1);
 * // err("Expected position after 'at'")
 * ```
 *
 * @public
 */
export function parseAtPosition(
	children: csstree.CssNode[],
	startIdx: number,
): Result<{ position?: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Check if we have an 'at' keyword at current position
	if (idx >= children.length) {
		return ok({ nextIdx: idx });
	}

	const atNode = children[idx];
	if (atNode?.type !== "Identifier" || atNode.name.toLowerCase() !== "at") {
		// No 'at' keyword - valid case (position is optional)
		return ok({ nextIdx: idx });
	}

	// Found 'at' keyword - advance past it
	idx++;

	// Must have position values after 'at'
	const positionNodes = children.slice(idx);
	if (positionNodes.length === 0) {
		return err("Expected position after 'at'");
	}

	// Parse position using existing utility
	const posResult = parsePosition2D(positionNodes, 0);
	if (!posResult.ok) return posResult;

	return ok({
		position: posResult.value.position,
		nextIdx: idx + posResult.value.nextIdx,
	});
}


=== File: src/utils/parse/nodes/radial.test.ts ===
// b_path:: src/utils/parse/nodes/radial.test.ts
import type * as csstree from "css-tree";
import { describe, expect, it } from "vitest";
import { parseRadialSize } from "./radial";

describe("parseRadialSize", () => {
	const createIdentifier = (name: string): csstree.Identifier => ({
		type: "Identifier",
		loc: undefined,
		name,
	});

	const createDimension = (value: string, unit: string): csstree.Dimension => ({
		type: "Dimension",
		loc: undefined,
		value,
		unit,
	});

	const createPercentage = (value: string): csstree.Percentage => ({
		type: "Percentage",
		loc: undefined,
		value,
	});

	describe("undefined node", () => {
		it("returns undefined for no node", () => {
			const result = parseRadialSize(undefined, "radius");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBeUndefined();
			}
		});
	});

	describe("radial extent keywords", () => {
		it("parses 'closest-side' keyword", () => {
			const node = createIdentifier("closest-side");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("closest-side");
			}
		});

		it("parses 'farthest-side' keyword", () => {
			const node = createIdentifier("farthest-side");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("farthest-side");
			}
		});

		it("handles case-insensitive keywords", () => {
			const node = createIdentifier("CLOSEST-SIDE");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBe("closest-side");
			}
		});

		it("rejects invalid keyword", () => {
			const node = createIdentifier("invalid");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("Invalid keyword for radius: invalid");
			}
		});
	});

	describe("'at' keyword handling", () => {
		it("rejects 'at' when allowAtKeyword is false", () => {
			const node = createIdentifier("at");
			const result = parseRadialSize(node, "radius", false);
			expect(result.ok).toBe(false);
		});

		it("returns undefined for 'at' when allowAtKeyword is true", () => {
			const node = createIdentifier("at");
			const result = parseRadialSize(node, "radiusX", true);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBeUndefined();
			}
		});

		it("handles case-insensitive 'at' with allowAtKeyword", () => {
			const node = createIdentifier("AT");
			const result = parseRadialSize(node, "radiusX", true);
			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value).toBeUndefined();
			}
		});
	});

	describe("length-percentage values", () => {
		it("parses pixel dimension", () => {
			const node = createDimension("50", "px");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(50);
				expect(result.value.unit).toBe("px");
			}
		});

		it("parses percentage value", () => {
			const node = createPercentage("75");
			const result = parseRadialSize(node, "radiusY");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(75);
				expect(result.value.unit).toBe("%");
			}
		});

		it("parses em dimension", () => {
			const node = createDimension("5", "em");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(5);
				expect(result.value.unit).toBe("em");
			}
		});

		it("parses rem dimension", () => {
			const node = createDimension("3", "rem");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(3);
				expect(result.value.unit).toBe("rem");
			}
		});

		it("parses viewport units", () => {
			const node = createDimension("50", "vw");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(50);
				expect(result.value.unit).toBe("vw");
			}
		});

		it("parses zero value", () => {
			const node = createDimension("0", "px");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(0);
			}
		});

		it("parses decimal values", () => {
			const node = createDimension("10.5", "px");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(10.5);
			}
		});
	});

	describe("non-negative validation", () => {
		it("rejects negative pixel value", () => {
			const node = createDimension("-10", "px");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("radius must be non-negative");
			}
		});

		it("rejects negative percentage", () => {
			const node = createPercentage("-50");
			const result = parseRadialSize(node, "radiusX");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("radiusX must be non-negative");
			}
		});

		it("includes property name in error message", () => {
			const node = createDimension("-5", "em");
			const result = parseRadialSize(node, "radiusY");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("radiusY");
			}
		});
	});

	describe("property name in errors", () => {
		it("uses property name for invalid keyword error", () => {
			const node = createIdentifier("invalid");
			const result = parseRadialSize(node, "customRadius");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("customRadius");
			}
		});

		it("uses property name for negative value error", () => {
			const node = createDimension("-10", "px");
			const result = parseRadialSize(node, "myRadius");
			expect(result.ok).toBe(false);
			if (!result.ok) {
				expect(result.error).toContain("myRadius");
			}
		});
	});

	describe("edge cases", () => {
		it("handles very large values", () => {
			const node = createDimension("99999", "px");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(99999);
			}
		});

		it("handles very small decimal values", () => {
			const node = createDimension("0.001", "px");
			const result = parseRadialSize(node, "radius");
			expect(result.ok).toBe(true);
			if (result.ok && typeof result.value === "object") {
				expect(result.value.value).toBe(0.001);
			}
		});
	});
});


=== File: src/utils/parse/nodes/radial.ts ===
// b_path:: src/utils/parse/nodes/radial.ts
import type * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type * as Type from "@/core/types";
import { parseLengthPercentageNode } from "./length";

/**
 * Parse radial size value (keyword or length-percentage).
 *
 * Handles both radial extent keywords (closest-side, farthest-side)
 * and numeric length-percentage values. Validates non-negative values.
 *
 * Used by circle() and ellipse() shape functions for radius values.
 *
 * @param node - AST node to parse (may be undefined)
 * @param propertyName - Name for error messages (e.g., "radius", "radiusX")
 * @param allowAtKeyword - If true, 'at' keyword returns undefined (not error)
 * @returns Result with parsed size value or undefined if node is undefined or 'at'
 *
 * @example
 * With keyword:
 * ```typescript
 * // node = Identifier { name: "closest-side" }
 * const result = parseRadialSize(node, "radius");
 * // ok("closest-side")
 * ```
 *
 * @example
 * With length-percentage:
 * ```typescript
 * // node = Dimension { value: 50, unit: "px" }
 * const result = parseRadialSize(node, "radiusX");
 * // ok({ value: 50, unit: "px" })
 * ```
 *
 * @example
 * No node (undefined):
 * ```typescript
 * const result = parseRadialSize(undefined, "radius");
 * // ok(undefined)
 * ```
 *
 * @example
 * 'at' keyword with allowAtKeyword=true:
 * ```typescript
 * // node = Identifier { name: "at" }
 * const result = parseRadialSize(node, "radiusX", true);
 * // ok(undefined) - signals to stop radius parsing
 * ```
 *
 * @example
 * Error - negative value:
 * ```typescript
 * // node = Dimension { value: -10, unit: "px" }
 * const result = parseRadialSize(node, "radius");
 * // err("radius must be non-negative")
 * ```
 *
 * @example
 * Error - invalid keyword:
 * ```typescript
 * // node = Identifier { name: "invalid" }
 * const result = parseRadialSize(node, "radius");
 * // err("Invalid keyword for radius: invalid")
 * ```
 *
 * @public
 */
export function parseRadialSize(
	node: csstree.CssNode | undefined,
	propertyName: string,
	allowAtKeyword = false,
): Result<"closest-side" | "farthest-side" | Type.LengthPercentage | undefined, string> {
	// No node provided - valid case
	if (!node) {
		return ok(undefined);
	}

	// Check for radial extent keywords
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();

		// Valid radial extent keywords
		if (keyword === "closest-side" || keyword === "farthest-side") {
			return ok(keyword);
		}

		// 'at' keyword handling (for ellipse - signals end of radius parsing)
		if (keyword === "at" && allowAtKeyword) {
			return ok(undefined);
		}

		// Invalid keyword
		return err(`Invalid keyword for ${propertyName}: ${keyword}`);
	}

	// Try parsing as length-percentage
	const lpResult = parseLengthPercentageNode(node);
	if (!lpResult.ok) {
		return lpResult;
	}

	// Validate non-negative
	if (lpResult.value.value < 0) {
		return err(`${propertyName} must be non-negative`);
	}

	return ok(lpResult.value);
}


=== File: src/utils/parse/url.test.ts ===
// b_path:: src/utils/parse/url.test.ts

import { describe, expect, it } from "vitest";
import { parseUrl } from "./url";

describe("parseUrl", () => {
	it("parses fragment identifier", () => {
		const result = parseUrl("url(#clip-shape)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.kind).toBe("url");
			expect(result.value.value).toBe("#clip-shape");
		}
	});

	it("parses quoted URL", () => {
		const result = parseUrl("url('shapes.svg#clip')");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("shapes.svg#clip");
		}
	});

	it("parses double-quoted URL", () => {
		const result = parseUrl('url("image.png")');
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("image.png");
		}
	});

	it("parses unquoted URL", () => {
		const result = parseUrl("url(path/to/file.svg)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("path/to/file.svg");
		}
	});

	it("parses absolute URL", () => {
		const result = parseUrl("url(https://example.com/image.png)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("https://example.com/image.png");
		}
	});

	it("parses data URL", () => {
		const result = parseUrl("url(data:image/svg+xml,...)");
		expect(result.ok).toBe(true);
		if (result.ok) {
			expect(result.value.value).toBe("data:image/svg+xml,...");
		}
	});

	it("rejects invalid syntax", () => {
		const result = parseUrl("not-a-url");
		expect(result.ok).toBe(false);
	});

	it("rejects empty string", () => {
		const result = parseUrl("");
		expect(result.ok).toBe(false);
	});

	it("rejects missing url function", () => {
		const result = parseUrl("#clip");
		expect(result.ok).toBe(false);
	});
});


=== File: src/utils/parse/url.ts ===
// b_path:: src/utils/parse/url.ts

import * as csstree from "css-tree";
import { err, ok, type Result } from "@/core/result";
import type { Url } from "@/core/types/url";
import * as ASTUtils from "@/utils/ast";

/**
 * Parse CSS url() function.
 *
 * Shared utility for parsing URL references across different CSS properties.
 * Handles quoted and unquoted URLs, fragment identifiers, file paths, etc.
 *
 * @param input - CSS string like "url(#id)" or "url('path.svg')"
 * @returns Result with Url IR or error message
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/url_function}
 *
 * @example
 * ```typescript
 * import { parseUrl } from "@/utils/parse/url";
 *
 * const result = parseUrl("url(#clip-shape)");
 * // { ok: true, value: { kind: "url", value: "#clip-shape" } }
 *
 * const result2 = parseUrl("url('shapes.svg#clip')");
 * // { ok: true, value: { kind: "url", value: "shapes.svg#clip" } }
 * ```
 *
 * @public
 */
export function parseUrl(input: string): Result<Url, string> {
	const astResult = ASTUtils.parseCssString(input, "value");
	if (!astResult.ok) {
		return err(astResult.error);
	}

	const ast = astResult.value;
	let foundUrl = "";

	csstree.walk(ast, {
		visit: "Url",
		enter(node: csstree.Url) {
			foundUrl = node.value;
			return false;
		},
	});

	if (foundUrl === "") {
		return err("Expected url() function");
	}

	return ok({ kind: "url", value: foundUrl });
}


