Excluding patterns: 
Documentation for LLMs
Excluding patterns: 
Excluding patterns: -not -path */__pycache__/* -not -path */.venv/* -not -path */.next/* -not -path */venv/* -not -path */node_modules/* -not -path */build/* -not -path */dist/* -not -path */.git/* -not -path */.idea/* -not -path */.vscode/*
=== File: src/core/index.ts ===
// b_path:: src/core/index.ts

export * as Keyword from "./keywords";
export * from "./result";
export * as Type from "./types";
export * as Unit from "./units";


=== File: src/core/keywords/align-content-keywords.ts ===
// b_path:: src/core/keywords/align-content-keywords.ts
import { z } from "zod";

/**
 * CSS `align-content` property keyword values.
 *
 * The align-content property sets the distribution of space between and around
 * content items along a flexbox's cross-axis or a grid's block axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-content}
 *
 * @example
 * ```typescript
 * import { alignContentKeywordsSchema } from "../keywords/align-content-keywords";
 *
 * const keyword = alignContentKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const alignContentKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items packed at start of cross axis"),
		z.literal("flex-end").describe("items packed at end of cross axis"),
		z.literal("center").describe("items centered along cross axis"),
		z.literal("space-between").describe("items evenly distributed, first/last at edges"),
		z.literal("space-around").describe("items evenly distributed with equal space around"),
		z.literal("space-evenly").describe("items evenly distributed with equal space between"),
		z.literal("stretch").describe("items stretched to fill container"),
		z.literal("start").describe("items packed at start of writing mode direction"),
		z.literal("end").describe("items packed at end of writing mode direction"),
	])
	.describe("CSS align-content property keyword values");

/**
 * Array of all align-content keyword values.
 *
 * @public
 */
export const ALIGN_CONTENT_KEYWORDS = alignContentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-content keywords.
 *
 * @public
 */
export type AlignContentKeyword = z.infer<typeof alignContentKeywordsSchema>;

/**
 * Metadata for align-content keyword options.
 *
 * @public
 */
export const alignContentKeywordOptions = alignContentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-content keyword options metadata.
 *
 * @public
 */
export type AlignContentKeywordOptions = typeof alignContentKeywordOptions;


=== File: src/core/keywords/align-items-keywords.ts ===
// b_path:: src/core/keywords/align-items-keywords.ts
import { z } from "zod";

/**
 * CSS `align-items` property keyword values.
 *
 * The align-items property sets the align-self value on all direct children as a group.
 * In flexbox, it controls the alignment of items on the cross axis. In grid layout,
 * it controls the alignment of items on the block axis within their grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-items}
 *
 * @example
 * ```typescript
 * import { alignItemsKeywordsSchema } from "../keywords/align-items-keywords";
 *
 * const keyword = alignItemsKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const alignItemsKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items aligned at start of cross axis"),
		z.literal("flex-end").describe("items aligned at end of cross axis"),
		z.literal("center").describe("items centered along cross axis"),
		z.literal("baseline").describe("items aligned along their baselines"),
		z.literal("stretch").describe("items stretched to fill container"),
		z.literal("start").describe("items aligned at start of writing mode direction"),
		z.literal("end").describe("items aligned at end of writing mode direction"),
		z.literal("self-start").describe("items aligned at start of their own writing mode"),
		z.literal("self-end").describe("items aligned at end of their own writing mode"),
	])
	.describe("CSS align-items property keyword values");

/**
 * Array of all align-items keyword values.
 *
 * @public
 */
export const ALIGN_ITEMS_KEYWORDS = alignItemsKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-items keywords.
 *
 * @public
 */
export type AlignItemsKeyword = z.infer<typeof alignItemsKeywordsSchema>;

/**
 * Metadata for align-items keyword options.
 *
 * @public
 */
export const alignItemsKeywordOptions = alignItemsKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-items keyword options metadata.
 *
 * @public
 */
export type AlignItemsKeywordOptions = typeof alignItemsKeywordOptions;


=== File: src/core/keywords/align-self-keywords.ts ===
// b_path:: src/core/keywords/align-self-keywords.ts
import { z } from "zod";

/**
 * CSS `align-self` property keyword values.
 *
 * The align-self property overrides a grid or flex item's align-items value.
 * In grid layout, it aligns the item inside the grid area on the block axis (vertical).
 * In flexbox, it aligns the item on the cross axis.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/align-self}
 *
 * @example
 * ```typescript
 * import { alignSelfKeywordsSchema } from "../keywords/align-self-keywords";
 *
 * const keyword = alignSelfKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const alignSelfKeywordsSchema = z
	.union([
		z.literal("auto").describe("uses parent's align-items value"),
		z.literal("start").describe("item aligned at start of writing mode direction"),
		z.literal("end").describe("item aligned at end of writing mode direction"),
		z.literal("center").describe("item centered along block axis"),
		z.literal("stretch").describe("item stretched to fill container"),
		z.literal("baseline").describe("item aligned along its baseline"),
		z.literal("flex-start").describe("item aligned at start of flex direction"),
		z.literal("flex-end").describe("item aligned at end of flex direction"),
		z.literal("self-start").describe("item aligned at start of its own writing mode"),
		z.literal("self-end").describe("item aligned at end of its own writing mode"),
	])
	.describe("CSS align-self property keyword values");

/**
 * Array of all align-self keyword values.
 *
 * @public
 */
export const ALIGN_SELF_KEYWORDS = alignSelfKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for align-self keywords.
 *
 * @public
 */
export type AlignSelfKeyword = z.infer<typeof alignSelfKeywordsSchema>;

/**
 * Metadata for align-self keyword options.
 *
 * @public
 */
export const alignSelfKeywordOptions = alignSelfKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for align-self keyword options metadata.
 *
 * @public
 */
export type AlignSelfKeywordOptions = typeof alignSelfKeywordOptions;


=== File: src/core/keywords/auto-keyword.ts ===
// b_path:: src/core/keywords/auto-keyword.ts
import { z } from "zod";

/**
 * CSS `auto` keyword.
 *
 * The `auto` keyword is used across many CSS properties to indicate
 * automatic calculation or default behavior. Context determines exact meaning.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/auto}
 *
 * @example
 * ```typescript
 * import { autoKeywordSchema } from "../keywords/auto-keyword";
 *
 * // Parse and validate
 * const keyword = autoKeywordSchema.parse("auto"); // "auto"
 *
 * // Use in property values
 * const width = "auto";
 * ```
 *
 * @public
 */
export const autoKeywordSchema = z.literal("auto").describe("automatic calculation or default behavior");

/**
 * TypeScript type for the `auto` keyword.
 *
 * @public
 */
export type AutoKeyword = z.infer<typeof autoKeywordSchema>;

/**
 * Constant for the `auto` keyword value.
 *
 * @example
 * ```typescript
 * import { AUTO_KEYWORD } from "../keywords/auto-keyword";
 *
 * if (value === AUTO_KEYWORD) {
 *   // Handle auto value
 * }
 * ```
 *
 * @public
 */
export const AUTO_KEYWORD = "auto" as const;

/**
 * Metadata for the `auto` keyword.
 *
 * Provides description for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { autoKeywordMetadata } from "../keywords/auto-keyword";
 *
 * // Display in UI
 * <Option value="auto" description={autoKeywordMetadata.description} />
 * ```
 *
 * @public
 */
export const autoKeywordMetadata = {
	value: "auto",
	description: "automatic calculation or default behavior",
} as const;

/**
 * Type for auto keyword metadata.
 *
 * @public
 */
export type AutoKeywordMetadata = typeof autoKeywordMetadata;


=== File: src/core/keywords/background-attachment-keywords.ts ===
// b_path:: src/core/keywords/background-attachment-keywords.ts
import { z } from "zod";

/**
 * CSS background-attachment keywords.
 *
 * The background-attachment property sets whether a background image's position
 * is fixed within the viewport, or scrolls with its containing block.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment}
 *
 * @example
 * ```typescript
 * import { backgroundAttachmentKeywordsSchema } from "../keywords/background-attachment-keywords";
 *
 * const keyword = backgroundAttachmentKeywordsSchema.parse("fixed"); // "fixed"
 * ```
 *
 * @public
 */
export const backgroundAttachmentKeywordsSchema = z
	.union([
		z
			.literal("scroll")
			.describe("background is fixed relative to the element itself and does not scroll with its contents"),
		z.literal("fixed").describe("background is fixed relative to the viewport"),
		z.literal("local").describe("background is fixed relative to the element's contents and scrolls with them"),
	])
	.describe(
		"Background attachment keywords control whether a background image scrolls with the page or is fixed. " +
			"Used in the background-attachment property.",
	);

/**
 * Array of all background-attachment keyword values.
 *
 * @example
 * ```typescript
 * import { BACKGROUND_ATTACHMENT_KEYWORDS } from "../keywords/background-attachment-keywords";
 *
 * console.log(BACKGROUND_ATTACHMENT_KEYWORDS); // ["scroll", "fixed", "local"]
 * ```
 *
 * @public
 */
export const BACKGROUND_ATTACHMENT_KEYWORDS = backgroundAttachmentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for background-attachment keywords.
 *
 * @public
 */
export type BackgroundAttachmentKeyword = z.infer<typeof backgroundAttachmentKeywordsSchema>;

/**
 * Metadata for background-attachment keyword options.
 *
 * Provides value and description for each background-attachment keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { backgroundAttachmentKeywordOptions } from "../keywords/background-attachment-keywords";
 *
 * backgroundAttachmentKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const backgroundAttachmentKeywordOptions = backgroundAttachmentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for background-attachment keyword options metadata.
 *
 * @public
 */
export type BackgroundAttachmentKeywordOptions = typeof backgroundAttachmentKeywordOptions;


=== File: src/core/keywords/basic-color-keywords.ts ===
// b_path:: src/core/keywords/basic-color-keywords.ts
import { z } from "zod";

/**
 * CSS basic named colors (22 colors).
 *
 * Common subset of named colors for basic use cases.
 * These are the most commonly used color names in CSS.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const basicNamedColorKeywordsSchema = z
	.union([
		z.literal("black").describe("Pure black color (#000000)"),
		z.literal("white").describe("Pure white color (#FFFFFF)"),
		z.literal("red").describe("Pure red color (#FF0000)"),
		z.literal("green").describe("Pure green color (#008000)"),
		z.literal("blue").describe("Pure blue color (#0000FF)"),
		z.literal("yellow").describe("Pure yellow color (#FFFF00)"),
		z.literal("orange").describe("Orange color (#FFA500)"),
		z.literal("purple").describe("Purple color (#800080)"),
		z.literal("pink").describe("Pink color (#FFC0CB)"),
		z.literal("brown").describe("Brown color (#A52A2A)"),
		z.literal("gray").describe("Gray color (#808080)"),
		z.literal("grey").describe("Alternative spelling of gray"),
		z.literal("silver").describe("Silver color (#C0C0C0)"),
		z.literal("gold").describe("Gold color (#FFD700)"),
		z.literal("navy").describe("Navy blue color (#000080)"),
		z.literal("teal").describe("Teal color (#008080)"),
		z.literal("lime").describe("Lime color (#00FF00)"),
		z.literal("aqua").describe("Aqua color (#00FFFF)"),
		z.literal("fuchsia").describe("Fuchsia color (#FF00FF)"),
		z.literal("maroon").describe("Maroon color (#800000)"),
		z.literal("olive").describe("Olive color (#808000)"),
		z.literal("cyan").describe("Cyan color (#00FFFF)"),
	])
	.describe("CSS basic named colors");

/**
 * Array of all basic named color keyword values.
 *
 * @example
 * ```typescript
 * import { BASIC_NAMED_COLOR_KEYWORDS } from "../keywords/basic-color-keywords";
 *
 * console.log(BASIC_NAMED_COLOR_KEYWORDS); // ["black", "white", "red", ...]
 * ```
 *
 * @public
 */
export const BASIC_NAMED_COLOR_KEYWORDS = basicNamedColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for basic named color keywords.
 *
 * @public
 */
export type BasicNamedColorKeyword = z.infer<typeof basicNamedColorKeywordsSchema>;

/**
 * Metadata for basic named color keyword options.
 *
 * Provides value and description for each basic named color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { basicNamedColorKeywordOptions } from "../keywords/basic-color-keywords";
 *
 * basicNamedColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const basicNamedColorKeywordOptions = basicNamedColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for basic named color keyword options metadata.
 *
 * @public
 */
export type BasicNamedColorKeywordOptions = typeof basicNamedColorKeywordOptions;


=== File: src/core/keywords/blend-mode-keywords.ts ===
// b_path:: src/core/keywords/blend-mode-keywords.ts
import { z } from "zod";

/**
 * CSS blend mode keywords.
 *
 * Blend modes describe how colors should appear when elements overlap.
 * Each mode defines a different way to combine the top and bottom colors.
 *
 * Used in:
 * - `background-blend-mode` - Blending between background layers
 * - `mix-blend-mode` - Blending an element with its backdrop
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/blend-mode}
 *
 * @example
 * ```typescript
 * import { blendModeKeywordsSchema } from "../keywords/blend-mode-keywords";
 *
 * const keyword = blendModeKeywordsSchema.parse("multiply"); // "multiply"
 * ```
 *
 * @public
 */
export const blendModeKeywordsSchema = z
	.union([
		z.literal("normal").describe("top color, regardless of bottom color"),
		z.literal("multiply").describe("result of multiplying top and bottom colors"),
		z.literal("screen").describe("result of inverting colors, multiplying, and inverting"),
		z.literal("overlay").describe("multiply if bottom darker, screen if bottom lighter"),
		z.literal("darken").describe("darkest values of each color channel"),
		z.literal("lighten").describe("lightest values of each color channel"),
		z.literal("color-dodge").describe("dividing bottom color by inverse of top color"),
		z.literal("color-burn").describe("inverting bottom, dividing by top, inverting result"),
		z.literal("hard-light").describe("multiply if top darker, screen if top lighter"),
		z.literal("soft-light").describe("similar to hard-light but softer"),
		z.literal("difference").describe("subtracting darker color from lighter"),
		z.literal("exclusion").describe("similar to difference but with less contrast"),
		z.literal("hue").describe("hue of top color, saturation and luminosity of bottom"),
		z.literal("saturation").describe("saturation of top color, hue and luminosity of bottom"),
		z.literal("color").describe("hue and saturation of top, luminosity of bottom"),
		z.literal("luminosity").describe("luminosity of top, hue and saturation of bottom"),
	])
	.describe(
		"Blend modes describe how colors should appear when elements overlap. " +
			"Used in background-blend-mode and mix-blend-mode properties.",
	);

/**
 * Array of all blend mode keyword values.
 *
 * @example
 * ```typescript
 * import { BLEND_MODE_KEYWORDS } from "../keywords/blend-mode-keywords";
 *
 * console.log(BLEND_MODE_KEYWORDS);
 * // ["normal", "multiply", "screen", "overlay", "darken", "lighten", ...]
 * ```
 *
 * @public
 */
export const BLEND_MODE_KEYWORDS = blendModeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for blend mode keywords.
 *
 * @public
 */
export type BlendModeKeyword = z.infer<typeof blendModeKeywordsSchema>;

/**
 * Metadata for blend mode keyword options.
 *
 * Provides value and description for each blend mode keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { blendModeKeywordOptions } from "../keywords/blend-mode-keywords";
 *
 * blendModeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const blendModeKeywordOptions = blendModeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for blend mode keyword options metadata.
 *
 * @public
 */
export type BlendModeKeywordOptions = typeof blendModeKeywordOptions;


=== File: src/core/keywords/border-style-keywords.ts ===
// b_path:: src/core/keywords/border-style-keywords.ts
import { z } from "zod";

/**
 * CSS border-style keywords.
 *
 * Defines the style of the border line for all four sides of an element's border.
 * These keywords control how the border appears visually.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style}
 *
 * @example
 * ```typescript
 * import { borderStyleKeywordsSchema } from "../keywords/border-style-keywords";
 *
 * const keyword = borderStyleKeywordsSchema.parse("solid"); // "solid"
 * ```
 *
 * @public
 */
export const borderStyleKeywordsSchema = z
	.union([
		z.literal("none").describe("No border"),
		z.literal("hidden").describe("Same as none, but with different behavior in table elements"),
		z.literal("dotted").describe("Series of round dots"),
		z.literal("dashed").describe("Series of short square-ended dashes"),
		z.literal("solid").describe("Single, straight, solid line"),
		z.literal("double").describe("Two straight lines that add up to the pixel size defined by border-width"),
		z.literal("groove").describe("Carved effect - opposite of ridge"),
		z.literal("ridge").describe("Extruded effect - opposite of groove"),
		z.literal("inset").describe("Border makes element appear embedded"),
		z.literal("outset").describe("Border makes element appear raised"),
	])
	.describe("CSS border style keywords");

/**
 * Array of all border-style keyword values.
 *
 * @example
 * ```typescript
 * import { BORDER_STYLE_KEYWORDS } from "../keywords/border-style-keywords";
 *
 * console.log(BORDER_STYLE_KEYWORDS); // ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"]
 * ```
 *
 * @public
 */
export const BORDER_STYLE_KEYWORDS = borderStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for border-style keywords.
 *
 * @public
 */
export type BorderStyleKeyword = z.infer<typeof borderStyleKeywordsSchema>;

/**
 * Metadata for border-style keyword options.
 *
 * Provides value and description for each border-style keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { borderStyleKeywordOptions } from "../keywords/border-style-keywords";
 *
 * borderStyleKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const borderStyleKeywordOptions = borderStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for border-style keyword options metadata.
 *
 * @public
 */
export type BorderStyleKeywordOptions = typeof borderStyleKeywordOptions;


=== File: src/core/keywords/border-width-keywords.ts ===
// b_path:: src/core/keywords/border-width-keywords.ts
import { z } from "zod";
import type * as Type from "../types";

/**
 * CSS border-width keywords.
 *
 * Predefined border width values that correspond to specific thickness levels.
 * These keywords provide a convenient way to specify common border widths without
 * needing to specify exact measurements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width}
 *
 * @example
 * ```typescript
 * import { borderWidthKeywordsSchema } from "../keywords/border-width-keywords";
 *
 * const keyword = borderWidthKeywordsSchema.parse("medium"); // "medium"
 * ```
 *
 * @public
 */
export const borderWidthKeywordsSchema = z
	.union([
		z.literal("thin").describe("A thin border (typically 1px)"),
		z.literal("medium").describe("A medium border (typically 3px)"),
		z.literal("thick").describe("A thick border (typically 5px)"),
	])
	.describe("Predefined border width keywords");

/**
 * Array of all border-width keyword values.
 *
 * @example
 * ```typescript
 * import { BORDER_WIDTH_KEYWORDS } from "../keywords/border-width-keywords";
 *
 * console.log(BORDER_WIDTH_KEYWORDS); // ["thin", "medium", "thick"]
 * ```
 *
 * @public
 */
export const BORDER_WIDTH_KEYWORDS = borderWidthKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for border-width keywords.
 *
 * @public
 */
export type BorderWidthKeyword = z.infer<typeof borderWidthKeywordsSchema>;

/**
 * TypeScript type for border-width values (keywords or length).
 *
 * @public
 */
export type BorderWidthValue = z.infer<typeof borderWidthKeywordsSchema> | Type.Length;

/**
 * Metadata for border-width keyword options.
 *
 * Provides value and description for each border-width keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { borderWidthKeywordOptions } from "../keywords/border-width-keywords";
 *
 * borderWidthKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const borderWidthKeywordOptions = borderWidthKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for border-width keyword options metadata.
 *
 * @public
 */
export type BorderWidthKeywordOptions = typeof borderWidthKeywordOptions;


=== File: src/core/keywords/box-edge-keywords.ts ===
// b_path:: src/core/keywords/box-edge-keywords.ts
import { z } from "zod";

/**
 * CSS box edge keywords.
 *
 * Box edge keywords define reference boxes for positioning, clipping, and layout.
 * Used in properties like clip-path, shape-outside, background-clip, and background-origin.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/box-edge}
 *
 * @example
 * ```typescript
 * import { boxEdgeKeywordsSchema } from "../keywords/box-edge-keywords";
 *
 * const keyword = boxEdgeKeywordsSchema.parse("border-box"); // "border-box"
 * ```
 *
 * @public
 */
export const boxEdgeKeywordsSchema = z
	.union([
		// Visual box (content, padding, border)
		z
			.literal("content-box")
			.describe("outer edge of the box's content area"),
		z.literal("padding-box").describe("outer edge of the padding of the box"),
		z.literal("border-box").describe("outer edge of the border of the box"),

		// Layout box (includes margin)
		z
			.literal("margin-box")
			.describe("outer edge of the margin of the box"),

		// SVG-specific boxes
		z
			.literal("fill-box")
			.describe("object bounding box in SVG"),
		z.literal("stroke-box").describe("stroke bounding box in SVG"),
		z.literal("view-box").describe("nearest SVG viewport element's origin box"),
	])
	.describe(
		"Box edge keywords define reference boxes for positioning, clipping, and layout. " +
			"Used in properties like clip-path, shape-outside, background-clip, and background-origin.",
	);

/**
 * Array of all box edge keyword values.
 *
 * @example
 * ```typescript
 * import { BOX_EDGE_KEYWORDS } from "../keywords/box-edge-keywords";
 *
 * console.log(BOX_EDGE_KEYWORDS);
 * // ["content-box", "padding-box", "border-box", "margin-box", "fill-box", "stroke-box", "view-box"]
 * ```
 *
 * @public
 */
export const BOX_EDGE_KEYWORDS = boxEdgeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for box edge keywords.
 *
 * @public
 */
export type BoxEdgeKeyword = z.infer<typeof boxEdgeKeywordsSchema>;

/**
 * Metadata for box edge keyword options.
 *
 * Provides value and description for each box edge keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { boxEdgeKeywordOptions } from "../keywords/box-edge-keywords";
 *
 * boxEdgeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const boxEdgeKeywordOptions = boxEdgeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for box edge keyword options metadata.
 *
 * @public
 */
export type BoxEdgeKeywordOptions = typeof boxEdgeKeywordOptions;

/**
 * CSS visual box edge keywords (subset).
 *
 * Visual box keywords are the most common subset used for layout and positioning.
 * Includes content-box, padding-box, and border-box only (excludes margin-box and SVG boxes).
 *
 * Used in properties like background-origin which only accept visual box keywords.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin}
 *
 * @example
 * ```typescript
 * import { visualBoxKeywordsSchema } from "../keywords/box-edge-keywords";
 *
 * const keyword = visualBoxKeywordsSchema.parse("padding-box"); // "padding-box"
 * ```
 *
 * @public
 */
export const visualBoxKeywordsSchema = z
	.union([
		z.literal("content-box").describe("outer edge of the box's content area"),
		z.literal("padding-box").describe("outer edge of the padding of the box"),
		z.literal("border-box").describe("outer edge of the border of the box"),
	])
	.describe("Visual box edge keywords (content-box, padding-box, border-box). Common subset for layout properties.");

/**
 * Array of visual box keyword values.
 *
 * @public
 */
export const VISUAL_BOX_KEYWORDS = visualBoxKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for visual box keywords.
 *
 * @public
 */
export type VisualBoxKeyword = z.infer<typeof visualBoxKeywordsSchema>;

/**
 * CSS background-clip keywords.
 *
 * Extends visual box keywords with the 'text' keyword which is specific to background-clip.
 * The 'text' keyword clips the background to the foreground text (WebKit prefixed in practice).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip}
 *
 * @example
 * ```typescript
 * import { backgroundClipKeywordsSchema } from "../keywords/box-edge-keywords";
 *
 * const keyword = backgroundClipKeywordsSchema.parse("text"); // "text"
 * ```
 *
 * @public
 */
export const backgroundClipKeywordsSchema = z
	.union([
		z.literal("content-box").describe("outer edge of the box's content area"),
		z.literal("padding-box").describe("outer edge of the padding of the box"),
		z.literal("border-box").describe("outer edge of the border of the box"),
		z.literal("text").describe("clip background to foreground text (WebKit)"),
	])
	.describe("Background-clip keywords: visual box keywords plus 'text' for clipping to foreground text.");

/**
 * Array of background-clip keyword values.
 *
 * @public
 */
export const BACKGROUND_CLIP_KEYWORDS = backgroundClipKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for background-clip keywords.
 *
 * @public
 */
export type BackgroundClipKeyword = z.infer<typeof backgroundClipKeywordsSchema>;


=== File: src/core/keywords/color-interpolation-keywords.ts ===
// b_path:: src/core/keywords/color-interpolation-keywords.ts
import { z } from "zod";

/**
 * Rectangular color space keywords for color interpolation.
 *
 * Rectangular (Cartesian) color spaces use perpendicular axes
 * for each color channel. Used for color interpolation in gradients,
 * animations, and color-mix() function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 * @public
 */
export const rectangularColorSpaceKeywordsSchema = z
	.union([
		z.literal("srgb").describe("sRGB color space"),
		z.literal("srgb-linear").describe("linear sRGB color space"),
		z.literal("display-p3").describe("Display P3 color space"),
		z.literal("display-p3-linear").describe("linear Display P3 color space"),
		z.literal("a98-rgb").describe("Adobe RGB (1998) color space"),
		z.literal("prophoto-rgb").describe("ProPhoto RGB color space"),
		z.literal("rec2020").describe("Rec. 2020 color space"),
		z.literal("lab").describe("CIE LAB color space"),
		z.literal("oklab").describe("OKLab color space"),
		z.literal("xyz").describe("CIE XYZ color space"),
		z.literal("xyz-d50").describe("CIE XYZ color space with D50 white point"),
		z.literal("xyz-d65").describe("CIE XYZ color space with D65 white point"),
	])
	.describe("Rectangular color spaces for color interpolation");

/**
 * Polar color space keywords for color interpolation.
 *
 * Polar (cylindrical) color spaces use hue as a circular component
 * and other attributes as radial distances. Used for color interpolation
 * in gradients, animations, and color-mix() function.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 * @public
 */
export const polarColorSpaceKeywordsSchema = z
	.union([
		z.literal("hsl").describe("HSL color space"),
		z.literal("hwb").describe("HWB color space"),
		z.literal("lch").describe("CIE LCH color space"),
		z.literal("oklch").describe("OKLCh color space"),
	])
	.describe("Polar color spaces for color interpolation");

/**
 * Hue interpolation method keywords for polar color spaces.
 *
 * When using polar color spaces, hue can be interpolated in different ways
 * around the color wheel. These keywords control that interpolation.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/hue-interpolation-method}
 * @public
 */
export const hueInterpolationMethodKeywordsSchema = z
	.union([
		z.literal("shorter").describe("shorter hue interpolation (default)"),
		z.literal("longer").describe("longer hue interpolation"),
		z.literal("increasing").describe("increasing hue interpolation"),
		z.literal("decreasing").describe("decreasing hue interpolation"),
	])
	.describe("Hue interpolation methods for polar color spaces");

/**
 * CSS color interpolation keywords.
 *
 * Color interpolation methods specify how colors are interpolated
 * in gradients, animations, and the color-mix() function.
 *
 * Includes:
 * - Rectangular color spaces (sRGB, Display P3, LAB, etc.)
 * - Polar color spaces (HSL, HWB, LCH, OKLCH)
 * - Hue interpolation methods (shorter, longer, increasing, decreasing)
 *
 * Used in:
 * - CSS gradients with `in` keyword
 * - color-mix() function
 * - CSS animations and transitions
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method}
 *
 * @example
 * ```typescript
 * import { colorInterpolationKeywordsSchema } from "../keywords/color-interpolation-keywords";
 *
 * const keyword = colorInterpolationKeywordsSchema.parse("oklch"); // "oklch"
 * ```
 *
 * @public
 */
export const colorInterpolationKeywordsSchema = z
	.union([
		// Rectangular color spaces
		z
			.literal("srgb")
			.describe("sRGB color space"),
		z.literal("srgb-linear").describe("linear sRGB color space"),
		z.literal("display-p3").describe("Display P3 color space"),
		z.literal("display-p3-linear").describe("linear Display P3 color space"),
		z.literal("a98-rgb").describe("Adobe RGB (1998) color space"),
		z.literal("prophoto-rgb").describe("ProPhoto RGB color space"),
		z.literal("rec2020").describe("Rec. 2020 color space"),
		z.literal("lab").describe("CIE LAB color space"),
		z.literal("oklab").describe("OKLab color space"),
		z.literal("xyz").describe("CIE XYZ color space"),
		z.literal("xyz-d50").describe("CIE XYZ color space with D50 white point"),
		z.literal("xyz-d65").describe("CIE XYZ color space with D65 white point"),

		// Polar color spaces
		z
			.literal("hsl")
			.describe("HSL color space"),
		z.literal("hwb").describe("HWB color space"),
		z.literal("lch").describe("CIE LCH color space"),
		z.literal("oklch").describe("OKLCh color space"),

		// Hue interpolation methods
		z
			.literal("shorter")
			.describe("shorter hue interpolation (default)"),
		z.literal("longer").describe("longer hue interpolation"),
		z.literal("increasing").describe("increasing hue interpolation"),
		z.literal("decreasing").describe("decreasing hue interpolation"),
	])
	.describe(
		"Color interpolation methods specify how colors are interpolated in gradients and animations. " +
			"Can use rectangular or polar color spaces with optional hue interpolation.",
	);

/**
 * Array of all color interpolation keyword values.
 *
 * @example
 * ```typescript
 * import { COLOR_INTERPOLATION_KEYWORDS } from "../keywords/color-interpolation-keywords";
 *
 * console.log(COLOR_INTERPOLATION_KEYWORDS);
 * // ["srgb", "srgb-linear", "display-p3", "hsl", "hwb", "shorter", ...]
 * ```
 *
 * @public
 */
export const COLOR_INTERPOLATION_KEYWORDS = colorInterpolationKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for color interpolation keywords.
 *
 * @public
 */
export type ColorInterpolationKeyword = z.infer<typeof colorInterpolationKeywordsSchema>;

/**
 * Metadata for color interpolation keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { colorInterpolationKeywordOptions } from "../keywords/color-interpolation-keywords";
 *
 * colorInterpolationKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const colorInterpolationKeywordOptions = colorInterpolationKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for color interpolation keyword options metadata.
 *
 * @public
 */
export type ColorInterpolationKeywordOptions = typeof colorInterpolationKeywordOptions;


=== File: src/core/keywords/color-keywords.ts ===
// b_path:: src/core/keywords/color-keywords.ts
import { z } from "zod";

/**
 * CSS special color keywords.
 *
 * These keywords have special meaning in CSS color contexts.
 * - `transparent`: Fully transparent color
 * - `currentcolor`: Uses the current text color
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @public
 */
export const specialColorKeywordsSchema = z
	.union([
		z.literal("transparent").describe("Fully transparent color"),
		z.literal("currentcolor").describe("Uses the current text color value"),
	])
	.describe("CSS special color keywords");

/**
 * Array of all special color keyword values.
 *
 * @example
 * ```typescript
 * import { SPECIAL_COLOR_KEYWORDS } from "../keywords/color-keywords";
 *
 * console.log(SPECIAL_COLOR_KEYWORDS); // ["transparent", "currentcolor"]
 * ```
 *
 * @public
 */
export const SPECIAL_COLOR_KEYWORDS = specialColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for special color keywords.
 *
 * @public
 */
export type SpecialColorKeyword = z.infer<typeof specialColorKeywordsSchema>;

/**
 * Metadata for special color keyword options.
 *
 * Provides value and description for each special color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { specialColorKeywordOptions } from "../keywords/color-keywords";
 *
 * specialColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const specialColorKeywordOptions = specialColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for special color keyword options metadata.
 *
 * @public
 */
export type SpecialColorKeywordOptions = typeof specialColorKeywordOptions;


=== File: src/core/keywords/color-value-keywords.ts ===
// b_path:: src/core/keywords/color-value-keywords.ts
import { z } from "zod";

/**
 * CSS hex color pattern.
 *
 * Matches 3, 4, 6, or 8 digit hex colors with # prefix.
 * Supports alpha channel (4 and 8 digit formats).
 *
 * @example
 * ```typescript
 * "#f00"      // 3-digit
 * "#ff0000"   // 6-digit
 * "#f00f"     // 4-digit with alpha
 * "#ff0000ff" // 8-digit with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color}
 * @public
 */
export const hexColorKeywordsSchema = z
	.string()
	.regex(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/)
	.describe("CSS hex color");

/**
 * CSS rgb() or rgba() function pattern.
 *
 * Simplified pattern for rgb() and rgba() functions.
 * Supports both legacy comma syntax and modern space syntax.
 *
 * @example
 * ```typescript
 * "rgb(255, 0, 0)"          // Legacy comma syntax
 * "rgba(255, 0, 0, 0.5)"    // Legacy with alpha
 * "rgb(255 0 0)"            // Modern space syntax
 * "rgb(255 0 0 / 0.5)"      // Modern with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb}
 * @public
 */
export const rgbColorKeywordsSchema = z
	.string()
	.regex(/^rgba?\(\s*\d+\s*(?:,\s*\d+\s*,\s*\d+|[\s]+\d+[\s]+\d+)\s*(?:[,/]\s*[\d.]+\s*)?\)$/)
	.describe("CSS rgb() or rgba() function");

/**
 * CSS hsl() or hsla() function pattern.
 *
 * Simplified pattern for hsl() and hsla() functions.
 * Supports both legacy comma syntax and modern space syntax.
 *
 * @example
 * ```typescript
 * "hsl(0, 100%, 50%)"       // Legacy comma syntax
 * "hsla(0, 100%, 50%, 0.5)" // Legacy with alpha
 * "hsl(0 100% 50%)"         // Modern space syntax
 * "hsl(0 100% 50% / 0.5)"   // Modern with alpha
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl}
 * @public
 */
export const hslColorKeywordsSchema = z
	.string()
	.regex(/^hsla?\(\s*\d+\s*(?:,\s*\d+%\s*,\s*\d+%|[\s]+\d+%[\s]+\d+%)\s*(?:[,/]\s*[\d.]+\s*)?\)$/)
	.describe("CSS hsl() or hsla() function");

/**
 * All CSS named colors (special + basic + extended = ~148 colors).
 *
 * Complete set of named colors supported in CSS Color Module Level 4.
 * Colors are case-insensitive in CSS - normalize to lowercase before validation.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#named-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const namedColorKeywordsSchema = z
	.union([
		z.literal("transparent"),
		z.literal("currentcolor"),
		z.literal("black"),
		z.literal("white"),
		z.literal("red"),
		z.literal("green"),
		z.literal("blue"),
		z.literal("yellow"),
		z.literal("orange"),
		z.literal("purple"),
		z.literal("pink"),
		z.literal("brown"),
		z.literal("gray"),
		z.literal("grey"),
		z.literal("silver"),
		z.literal("gold"),
		z.literal("navy"),
		z.literal("teal"),
		z.literal("lime"),
		z.literal("aqua"),
		z.literal("fuchsia"),
		z.literal("maroon"),
		z.literal("olive"),
		z.literal("cyan"),
		z.literal("aliceblue"),
		z.literal("antiquewhite"),
		z.literal("aquamarine"),
		z.literal("azure"),
		z.literal("beige"),
		z.literal("bisque"),
		z.literal("blanchedalmond"),
		z.literal("blueviolet"),
		z.literal("burlywood"),
		z.literal("cadetblue"),
		z.literal("chartreuse"),
		z.literal("chocolate"),
		z.literal("coral"),
		z.literal("cornflowerblue"),
		z.literal("cornsilk"),
		z.literal("crimson"),
		z.literal("darkblue"),
		z.literal("darkcyan"),
		z.literal("darkgoldenrod"),
		z.literal("darkgray"),
		z.literal("darkgrey"),
		z.literal("darkgreen"),
		z.literal("darkkhaki"),
		z.literal("darkmagenta"),
		z.literal("darkolivegreen"),
		z.literal("darkorange"),
		z.literal("darkorchid"),
		z.literal("darkred"),
		z.literal("darksalmon"),
		z.literal("darkseagreen"),
		z.literal("darkslateblue"),
		z.literal("darkslategray"),
		z.literal("darkslategrey"),
		z.literal("darkturquoise"),
		z.literal("darkviolet"),
		z.literal("deeppink"),
		z.literal("deepskyblue"),
		z.literal("dimgray"),
		z.literal("dimgrey"),
		z.literal("dodgerblue"),
		z.literal("firebrick"),
		z.literal("floralwhite"),
		z.literal("forestgreen"),
		z.literal("gainsboro"),
		z.literal("ghostwhite"),
		z.literal("goldenrod"),
		z.literal("greenyellow"),
		z.literal("honeydew"),
		z.literal("hotpink"),
		z.literal("indianred"),
		z.literal("indigo"),
		z.literal("ivory"),
		z.literal("khaki"),
		z.literal("lavender"),
		z.literal("lavenderblush"),
		z.literal("lawngreen"),
		z.literal("lemonchiffon"),
		z.literal("lightblue"),
		z.literal("lightcoral"),
		z.literal("lightcyan"),
		z.literal("lightgoldenrodyellow"),
		z.literal("lightgray"),
		z.literal("lightgrey"),
		z.literal("lightgreen"),
		z.literal("lightpink"),
		z.literal("lightsalmon"),
		z.literal("lightseagreen"),
		z.literal("lightskyblue"),
		z.literal("lightslategray"),
		z.literal("lightslategrey"),
		z.literal("lightsteelblue"),
		z.literal("lightyellow"),
		z.literal("limegreen"),
		z.literal("linen"),
		z.literal("magenta"),
		z.literal("mediumaquamarine"),
		z.literal("mediumblue"),
		z.literal("mediumorchid"),
		z.literal("mediumpurple"),
		z.literal("mediumseagreen"),
		z.literal("mediumslateblue"),
		z.literal("mediumspringgreen"),
		z.literal("mediumturquoise"),
		z.literal("mediumvioletred"),
		z.literal("midnightblue"),
		z.literal("mintcream"),
		z.literal("mistyrose"),
		z.literal("moccasin"),
		z.literal("navajowhite"),
		z.literal("oldlace"),
		z.literal("olivedrab"),
		z.literal("orangered"),
		z.literal("orchid"),
		z.literal("palegoldenrod"),
		z.literal("palegreen"),
		z.literal("paleturquoise"),
		z.literal("palevioletred"),
		z.literal("papayawhip"),
		z.literal("peachpuff"),
		z.literal("peru"),
		z.literal("plum"),
		z.literal("powderblue"),
		z.literal("rebeccapurple"),
		z.literal("rosybrown"),
		z.literal("royalblue"),
		z.literal("saddlebrown"),
		z.literal("salmon"),
		z.literal("sandybrown"),
		z.literal("seagreen"),
		z.literal("seashell"),
		z.literal("sienna"),
		z.literal("skyblue"),
		z.literal("slateblue"),
		z.literal("slategray"),
		z.literal("slategrey"),
		z.literal("snow"),
		z.literal("springgreen"),
		z.literal("steelblue"),
		z.literal("tan"),
		z.literal("thistle"),
		z.literal("tomato"),
		z.literal("turquoise"),
		z.literal("violet"),
		z.literal("wheat"),
		z.literal("whitesmoke"),
		z.literal("yellowgreen"),
	])
	.describe("CSS named colors");

/**
 * Complete CSS color value.
 *
 * Supports all common CSS color formats:
 * - Named colors (transparent, currentColor, red, etc.)
 * - Hex colors (#RGB, #RRGGBB, with optional alpha)
 * - RGB/RGBA functions
 * - HSL/HSLA functions
 *
 * Note: Modern color spaces (lab, lch, oklab, oklch, color()) are not yet supported.
 *
 * @example
 * ```typescript
 * import { colorValueKeywordsSchema } from "../keywords/color-value-keywords";
 *
 * const color1 = colorValueKeywordsSchema.parse("red");
 * const color2 = colorValueKeywordsSchema.parse("#ff0000");
 * const color3 = colorValueKeywordsSchema.parse("rgb(255, 0, 0)");
 * const color4 = colorValueKeywordsSchema.parse("hsl(0, 100%, 50%)");
 * const color5 = colorValueKeywordsSchema.parse("transparent");
 * ```
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @public
 */
export const colorValueKeywordsSchema = z
	.union([namedColorKeywordsSchema, hexColorKeywordsSchema, rgbColorKeywordsSchema, hslColorKeywordsSchema])
	.describe("CSS color value");

/**
 * TypeScript types for color values.
 *
 * @public
 */
export type HexColorKeyword = z.infer<typeof hexColorKeywordsSchema>;
export type RgbColorKeyword = z.infer<typeof rgbColorKeywordsSchema>;
export type HslColorKeyword = z.infer<typeof hslColorKeywordsSchema>;
export type NamedColorKeyword = z.infer<typeof namedColorKeywordsSchema>;
export type ColorValueKeyword = z.infer<typeof colorValueKeywordsSchema>;

/**
 * Combined array of all named color keywords.
 *
 * This is a convenience export that combines all color categories.
 *
 * @example
 * ```typescript
 * import { ALL_NAMED_COLOR_KEYWORDS } from "../keywords/color-value-keywords";
 *
 * console.log(ALL_NAMED_COLOR_KEYWORDS.length); // 148
 * ```
 *
 * @public
 */
export const ALL_NAMED_COLOR_KEYWORDS = [
	"transparent",
	"currentcolor",
	"black",
	"white",
	"red",
	"green",
	"blue",
	"yellow",
	"orange",
	"purple",
	"pink",
	"brown",
	"gray",
	"grey",
	"silver",
	"gold",
	"navy",
	"teal",
	"lime",
	"aqua",
	"fuchsia",
	"maroon",
	"olive",
	"cyan",
	"aliceblue",
	"antiquewhite",
	"aquamarine",
	"azure",
	"beige",
	"bisque",
	"blanchedalmond",
	"blueviolet",
	"burlywood",
	"cadetblue",
	"chartreuse",
	"chocolate",
	"coral",
	"cornflowerblue",
	"cornsilk",
	"crimson",
	"darkblue",
	"darkcyan",
	"darkgoldenrod",
	"darkgray",
	"darkgrey",
	"darkgreen",
	"darkkhaki",
	"darkmagenta",
	"darkolivegreen",
	"darkorange",
	"darkorchid",
	"darkred",
	"darksalmon",
	"darkseagreen",
	"darkslateblue",
	"darkslategray",
	"darkslategrey",
	"darkturquoise",
	"darkviolet",
	"deeppink",
	"deepskyblue",
	"dimgray",
	"dimgrey",
	"dodgerblue",
	"firebrick",
	"floralwhite",
	"forestgreen",
	"gainsboro",
	"ghostwhite",
	"goldenrod",
	"greenyellow",
	"honeydew",
	"hotpink",
	"indianred",
	"indigo",
	"ivory",
	"khaki",
	"lavender",
	"lavenderblush",
	"lawngreen",
	"lemonchiffon",
	"lightblue",
	"lightcoral",
	"lightcyan",
	"lightgoldenrodyellow",
	"lightgray",
	"lightgrey",
	"lightgreen",
	"lightpink",
	"lightsalmon",
	"lightseagreen",
	"lightskyblue",
	"lightslategray",
	"lightslategrey",
	"lightsteelblue",
	"lightyellow",
	"limegreen",
	"linen",
	"magenta",
	"mediumaquamarine",
	"mediumblue",
	"mediumorchid",
	"mediumpurple",
	"mediumseagreen",
	"mediumslateblue",
	"mediumspringgreen",
	"mediumturquoise",
	"mediumvioletred",
	"midnightblue",
	"mintcream",
	"mistyrose",
	"moccasin",
	"navajowhite",
	"oldlace",
	"olivedrab",
	"orangered",
	"orchid",
	"palegoldenrod",
	"palegreen",
	"paleturquoise",
	"palevioletred",
	"papayawhip",
	"peachpuff",
	"peru",
	"plum",
	"powderblue",
	"rebeccapurple",
	"rosybrown",
	"royalblue",
	"saddlebrown",
	"salmon",
	"sandybrown",
	"seagreen",
	"seashell",
	"sienna",
	"skyblue",
	"slateblue",
	"slategray",
	"slategrey",
	"snow",
	"springgreen",
	"steelblue",
	"tan",
	"thistle",
	"tomato",
	"turquoise",
	"violet",
	"wheat",
	"whitesmoke",
	"yellowgreen",
] as const;

/**
 * Metadata for color values.
 *
 * @public
 */
export const colorKeywordsMetadata = {
	totalNamedColors: ALL_NAMED_COLOR_KEYWORDS.length,
	hexPattern: "#RGB, #RRGGBB, #RGBA, #RRGGBBAA",
	rgbPattern: "rgb(r, g, b) or rgba(r, g, b, a)",
	hslPattern: "hsl(h, s%, l%) or hsla(h, s%, l%, a)",
} as const;

/**
 * Type for color keywords metadata.
 *
 * @public
 */
export type ColorKeywordsMetadata = typeof colorKeywordsMetadata;


=== File: src/core/keywords/content-distribution-keywords.ts ===
// b_path:: src/core/keywords/content-distribution-keywords.ts
import { z } from "zod";

/**
 * CSS content distribution keywords.
 *
 * Content distribution values control how extra space is distributed
 * among flex items or grid tracks within their alignment container.
 *
 * Used in:
 * - `justify-content` - Alignment along main axis
 * - `align-content` - Alignment along cross axis
 * - `place-content` - Shorthand for both axes
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Alignment#content_distribution}
 *
 * @example
 * ```typescript
 * import { contentDistributionKeywordsSchema } from "../keywords/content-distribution-keywords";
 *
 * const keyword = contentDistributionKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const contentDistributionKeywordsSchema = z
	.union([
		z.literal("space-between").describe("evenly distributes items with first/last flush to edges"),
		z.literal("space-around").describe("evenly distributes items with half-size space on ends"),
		z.literal("space-evenly").describe("evenly distributes items with full-size space on ends"),
		z.literal("stretch").describe("grows items equally to fill container"),
	])
	.describe(
		"Content distribution values control how extra space is distributed among alignment subjects. " +
			"Used in justify-content, align-content, and place-content properties.",
	);

/**
 * Array of all content distribution keyword values.
 *
 * @example
 * ```typescript
 * import { CONTENT_DISTRIBUTION_KEYWORDS } from "../keywords/content-distribution-keywords";
 *
 * console.log(CONTENT_DISTRIBUTION_KEYWORDS);
 * // ["space-between", "space-around", "space-evenly", "stretch"]
 * ```
 *
 * @public
 */
export const CONTENT_DISTRIBUTION_KEYWORDS = contentDistributionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for content distribution keywords.
 *
 * @public
 */
export type ContentDistributionKeyword = z.infer<typeof contentDistributionKeywordsSchema>;

/**
 * Metadata for content distribution keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { contentDistributionKeywordOptions } from "../keywords/content-distribution-keywords";
 *
 * contentDistributionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const contentDistributionKeywordOptions = contentDistributionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for content distribution keyword options metadata.
 *
 * @public
 */
export type ContentDistributionKeywordOptions = typeof contentDistributionKeywordOptions;


=== File: src/core/keywords/content-position-keywords.ts ===
// b_path:: src/core/keywords/content-position-keywords.ts
import { z } from "zod";

/**
 * CSS content position keywords.
 *
 * Content position values align the box's contents within itself
 * along a single axis (main or cross axis for flex, inline or block for grid).
 *
 * Used in:
 * - `justify-content` - Alignment along main/inline axis
 * - `align-content` - Alignment along cross/block axis
 * - `place-content` - Shorthand for both axes
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Alignment#positional_alignment}
 *
 * @example
 * ```typescript
 * import { contentPositionKeywordsSchema } from "../keywords/content-position-keywords";
 *
 * const keyword = contentPositionKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const contentPositionKeywordsSchema = z
	.union([
		z.literal("center").describe("centers the alignment subject within its alignment container"),
		z.literal("start").describe("aligns the alignment subject flush with the alignment container's start edge"),
		z.literal("end").describe("aligns the alignment subject flush with the alignment container's end edge"),
		z.literal("flex-start").describe("aligns flush with flex container's main-start or cross-start side"),
		z.literal("flex-end").describe("aligns flush with flex container's main-end or cross-end side"),
	])
	.describe(
		"Content position values align the box's contents within itself. " +
			"Used in justify-content, align-content, and place-content properties.",
	);

/**
 * Array of all content position keyword values.
 *
 * @example
 * ```typescript
 * import { CONTENT_POSITION_KEYWORDS } from "../keywords/content-position-keywords";
 *
 * console.log(CONTENT_POSITION_KEYWORDS);
 * // ["center", "start", "end", "flex-start", "flex-end"]
 * ```
 *
 * @public
 */
export const CONTENT_POSITION_KEYWORDS = contentPositionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for content position keywords.
 *
 * @public
 */
export type ContentPositionKeyword = z.infer<typeof contentPositionKeywordsSchema>;

/**
 * Metadata for content position keyword options.
 *
 * Provides value and description for each keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { contentPositionKeywordOptions } from "../keywords/content-position-keywords";
 *
 * contentPositionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const contentPositionKeywordOptions = contentPositionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for content position keyword options metadata.
 *
 * @public
 */
export type ContentPositionKeywordOptions = typeof contentPositionKeywordOptions;


=== File: src/core/keywords/corner-shape-keywords.ts ===
// b_path:: src/core/keywords/corner-shape-keywords.ts
import { z } from "zod";

/**
 * CSS corner-shape keyword values.
 *
 * Corner shape values describe the shape of container corners.
 * Used in corner-shape property to specify custom corner shapes beyond standard border-radius.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/corner-shape}
 *
 * @example
 * ```typescript
 * import { cornerShapeKeywordsSchema } from "../keywords/corner-shape-keywords";
 *
 * const keyword = cornerShapeKeywordsSchema.parse("round");
 * ```
 *
 * @public
 */
export const cornerShapeKeywordsSchema = z
	.union([
		z.literal("round").describe("convex ordinary ellipse (default rounded corner)"),
		z.literal("scoop").describe("concave ordinary ellipse"),
		z.literal("bevel").describe("straight diagonal corner (neither convex nor concave)"),
		z.literal("notch").describe("90-degree concave square corner"),
		z.literal("square").describe("90-degree convex square corner"),
		z.literal("squircle").describe("convex curve between round and square"),
	])
	.describe(
		"Corner shape values describe the shape of container corners. " +
			"Used in corner-shape property to specify custom corner shapes beyond standard border-radius.",
	);

/**
 * Array of all corner-shape keyword values.
 *
 * @public
 */
export const CORNER_SHAPE_KEYWORDS = cornerShapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for corner-shape keywords.
 *
 * @public
 */
export type CornerShapeKeyword = z.infer<typeof cornerShapeKeywordsSchema>;

/**
 * Metadata for corner-shape keyword options.
 *
 * @public
 */
export const cornerShapeKeywordOptions = cornerShapeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for corner-shape keyword options metadata.
 *
 * @public
 */
export type CornerShapeKeywordOptions = typeof cornerShapeKeywordOptions;


=== File: src/core/keywords/cursor-keywords.ts ===
// b_path:: src/core/keywords/cursor-keywords.ts
import { z } from "zod";

/**
 * CSS cursor keyword values.
 *
 * The cursor property sets the mouse cursor to display when the mouse pointer is over an element.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor}
 *
 * @example
 * ```typescript
 * import { cursorKeywordsSchema } from "../keywords/cursor-keywords";
 *
 * const keyword = cursorKeywordsSchema.parse("pointer");
 * ```
 *
 * @public
 */
export const cursorKeywordsSchema = z
	.union([
		z.literal("auto").describe("browser determines cursor based on context"),
		z.literal("default").describe("platform-dependent default cursor (usually arrow)"),
		z.literal("none").describe("no cursor is rendered"),
		z.literal("context-menu").describe("context menu is available"),
		z.literal("help").describe("help information is available"),
		z.literal("pointer").describe("link or clickable element (usually hand)"),
		z.literal("progress").describe("program is busy but user can still interact"),
		z.literal("wait").describe("program is busy"),
		z.literal("cell").describe("cell or set of cells can be selected"),
		z.literal("crosshair").describe("simple crosshair"),
		z.literal("text").describe("text can be selected (usually I-beam)"),
		z.literal("vertical-text").describe("vertical text can be selected"),
		z.literal("alias").describe("alias or shortcut is to be created"),
		z.literal("copy").describe("something is to be copied"),
		z.literal("move").describe("something is to be moved"),
		z.literal("no-drop").describe("drop is not allowed at current location"),
		z.literal("not-allowed").describe("requested action will not be executed"),
		z.literal("grab").describe("something can be grabbed"),
		z.literal("grabbing").describe("something is being grabbed"),
		z.literal("e-resize").describe("edge is to be moved east"),
		z.literal("n-resize").describe("edge is to be moved north"),
		z.literal("ne-resize").describe("edge is to be moved northeast"),
		z.literal("nw-resize").describe("edge is to be moved northwest"),
		z.literal("s-resize").describe("edge is to be moved south"),
		z.literal("se-resize").describe("edge is to be moved southeast"),
		z.literal("sw-resize").describe("edge is to be moved southwest"),
		z.literal("w-resize").describe("edge is to be moved west"),
		z.literal("ew-resize").describe("bidirectional resize cursor (east-west)"),
		z.literal("ns-resize").describe("bidirectional resize cursor (north-south)"),
		z.literal("nesw-resize").describe("bidirectional resize cursor (northeast-southwest)"),
		z.literal("nwse-resize").describe("bidirectional resize cursor (northwest-southeast)"),
		z.literal("col-resize").describe("column can be resized horizontally"),
		z.literal("row-resize").describe("row can be resized vertically"),
		z.literal("all-scroll").describe("scrolling in any direction"),
		z.literal("zoom-in").describe("something can be zoomed in"),
		z.literal("zoom-out").describe("something can be zoomed out"),
	])
	.describe("CSS cursor property keyword values");

/**
 * Array of all cursor keyword values.
 *
 * @public
 */
export const CURSOR_KEYWORDS = cursorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for cursor keywords.
 *
 * @public
 */
export type CursorKeyword = z.infer<typeof cursorKeywordsSchema>;

/**
 * Metadata for cursor keyword options.
 *
 * @public
 */
export const cursorKeywordOptions = cursorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for cursor keyword options metadata.
 *
 * @public
 */
export type CursorKeywordOptions = typeof cursorKeywordOptions;


=== File: src/core/keywords/display-keywords.ts ===
// b_path:: src/core/keywords/display-keywords.ts
import { z } from "zod";

/**
 * CSS display box keywords.
 *
 * Display box values control whether an element generates a box at all.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#box}
 * @public
 */
export const displayBoxKeywordsSchema = z
	.union([
		z.literal("contents").describe("element doesn't produce a specific box by itself"),
		z.literal("none").describe("turns off the display of an element"),
	])
	.describe("Display box values that control whether an element generates a box");

/**
 * CSS display inside keywords.
 *
 * Display inside values specify the element's inner display type,
 * which defines how its contents are laid out.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#inside}
 * @public
 */
export const displayInsideKeywordsSchema = z
	.union([
		z.literal("flow").describe("element lays out its contents using flow layout"),
		z.literal("flow-root").describe("generates a block element box that establishes a new block formatting context"),
		z.literal("table").describe("behaves like HTML table elements"),
		z.literal("flex").describe("behaves like a block element and lays out content according to the flexbox model"),
		z.literal("grid").describe("behaves like a block element and lays out content according to the grid model"),
		z
			.literal("ruby")
			.describe("behaves like an inline element and lays out content according to the ruby formatting model"),
	])
	.describe("Display inside values that specify the element's inner display type");

/**
 * CSS display internal keywords.
 *
 * Display internal values are for complex layout models like table and ruby.
 * These elements have internal structures with specific roles.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#internal}
 * @public
 */
export const displayInternalKeywordsSchema = z
	.union([
		z.literal("table-row-group").describe("behaves like tbody HTML elements"),
		z.literal("table-header-group").describe("behaves like thead HTML elements"),
		z.literal("table-footer-group").describe("behaves like tfoot HTML elements"),
		z.literal("table-row").describe("behaves like tr HTML elements"),
		z.literal("table-cell").describe("behaves like td HTML elements"),
		z.literal("table-column-group").describe("behaves like colgroup HTML elements"),
		z.literal("table-column").describe("behaves like col HTML elements"),
		z.literal("table-caption").describe("behaves like caption HTML elements"),
		z.literal("ruby-base").describe("behaves like rb HTML elements"),
		z.literal("ruby-text").describe("behaves like rt HTML elements"),
		z.literal("ruby-base-container").describe("generated as anonymous boxes"),
		z.literal("ruby-text-container").describe("behaves like rtc HTML elements"),
	])
	.describe("Display internal values for complex layout models like table and ruby");

/**
 * CSS display legacy keywords.
 *
 * Display legacy values are from CSS 2 single-keyword syntax.
 * These combine outer and inner display types in a single keyword.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#legacy}
 * @public
 */
export const displayLegacyKeywordsSchema = z
	.union([
		z.literal("inline-block").describe("generates a block element box flowed with surrounding content as inline"),
		z.literal("inline-table").describe("behaves like HTML table element but as an inline box"),
		z.literal("inline-flex").describe("behaves like an inline element and lays out content according to flexbox model"),
		z.literal("inline-grid").describe("behaves like an inline element and lays out content according to grid model"),
	])
	.describe("Display legacy values from CSS 2 single-keyword syntax");

/**
 * CSS display outside keywords.
 *
 * Display outside values specify the element's outer display type,
 * which determines how it participates in flow layout.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#outside}
 * @public
 */
export const displayOutsideKeywordsSchema = z
	.union([
		z.literal("block").describe("generates a block element box with line breaks before and after"),
		z.literal("inline").describe("generates inline element boxes without line breaks"),
		z.literal("run-in").describe("element runs into the next block if possible"),
	])
	.describe("Display outside values that specify the element's outer display type");

/**
 * CSS display list-item keyword.
 *
 * The list-item keyword makes an element behave like a list item,
 * generating both a principal box and a marker box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display#list-item}
 * @public
 */
export const displayListItemKeywordsSchema = z.literal("list-item").describe("element behaves like a list item");

/**
 * CSS display keywords.
 *
 * The display property controls how an element is displayed in the layout,
 * including its box generation, inner layout type, and outer display type.
 *
 * This schema includes all valid display values:
 * - Box values (contents, none)
 * - Inside values (flow, flex, grid, table, etc.)
 * - Internal values (table-row, table-cell, etc.)
 * - Legacy values (inline-block, inline-flex, etc.)
 * - Outside values (block, inline, run-in)
 * - List item
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/display}
 *
 * @example
 * ```typescript
 * import { displayKeywordsSchema } from "../keywords/display-keywords";
 *
 * const keyword = displayKeywordsSchema.parse("flex"); // "flex"
 * ```
 *
 * @public
 */
export const displayKeywordsSchema = z
	.union([
		// Display Box
		z
			.literal("contents")
			.describe("element doesn't produce a specific box by itself"),
		z.literal("none").describe("turns off the display of an element"),

		// Display Inside
		z
			.literal("flow")
			.describe("element lays out its contents using flow layout"),
		z.literal("flow-root").describe("generates a block element box that establishes a new block formatting context"),
		z.literal("table").describe("behaves like HTML table elements"),
		z.literal("flex").describe("behaves like a block element and lays out content according to the flexbox model"),
		z.literal("grid").describe("behaves like a block element and lays out content according to the grid model"),
		z
			.literal("ruby")
			.describe("behaves like an inline element and lays out content according to the ruby formatting model"),

		// Display Internal
		z
			.literal("table-row-group")
			.describe("behaves like tbody HTML elements"),
		z.literal("table-header-group").describe("behaves like thead HTML elements"),
		z.literal("table-footer-group").describe("behaves like tfoot HTML elements"),
		z.literal("table-row").describe("behaves like tr HTML elements"),
		z.literal("table-cell").describe("behaves like td HTML elements"),
		z.literal("table-column-group").describe("behaves like colgroup HTML elements"),
		z.literal("table-column").describe("behaves like col HTML elements"),
		z.literal("table-caption").describe("behaves like caption HTML elements"),
		z.literal("ruby-base").describe("behaves like rb HTML elements"),
		z.literal("ruby-text").describe("behaves like rt HTML elements"),
		z.literal("ruby-base-container").describe("generated as anonymous boxes"),
		z.literal("ruby-text-container").describe("behaves like rtc HTML elements"),

		// Display Legacy
		z
			.literal("inline-block")
			.describe("generates a block element box flowed with surrounding content as inline"),
		z.literal("inline-table").describe("behaves like HTML table element but as an inline box"),
		z.literal("inline-flex").describe("behaves like an inline element and lays out content according to flexbox model"),
		z.literal("inline-grid").describe("behaves like an inline element and lays out content according to grid model"),

		// Display Outside
		z
			.literal("block")
			.describe("generates a block element box with line breaks before and after"),
		z.literal("inline").describe("generates inline element boxes without line breaks"),
		z.literal("run-in").describe("element runs into the next block if possible"),

		// List Item
		z
			.literal("list-item")
			.describe("element behaves like a list item"),
	])
	.describe("CSS display property values that control how an element is displayed");

/**
 * Array of all display keyword values.
 *
 * @example
 * ```typescript
 * import { DISPLAY_KEYWORDS } from "../keywords/display-keywords";
 *
 * console.log(DISPLAY_KEYWORDS);
 * // ["contents", "none", "flow", "flex", "grid", "block", "inline", ...]
 * ```
 *
 * @public
 */
export const DISPLAY_KEYWORDS = displayKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for display keywords.
 *
 * @public
 */
export type DisplayKeyword = z.infer<typeof displayKeywordsSchema>;

/**
 * Metadata for display keyword options.
 *
 * Provides value and description for each display keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { displayKeywordOptions } from "../keywords/display-keywords";
 *
 * displayKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const displayKeywordOptions = displayKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for display keyword options metadata.
 *
 * @public
 */
export type DisplayKeywordOptions = typeof displayKeywordOptions;


=== File: src/core/keywords/extended-color-keywords.ts ===
// b_path:: src/core/keywords/extended-color-keywords.ts
import { z } from "zod";

/**
 * CSS extended named colors (~125 colors).
 *
 * Full X11/SVG color set from CSS Color Module Level 4.
 * These are additional named colors beyond the basic set.
 *
 * @see {@link https://www.w3.org/TR/css-color-4/#named-colors}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/named-color}
 * @public
 */
export const extendedNamedColorKeywordsSchema = z
	.union([
		z.literal("aliceblue").describe("Alice blue color (#F0F8FF)"),
		z.literal("antiquewhite").describe("Antique white color (#FAEBD7)"),
		z.literal("aquamarine").describe("Aquamarine color (#7FFFD4)"),
		z.literal("azure").describe("Azure color (#F0FFFF)"),
		z.literal("beige").describe("Beige color (#F5F5DC)"),
		z.literal("bisque").describe("Bisque color (#FFE4C4)"),
		z.literal("blanchedalmond").describe("Blanched almond color (#FFEBCD)"),
		z.literal("blueviolet").describe("Blue violet color (#8A2BE2)"),
		z.literal("burlywood").describe("Burlywood color (#DEB887)"),
		z.literal("cadetblue").describe("Cadet blue color (#5F9EA0)"),
		z.literal("chartreuse").describe("Chartreuse color (#7FFF00)"),
		z.literal("chocolate").describe("Chocolate color (#D2691E)"),
		z.literal("coral").describe("Coral color (#FF7F50)"),
		z.literal("cornflowerblue").describe("Cornflower blue color (#6495ED)"),
		z.literal("cornsilk").describe("Cornsilk color (#FFF8DC)"),
		z.literal("crimson").describe("Crimson color (#DC143C)"),
		z.literal("darkblue").describe("Dark blue color (#00008B)"),
		z.literal("darkcyan").describe("Dark cyan color (#008B8B)"),
		z.literal("darkgoldenrod").describe("Dark goldenrod color (#B8860B)"),
		z.literal("darkgray").describe("Dark gray color (#A9A9A9)"),
		z.literal("darkgrey").describe("Alternative spelling of darkgray"),
		z.literal("darkgreen").describe("Dark green color (#006400)"),
		z.literal("darkkhaki").describe("Dark khaki color (#BDB76B)"),
		z.literal("darkmagenta").describe("Dark magenta color (#8B008B)"),
		z.literal("darkolivegreen").describe("Dark olive green color (#556B2F)"),
		z.literal("darkorange").describe("Dark orange color (#FF8C00)"),
		z.literal("darkorchid").describe("Dark orchid color (#9932CC)"),
		z.literal("darkred").describe("Dark red color (#8B0000)"),
		z.literal("darksalmon").describe("Dark salmon color (#E9967A)"),
		z.literal("darkseagreen").describe("Dark sea green color (#8FBC8F)"),
		z.literal("darkslateblue").describe("Dark slate blue color (#483D8B)"),
		z.literal("darkslategray").describe("Dark slate gray color (#2F4F4F)"),
		z.literal("darkslategrey").describe("Alternative spelling of darkslategray"),
		z.literal("darkturquoise").describe("Dark turquoise color (#00CED1)"),
		z.literal("darkviolet").describe("Dark violet color (#9400D3)"),
		z.literal("deeppink").describe("Deep pink color (#FF1493)"),
		z.literal("deepskyblue").describe("Deep sky blue color (#00BFFF)"),
		z.literal("dimgray").describe("Dim gray color (#696969)"),
		z.literal("dimgrey").describe("Alternative spelling of dimgrey"),
		z.literal("dodgerblue").describe("Dodger blue color (#1E90FF)"),
		z.literal("firebrick").describe("Fire brick color (#B22222)"),
		z.literal("floralwhite").describe("Floral white color (#FFFAF0)"),
		z.literal("forestgreen").describe("Forest green color (#228B22)"),
		z.literal("gainsboro").describe("Gainsboro color (#DCDCDC)"),
		z.literal("ghostwhite").describe("Ghost white color (#F8F8FF)"),
		z.literal("goldenrod").describe("Goldenrod color (#DAA520)"),
		z.literal("greenyellow").describe("Green yellow color (#ADFF2F)"),
		z.literal("honeydew").describe("Honeydew color (#F0FFF0)"),
		z.literal("hotpink").describe("Hot pink color (#FF69B4)"),
		z.literal("indianred").describe("Indian red color (#CD5C5C)"),
		z.literal("indigo").describe("Indigo color (#4B0082)"),
		z.literal("ivory").describe("Ivory color (#FFFFF0)"),
		z.literal("khaki").describe("Khaki color (#F0E68C)"),
		z.literal("lavender").describe("Lavender color (#E6E6FA)"),
		z.literal("lavenderblush").describe("Lavender blush color (#FFF0F5)"),
		z.literal("lawngreen").describe("Lawn green color (#7CFC00)"),
		z.literal("lemonchiffon").describe("Lemon chiffon color (#FFFACD)"),
		z.literal("lightblue").describe("Light blue color (#ADD8E6)"),
		z.literal("lightcoral").describe("Light coral color (#F08080)"),
		z.literal("lightcyan").describe("Light cyan color (#E0FFFF)"),
		z.literal("lightgoldenrodyellow").describe("Light goldenrod yellow color (#FAFAD2)"),
		z.literal("lightgray").describe("Light gray color (#D3D3D3)"),
		z.literal("lightgrey").describe("Alternative spelling of lightgrey"),
		z.literal("lightgreen").describe("Light green color (#90EE90)"),
		z.literal("lightpink").describe("Light pink color (#FFB6C1)"),
		z.literal("lightsalmon").describe("Light salmon color (#FFA07A)"),
		z.literal("lightseagreen").describe("Light sea green color (#20B2AA)"),
		z.literal("lightskyblue").describe("Light sky blue color (#87CEFA)"),
		z.literal("lightslategray").describe("Light slate gray color (#778899)"),
		z.literal("lightslategrey").describe("Alternative spelling of lightslategrey"),
		z.literal("lightsteelblue").describe("Light steel blue color (#B0C4DE)"),
		z.literal("lightyellow").describe("Light yellow color (#FFFFE0)"),
		z.literal("limegreen").describe("Lime green color (#32CD32)"),
		z.literal("linen").describe("Linen color (#FAF0E6)"),
		z.literal("magenta").describe("Magenta color (#FF00FF)"),
		z.literal("mediumaquamarine").describe("Medium aquamarine color (#66CDAA)"),
		z.literal("mediumblue").describe("Medium blue color (#0000CD)"),
		z.literal("mediumorchid").describe("Medium orchid color (#BA55D3)"),
		z.literal("mediumpurple").describe("Medium purple color (#9370DB)"),
		z.literal("mediumseagreen").describe("Medium sea green color (#3CB371)"),
		z.literal("mediumslateblue").describe("Medium slate blue color (#7B68EE)"),
		z.literal("mediumspringgreen").describe("Medium spring green color (#00FA9A)"),
		z.literal("mediumturquoise").describe("Medium turquoise color (#48D1CC)"),
		z.literal("mediumvioletred").describe("Medium violet red color (#C71585)"),
		z.literal("midnightblue").describe("Midnight blue color (#191970)"),
		z.literal("mintcream").describe("Mint cream color (#F5FFFA)"),
		z.literal("mistyrose").describe("Misty rose color (#FFE4E1)"),
		z.literal("moccasin").describe("Moccasin color (#FFE4B5)"),
		z.literal("navajowhite").describe("Navajo white color (#FFDEAD)"),
		z.literal("oldlace").describe("Old lace color (#FDF5E6)"),
		z.literal("olivedrab").describe("Olive drab color (#6B8E23)"),
		z.literal("orangered").describe("Orange red color (#FF4500)"),
		z.literal("orchid").describe("Orchid color (#DA70D6)"),
		z.literal("palegoldenrod").describe("Pale goldenrod color (#EEE8AA)"),
		z.literal("palegreen").describe("Pale green color (#98FB98)"),
		z.literal("paleturquoise").describe("Pale turquoise color (#AFEEEE)"),
		z.literal("palevioletred").describe("Pale violet red color (#DB7093)"),
		z.literal("papayawhip").describe("Papaya whip color (#FFEFD5)"),
		z.literal("peachpuff").describe("Peach puff color (#FFDAB9)"),
		z.literal("peru").describe("Peru color (#CD853F)"),
		z.literal("plum").describe("Plum color (#DDA0DD)"),
		z.literal("powderblue").describe("Powder blue color (#B0E0E6)"),
		z.literal("rebeccapurple").describe("Rebecca purple color (#663399)"),
		z.literal("rosybrown").describe("Rosy brown color (#BC8F8F)"),
		z.literal("royalblue").describe("Royal blue color (#4169E1)"),
		z.literal("saddlebrown").describe("Saddle brown color (#8B4513)"),
		z.literal("salmon").describe("Salmon color (#FA8072)"),
		z.literal("sandybrown").describe("Sandy brown color (#F4A460)"),
		z.literal("seagreen").describe("Sea green color (#2E8B57)"),
		z.literal("seashell").describe("Seashell color (#FFF5EE)"),
		z.literal("sienna").describe("Sienna color (#A0522D)"),
		z.literal("skyblue").describe("Sky blue color (#87CEEB)"),
		z.literal("slateblue").describe("Slate blue color (#6A5ACD)"),
		z.literal("slategray").describe("Slate gray color (#708090)"),
		z.literal("slategrey").describe("Alternative spelling of slategray"),
		z.literal("snow").describe("Snow color (#FFFAFA)"),
		z.literal("springgreen").describe("Spring green color (#00FF7F)"),
		z.literal("steelblue").describe("Steel blue color (#4682B4)"),
		z.literal("tan").describe("Tan color (#D2B48C)"),
		z.literal("thistle").describe("Thistle color (#D8BFD8)"),
		z.literal("tomato").describe("Tomato color (#FF6347)"),
		z.literal("turquoise").describe("Turquoise color (#40E0D0)"),
		z.literal("violet").describe("Violet color (#EE82EE)"),
		z.literal("wheat").describe("Wheat color (#F5DEB3)"),
		z.literal("whitesmoke").describe("White smoke color (#F5F5F5)"),
		z.literal("yellowgreen").describe("Yellow green color (#9ACD32)"),
	])
	.describe("CSS extended named colors");

/**
 * Array of all extended named color keyword values.
 *
 * @example
 * ```typescript
 * import { EXTENDED_NAMED_COLOR_KEYWORDS } from "../keywords/extended-color-keywords";
 *
 * console.log(EXTENDED_NAMED_COLOR_KEYWORDS.length); // 125
 * ```
 *
 * @public
 */
export const EXTENDED_NAMED_COLOR_KEYWORDS = extendedNamedColorKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for extended named color keywords.
 *
 * @public
 */
export type ExtendedNamedColorKeyword = z.infer<typeof extendedNamedColorKeywordsSchema>;

/**
 * Metadata for extended named color keyword options.
 *
 * Provides value and description for each extended named color keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { extendedNamedColorKeywordOptions } from "../keywords/extended-color-keywords";
 *
 * extendedNamedColorKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const extendedNamedColorKeywordOptions = extendedNamedColorKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for extended named color keyword options metadata.
 *
 * @public
 */
export type ExtendedNamedColorKeywordOptions = typeof extendedNamedColorKeywordOptions;


=== File: src/core/keywords/flex-direction-keywords.ts ===
// b_path:: src/core/keywords/flex-direction-keywords.ts
import { z } from "zod";

/**
 * CSS `flex-direction` property keyword values.
 *
 * The flex-direction property sets how flex items are placed in the flex container,
 * defining the main axis and the direction (normal or reversed).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction}
 *
 * @example
 * ```typescript
 * import { flexDirectionKeywordsSchema } from "../keywords/flex-direction-keywords";
 *
 * const keyword = flexDirectionKeywordsSchema.parse("row");
 * ```
 *
 * @public
 */
export const flexDirectionKeywordsSchema = z
	.union([
		z.literal("row").describe("horizontal direction in left-to-right layout"),
		z.literal("row-reverse").describe("horizontal direction reversed"),
		z.literal("column").describe("vertical direction from top to bottom"),
		z.literal("column-reverse").describe("vertical direction reversed"),
	])
	.describe("CSS flex-direction property keyword values");

/**
 * Array of all flex-direction keyword values.
 *
 * @public
 */
export const FLEX_DIRECTION_KEYWORDS = flexDirectionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for flex-direction keywords.
 *
 * @public
 */
export type FlexDirectionKeyword = z.infer<typeof flexDirectionKeywordsSchema>;

/**
 * Metadata for flex-direction keyword options.
 *
 * @public
 */
export const flexDirectionKeywordOptions = flexDirectionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for flex-direction keyword options metadata.
 *
 * @public
 */
export type FlexDirectionKeywordOptions = typeof flexDirectionKeywordOptions;


=== File: src/core/keywords/flex-wrap-keywords.ts ===
// b_path:: src/core/keywords/flex-wrap-keywords.ts
import { z } from "zod";

/**
 * CSS `flex-wrap` property keyword values.
 *
 * The flex-wrap property sets whether flex items are forced onto one line
 * or can wrap onto multiple lines.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap}
 *
 * @example
 * ```typescript
 * import { flexWrapKeywordsSchema } from "../keywords/flex-wrap-keywords";
 *
 * const keyword = flexWrapKeywordsSchema.parse("wrap");
 * ```
 *
 * @public
 */
export const flexWrapKeywordsSchema = z
	.union([
		z.literal("nowrap").describe("items laid out in single line (may overflow)"),
		z.literal("wrap").describe("items wrap onto multiple lines top to bottom"),
		z.literal("wrap-reverse").describe("items wrap onto multiple lines bottom to top"),
	])
	.describe("CSS flex-wrap property keyword values");

/**
 * Array of all flex-wrap keyword values.
 *
 * @public
 */
export const FLEX_WRAP_KEYWORDS = flexWrapKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for flex-wrap keywords.
 *
 * @public
 */
export type FlexWrapKeyword = z.infer<typeof flexWrapKeywordsSchema>;

/**
 * Metadata for flex-wrap keyword options.
 *
 * @public
 */
export const flexWrapKeywordOptions = flexWrapKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for flex-wrap keyword options metadata.
 *
 * @public
 */
export type FlexWrapKeywordOptions = typeof flexWrapKeywordOptions;


=== File: src/core/keywords/font-size-keywords.ts ===
// b_path:: src/core/keywords/font-size-keywords.ts
import { z } from "zod";

/**
 * CSS font-size absolute size keywords.
 *
 * Absolute size keywords are mapped to font sizes computed and kept by the browser.
 * These values scale relative to each other based on the user's preferred font size (medium).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size#absolute-size}
 * @public
 */
export const fontSizeAbsoluteKeywordsSchema = z
	.union([
		z.literal("xx-small").describe("absolute size 60% the size of medium"),
		z.literal("x-small").describe("absolute size 75% the size of medium"),
		z.literal("small").describe("absolute size 89% the size of medium"),
		z.literal("medium").describe("user's preferred font size (reference middle value)"),
		z.literal("large").describe("absolute size 20% larger than medium"),
		z.literal("x-large").describe("absolute size 50% larger than medium"),
		z.literal("xx-large").describe("absolute size twice the size of medium"),
		z.literal("xxx-large").describe("absolute size three times the size of medium"),
	])
	.describe(
		"Absolute size keywords for font sizing. " +
			"Used in font shorthand and font-size properties, mapped to deprecated HTML size attributes.",
	);

/**
 * CSS font-size relative size keywords.
 *
 * Relative size keywords scale relative to the parent element's computed font size.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size#relative-size}
 * @public
 */
export const fontSizeRelativeKeywordsSchema = z
	.union([
		z.literal("smaller").describe("one relative size smaller than parent element"),
		z.literal("larger").describe("one relative size larger than parent element"),
	])
	.describe("Relative size keywords scale relative to the parent element's font size.");

/**
 * CSS font-size keywords (all absolute and relative values).
 *
 * The font-size property sets the size of the font. Can be specified using
 * absolute size keywords (xx-small through xxx-large) or relative keywords (smaller, larger).
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-size}
 *
 * @example
 * ```typescript
 * import { fontSizeKeywordsSchema } from "../keywords/font-size-keywords";
 *
 * const keyword = fontSizeKeywordsSchema.parse("medium"); // "medium"
 * ```
 *
 * @public
 */
export const fontSizeKeywordsSchema = z
	.union([
		// Absolute sizes
		z
			.literal("xx-small")
			.describe("absolute size 60% the size of medium"),
		z.literal("x-small").describe("absolute size 75% the size of medium"),
		z.literal("small").describe("absolute size 89% the size of medium"),
		z.literal("medium").describe("user's preferred font size (reference middle value)"),
		z.literal("large").describe("absolute size 20% larger than medium"),
		z.literal("x-large").describe("absolute size 50% larger than medium"),
		z.literal("xx-large").describe("absolute size twice the size of medium"),
		z.literal("xxx-large").describe("absolute size three times the size of medium"),

		// Relative sizes
		z
			.literal("smaller")
			.describe("one relative size smaller than parent element"),
		z.literal("larger").describe("one relative size larger than parent element"),
	])
	.describe("CSS font-size keywords (absolute and relative)");

/**
 * Array of all absolute font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_ABSOLUTE_KEYWORDS } from "../keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_ABSOLUTE_KEYWORDS);
 * // ["xx-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_ABSOLUTE_KEYWORDS = fontSizeAbsoluteKeywordsSchema.options.map((option) => option.value);

/**
 * Array of all relative font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_RELATIVE_KEYWORDS } from "../keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_RELATIVE_KEYWORDS); // ["smaller", "larger"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_RELATIVE_KEYWORDS = fontSizeRelativeKeywordsSchema.options.map((option) => option.value);

/**
 * Array of all font-size keyword values.
 *
 * @example
 * ```typescript
 * import { FONT_SIZE_KEYWORDS } from "../keywords/font-size-keywords";
 *
 * console.log(FONT_SIZE_KEYWORDS);
 * // ["xx-small", "x-small", ..., "smaller", "larger"]
 * ```
 *
 * @public
 */
export const FONT_SIZE_KEYWORDS = fontSizeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-size keywords.
 *
 * @public
 */
export type FontSizeKeyword = z.infer<typeof fontSizeKeywordsSchema>;

/**
 * TypeScript type for absolute font-size keywords.
 *
 * @public
 */
export type FontSizeAbsoluteKeyword = z.infer<typeof fontSizeAbsoluteKeywordsSchema>;

/**
 * TypeScript type for relative font-size keywords.
 *
 * @public
 */
export type FontSizeRelativeKeyword = z.infer<typeof fontSizeRelativeKeywordsSchema>;

/**
 * Metadata for font-size keyword options.
 *
 * Provides value and description for each font-size keyword,
 * useful for Studio UI generation and documentation.
 *
 * @example
 * ```typescript
 * import { fontSizeKeywordOptions } from "../keywords/font-size-keywords";
 *
 * fontSizeKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const fontSizeKeywordOptions = fontSizeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeKeywordOptions = typeof fontSizeKeywordOptions;

/**
 * Metadata for absolute font-size keyword options.
 *
 * @public
 */
export const fontSizeAbsoluteKeywordOptions = fontSizeAbsoluteKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for absolute font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeAbsoluteKeywordOptions = typeof fontSizeAbsoluteKeywordOptions;

/**
 * Metadata for relative font-size keyword options.
 *
 * @public
 */
export const fontSizeRelativeKeywordOptions = fontSizeRelativeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for relative font-size keyword options metadata.
 *
 * @public
 */
export type FontSizeRelativeKeywordOptions = typeof fontSizeRelativeKeywordOptions;


=== File: src/core/keywords/font-style-keywords.ts ===
// b_path:: src/core/keywords/font-style-keywords.ts
import { z } from "zod";

/**
 * CSS font-style keyword values.
 *
 * The font-style property sets whether a font should be styled with a normal, italic,
 * or oblique face from its font-family.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-style}
 *
 * @example
 * ```typescript
 * import { fontStyleKeywordsSchema } from "../keywords/font-style-keywords";
 *
 * const keyword = fontStyleKeywordsSchema.parse("italic");
 * ```
 *
 * @public
 */
export const fontStyleKeywordsSchema = z
	.union([
		z.literal("normal").describe("normal font style"),
		z.literal("italic").describe("italic font style using dedicated italic font face"),
		z.literal("oblique").describe("oblique font style using slanted version of normal font"),
	])
	.describe("CSS font-style property keyword values");

/**
 * Array of all font-style keyword values.
 *
 * @public
 */
export const FONT_STYLE_KEYWORDS = fontStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-style keywords.
 *
 * @public
 */
export type FontStyleKeyword = z.infer<typeof fontStyleKeywordsSchema>;

/**
 * Metadata for font-style keyword options.
 *
 * @public
 */
export const fontStyleKeywordOptions = fontStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-style keyword options metadata.
 *
 * @public
 */
export type FontStyleKeywordOptions = typeof fontStyleKeywordOptions;


=== File: src/core/keywords/font-weight-keywords.ts ===
// b_path:: src/core/keywords/font-weight-keywords.ts
import { z } from "zod";

/**
 * CSS font-weight keyword values.
 *
 * The font-weight property sets the weight (or boldness) of the font.
 * These keyword values are relative to the inherited weight or absolute weights.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight}
 *
 * @example
 * ```typescript
 * import { fontWeightKeywordsSchema } from "../keywords/font-weight-keywords";
 *
 * const keyword = fontWeightKeywordsSchema.parse("bold");
 * ```
 *
 * @public
 */
export const fontWeightKeywordsSchema = z
	.union([
		z.literal("normal").describe("normal font weight (equivalent to 400)"),
		z.literal("bold").describe("bold font weight (equivalent to 700)"),
		z.literal("lighter").describe("one relative font weight lighter than parent"),
		z.literal("bolder").describe("one relative font weight bolder than parent"),
	])
	.describe("CSS font-weight property keyword values");

/**
 * Array of all font-weight keyword values.
 *
 * @public
 */
export const FONT_WEIGHT_KEYWORDS = fontWeightKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-weight keywords.
 *
 * @public
 */
export type FontWeightKeyword = z.infer<typeof fontWeightKeywordsSchema>;

/**
 * Metadata for font-weight keyword options.
 *
 * @public
 */
export const fontWeightKeywordOptions = fontWeightKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-weight keyword options metadata.
 *
 * @public
 */
export type FontWeightKeywordOptions = typeof fontWeightKeywordOptions;


=== File: src/core/keywords/grid-auto-flow-keywords.ts ===
// b_path:: src/core/keywords/grid-auto-flow-keywords.ts
import { z } from "zod";

/**
 * CSS `grid-auto-flow` property keyword values.
 *
 * The grid-auto-flow property controls how auto-placed items get inserted into the grid.
 * It determines whether to place items by filling rows or columns, and whether to use
 * dense packing to fill holes.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/grid-auto-flow}
 *
 * @example
 * ```typescript
 * import { gridAutoFlowKeywordsSchema } from "../keywords/grid-auto-flow-keywords";
 *
 * const keyword = gridAutoFlowKeywordsSchema.parse("row");
 * ```
 *
 * @public
 */
export const gridAutoFlowKeywordsSchema = z
	.union([
		z.literal("row").describe("auto-placed items fill rows"),
		z.literal("column").describe("auto-placed items fill columns"),
		z.literal("dense").describe("use dense packing algorithm to fill holes"),
		z.literal("row dense").describe("auto-placed items fill rows with dense packing"),
		z.literal("column dense").describe("auto-placed items fill columns with dense packing"),
	])
	.describe("CSS grid-auto-flow property keyword values");

/**
 * Array of all grid-auto-flow keyword values.
 *
 * @public
 */
export const GRID_AUTO_FLOW_KEYWORDS = gridAutoFlowKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for grid-auto-flow keywords.
 *
 * @public
 */
export type GridAutoFlowKeyword = z.infer<typeof gridAutoFlowKeywordsSchema>;

/**
 * Metadata for grid-auto-flow keyword options.
 *
 * @public
 */
export const gridAutoFlowKeywordOptions = gridAutoFlowKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for grid-auto-flow keyword options metadata.
 *
 * @public
 */
export type GridAutoFlowKeywordOptions = typeof gridAutoFlowKeywordOptions;


=== File: src/core/keywords/index.ts ===
// b_path:: src/core/keywords/index.ts

export * from "./align-content-keywords";
export * from "./align-items-keywords";
export * from "./align-self-keywords";
export * from "./auto-keyword";
export * from "./background-attachment-keywords";
export * from "./basic-color-keywords";
export * from "./blend-mode-keywords";
export * from "./border-style-keywords";
export * from "./border-width-keywords";
export * from "./box-edge-keywords";
export * from "./color-interpolation-keywords";
export * from "./color-keywords";
export * from "./color-value-keywords";
export * from "./content-distribution-keywords";
export * from "./content-position-keywords";
export * from "./corner-shape-keywords";
export * from "./cursor-keywords";
export * from "./display-keywords";
export * from "./extended-color-keywords";
export * from "./flex-direction-keywords";
export * from "./flex-wrap-keywords";
export * from "./font-size-keywords";
export * from "./font-style-keywords";
export * from "./font-weight-keywords";
export * from "./grid-auto-flow-keywords";
export * from "./justify-content-keywords";
export * from "./justify-items-keywords";
export * from "./justify-items-keywords";
export * from "./justify-self-keywords";
export * from "./outline-style-keywords";
export * from "./overflow-wrap-keywords";
export * from "./position-keywords";
export * from "./repeat-keywords";
export * from "./shape-keywords";
export * from "./sizing-keywords";
export * from "./text-align-keywords";
export * from "./text-decoration-line-keywords";
export * from "./text-decoration-style-keywords";
export * from "./text-decoration-thickness-keywords";
export * from "./text-transform-keywords";
export * from "./vertical-align-keywords";
export * from "./white-space-keywords";
export * from "./word-break-keywords";


=== File: src/core/keywords/justify-content-keywords.ts ===
// b_path:: src/core/keywords/justify-content-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-content` property keyword values.
 *
 * The justify-content property defines how the browser distributes space between
 * and around content items along the main-axis of a flex container, and the inline
 * axis of a grid container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content}
 *
 * @example
 * ```typescript
 * import { justifyContentKeywordsSchema } from "../keywords/justify-content-keywords";
 *
 * const keyword = justifyContentKeywordsSchema.parse("space-between");
 * ```
 *
 * @public
 */
export const justifyContentKeywordsSchema = z
	.union([
		z.literal("flex-start").describe("items packed at start of flex direction"),
		z.literal("flex-end").describe("items packed at end of flex direction"),
		z.literal("center").describe("items centered along main axis"),
		z.literal("space-between").describe("items evenly distributed, first/last at edges"),
		z.literal("space-around").describe("items evenly distributed with equal space around"),
		z.literal("space-evenly").describe("items evenly distributed with equal space between"),
		z.literal("start").describe("items packed at start of writing mode direction"),
		z.literal("end").describe("items packed at end of writing mode direction"),
		z.literal("left").describe("items packed toward left edge"),
		z.literal("right").describe("items packed toward right edge"),
	])
	.describe("CSS justify-content property keyword values");

/**
 * Array of all justify-content keyword values.
 *
 * @public
 */
export const JUSTIFY_CONTENT_KEYWORDS = justifyContentKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-content keywords.
 *
 * @public
 */
export type JustifyContentKeyword = z.infer<typeof justifyContentKeywordsSchema>;

/**
 * Metadata for justify-content keyword options.
 *
 * @public
 */
export const justifyContentKeywordOptions = justifyContentKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-content keyword options metadata.
 *
 * @public
 */
export type JustifyContentKeywordOptions = typeof justifyContentKeywordOptions;


=== File: src/core/keywords/justify-items-keywords.ts ===
// b_path:: src/core/keywords/justify-items-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-items` property keyword values.
 *
 * The justify-items property defines the default justify-self for all items of the box,
 * giving them all a default way of justifying each box along the appropriate axis.
 * In grid layout, it controls the inline axis (horizontal) alignment of items within their grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-items}
 *
 * @example
 * ```typescript
 * import { justifyItemsKeywordsSchema } from "../keywords/justify-items-keywords";
 *
 * const keyword = justifyItemsKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const justifyItemsKeywordsSchema = z
	.union([
		z.literal("start").describe("items aligned at start of writing mode direction"),
		z.literal("end").describe("items aligned at end of writing mode direction"),
		z.literal("center").describe("items centered along inline axis"),
		z.literal("stretch").describe("items stretched to fill grid area"),
		z.literal("baseline").describe("items aligned along their baselines"),
		z.literal("flex-start").describe("items aligned at start of flex direction"),
		z.literal("flex-end").describe("items aligned at end of flex direction"),
		z.literal("self-start").describe("items aligned at start of their own writing mode"),
		z.literal("self-end").describe("items aligned at end of their own writing mode"),
		z.literal("left").describe("items aligned to left edge"),
		z.literal("right").describe("items aligned to right edge"),
	])
	.describe("CSS justify-items property keyword values");

/**
 * Array of all justify-items keyword values.
 *
 * @public
 */
export const JUSTIFY_ITEMS_KEYWORDS = justifyItemsKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-items keywords.
 *
 * @public
 */
export type JustifyItemsKeyword = z.infer<typeof justifyItemsKeywordsSchema>;

/**
 * Metadata for justify-items keyword options.
 *
 * @public
 */
export const justifyItemsKeywordOptions = justifyItemsKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-items keyword options metadata.
 *
 * @public
 */
export type JustifyItemsKeywordOptions = typeof justifyItemsKeywordOptions;


=== File: src/core/keywords/justify-self-keywords.ts ===
// b_path:: src/core/keywords/justify-self-keywords.ts
import { z } from "zod";

/**
 * CSS `justify-self` property keyword values.
 *
 * The justify-self property sets the way a box is justified inside its alignment container
 * along the appropriate axis. In grid layout, it controls the inline axis (horizontal)
 * alignment of a single item within its grid area.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/justify-self}
 *
 * @example
 * ```typescript
 * import { justifySelfKeywordsSchema } from "../keywords/justify-self-keywords";
 *
 * const keyword = justifySelfKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const justifySelfKeywordsSchema = z
	.union([
		z.literal("auto").describe("uses parent's justify-items value"),
		z.literal("start").describe("item aligned at start of writing mode direction"),
		z.literal("end").describe("item aligned at end of writing mode direction"),
		z.literal("center").describe("item centered along inline axis"),
		z.literal("stretch").describe("item stretched to fill grid area"),
		z.literal("baseline").describe("item aligned along its baseline"),
		z.literal("flex-start").describe("item aligned at start of flex direction"),
		z.literal("flex-end").describe("item aligned at end of flex direction"),
		z.literal("self-start").describe("item aligned at start of its own writing mode"),
		z.literal("self-end").describe("item aligned at end of its own writing mode"),
		z.literal("left").describe("item aligned to left edge"),
		z.literal("right").describe("item aligned to right edge"),
	])
	.describe("CSS justify-self property keyword values");

/**
 * Array of all justify-self keyword values.
 *
 * @public
 */
export const JUSTIFY_SELF_KEYWORDS = justifySelfKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for justify-self keywords.
 *
 * @public
 */
export type JustifySelfKeyword = z.infer<typeof justifySelfKeywordsSchema>;

/**
 * Metadata for justify-self keyword options.
 *
 * @public
 */
export const justifySelfKeywordOptions = justifySelfKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for justify-self keyword options metadata.
 *
 * @public
 */
export type JustifySelfKeywordOptions = typeof justifySelfKeywordOptions;


=== File: src/core/keywords/outline-style-keywords.ts ===
// b_path:: src/core/keywords/outline-style-keywords.ts
import { z } from "zod";

/**
 * CSS outline-style keyword values.
 *
 * The outline-style property sets the style of an element's outline.
 * Includes 'auto' which is outline-specific, plus all border-style values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/outline-style}
 *
 * @public
 */
export const outlineStyleKeywordsSchema = z
	.union([
		z.literal("auto").describe("browser determines outline style"),
		z.literal("none").describe("no outline"),
		z.literal("hidden").describe("same as none, but with different behavior in table elements"),
		z.literal("dotted").describe("series of round dots"),
		z.literal("dashed").describe("series of short square-ended dashes"),
		z.literal("solid").describe("single, straight, solid line"),
		z.literal("double").describe("two straight lines that add up to the pixel size"),
		z.literal("groove").describe("carved effect - opposite of ridge"),
		z.literal("ridge").describe("extruded effect - opposite of groove"),
		z.literal("inset").describe("outline makes element appear embedded"),
		z.literal("outset").describe("outline makes element appear raised"),
	])
	.describe("CSS outline-style property keyword values");

/**
 * Array of all outline-style keyword values.
 *
 * @public
 */
export const OUTLINE_STYLE_KEYWORDS = outlineStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for outline-style keywords.
 *
 * @public
 */
export type OutlineStyleKeyword = z.infer<typeof outlineStyleKeywordsSchema>;

/**
 * Metadata for outline-style keyword options.
 *
 * @public
 */
export const outlineStyleKeywordOptions = outlineStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for outline-style keyword options metadata.
 *
 * @public
 */
export type OutlineStyleKeywordOptions = typeof outlineStyleKeywordOptions;


=== File: src/core/keywords/overflow-wrap-keywords.ts ===
// b_path:: src/core/keywords/overflow-wrap-keywords.ts
import { z } from "zod";

/**
 * CSS overflow-wrap keyword values.
 *
 * The overflow-wrap property applies to inline elements, setting whether the browser
 * should insert line breaks within an otherwise unbreakable string to prevent text
 * from overflowing its line box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/overflow-wrap}
 *
 * @example
 * ```typescript
 * import { overflowWrapKeywordsSchema } from "../keywords/overflow-wrap-keywords";
 *
 * const keyword = overflowWrapKeywordsSchema.parse("break-word");
 * ```
 *
 * @public
 */
export const overflowWrapKeywordsSchema = z
	.union([
		z.literal("normal").describe("lines break only at normal break points"),
		z.literal("anywhere").describe("breaks at any character if no acceptable break point"),
		z.literal("break-word").describe("like anywhere but affects min-content size"),
	])
	.describe("CSS overflow-wrap property keyword values");

/**
 * Array of all overflow-wrap keyword values.
 *
 * @public
 */
export const OVERFLOW_WRAP_KEYWORDS = overflowWrapKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for overflow-wrap keywords.
 *
 * @public
 */
export type OverflowWrapKeyword = z.infer<typeof overflowWrapKeywordsSchema>;

/**
 * Metadata for overflow-wrap keyword options.
 *
 * @public
 */
export const overflowWrapKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Lines break only at normal break points",
	},
	anywhere: {
		value: "anywhere" as const,
		description: "Breaks at any character if no acceptable break point",
	},
	"break-word": {
		value: "break-word" as const,
		description: "Like anywhere but affects min-content size",
	},
} as const;


=== File: src/core/keywords/position-keywords.ts ===
// b_path:: src/core/keywords/position-keywords.ts
import { z } from "zod";

/**
 * CSS position keywords.
 *
 * Position keywords specify locations along horizontal and vertical axes.
 * Used extensively in properties like background-position, object-position,
 * transform-origin, and perspective-origin.
 *
 * Keywords can be combined in various ways:
 * - Single keyword: `center` (applies to both axes)
 * - Horizontal + vertical: `left top`, `center bottom`
 * - Edge + offset: `left 10px top 20px`
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionKeywordsSchema } from "../keywords/position-keywords";
 *
 * const keyword = positionKeywordsSchema.parse("center"); // "center"
 * ```
 *
 * @public
 */
export const positionKeywordsSchema = z
	.union([
		z.literal("center").describe("centered on both axes (50% 50%)"),
		z.literal("left").describe("left edge (0% on horizontal axis)"),
		z.literal("right").describe("right edge (100% on horizontal axis)"),
		z.literal("top").describe("top edge (0% on vertical axis)"),
		z.literal("bottom").describe("bottom edge (100% on vertical axis)"),
	])
	.describe(
		"Position keywords specify locations along horizontal and vertical axes. " +
			"Used in background-position, object-position, transform-origin, etc.",
	);

/**
 * Array of all position keyword values.
 *
 * @example
 * ```typescript
 * import { POSITION_KEYWORDS } from "../keywords/position-keywords";
 *
 * console.log(POSITION_KEYWORDS);
 * // ["center", "left", "right", "top", "bottom"]
 * ```
 *
 * @public
 */
export const POSITION_KEYWORDS = positionKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for position keywords.
 *
 * @public
 */
export type PositionKeyword = z.infer<typeof positionKeywordsSchema>;

/**
 * Metadata for position keyword options.
 *
 * Provides value and description for each position keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { positionKeywordOptions } from "../keywords/position-keywords";
 *
 * positionKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const positionKeywordOptions = positionKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for position keyword options metadata.
 *
 * @public
 */
export type PositionKeywordOptions = typeof positionKeywordOptions;

/**
 * CSS horizontal edge position keywords.
 *
 * Subset of position keywords that specify horizontal edges.
 * Used in four-value syntax for properties like background-position:
 * `right 10px bottom 20px` (edge + offset pairs)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionHorizontalEdgeKeywordsSchema } from "../keywords/position-keywords";
 *
 * const edge = positionHorizontalEdgeKeywordsSchema.parse("left"); // "left"
 * ```
 *
 * @public
 */
export const positionHorizontalEdgeKeywordsSchema = z
	.union([z.literal("left").describe("left horizontal edge"), z.literal("right").describe("right horizontal edge")])
	.describe("Horizontal edge position keywords (left, right) for edge+offset syntax.");

/**
 * Array of horizontal edge position keywords.
 *
 * @public
 */
export const POSITION_HORIZONTAL_EDGE_KEYWORDS = positionHorizontalEdgeKeywordsSchema.options.map(
	(option) => option.value,
);

/**
 * TypeScript type for horizontal edge position keywords.
 *
 * @public
 */
export type PositionHorizontalEdgeKeyword = z.infer<typeof positionHorizontalEdgeKeywordsSchema>;

/**
 * CSS vertical edge position keywords.
 *
 * Subset of position keywords that specify vertical edges.
 * Used in four-value syntax for properties like background-position:
 * `right 10px bottom 20px` (edge + offset pairs)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionVerticalEdgeKeywordsSchema } from "../keywords/position-keywords";
 *
 * const edge = positionVerticalEdgeKeywordsSchema.parse("top"); // "top"
 * ```
 *
 * @public
 */
export const positionVerticalEdgeKeywordsSchema = z
	.union([z.literal("top").describe("top vertical edge"), z.literal("bottom").describe("bottom vertical edge")])
	.describe("Vertical edge position keywords (top, bottom) for edge+offset syntax.");

/**
 * Array of vertical edge position keywords.
 *
 * @public
 */
export const POSITION_VERTICAL_EDGE_KEYWORDS = positionVerticalEdgeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for vertical edge position keywords.
 *
 * @public
 */
export type PositionVerticalEdgeKeyword = z.infer<typeof positionVerticalEdgeKeywordsSchema>;


=== File: src/core/keywords/repeat-keywords.ts ===
// b_path:: src/core/keywords/repeat-keywords.ts
import { z } from "zod";

/**
 * CSS background-repeat single value keywords.
 *
 * These keywords control how background images repeat along both axes.
 * Used in the single-value syntax of background-repeat.
 *
 * - `repeat`: Images repeat in both directions (tiles to fill area)
 * - `repeat-x`: Images repeat horizontally only (shorthand for `repeat no-repeat`)
 * - `repeat-y`: Images repeat vertically only (shorthand for `no-repeat repeat`)
 * - `no-repeat`: Images don't repeat (displayed once)
 * - `space`: Images repeat with spacing between them to fill area exactly
 * - `round`: Images repeat and scale to fill area without clipping
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat}
 *
 * @example
 * ```typescript
 * import { repeatKeywordsSchema } from "../keywords/repeat-keywords";
 *
 * const keyword = repeatKeywordsSchema.parse("repeat-x"); // "repeat-x"
 * ```
 *
 * @public
 */
export const repeatKeywordsSchema = z
	.union([
		z.literal("repeat").describe("repeat in both directions"),
		z.literal("repeat-x").describe("repeat horizontally only"),
		z.literal("repeat-y").describe("repeat vertically only"),
		z.literal("no-repeat").describe("do not repeat"),
		z.literal("space").describe("repeat with spacing to fill area exactly"),
		z.literal("round").describe("repeat and scale to fill area without clipping"),
	])
	.describe(
		"Keywords for background-repeat single value syntax. " + "Controls how background images repeat along both axes.",
	);

/**
 * Array of all repeat keyword values.
 *
 * @example
 * ```typescript
 * import { REPEAT_KEYWORDS } from "../keywords/repeat-keywords";
 *
 * console.log(REPEAT_KEYWORDS);
 * // ["repeat", "repeat-x", "repeat-y", "no-repeat", "space", "round"]
 * ```
 *
 * @public
 */
export const REPEAT_KEYWORDS = repeatKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for repeat keywords.
 *
 * @public
 */
export type RepeatKeyword = z.infer<typeof repeatKeywordsSchema>;

/**
 * Metadata for repeat keyword options.
 *
 * Provides value and description for each repeat keyword,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { repeatKeywordOptions } from "../keywords/repeat-keywords";
 *
 * repeatKeywordOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const repeatKeywordOptions = repeatKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for repeat keyword options metadata.
 *
 * @public
 */
export type RepeatKeywordOptions = typeof repeatKeywordOptions;

/**
 * CSS background-repeat two-value keywords.
 *
 * Subset of repeat keywords valid in two-value syntax.
 * Used to specify separate horizontal and vertical repeat behavior.
 *
 * Note: `repeat-x` and `repeat-y` are NOT valid in two-value syntax
 * as they are themselves shorthand for two-value combinations:
 * - `repeat-x` = `repeat no-repeat`
 * - `repeat-y` = `no-repeat repeat`
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat}
 *
 * @example
 * ```typescript
 * import { repeatTwoValueKeywordsSchema } from "../keywords/repeat-keywords";
 *
 * // Valid in two-value syntax
 * const horizontal = repeatTwoValueKeywordsSchema.parse("repeat"); // "repeat"
 * const vertical = repeatTwoValueKeywordsSchema.parse("space"); // "space"
 *
 * // Invalid in two-value syntax (would fail validation)
 * // repeatTwoValueKeywordsSchema.parse("repeat-x"); // Error!
 * ```
 *
 * @public
 */
export const repeatTwoValueKeywordsSchema = z
	.union([
		z.literal("repeat").describe("repeat along axis"),
		z.literal("space").describe("repeat with spacing along axis"),
		z.literal("round").describe("repeat and scale along axis"),
		z.literal("no-repeat").describe("do not repeat along axis"),
	])
	.describe(
		"Keywords for background-repeat two-value syntax (horizontal/vertical). " +
			"Note: repeat-x and repeat-y are not valid in two-value syntax.",
	);

/**
 * Array of two-value repeat keywords.
 *
 * @public
 */
export const REPEAT_TWO_VALUE_KEYWORDS = repeatTwoValueKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for two-value repeat keywords.
 *
 * @public
 */
export type RepeatTwoValueKeyword = z.infer<typeof repeatTwoValueKeywordsSchema>;

/**
 * Metadata for two-value repeat keyword options.
 *
 * @public
 */
export const repeatTwoValueKeywordOptions = repeatTwoValueKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for two-value repeat keyword options metadata.
 *
 * @public
 */
export type RepeatTwoValueKeywordOptions = typeof repeatTwoValueKeywordOptions;


=== File: src/core/keywords/shape-keywords.ts ===
// b_path:: src/core/keywords/shape-keywords.ts
import { z } from "zod";

/**
 * CSS shape radius keywords for circles and ellipses.
 *
 * Shape radius keywords specify the radius of circles and ellipses relative to the reference box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape}
 * @public
 */
export const shapeRadiusKeywordsSchema = z
	.union([
		z.literal("closest-side").describe("length from center to closest side of reference box"),
		z.literal("farthest-side").describe("length from center to farthest side of reference box"),
	])
	.describe("Shape radius keywords for circles and ellipses");

/**
 * Array of all shape radius keyword values.
 *
 * @public
 */
export const SHAPE_RADIUS_KEYWORDS = shapeRadiusKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for shape radius keywords.
 *
 * @public
 */
export type ShapeRadiusKeyword = z.infer<typeof shapeRadiusKeywordsSchema>;

/**
 * CSS fill-rule keywords.
 *
 * Fill rule determines how the interior of shapes is filled.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule}
 * @public
 */
export const fillRuleKeywordsSchema = z
	.union([
		z.literal("nonzero").describe("nonzero winding rule (default)"),
		z.literal("evenodd").describe("even-odd winding rule"),
	])
	.describe("Fill rule determines how interior of shapes is filled");

/**
 * Array of all fill-rule keyword values.
 *
 * @public
 */
export const FILL_RULE_KEYWORDS = fillRuleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for fill-rule keywords.
 *
 * @public
 */
export type FillRuleKeyword = z.infer<typeof fillRuleKeywordsSchema>;

/**
 * CSS basic shape function keywords.
 *
 * Basic shape functions create geometric shapes for use in clip-path, shape-outside,
 * and other CSS properties.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/basic-shape}
 * @public
 */
export const basicShapeKeywordsSchema = z
	.union([
		z.literal("inset").describe("rectangle by container inset"),
		z.literal("circle").describe("circular shape"),
		z.literal("ellipse").describe("elliptical shape"),
		z.literal("polygon").describe("polygonal shape with multiple points"),
		z.literal("path").describe("custom path shape"),
		z.literal("rect").describe("rectangle by coordinates"),
		z.literal("xywh").describe("rectangle by x, y, width, height"),
	])
	.describe(
		"Basic shape functions for creating geometric shapes. " +
			"Used in clip-path, shape-outside, and other CSS properties.",
	);

/**
 * Array of all basic shape keyword values.
 *
 * @public
 */
export const BASIC_SHAPE_KEYWORDS = basicShapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for basic shape keywords.
 *
 * @public
 */
export type BasicShapeKeyword = z.infer<typeof basicShapeKeywordsSchema>;

/**
 * Combined CSS shape keywords.
 *
 * Includes basic shapes, shape radius keywords, and fill rules.
 *
 * @public
 */
export const shapeKeywordsSchema = z
	.union([
		// Basic shapes
		z
			.literal("inset")
			.describe("rectangle by container inset"),
		z.literal("circle").describe("circular shape"),
		z.literal("ellipse").describe("elliptical shape"),
		z.literal("polygon").describe("polygonal shape with multiple points"),
		z.literal("path").describe("custom path shape"),
		z.literal("rect").describe("rectangle by coordinates"),
		z.literal("xywh").describe("rectangle by x, y, width, height"),

		// Shape radius
		z
			.literal("closest-side")
			.describe("length from center to closest side of reference box"),
		z.literal("farthest-side").describe("length from center to farthest side of reference box"),

		// Fill rules
		z
			.literal("nonzero")
			.describe("nonzero winding rule (default)"),
		z.literal("evenodd").describe("even-odd winding rule"),
	])
	.describe("CSS shape-related keywords");

/**
 * Array of all shape keyword values.
 *
 * @public
 */
export const SHAPE_KEYWORDS = shapeKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for shape keywords.
 *
 * @public
 */
export type ShapeKeyword = z.infer<typeof shapeKeywordsSchema>;

/**
 * Metadata for shape keyword options.
 *
 * @public
 */
export const shapeKeywordOptions = shapeKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for shape keyword options metadata.
 *
 * @public
 */
export type ShapeKeywordOptions = typeof shapeKeywordOptions;


=== File: src/core/keywords/sizing-keywords.ts ===
// b_path:: src/core/keywords/sizing-keywords.ts
import { z } from "zod";

/**
 * CSS sizing keywords for properties like `background-size`, `object-fit`, etc.
 *
 * These keywords control how content is sized to fit its container.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit}
 *
 * @example
 * ```typescript
 * import { sizingKeywordsSchema } from "../keywords/sizing-keywords";
 *
 * // Parse and validate
 * const size = sizingKeywordsSchema.parse("cover"); // "cover"
 *
 * // Use in background-size
 * const backgroundSize = "contain";
 * ```
 *
 * @public
 */
export const sizingKeywordsSchema = z
	.union([
		z.literal("cover").describe("scale content to cover container (may crop to maintain aspect ratio)"),
		z
			.literal("contain")
			.describe("scale content to fit inside container (maintains aspect ratio, may have empty space)"),
	])
	.describe("sizing keywords that control how content is sized to fit its container");

/**
 * TypeScript type for sizing keywords.
 *
 * @public
 */
export type SizingKeyword = z.infer<typeof sizingKeywordsSchema>;

/**
 * Array of all valid sizing keyword values.
 *
 * Extracted from the schema for runtime iteration.
 *
 * @example
 * ```typescript
 * import { SIZING_KEYWORDS } from "../keywords/sizing-keywords";
 *
 * // Iterate over keywords
 * SIZING_KEYWORDS.forEach(keyword => {
 *   console.log(keyword); // "cover", "contain"
 * });
 *
 * // Check if value is valid
 * if (SIZING_KEYWORDS.includes(input)) {
 *   // Valid sizing keyword
 * }
 * ```
 *
 * @public
 */
export const SIZING_KEYWORDS = sizingKeywordsSchema.options.map((option) => option.value);

/**
 * Metadata for sizing keywords including descriptions.
 *
 * Provides both value and description for each keyword option,
 * useful for generating Studio UI select menus or documentation.
 *
 * @example
 * ```typescript
 * import { sizingKeywordOptions } from "../keywords/sizing-keywords";
 *
 * // Generate UI options
 * sizingKeywordOptions.forEach(({ value, description }) => {
 *   <Option value={value} tooltip={description} />
 * });
 * ```
 *
 * @public
 */
export const sizingKeywordOptions = sizingKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for sizing keyword options metadata array.
 *
 * @public
 */
export type SizingKeywordOptions = typeof sizingKeywordOptions;


=== File: src/core/keywords/text-align-keywords.ts ===
// b_path:: src/core/keywords/text-align-keywords.ts
import { z } from "zod";

/**
 * CSS text-align keyword values.
 *
 * The text-align property sets the horizontal alignment of the inline-level content
 * inside a block element or table-cell box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-align}
 *
 * @example
 * ```typescript
 * import { textAlignKeywordsSchema } from "../keywords/text-align-keywords";
 *
 * const keyword = textAlignKeywordsSchema.parse("center");
 * ```
 *
 * @public
 */
export const textAlignKeywordsSchema = z
	.union([
		z.literal("left").describe("inline contents aligned to left edge"),
		z.literal("right").describe("inline contents aligned to right edge"),
		z.literal("center").describe("inline contents centered"),
		z.literal("justify").describe("inline contents justified (text spaced to fill line)"),
		z.literal("start").describe("aligned to start edge of writing mode direction"),
		z.literal("end").describe("aligned to end edge of writing mode direction"),
	])
	.describe("CSS text-align property keyword values");

/**
 * Array of all text-align keyword values.
 *
 * @public
 */
export const TEXT_ALIGN_KEYWORDS = textAlignKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-align keywords.
 *
 * @public
 */
export type TextAlignKeyword = z.infer<typeof textAlignKeywordsSchema>;

/**
 * Metadata for text-align keyword options.
 *
 * @public
 */
export const textAlignKeywordOptions = textAlignKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-align keyword options metadata.
 *
 * @public
 */
export type TextAlignKeywordOptions = typeof textAlignKeywordOptions;


=== File: src/core/keywords/text-decoration-line-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-line-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-line keyword values.
 *
 * The text-decoration-line property sets the kind of decoration that is used on text
 * in an element, such as an underline or overline.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-line}
 *
 * @example
 * ```typescript
 * import { textDecorationLineKeywordsSchema } from "../keywords/text-decoration-line-keywords";
 *
 * const keyword = textDecorationLineKeywordsSchema.parse("underline");
 * ```
 *
 * @public
 */
export const textDecorationLineKeywordsSchema = z
	.union([
		z.literal("none").describe("no text decoration"),
		z.literal("underline").describe("line below the text"),
		z.literal("overline").describe("line above the text"),
		z.literal("line-through").describe("line through the middle of the text"),
	])
	.describe("CSS text-decoration-line property keyword values");

/**
 * Array of all text-decoration-line keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_LINE_KEYWORDS = textDecorationLineKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-decoration-line keywords.
 *
 * @public
 */
export type TextDecorationLineKeyword = z.infer<typeof textDecorationLineKeywordsSchema>;

/**
 * Metadata for text-decoration-line keyword options.
 *
 * @public
 */
export const textDecorationLineKeywordOptions = textDecorationLineKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-line keyword options metadata.
 *
 * @public
 */
export type TextDecorationLineKeywordOptions = typeof textDecorationLineKeywordOptions;


=== File: src/core/keywords/text-decoration-style-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-style-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-style keyword values.
 *
 * The text-decoration-style property sets the style of the lines specified
 * by text-decoration-line.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-style}
 *
 * @public
 */
export const textDecorationStyleKeywordsSchema = z
	.union([
		z.literal("solid").describe("single line"),
		z.literal("double").describe("double line"),
		z.literal("dotted").describe("dotted line"),
		z.literal("dashed").describe("dashed line"),
		z.literal("wavy").describe("wavy line"),
	])
	.describe("CSS text-decoration-style property keyword values");

/**
 * Array of all text-decoration-style keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_STYLE_KEYWORDS = textDecorationStyleKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-decoration-style keywords.
 *
 * @public
 */
export type TextDecorationStyleKeyword = z.infer<typeof textDecorationStyleKeywordsSchema>;

/**
 * Metadata for text-decoration-style keyword options.
 *
 * @public
 */
export const textDecorationStyleKeywordOptions = textDecorationStyleKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-style keyword options metadata.
 *
 * @public
 */
export type TextDecorationStyleKeywordOptions = typeof textDecorationStyleKeywordOptions;


=== File: src/core/keywords/text-decoration-thickness-keywords.ts ===
// b_path:: src/core/keywords/text-decoration-thickness-keywords.ts
import { z } from "zod";

/**
 * CSS text-decoration-thickness keyword values.
 *
 * The text-decoration-thickness property sets the thickness of the decoration
 * line used on text.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration-thickness}
 *
 * @public
 */
export const textDecorationThicknessKeywordsSchema = z
	.union([
		z.literal("auto").describe("browser chooses thickness"),
		z.literal("from-font").describe("use thickness from font file"),
	])
	.describe("CSS text-decoration-thickness property keyword values");

/**
 * Array of all text-decoration-thickness keyword values.
 *
 * @public
 */
export const TEXT_DECORATION_THICKNESS_KEYWORDS = textDecorationThicknessKeywordsSchema.options.map(
	(option) => option.value,
);

/**
 * TypeScript type for text-decoration-thickness keywords.
 *
 * @public
 */
export type TextDecorationThicknessKeyword = z.infer<typeof textDecorationThicknessKeywordsSchema>;

/**
 * Metadata for text-decoration-thickness keyword options.
 *
 * @public
 */
export const textDecorationThicknessKeywordOptions = textDecorationThicknessKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-decoration-thickness keyword options metadata.
 *
 * @public
 */
export type TextDecorationThicknessKeywordOptions = typeof textDecorationThicknessKeywordOptions;


=== File: src/core/keywords/text-transform-keywords.ts ===
// b_path:: src/core/keywords/text-transform-keywords.ts
import { z } from "zod";

/**
 * CSS text-transform keyword values.
 *
 * The text-transform property specifies how to capitalize an element's text.
 * It can be used to make text appear in all-uppercase or all-lowercase, or with
 * each word capitalized.
 *
 * Includes CSS Text Level 4 values for CJK (Chinese/Japanese/Korean) typography support.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform}
 * @see {@link https://www.w3.org/TR/css-text-4/#text-transform-property}
 *
 * @example
 * ```typescript
 * import { textTransformKeywordsSchema } from "../keywords/text-transform-keywords";
 *
 * const keyword = textTransformKeywordsSchema.parse("uppercase");
 * ```
 *
 * @public
 */
export const textTransformKeywordsSchema = z
	.union([
		z.literal("none").describe("no capitalization, text renders as is"),
		z.literal("capitalize").describe("first letter of each word capitalized"),
		z.literal("uppercase").describe("all characters converted to uppercase"),
		z.literal("lowercase").describe("all characters converted to lowercase"),
		z.literal("full-width").describe("transforms characters to their fullwidth forms (CJK typography)"),
		z.literal("full-size-kana").describe("converts small Kana to full-size characters (Japanese typography)"),
	])
	.describe("CSS text-transform property keyword values (includes CSS Text Level 4 values)");

/**
 * Array of all text-transform keyword values.
 *
 * @public
 */
export const TEXT_TRANSFORM_KEYWORDS = textTransformKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for text-transform keywords.
 *
 * @public
 */
export type TextTransformKeyword = z.infer<typeof textTransformKeywordsSchema>;

/**
 * Metadata for text-transform keyword options.
 *
 * @public
 */
export const textTransformKeywordOptions = textTransformKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for text-transform keyword options metadata.
 *
 * @public
 */
export type TextTransformKeywordOptions = typeof textTransformKeywordOptions;


=== File: src/core/keywords/vertical-align-keywords.ts ===
// b_path:: src/core/keywords/vertical-align-keywords.ts
import { z } from "zod";

/**
 * CSS vertical-align keyword values.
 *
 * The vertical-align property sets vertical alignment of an inline, inline-block
 * or table-cell box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/vertical-align}
 *
 * @public
 */
export const verticalAlignKeywordsSchema = z
	.union([
		z.literal("baseline").describe("align baseline with parent baseline"),
		z.literal("sub").describe("align baseline with parent subscript baseline"),
		z.literal("super").describe("align baseline with parent superscript baseline"),
		z.literal("text-top").describe("align top with parent font top"),
		z.literal("text-bottom").describe("align bottom with parent font bottom"),
		z.literal("middle").describe("align middle with parent baseline plus half x-height"),
		z.literal("top").describe("align top with line top"),
		z.literal("bottom").describe("align bottom with line bottom"),
	])
	.describe("CSS vertical-align property keyword values");

/**
 * Array of all vertical-align keyword values.
 *
 * @public
 */
export const VERTICAL_ALIGN_KEYWORDS = verticalAlignKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for vertical-align keywords.
 *
 * @public
 */
export type VerticalAlignKeyword = z.infer<typeof verticalAlignKeywordsSchema>;

/**
 * Metadata for vertical-align keyword options.
 *
 * @public
 */
export const verticalAlignKeywordOptions = verticalAlignKeywordsSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for vertical-align keyword options metadata.
 *
 * @public
 */
export type VerticalAlignKeywordOptions = typeof verticalAlignKeywordOptions;


=== File: src/core/keywords/white-space-keywords.ts ===
// b_path:: src/core/keywords/white-space-keywords.ts
import { z } from "zod";

/**
 * CSS white-space keyword values.
 *
 * The white-space property sets how white space inside an element is handled.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/white-space}
 *
 * @example
 * ```typescript
 * import { whiteSpaceKeywordsSchema } from "../keywords/white-space-keywords";
 *
 * const keyword = whiteSpaceKeywordsSchema.parse("nowrap");
 * ```
 *
 * @public
 */
export const whiteSpaceKeywordsSchema = z
	.union([
		z.literal("normal").describe("sequences of whitespace collapsed, newlines ignored"),
		z.literal("nowrap").describe("collapses whitespace, prevents wrapping"),
		z.literal("pre").describe("preserves whitespace and newlines, no wrapping"),
		z.literal("pre-wrap").describe("preserves whitespace and newlines, wraps normally"),
		z.literal("pre-line").describe("collapses whitespace, preserves newlines, wraps normally"),
		z.literal("break-spaces").describe("like pre-wrap but preserves sequences of spaces"),
	])
	.describe("CSS white-space property keyword values");

/**
 * Array of all white-space keyword values.
 *
 * @public
 */
export const WHITE_SPACE_KEYWORDS = whiteSpaceKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for white-space keywords.
 *
 * @public
 */
export type WhiteSpaceKeyword = z.infer<typeof whiteSpaceKeywordsSchema>;

/**
 * Metadata for white-space keyword options.
 *
 * @public
 */
export const whiteSpaceKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Sequences of whitespace collapsed, newlines ignored",
	},
	nowrap: {
		value: "nowrap" as const,
		description: "Collapses whitespace, prevents wrapping",
	},
	pre: {
		value: "pre" as const,
		description: "Preserves whitespace and newlines, no wrapping",
	},
	"pre-wrap": {
		value: "pre-wrap" as const,
		description: "Preserves whitespace and newlines, wraps normally",
	},
	"pre-line": {
		value: "pre-line" as const,
		description: "Collapses whitespace, preserves newlines, wraps normally",
	},
	"break-spaces": {
		value: "break-spaces" as const,
		description: "Like pre-wrap but preserves sequences of spaces",
	},
} as const;


=== File: src/core/keywords/word-break-keywords.ts ===
// b_path:: src/core/keywords/word-break-keywords.ts
import { z } from "zod";

/**
 * CSS word-break keyword values.
 *
 * The word-break property sets whether line breaks appear wherever the text would
 * otherwise overflow its content box.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/word-break}
 *
 * @example
 * ```typescript
 * import { wordBreakKeywordsSchema } from "../keywords/word-break-keywords";
 *
 * const keyword = wordBreakKeywordsSchema.parse("break-all");
 * ```
 *
 * @public
 */
export const wordBreakKeywordsSchema = z
	.union([
		z.literal("normal").describe("default line break rules"),
		z.literal("break-all").describe("breaks can be inserted between any characters"),
		z.literal("keep-all").describe("breaks prohibited between CJK characters"),
		z.literal("break-word").describe("like word-break: normal with overflow-wrap: anywhere"),
	])
	.describe("CSS word-break property keyword values");

/**
 * Array of all word-break keyword values.
 *
 * @public
 */
export const WORD_BREAK_KEYWORDS = wordBreakKeywordsSchema.options.map((option) => option.value);

/**
 * TypeScript type for word-break keywords.
 *
 * @public
 */
export type WordBreakKeyword = z.infer<typeof wordBreakKeywordsSchema>;

/**
 * Metadata for word-break keyword options.
 *
 * @public
 */
export const wordBreakKeywordsMetadata = {
	normal: {
		value: "normal" as const,
		description: "Default line break rules",
	},
	"break-all": {
		value: "break-all" as const,
		description: "Breaks can be inserted between any characters",
	},
	"keep-all": {
		value: "keep-all" as const,
		description: "Breaks prohibited between CJK characters",
	},
	"break-word": {
		value: "break-word" as const,
		description: "Like word-break: normal with overflow-wrap: anywhere",
	},
} as const;


=== File: src/core/result.ts ===
// b_path:: src/core/result.ts

/**
 * Result type for operations that may fail.
 *
 * Provides a type-safe way to handle errors without throwing exceptions.
 * Inspired by Rust's Result<T, E> and functional programming patterns.
 *
 * Supports destructuring for convenient access:
 * - `ok: true` → `value` is available, `error` is undefined
 * - `ok: false` → `error` is available, `value` is undefined
 *
 * @example
 * ```typescript
 * import { Result, ok, err } from "../result";
 *
 * function divide(a: number, b: number): Result<number, string> {
 *   if (b === 0) return err("Division by zero");
 *   return ok(a / b);
 * }
 *
 * const { ok, value, error } = divide(10, 2);
 * if (ok) {
 *   console.log(value); // 5 (type: number)
 * } else {
 *   console.error(error); // string
 * }
 * ```
 *
 * @public
 */
export type Result<T, E = Error> = { ok: true; value: T; error: undefined } | { ok: false; value: undefined; error: E };

/**
 * Create a successful result.
 *
 * @example
 * ```typescript
 * const result = ok(42);
 * console.log(result.ok); // true
 * console.log(result.value); // 42
 * console.log(result.error); // undefined
 * ```
 *
 * @public
 */
export function ok<T>(value: T): Result<T, never> {
	return { ok: true, value, error: undefined };
}

/**
 * Create an error result.
 *
 * @example
 * ```typescript
 * const result = err("Something went wrong");
 * console.log(result.ok); // false
 * console.log(result.error); // "Something went wrong"
 * console.log(result.value); // undefined
 * ```
 *
 * @public
 */
export function err<E>(error: E): Result<never, E> {
	return { ok: false, value: undefined, error };
}

/**
 * Convert a Zod SafeParseReturnType to a Result.
 *
 * @example
 * ```typescript
 * import { z } from "zod";
 * import { fromZod } from "../result";
 *
 * const schema = z.number();
 * const zodResult = schema.safeParse("not a number");
 * const result = fromZod(zodResult);
 *
 * if (!result.ok) {
 *   console.error(result.error); // ZodError
 * }
 * ```
 *
 * @public
 */
export function fromZod<T, E = unknown>(
	zodResult: { success: true; data: T } | { success: false; error: E },
): Result<T, E> {
	if (zodResult.success) {
		return ok(zodResult.data);
	}
	return err(zodResult.error);
}

/**
 * Unwrap a result, throwing if it's an error.
 * Use sparingly - prefer explicit error handling.
 *
 * @example
 * ```typescript
 * const result = ok(42);
 * const value = unwrap(result); // 42
 *
 * const errorResult = err("Failed");
 * unwrap(errorResult); // throws Error("Failed")
 * ```
 *
 * @public
 */
export function unwrap<T, E>(result: Result<T, E>): T {
	if (result.ok) {
		return result.value;
	}
	throw result.error instanceof Error ? result.error : new Error(String(result.error));
}

/**
 * Get the value or a default if error.
 *
 * @example
 * ```typescript
 * const result = err("Failed");
 * const value = unwrapOr(result, 42); // 42
 * ```
 *
 * @public
 */
export function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {
	return result.ok ? result.value : defaultValue;
}

/**
 * Map over a successful result.
 *
 * @example
 * ```typescript
 * const result = ok(2);
 * const doubled = map(result, x => x * 2);
 * console.log(doubled.value); // 4
 * ```
 *
 * @public
 */
export function map<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E> {
	return result.ok ? ok(fn(result.value)) : result;
}

/**
 * Chain results together (flatMap).
 *
 * @example
 * ```typescript
 * const result = ok(2);
 * const doubled = andThen(result, x =>
 *   x > 0 ? ok(x * 2) : err("Must be positive")
 * );
 * ```
 *
 * @public
 */
export function andThen<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E> {
	return result.ok ? fn(result.value) : result;
}


=== File: src/core/types/angle.ts ===
// b_path:: src/core/types/angle.ts
import { z } from "zod";
import * as Unit from "../units";

/**
 * CSS `<angle>` dimension.
 *
 * An angle is a rotation measurement consisting of a number and an angle unit.
 * Used in transforms, gradients, and other CSS properties requiring angular measurements.
 *
 * Per CSS Values & Units Module Level 4 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/angle}
 * @see {@link https://www.w3.org/TR/css-values-4/#angles}
 *
 * @example
 * ```typescript
 * import { angleSchema } from "../types/angle";
 *
 * const rotation: Angle = { value: 45, unit: "deg" };
 * const fullCircle: Angle = { value: 360, unit: "deg" };
 * const radians: Angle = { value: 1.57, unit: "rad" };
 * ```
 *
 * @public
 */
export const angleSchema = z.object({
	value: z.number(),
	unit: Unit.angleUnitSchema,
});

/**
 * TypeScript type for `<angle>` dimension.
 *
 * @public
 */
export type Angle = z.infer<typeof angleSchema>;


=== File: src/core/types/border.ts ===
// b_path:: src/core/types/border.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthSchema } from "./length-percentage";

/**
 * CSS <border-width> data type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-width}
 * @public
 */
export const borderWidthSchema = z.union([lengthSchema, Keyword.borderWidthKeywordsSchema]);

/**
 * CSS <border-style> data type.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-style}
 * @public
 */
export const borderStyleSchema = Keyword.borderStyleKeywordsSchema;

/**
 * CSS <color> data type for borders.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/border-color}
 * @public
 */
export const borderColorSchema = Keyword.colorValueKeywordsSchema;

/**
 * Side specification for multi-side operations.
 * Optional - when omitted, applies to all sides.
 *
 * @public
 */
export const borderSidesSchema = z.array(z.enum(["top", "right", "bottom", "left"])).optional();

/**
 * Unified border specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying complete borders to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { width: { value: 1, unit: "px" }, style: "solid", color: "red" }
 *
 * // Specific sides
 * { sides: ["top"], width: { value: 2, unit: "px" }, style: "dashed", color: "blue" }
 * ```
 *
 * @public
 */
export const unifiedBorderSchema = z.object({
	sides: borderSidesSchema,
	width: borderWidthSchema,
	style: borderStyleSchema,
	color: borderColorSchema,
});

export type BorderWidth = z.infer<typeof borderWidthSchema>;
export type BorderStyle = z.infer<typeof borderStyleSchema>;
export type BorderColor = z.infer<typeof borderColorSchema>;
export type BorderSides = z.infer<typeof borderSidesSchema>;
export type UnifiedBorder = z.infer<typeof unifiedBorderSchema>;


=== File: src/core/types/box-model.ts ===
// b_path:: src/core/types/box-model.ts
import { z } from "zod";
import { lengthPercentageAutoSchema, lengthPercentageSchema } from "./length-percentage";

/**
 * Side specification for multi-side operations.
 * Optional - when omitted, applies to all sides.
 *
 * @public
 */
export const boxSidesSchema = z.array(z.enum(["top", "right", "bottom", "left"])).optional();

/**
 * Unified margin specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying margins to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { value: 10, unit: "px" }
 *
 * // Specific sides
 * { sides: ["top", "bottom"], value: 20, unit: "px" }
 * ```
 *
 * @public
 */
export const unifiedMarginSchema = z.object({
	sides: boxSidesSchema,
	value: lengthPercentageAutoSchema,
});

/**
 * Unified padding specification.
 *
 * NOT a CSS spec type - this is a convenience type for
 * applying padding to one or more sides programmatically.
 *
 * @example
 * ```typescript
 * // All sides
 * { value: 10, unit: "px" }
 *
 * // Specific sides
 * { sides: ["left", "right"], value: 15, unit: "px" }
 * ```
 *
 * @public
 */
export const unifiedPaddingSchema = z.object({
	sides: boxSidesSchema,
	value: lengthPercentageSchema,
});

export type BoxSides = z.infer<typeof boxSidesSchema>;
export type UnifiedMargin = z.infer<typeof unifiedMarginSchema>;
export type UnifiedPadding = z.infer<typeof unifiedPaddingSchema>;


=== File: src/core/types/color-stop.ts ===
// b_path:: src/core/types/color-stop.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthPercentageSchema } from "./length-percentage";

/**
 * CSS color stop value.
 *
 * A color stop consists of a color value and an optional position.
 * Used in CSS gradients and other color-based properties.
 *
 * Per CSS spec: <color-stop> = <color> [ <length-percentage> ]?
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient}
 *
 * @example
 * ```typescript
 * import { colorStopSchema } from "../types/color-stop";
 *
 * // Color only
 * const stop1: ColorStop = { color: "red" };
 *
 * // Color with percentage position
 * const stop2: ColorStop = {
 *   color: "blue",
 *   position: { value: 50, unit: "%" }
 * };
 *
 * // Color with length position
 * const stop3: ColorStop = {
 *   color: "rgba(255, 0, 0, 0.5)",
 *   position: { value: 10, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const colorStopSchema = z.object({
	color: Keyword.colorValueKeywordsSchema.describe("color value for the stop"),
	position: lengthPercentageSchema.optional().describe("optional position of the color stop"),
});

/**
 * TypeScript type for color stop.
 * @public
 */
export type ColorStop = z.infer<typeof colorStopSchema>;

/**
 * CSS color stop list.
 *
 * An array of color stops used in gradients and other multi-stop color properties.
 * Must contain at least 2 color stops for valid gradients.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient}
 *
 * @example
 * ```typescript
 * import { colorStopListSchema } from "../types/color-stop";
 *
 * const stops: ColorStopList = [
 *   { color: "red" },
 *   { color: "yellow", position: { value: 50, unit: "%" } },
 *   { color: "blue" }
 * ];
 * ```
 *
 * @public
 */
export const colorStopListSchema = z
	.array(colorStopSchema)
	.min(2, "Color stop list must contain at least 2 stops")
	.describe("array of color stops for gradients and multi-stop color properties");

/**
 * TypeScript type for color stop list.
 * @public
 */
export type ColorStopList = z.infer<typeof colorStopListSchema>;


=== File: src/core/types/gradient/conic.ts ===
// b_path:: src/core/types/gradient/conic.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import { angleSchema } from "../angle";
import { colorStopListSchema } from "../color-stop";
import { position2DSchema } from "../position";

/**
 * CSS conic gradient value.
 *
 * A conic gradient transitions colors progressively around a center point.
 * The gradient sweeps in a circular arc, starting from a specified angle.
 * It can have optional starting angle, position, color interpolation method,
 * and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 4 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient}
 * @see {@link https://www.w3.org/TR/css-images-4/#conic-gradients}
 *
 * @example
 * ```typescript
 * import { conicGradientSchema } from "../gradient/conic";
 *
 * // Simple conic gradient (defaults to starting from top, center position)
 * const grad1: ConicGradient = {
 *   kind: "conic",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With starting angle
 * const grad2: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 45, unit: "deg" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // At specific position
 * const grad3: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 0, unit: "deg" },
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With color interpolation
 * const grad4: ConicGradient = {
 *   kind: "conic",
 *   fromAngle: { value: 90, unit: "deg" },
 *   position: { horizontal: "center", vertical: "center" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "deg" } },
 *     { color: "yellow", position: { value: 120, unit: "deg" } },
 *     { color: "blue", position: { value: 240, unit: "deg" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating conic gradient
 * const grad5: ConicGradient = {
 *   kind: "conic",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 45, unit: "deg" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const conicGradientSchema = z.object({
	kind: z.literal("conic"),
	fromAngle: angleSchema.optional().describe("starting angle (default: 0deg from top)"),
	position: position2DSchema.optional().describe("gradient center position (default: center)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for conic gradient.
 *
 * @public
 */
export type ConicGradient = z.infer<typeof conicGradientSchema>;


=== File: src/core/types/gradient/direction.ts ===
// b_path:: src/core/types/gradient/direction.ts
import { z } from "zod";
import * as Type from "..";

/**
 * CSS gradient direction value.
 *
 * Specifies the direction of a linear gradient. Can be an angle,
 * a side keyword (to top, to right, etc.), or a corner keyword
 * (to top left, to bottom right, etc.).
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients}
 *
 * @example
 * ```typescript
 * import { gradientDirectionSchema } from "../gradient/direction";
 *
 * // Angle direction
 * const dir1: GradientDirection = {
 *   kind: "angle",
 *   value: { value: 45, unit: "deg" }
 * };
 *
 * // Side direction
 * const dir2: GradientDirection = {
 *   kind: "to-side",
 *   value: "right"
 * };
 *
 * // Corner direction
 * const dir3: GradientDirection = {
 *   kind: "to-corner",
 *   value: "top right"
 * };
 * ```
 *
 * @public
 */
export const gradientDirectionSchema = z.union([
	z.object({
		kind: z.literal("angle"),
		value: Type.angleSchema,
	}),
	z.object({
		kind: z.literal("to-side"),
		value: z.union([z.literal("top"), z.literal("right"), z.literal("bottom"), z.literal("left")]),
	}),
	z.object({
		kind: z.literal("to-corner"),
		value: z.union([
			z.literal("top left"),
			z.literal("top right"),
			z.literal("bottom left"),
			z.literal("bottom right"),
		]),
	}),
]);

/**
 * TypeScript type for gradient direction.
 *
 * @public
 */
export type GradientDirection = z.infer<typeof gradientDirectionSchema>;


=== File: src/core/types/gradient/index.ts ===
// b_path:: src/core/types/gradient/index.ts

export * from "./conic";
export * from "./direction";
export * from "./linear";
export * from "./radial";
export * from "./radial-shape";
export * from "./radial-size";


=== File: src/core/types/gradient/linear.ts ===
// b_path:: src/core/types/gradient/linear.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import * as Type from "..";
import { gradientDirectionSchema } from "./direction";

/**
 * CSS linear gradient value.
 *
 * A linear gradient transitions colors progressively along a straight line.
 * The gradient can have an optional direction (angle or side/corner keyword),
 * optional color interpolation method, and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#linear-gradients}
 *
 * @example
 * ```typescript
 * import { linearGradientSchema } from "../gradient/linear";
 *
 * // Simple gradient (defaults to top to bottom)
 * const grad1: LinearGradient = {
 *   kind: "linear",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With angle direction
 * const grad2: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With color interpolation
 * const grad3: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "to-side", value: "right" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating gradient
 * const grad4: LinearGradient = {
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const linearGradientSchema = z.object({
	kind: z.literal("linear"),
	direction: gradientDirectionSchema.optional().describe("gradient direction (default: to bottom)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: Type.colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for linear gradient.
 *
 * @public
 */
export type LinearGradient = z.infer<typeof linearGradientSchema>;


=== File: src/core/types/gradient/radial-shape.ts ===
// b_path:: src/core/types/gradient/radial-shape.ts
import { z } from "zod";

/**
 * CSS radial gradient shape value.
 *
 * Specifies the shape of a radial gradient. Can be either a circle or an ellipse.
 * If omitted in CSS, the shape is inferred from the size specification.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients}
 *
 * @example
 * ```typescript
 * import { radialGradientShapeSchema } from "../gradient/radial-shape";
 *
 * const shape1: RadialGradientShape = "circle";
 * const shape2: RadialGradientShape = "ellipse";
 * ```
 *
 * @public
 */
export const radialGradientShapeSchema = z.union([z.literal("circle"), z.literal("ellipse")]);

/**
 * TypeScript type for radial gradient shape.
 *
 * @public
 */
export type RadialGradientShape = z.infer<typeof radialGradientShapeSchema>;


=== File: src/core/types/gradient/radial-size.ts ===
// b_path:: src/core/types/gradient/radial-size.ts
import { z } from "zod";
import { lengthPercentageSchema } from "../length-percentage";

/**
 * CSS radial gradient size value.
 *
 * Specifies the size of a radial gradient. Can be a keyword describing
 * the ending shape's size relative to the gradient box, or explicit lengths.
 *
 * Per CSS Images Module Level 3 specification:
 * - closest-side: gradient ends at the side of the box closest to the gradient's center
 * - farthest-side: gradient ends at the side of the box farthest from the gradient's center
 * - closest-corner: gradient ends at the corner of the box closest to the gradient's center
 * - farthest-corner: gradient ends at the corner of the box farthest from the gradient's center (default)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-size-circle}
 *
 * @example
 * ```typescript
 * import { radialGradientSizeSchema } from "../gradient/radial-size";
 *
 * // Keyword size
 * const size1: RadialGradientSize = {
 *   kind: "keyword",
 *   value: "closest-side"
 * };
 *
 * // Explicit circle size (single length)
 * const size2: RadialGradientSize = {
 *   kind: "circle-explicit",
 *   radius: { value: 100, unit: "px" }
 * };
 *
 * // Explicit ellipse size (two length-percentage values)
 * const size3: RadialGradientSize = {
 *   kind: "ellipse-explicit",
 *   radiusX: { value: 50, unit: "%" },
 *   radiusY: { value: 100, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const radialGradientSizeSchema = z.union([
	z.object({
		kind: z.literal("keyword"),
		value: z.union([
			z.literal("closest-side"),
			z.literal("farthest-side"),
			z.literal("closest-corner"),
			z.literal("farthest-corner"),
		]),
	}),
	z.object({
		kind: z.literal("circle-explicit"),
		radius: lengthPercentageSchema.describe("circle radius"),
	}),
	z.object({
		kind: z.literal("ellipse-explicit"),
		radiusX: lengthPercentageSchema.describe("horizontal radius"),
		radiusY: lengthPercentageSchema.describe("vertical radius"),
	}),
]);

/**
 * TypeScript type for radial gradient size.
 *
 * @public
 */
export type RadialGradientSize = z.infer<typeof radialGradientSizeSchema>;


=== File: src/core/types/gradient/radial.ts ===
// b_path:: src/core/types/gradient/radial.ts
import { z } from "zod";
import * as Keyword from "../../keywords";
import { colorStopListSchema } from "../color-stop";
import { position2DSchema } from "../position";
import { radialGradientShapeSchema } from "./radial-shape";
import { radialGradientSizeSchema } from "./radial-size";

/**
 * CSS radial gradient value.
 *
 * A radial gradient transitions colors progressively from a center point (origin)
 * outward in a circular or elliptical pattern. The gradient can have optional shape,
 * size, position, color interpolation method, and must have at least 2 color stops.
 *
 * Per CSS Images Module Level 3 specification.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient}
 * @see {@link https://www.w3.org/TR/css-images-3/#radial-gradients}
 *
 * @example
 * ```typescript
 * import { radialGradientSchema } from "../gradient/radial";
 *
 * // Simple radial gradient (defaults to ellipse at center)
 * const grad1: RadialGradient = {
 *   kind: "radial",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // Circle with keyword size
 * const grad2: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "keyword", value: "closest-side" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // Ellipse at specific position
 * const grad3: RadialGradient = {
 *   kind: "radial",
 *   shape: "ellipse",
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue" }
 *   ],
 *   repeating: false
 * };
 *
 * // With explicit size and color interpolation
 * const grad4: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "circle-explicit", radius: { value: 100, unit: "px" } },
 *   position: { horizontal: "center", vertical: "center" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * };
 *
 * // Repeating radial gradient
 * const grad5: RadialGradient = {
 *   kind: "radial",
 *   shape: "circle",
 *   colorStops: [
 *     { color: "red" },
 *     { color: "blue", position: { value: 20, unit: "px" } }
 *   ],
 *   repeating: true
 * };
 * ```
 *
 * @public
 */
export const radialGradientSchema = z.object({
	kind: z.literal("radial"),
	shape: radialGradientShapeSchema.optional().describe("gradient shape (default: ellipse)"),
	size: radialGradientSizeSchema.optional().describe("gradient size (default: farthest-corner)"),
	position: position2DSchema.optional().describe("gradient center position (default: center)"),
	colorSpace: Keyword.colorInterpolationKeywordsSchema
		.optional()
		.describe("color interpolation method (e.g., oklch, srgb)"),
	colorStops: colorStopListSchema.describe("array of color stops (min 2)"),
	repeating: z.boolean().describe("whether this is a repeating gradient"),
});

/**
 * TypeScript type for radial gradient.
 *
 * @public
 */
export type RadialGradient = z.infer<typeof radialGradientSchema>;


=== File: src/core/types/grid-line.ts ===
// b_path:: src/core/types/grid-line.ts
import { z } from "zod";

/**
 * CSS Grid line value (simple version for Phase 1).
 *
 * Grid line values specify where grid items start and end.
 * This implementation supports:
 * - Integer values (positive, negative, or zero)
 * - The `auto` keyword (browser places item automatically)
 * - Span notation (e.g., `span 2` means span 2 grid tracks)
 *
 * Phase 2 will add support for named grid lines.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/grid-column-start}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Line-based_Placement_with_CSS_Grid}
 *
 * @example
 * ```typescript
 * import { gridLineSchema } from "../types/grid-line";
 *
 * // Integer line number
 * const line1: GridLine = 1;
 * const line2: GridLine = -1; // Last line
 *
 * // Auto keyword
 * const line3: GridLine = "auto";
 *
 * // Span notation
 * const line4: GridLine = { type: "span", value: 2 };
 * ```
 *
 * @public
 */
export const gridLineSchema = z.union([
	z.number().int().describe("integer grid line number (positive, negative, or zero)"),
	z.literal("auto").describe("browser automatically places the item"),
	z
		.object({
			type: z.literal("span"),
			value: z.number().int().positive().describe("number of tracks to span"),
		})
		.describe("span notation (e.g., span 2 means span across 2 tracks)"),
]);

/**
 * TypeScript type for grid line values.
 *
 * @public
 */
export type GridLine = z.infer<typeof gridLineSchema>;

/**
 * Metadata for grid line values.
 *
 * Provides documentation for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { gridLineMetadata } from "../types/grid-line";
 *
 * console.log(gridLineMetadata.description);
 * ```
 *
 * @public
 */
export const gridLineMetadata = {
	description: "Specifies grid line position (integer, auto, or span)",
	syntax: ["<integer>", "auto", "span <integer>"],
	examples: ["1", "-1", "auto", "span 2"],
} as const;

/**
 * Type for grid line metadata.
 *
 * @public
 */
export type GridLineMetadata = typeof gridLineMetadata;


=== File: src/core/types/index.ts ===
// b_path:: src/core/types/index.ts

export * from "./angle";
export * from "./border";
export * from "./color-stop";
export * from "./gradient";
export * from "./grid-line";
export * from "./length-percentage";
export * from "./position";
export * from "./position-layer";
export * from "./ratio";
export * from "./size-layer";


=== File: src/core/types/length-percentage.ts ===
// b_path:: src/core/types/length-percentage.ts
import { z } from "zod";
import * as Unit from "../units";

/**
 * All CSS length unit identifiers.
 *
 * Union of absolute, font-relative, and viewport-relative length units.
 * Per CSS Values & Units Module Level 4 specification.
 *
 * @see {@link https://www.w3.org/TR/css-values-4/#lengths}
 *
 * @internal
 */
const allLengthUnitsSchema = z.union([
	Unit.absoluteLengthUnitSchema,
	Unit.fontLengthUnitSchema,
	Unit.viewportLengthUnitSchema,
]);

/**
 * CSS `<length>` dimension.
 *
 * A length is a distance measurement consisting of a number and a unit.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length}
 *
 * @example
 * ```typescript
 * import { lengthSchema } from "../types/length-percentage";
 *
 * const size: Length = { value: 100, unit: "px" };
 * const fontSize: Length = { value: 1.5, unit: "rem" };
 * ```
 *
 * @public
 */
export const lengthSchema = z.object({
	value: z.number(),
	unit: allLengthUnitsSchema,
});

/**
 * TypeScript type for `<length>` dimension.
 *
 * @public
 */
export type Length = z.infer<typeof lengthSchema>;

/**
 * CSS `<length-percentage>` data type.
 *
 * A type that can accept either a `<length>` or a `<percentage>` value.
 * This is a CSS spec-defined composite type.
 *
 * Per CSS spec: <length-percentage> = <length> | <percentage>
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage}
 *
 * @example
 * ```typescript
 * import { lengthPercentageSchema } from "../types/length-percentage";
 *
 * // Percentage
 * const size1: LengthPercentage = { value: 50, unit: "%" };
 *
 * // Length (px)
 * const size2: LengthPercentage = { value: 100, unit: "px" };
 *
 * // Length (em)
 * const size3: LengthPercentage = { value: 2, unit: "em" };
 * ```
 *
 * @public
 */
export const lengthPercentageSchema = z.union([lengthSchema, Unit.percentageSchema]);

/**
 * TypeScript type for `<length-percentage>` values.
 *
 * @public
 */
export type LengthPercentage = z.infer<typeof lengthPercentageSchema>;

/**
 * CSS `<length-percentage>` with `auto` keyword.
 *
 * Extends `<length-percentage>` to also accept the `auto` keyword.
 * Used in properties like `background-size` where auto is valid.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage}
 *
 * @example
 * ```typescript
 * import { lengthPercentageAutoSchema } from "../types/length-percentage";
 *
 * // Auto keyword
 * const size1: LengthPercentageAuto = "auto";
 *
 * // Percentage
 * const size2: LengthPercentageAuto = { value: 50, unit: "%" };
 *
 * // Length
 * const size3: LengthPercentageAuto = { value: 100, unit: "px" };
 * ```
 *
 * @public
 */
export const lengthPercentageAutoSchema = z.union([z.literal("auto"), lengthPercentageSchema]);

/**
 * TypeScript type for `<length-percentage>` with `auto`.
 *
 * @public
 */
export type LengthPercentageAuto = z.infer<typeof lengthPercentageAutoSchema>;


=== File: src/core/types/position-layer.ts ===
// b_path:: src/core/types/position-layer.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import * as Type from "../types";

/**
 * CSS position value for background positioning.
 *
 * Can be a keyword, length, or percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 * @public
 */
export const backgroundPositionValueSchema = z.union([Keyword.positionKeywordsSchema, Type.lengthPercentageSchema]);

/**
 * TypeScript type for background position value.
 * @public
 */
export type BackgroundPositionValue = z.infer<typeof backgroundPositionValueSchema>;

/**
 * CSS background-position layer value.
 *
 * Represents a single layer value for the background-position property.
 * Supports 1-value, 2-value, and 4-value syntax.
 *
 * Per CSS spec, background-position accepts:
 * - Single keyword: `center` | `left` | `right` | `top` | `bottom`
 * - One value: `<length-percentage>` | keyword
 * - Two values: `<length-percentage> <length-percentage>` | keyword combinations
 * - Four values: `<edge> <length-percentage> <edge> <length-percentage>` (edge offsets)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-position}
 *
 * @example
 * ```typescript
 * import { positionLayerSchema } from "../types/position-layer";
 *
 * // Center keyword
 * const layer1: PositionLayer = { kind: "center" };
 *
 * // One value
 * const layer2: PositionLayer = {
 *   kind: "one-value",
 *   value: { value: 50, unit: "%" }
 * };
 *
 * // Two values
 * const layer3: PositionLayer = {
 *   kind: "two-value",
 *   horizontal: "left",
 *   vertical: { value: 20, unit: "px" }
 * };
 *
 * // Four values (edge offsets)
 * const layer4: PositionLayer = {
 *   kind: "four-value",
 *   horizontalEdge: "right",
 *   horizontalOffset: { value: 10, unit: "px" },
 *   verticalEdge: "bottom",
 *   verticalOffset: { value: 20, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const positionLayerSchema = z.discriminatedUnion("kind", [
	// Center keyword (special case)
	z.object({
		kind: z.literal("center"),
	}),

	// One value: applies to horizontal, vertical is centered (50%)
	z.object({
		kind: z.literal("one-value"),
		value: backgroundPositionValueSchema,
	}),

	// Two values: horizontal vertical
	z.object({
		kind: z.literal("two-value"),
		horizontal: backgroundPositionValueSchema,
		vertical: backgroundPositionValueSchema,
	}),

	// Four values: edge offset pairs
	// Format: <horizontal-edge> <h-offset> <vertical-edge> <v-offset>
	// Example: right 10px bottom 20px
	z.object({
		kind: z.literal("four-value"),
		horizontalEdge: z.literal("left").or(z.literal("right")),
		horizontalOffset: Type.lengthPercentageSchema,
		verticalEdge: z.literal("top").or(z.literal("bottom")),
		verticalOffset: Type.lengthPercentageSchema,
	}),
]);

/**
 * TypeScript type for position layer.
 * @public
 */
export type PositionLayer = z.infer<typeof positionLayerSchema>;

/**
 * CSS position property (reusable across properties).
 *
 * Specifies the position of elements. Used in:
 * - `background-position` - Background image positioning
 * - `object-position` - Replaced element positioning
 * - `transform-origin` - Transform origin positioning
 * - `perspective-origin` - Perspective origin positioning
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionSchema, type Position } from "../types/position-layer";
 *
 * // Single layer
 * const pos1: Position = {
 *   layers: [{ kind: "center" }]
 * };
 *
 * // Multiple layers with different syntaxes
 * const pos2: Position = {
 *   layers: [
 *     { kind: "center" },
 *     { kind: "two-value", horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } },
 *     {
 *       kind: "four-value",
 *       horizontalEdge: "right",
 *       horizontalOffset: { value: 10, unit: "px" },
 *       verticalEdge: "bottom",
 *       verticalOffset: { value: 20, unit: "px" }
 *     }
 *   ]
 * };
 * ```
 *
 * @public
 */
export const positionSchema = z.object({
	layers: z.array(positionLayerSchema).min(1),
});

/**
 * TypeScript type for position property.
 * @public
 */
export type Position = z.infer<typeof positionSchema>;


=== File: src/core/types/position.ts ===
// b_path:: src/core/types/position.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import { lengthPercentageSchema, lengthSchema } from "./length-percentage";

/**
 * CSS position value (single axis).
 *
 * A position value that can be used on a single axis (horizontal or vertical).
 * Used as a building block for 2D position values.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { positionValueSchema } from "../types/position";
 *
 * // Keyword
 * const pos1: PositionValue = "center";
 *
 * // Length
 * const pos2: PositionValue = { value: 100, unit: "px" };
 *
 * // Percentage
 * const pos3: PositionValue = { value: 50, unit: "%" };
 * ```
 *
 * @public
 */
export const positionValueSchema = z.union([Keyword.positionKeywordsSchema, lengthPercentageSchema]);

/**
 * TypeScript type for position value.
 * @public
 */
export type PositionValue = z.infer<typeof positionValueSchema>;

/**
 * CSS 2D position value.
 *
 * A position value that specifies both horizontal and vertical positions.
 * Used in properties like transform-origin, perspective-origin, object-position.
 *
 * Per CSS spec: <position> = [ [ left | center | right | top | bottom | <length-percentage> ] |
 *                            [ left | center | right ] && [ top | center | bottom ] |
 *                            [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] |
 *                            [ [ center | [ left | right ] <length-percentage>? ] &&
 *                              [ center | [ top | bottom ] <length-percentage>? ] ] ]
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/position_value}
 *
 * @example
 * ```typescript
 * import { position2DSchema } from "../types/position";
 *
 * // Keywords
 * const pos1: Position2D = { horizontal: "center", vertical: "center" };
 * const pos2: Position2D = { horizontal: "left", vertical: "top" };
 *
 * // Mixed keywords and values
 * const pos3: Position2D = {
 *   horizontal: { value: 25, unit: "%" },
 *   vertical: "center"
 * };
 *
 * // Both values
 * const pos4: Position2D = {
 *   horizontal: { value: 100, unit: "px" },
 *   vertical: { value: 50, unit: "%" }
 * };
 * ```
 *
 * @public
 */
export const position2DSchema = z.object({
	horizontal: positionValueSchema.describe("horizontal position"),
	vertical: positionValueSchema.describe("vertical position"),
});

/**
 * TypeScript type for 2D position.
 * @public
 */
export type Position2D = z.infer<typeof position2DSchema>;

/**
 * CSS 3D position value.
 *
 * A position value that specifies position in 3D space with x, y, and z coordinates.
 * Used in properties like transform-origin in 3D contexts.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin}
 *
 * @example
 * ```typescript
 * import { position3DSchema } from "../types/position";
 *
 * const pos: Position3D = {
 *   x: { value: 100, unit: "px" },
 *   y: { value: 50, unit: "%" },
 *   z: { value: 10, unit: "px" }
 * };
 * ```
 *
 * @public
 */
export const position3DSchema = z.object({
	x: positionValueSchema.describe("x-axis position"),
	y: positionValueSchema.describe("y-axis position"),
	z: lengthSchema.describe("z-axis position (depth)"),
});

/**
 * TypeScript type for 3D position.
 * @public
 */
export type Position3D = z.infer<typeof position3DSchema>;

/**
 * CSS position list.
 *
 * An array of position values used in properties that accept multiple positions.
 * Common in animation keyframes and multi-position properties.
 *
 * @example
 * ```typescript
 * import { positionListSchema } from "../types/position";
 *
 * const positions: PositionList = [
 *   { horizontal: "left", vertical: "top" },
 *   { horizontal: { value: 50, unit: "%" }, vertical: { value: 50, unit: "%" } },
 *   { horizontal: "right", vertical: "bottom" }
 * ];
 * ```
 *
 * @public
 */
export const positionListSchema = z
	.array(position2DSchema)
	.min(1, "Position list must contain at least 1 position")
	.describe("array of 2D positions for multi-position CSS properties");

/**
 * TypeScript type for position list.
 * @public
 */
export type PositionList = z.infer<typeof positionListSchema>;

/**
 * Common position presets.
 *
 * Predefined positions for common use cases in CSS layout and positioning.
 *
 * @example
 * ```typescript
 * import { COMMON_POSITIONS } from "../types/position";
 *
 * const centerPos = COMMON_POSITIONS.center; // { horizontal: "center", vertical: "center" }
 * const topLeftPos = COMMON_POSITIONS.topLeft; // { horizontal: "left", vertical: "top" }
 * ```
 *
 * @public
 */
export const COMMON_POSITIONS = {
	center: { horizontal: "center" as const, vertical: "center" as const },
	topLeft: { horizontal: "left" as const, vertical: "top" as const },
	topCenter: { horizontal: "center" as const, vertical: "top" as const },
	topRight: { horizontal: "right" as const, vertical: "top" as const },
	middleLeft: { horizontal: "left" as const, vertical: "center" as const },
	middleRight: { horizontal: "right" as const, vertical: "center" as const },
	bottomLeft: { horizontal: "left" as const, vertical: "bottom" as const },
	bottomCenter: { horizontal: "center" as const, vertical: "bottom" as const },
	bottomRight: { horizontal: "right" as const, vertical: "bottom" as const },
} as const;

/**
 * Type for common position presets.
 * @public
 */
export type CommonPositions = typeof COMMON_POSITIONS;


=== File: src/core/types/ratio.ts ===
// b_path:: src/core/types/ratio.ts
import { z } from "zod";

/**
 * CSS ratio value.
 *
 * A ratio consists of two numbers separated by a slash (/).
 * Used in properties like aspect-ratio, resolution, and other ratio-based values.
 *
 * Per CSS spec: <ratio> = <number> [ / <number> ]?
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/ratio}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio}
 *
 * @example
 * ```typescript
 * import { ratioSchema } from "../types/ratio";
 *
 * // Simple ratio
 * const ratio1: Ratio = { numerator: 16, denominator: 9 };
 *
 * // Single number (denominator defaults to 1)
 * const ratio2: Ratio = { numerator: 4, denominator: 3 };
 *
 * // Auto keyword
 * const ratio3: Ratio = "auto";
 * ```
 *
 * @public
 */
export const ratioSchema = z.union([
	// Explicit ratio with numerator and denominator
	z.object({
		numerator: z.number().positive().describe("numerator of the ratio"),
		denominator: z.number().positive().describe("denominator of the ratio"),
	}),

	// Auto keyword for automatic ratio
	z
		.literal("auto")
		.describe("automatic ratio based on content"),
]);

/**
 * TypeScript type for ratio.
 * @public
 */
export type Ratio = z.infer<typeof ratioSchema>;

/**
 * CSS ratio list.
 *
 * An array of ratios used in properties that accept multiple ratios.
 * Common in resolution and aspect-ratio contexts.
 *
 * @example
 * ```typescript
 * import { ratioListSchema } from "../types/ratio";
 *
 * const ratios: RatioList = [
 *   { numerator: 16, denominator: 9 },
 *   { numerator: 4, denominator: 3 },
 *   "auto"
 * ];
 * ```
 *
 * @public
 */
export const ratioListSchema = z
	.array(ratioSchema)
	.min(1, "Ratio list must contain at least 1 ratio")
	.describe("array of ratios for multi-ratio CSS properties");

/**
 * TypeScript type for ratio list.
 * @public
 */
export type RatioList = z.infer<typeof ratioListSchema>;

/**
 * Common aspect ratio presets.
 *
 * Predefined ratios for common use cases like video, images, and design.
 *
 * @example
 * ```typescript
 * import { COMMON_ASPECT_RATIOS } from "../types/ratio";
 *
 * const videoRatio = COMMON_ASPECT_RATIOS["16:9"]; // { numerator: 16, denominator: 9 }
 * const squareRatio = COMMON_ASPECT_RATIOS["1:1"]; // { numerator: 1, denominator: 1 }
 * ```
 *
 * @public
 */
export const COMMON_ASPECT_RATIOS = {
	"21:9": { numerator: 21, denominator: 9 },
	"16:9": { numerator: 16, denominator: 9 },
	"3:2": { numerator: 3, denominator: 2 },
	"4:3": { numerator: 4, denominator: 3 },
	"1:1": { numerator: 1, denominator: 1 },
	"3:4": { numerator: 3, denominator: 4 },
	"2:3": { numerator: 2, denominator: 3 },
	"9:16": { numerator: 9, denominator: 16 },
	"9:21": { numerator: 9, denominator: 21 },
} as const;

/**
 * Type for common aspect ratio presets.
 * @public
 */
export type CommonAspectRatio = typeof COMMON_ASPECT_RATIOS;

/**
 * Helper function to create a ratio from a string.
 *
 * @param ratioString - String in format "numerator:denominator" or "numerator/denominator"
 * @returns Ratio object or null if invalid format
 *
 * @example
 * ```typescript
 * import { createRatioFromString } from "../types/ratio";
 *
 * const ratio1 = createRatioFromString("16:9"); // { numerator: 16, denominator: 9 }
 * const ratio2 = createRatioFromString("4/3"); // { numerator: 4, denominator: 3 }
 * ```
 *
 * @public
 */
export function createRatioFromString(ratioString: string): Ratio | null {
	const colonMatch = ratioString.match(/^(\d+):(\d+)$/);
	const slashMatch = ratioString.match(/^(\d+)\/(\d+)$/);

	if (colonMatch?.[1] && colonMatch?.[2]) {
		const numerator = Number.parseInt(colonMatch[1], 10);
		const denominator = Number.parseInt(colonMatch[2], 10);
		if (numerator > 0 && denominator > 0) {
			return { numerator, denominator };
		}
	}

	if (slashMatch?.[1] && slashMatch?.[2]) {
		const numerator = Number.parseInt(slashMatch[1], 10);
		const denominator = Number.parseInt(slashMatch[2], 10);
		if (numerator > 0 && denominator > 0) {
			return { numerator, denominator };
		}
	}

	return null;
}

/**
 * Helper function to format a ratio as a string.
 *
 * @param ratio - Ratio object
 * @returns Formatted string representation
 *
 * @example
 * ```typescript
 * import { formatRatioAsString } from "../types/ratio";
 *
 * const ratioString = formatRatioAsString({ numerator: 16, denominator: 9 }); // "16:9"
 * ```
 *
 * @public
 */
export function formatRatioAsString(ratio: Ratio): string {
	if (ratio === "auto") {
		return "auto";
	}

	return `${ratio.numerator}:${ratio.denominator}`;
}


=== File: src/core/types/size-layer.ts ===
// b_path:: src/core/types/size-layer.ts
import { z } from "zod";
import * as Keyword from "../keywords";
import * as Type from "../types";

/**
 * CSS size layer value.
 *
 * Represents a single layer value for sizing properties.
 * Can be a sizing keyword, auto, or explicit dimensions.
 *
 * Per CSS spec, size values accept:
 * - Keywords: `cover` | `contain`
 * - Single value: `<length-percentage>` | `auto`
 * - Two values: `<length-percentage>` | `auto` for width and height
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 *
 * @example
 * ```typescript
 * import { sizeLayerSchema } from "../types/size-layer";
 *
 * // Keyword
 * const layer1: SizeLayer = { kind: "keyword", value: "cover" };
 *
 * // Auto
 * const layer2: SizeLayer = { kind: "auto" };
 *
 * // Single value
 * const layer3: SizeLayer = {
 *   kind: "one-value",
 *   value: { value: 50, unit: "%" }
 * };
 *
 * // Two values
 * const layer4: SizeLayer = {
 *   kind: "two-value",
 *   width: { value: 100, unit: "px" },
 *   height: "auto"
 * };
 * ```
 *
 * @public
 */
export const sizeLayerSchema = z.discriminatedUnion("kind", [
	// Sizing keywords: cover, contain
	z.object({
		kind: z.literal("keyword"),
		value: Keyword.sizingKeywordsSchema,
	}),

	// Auto keyword
	z.object({
		kind: z.literal("auto"),
	}),

	// Single value: <length-percentage> or auto
	// Applies to both width and height (maintaining aspect ratio)
	z.object({
		kind: z.literal("one-value"),
		value: Type.lengthPercentageAutoSchema,
	}),

	// Two values: width height
	// Each can be <length-percentage> or auto
	z.object({
		kind: z.literal("two-value"),
		width: Type.lengthPercentageAutoSchema,
		height: Type.lengthPercentageAutoSchema,
	}),
]);

/**
 * TypeScript type for size layer.
 * @public
 */
export type SizeLayer = z.infer<typeof sizeLayerSchema>;

/**
 * CSS size property (reusable across properties).
 *
 * Specifies the size of elements. Used in:
 * - `background-size` - Background image sizing
 * - `object-fit` - Replaced element sizing
 * - `column-size` - Multi-column sizing
 * - `box-size` - Box sizing (future)
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/background-size}
 *
 * @example
 * ```typescript
 * import { sizeSchema, type Size } from "../types/size-layer";
 *
 * // Single keyword
 * const size1: Size = {
 *   layers: [{ kind: "keyword", value: "cover" }]
 * };
 *
 * // Multiple layers
 * const size2: Size = {
 *   layers: [
 *     { kind: "keyword", value: "cover" },
 *     { kind: "two-value", width: { value: 100, unit: "px" }, height: "auto" },
 *     { kind: "keyword", value: "contain" }
 *   ]
 * };
 *
 * // Single value
 * const size3: Size = {
 *   layers: [{ kind: "one-value", value: { value: 50, unit: "%" } }]
 * };
 * ```
 *
 * @public
 */
export const sizeSchema = z.object({
	layers: z.array(sizeLayerSchema).min(1),
});

/**
 * TypeScript type for size property.
 * @public
 */
export type Size = z.infer<typeof sizeSchema>;


=== File: src/core/units/angle.ts ===
// b_path:: src/core/units/angle.ts
import { z } from "zod";

export const angleUnitSchema = z
	.union([
		z.literal("deg").describe("degrees - one full circle is 360deg"),
		z.literal("grad").describe("gradians - one full circle is 400grad"),
		z.literal("rad").describe("radians - one full circle is 2π radians (≈6.2832rad)"),
		z.literal("turn").describe("turns - one full circle is 1turn"),
	])
	.describe(
		"Angle units specify rotation or direction." +
			"Used in transforms, gradients, and other CSS properties requiring angular measurements.",
	);

export const ANGLE_UNITS = angleUnitSchema.options.map((option) => option.value);

export type AngleUnit = z.infer<typeof angleUnitSchema>;

export const angleUnitOptions = angleUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type AngleUnitOptions = typeof angleUnitOptions;


=== File: src/core/units/frequency.ts ===
// b_path:: src/core/units/frequency.ts
import { z } from "zod";

export const frequencyUnitSchema = z
	.union([
		z.literal("Hz").describe("hertz - number of occurrences per second (canonical unit)"),
		z.literal("kHz").describe("kilohertz - 1000 hertz"),
	])
	.describe(
		"Frequency units specify the number of occurrences per second." +
			"Used for sound pitches and other frequency-based CSS properties.",
	);

export const FREQUENCY_UNITS = frequencyUnitSchema.options.map((option) => option.value);

export type FrequencyUnit = z.infer<typeof frequencyUnitSchema>;

export const frequencyUnitOptions = frequencyUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type FrequencyUnitOptions = typeof frequencyUnitOptions;


=== File: src/core/units/index.ts ===
// b_path:: src/core/units/index.ts

export * from "./angle";
export * from "./frequency";
export * from "./length.absolute";
export * from "./length.font";
export * from "./length.viewport";
export * from "./percentage";
export * from "./time";


=== File: src/core/units/length.absolute.ts ===
// b_path:: src/core/units/length.absolute.ts
import { z } from "zod";

/**
 * CSS absolute length unit identifiers.
 *
 * Absolute length units specify a length using physical units.
 * These units are fixed and do not scale relative to other elements.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#absolute_length_units}
 *
 * @example
 * ```typescript
 * import { absoluteLengthUnitSchema } from "../units/length.absolute";
 *
 * const unit = absoluteLengthUnitSchema.parse("px"); // "px"
 * ```
 *
 * @public
 */
export const absoluteLengthUnitSchema = z
	.union([
		z.literal("px").describe("pixels - 1/96th of 1 inch"),
		z.literal("pt").describe("points - 1/72nd of 1 inch"),
		z.literal("cm").describe("centimeters"),
		z.literal("mm").describe("millimeters"),
		z.literal("Q").describe("quarter-millimeters - 1/40th of 1 centimeter"),
		z.literal("in").describe("inches - 2.54 centimeters"),
		z.literal("pc").describe("picas - 12 points"),
	])
	.describe(
		"Absolute length units specify a length using physical units. " +
			"These units are fixed and do not scale relative to other elements.",
	);

/**
 * Array of all absolute length unit values.
 *
 * @example
 * ```typescript
 * import { ABSOLUTE_LENGTH_UNITS } from "../units/length.absolute";
 *
 * console.log(ABSOLUTE_LENGTH_UNITS); // ["px", "pt", "cm", "mm", "Q", "in", "pc"]
 * ```
 *
 * @public
 */
export const ABSOLUTE_LENGTH_UNITS = absoluteLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for absolute length units.
 *
 * @public
 */
export type AbsoluteLengthUnit = z.infer<typeof absoluteLengthUnitSchema>;

/**
 * Metadata for absolute length unit options.
 *
 * Provides value and description for each absolute length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { absoluteLengthUnitOptions } from "../units/length.absolute";
 *
 * absoluteLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const absoluteLengthUnitOptions = absoluteLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for absolute length unit options metadata.
 *
 * @public
 */
export type AbsoluteLengthUnitOptions = typeof absoluteLengthUnitOptions;


=== File: src/core/units/length.font.ts ===
// b_path:: src/core/units/length.font.ts
import { z } from "zod";

/**
 * CSS font-relative length unit identifiers.
 *
 * Font-relative length units specify a length relative to font metrics.
 * These units allow measurements based on typography and text characteristics.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#font-relative_lengths}
 *
 * @example
 * ```typescript
 * import { fontLengthUnitSchema } from "../units/length.font";
 *
 * const unit = fontLengthUnitSchema.parse("em"); // "em"
 * ```
 *
 * @public
 */
export const fontLengthUnitSchema = z
	.union([
		z.literal("em").describe("font size of the element"),
		z.literal("ex").describe("x-height of the element's font"),
		z.literal("cap").describe("cap height of capital letters"),
		z.literal("ch").describe("typical character advance of a narrow glyph"),
		z.literal("ic").describe("typical character advance of a fullwidth glyph"),
		z.literal("rem").describe("font size of the root element"),
		z.literal("rex").describe("x-height of the root element's font"),
		z.literal("rcap").describe("cap height of the root element's font"),
		z.literal("rch").describe("typical character advance of a narrow glyph in root element"),
		z.literal("ric").describe("typical character advance of a fullwidth glyph in root element"),
		z.literal("lh").describe("line height of the element"),
		z.literal("rlh").describe("line height of the root element"),
	])
	.describe(
		"Font-relative length units specify a length relative to font metrics. " +
			"These units allow measurements based on typography and text characteristics.",
	);

/**
 * Array of all font-relative length unit values.
 *
 * @example
 * ```typescript
 * import { FONT_LENGTH_UNITS } from "../units/length.font";
 *
 * console.log(FONT_LENGTH_UNITS); // ["em", "ex", "cap", ...]
 * ```
 *
 * @public
 */
export const FONT_LENGTH_UNITS = fontLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for font-relative length units.
 *
 * @public
 */
export type FontLengthUnit = z.infer<typeof fontLengthUnitSchema>;

/**
 * Metadata for font-relative length unit options.
 *
 * Provides value and description for each font-relative length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { fontLengthUnitOptions } from "../units/length.font";
 *
 * fontLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const fontLengthUnitOptions = fontLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for font-relative length unit options metadata.
 *
 * @public
 */
export type FontLengthUnitOptions = typeof fontLengthUnitOptions;


=== File: src/core/units/length.viewport.ts ===
// b_path:: src/core/units/length.viewport.ts
import { z } from "zod";

/**
 * CSS viewport-percentage length unit identifiers.
 *
 * Viewport-percentage length units are relative to the size of the initial containing block.
 * They provide different sizing strategies for responsive design across various viewport states.
 *
 * Includes default (large), small, large (explicit), and dynamic viewport units.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/length#viewport-percentage_lengths}
 *
 * @example
 * ```typescript
 * import { viewportLengthUnitSchema } from "../units/length.viewport";
 *
 * const unit = viewportLengthUnitSchema.parse("vw"); // "vw"
 * ```
 *
 * @public
 */
export const viewportLengthUnitSchema = z
	.union([
		// Default/Large viewport units
		z
			.literal("vw")
			.describe("1% of the width of the large viewport size"),
		z.literal("vh").describe("1% of the height of the large viewport size"),
		z.literal("vi").describe("1% of the large viewport size in the inline axis"),
		z.literal("vb").describe("1% of the large viewport size in the block axis"),
		z.literal("vmin").describe("smaller of vw or vh"),
		z.literal("vmax").describe("larger of vw or vh"),

		// Small viewport units
		z
			.literal("svw")
			.describe("1% of the width of the small viewport size"),
		z.literal("svh").describe("1% of the height of the small viewport size"),
		z.literal("svi").describe("1% of the small viewport size in the inline axis"),
		z.literal("svb").describe("1% of the small viewport size in the block axis"),
		z.literal("svmin").describe("smaller of svw or svh"),
		z.literal("svmax").describe("larger of svw or svh"),

		// Large viewport units (explicit)
		z
			.literal("lvw")
			.describe("1% of the width of the large viewport size"),
		z.literal("lvh").describe("1% of the height of the large viewport size"),
		z.literal("lvi").describe("1% of the large viewport size in the inline axis"),
		z.literal("lvb").describe("1% of the large viewport size in the block axis"),
		z.literal("lvmin").describe("smaller of lvw or lvh"),
		z.literal("lvmax").describe("larger of lvw or lvh"),

		// Dynamic viewport units
		z
			.literal("dvw")
			.describe("1% of the width of the dynamic viewport size"),
		z.literal("dvh").describe("1% of the height of the dynamic viewport size"),
		z.literal("dvi").describe("1% of the dynamic viewport size in the inline axis"),
		z.literal("dvb").describe("1% of the dynamic viewport size in the block axis"),
		z.literal("dvmin").describe("smaller of dvw or dvh"),
		z.literal("dvmax").describe("larger of dvw or dvh"),
	])
	.describe(
		"Viewport-percentage length units are relative to the size of the initial containing block. " +
			"They provide different sizing strategies for responsive design across various viewport states.",
	);

/**
 * Array of all viewport-percentage length unit values.
 *
 * @example
 * ```typescript
 * import { VIEWPORT_LENGTH_UNITS } from "../units/length.viewport";
 *
 * console.log(VIEWPORT_LENGTH_UNITS); // ["vw", "vh", "vi", ...]
 * ```
 *
 * @public
 */
export const VIEWPORT_LENGTH_UNITS = viewportLengthUnitSchema.options.map((option) => option.value);

/**
 * TypeScript type for viewport-percentage length units.
 *
 * @public
 */
export type ViewportLengthUnit = z.infer<typeof viewportLengthUnitSchema>;

/**
 * Metadata for viewport-percentage length unit options.
 *
 * Provides value and description for each viewport-percentage length unit,
 * useful for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { viewportLengthUnitOptions } from "../units/length.viewport";
 *
 * viewportLengthUnitOptions.forEach(({ value, description }) => {
 *   <Option value={value} description={description} />
 * });
 * ```
 *
 * @public
 */
export const viewportLengthUnitOptions = viewportLengthUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));

/**
 * Type for viewport-percentage length unit options metadata.
 *
 * @public
 */
export type ViewportLengthUnitOptions = typeof viewportLengthUnitOptions;


=== File: src/core/units/percentage.ts ===
// b_path:: src/core/units/percentage.ts
import { z } from "zod";

/**
 * CSS percentage unit identifier.
 *
 * The percentage unit `%` represents a fraction of some reference value.
 * The reference value depends on the property using the percentage.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/percentage}
 *
 * @example
 * ```typescript
 * import { percentageUnitSchema } from "../units/percentage";
 *
 * const unit = percentageUnitSchema.parse("%"); // "%"
 * ```
 *
 * @public
 */
export const percentageUnitSchema = z
	.literal("%")
	.describe("percentage sign - represents a fraction of some reference value");

/**
 * CSS `<percentage>` dimension.
 *
 * A percentage consists of a number followed by the percentage sign (%).
 * May be preceded by + or - sign, with no space between symbol and number.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/percentage}
 *
 * @example
 * ```typescript
 * import { percentageSchema, type Percentage } from "../units/percentage";
 *
 * const size: Percentage = { value: 50, unit: "%" };
 * const opacity: Percentage = { value: 75, unit: "%" };
 *
 * // Validate
 * percentageSchema.parse({ value: 100, unit: "%" }); // Valid
 * ```
 *
 * @public
 */
export const percentageSchema = z
	.object({
		value: z.number().describe("numeric value of the percentage"),
		unit: percentageUnitSchema,
	})
	.describe(
		"Percentage data type consists of a number followed by the percentage sign (%). " +
			"May be preceded by + or - sign, with no space between symbol and number.",
	);

/**
 * Constant for the percentage unit value.
 *
 * @example
 * ```typescript
 * import { PERCENTAGE_UNIT } from "../units/percentage";
 *
 * console.log(PERCENTAGE_UNIT); // "%"
 * ```
 *
 * @public
 */
export const PERCENTAGE_UNIT = percentageUnitSchema.value;

/**
 * TypeScript type for percentage unit.
 *
 * @public
 */
export type PercentageUnit = z.infer<typeof percentageUnitSchema>;

/**
 * TypeScript type for percentage dimension.
 *
 * @public
 */
export type Percentage = z.infer<typeof percentageSchema>;

/**
 * Metadata for percentage unit option.
 *
 * Provides value and description for Studio UI generation.
 *
 * @example
 * ```typescript
 * import { percentageUnitOptions } from "../units/percentage";
 *
 * percentageUnitOptions.forEach(({ value, description }) => {
 *   console.log(`${value}: ${description}`);
 * });
 * ```
 *
 * @public
 */
export const percentageUnitOptions = [
	{
		value: percentageUnitSchema.value,
		description: percentageUnitSchema.description,
	},
];

/**
 * Type for percentage unit options metadata.
 *
 * @public
 */
export type PercentageUnitOptions = typeof percentageUnitOptions;


=== File: src/core/units/time.ts ===
// b_path:: src/core/units/time.ts
import { z } from "zod";

export const timeUnitSchema = z
	.union([
		z.literal("s").describe("seconds - canonical time unit"),
		z.literal("ms").describe("milliseconds - 1000 milliseconds in a second"),
	])
	.describe(
		"Time units specify duration or delay." + "Used in animations, transitions, and other time-based CSS properties.",
	);

export const TIME_UNITS = timeUnitSchema.options.map((option) => option.value);

export type TimeUnit = z.infer<typeof timeUnitSchema>;

export const timeUnitOptions = timeUnitSchema.options.map((option) => ({
	value: option.value,
	description: option.description,
}));
export type TimeUnitOptions = typeof timeUnitOptions;


=== File: src/generate/gradient/color-stop.ts ===
// b_path:: src/generate/gradient/color-stop.ts

import type * as Type from "../../core/types";

/**
 * Generate CSS color stop string from IR.
 *
 * Converts color stop IR into a valid CSS color stop string.
 *
 * @param ir - ColorStop IR object
 * @returns CSS color stop string
 *
 * @public
 *
 * @example
 * ```typescript
 * import * as Gradient from "@/ast/generate/gradient";
 *
 * const css1 = Gradient.ColorStop.toCss({ color: "red" });
 * // Returns: "red"
 *
 * const css2 = Gradient.ColorStop.toCss({
 *   color: "blue",
 *   position: { value: 50, unit: "%" }
 * });
 * // Returns: "blue 50%"
 *
 * const css3 = Gradient.ColorStop.toCss({
 *   color: "rgba(255, 0, 0, 0.5)",
 *   position: { value: 100, unit: "px" }
 * });
 * // Returns: "rgba(255, 0, 0, 0.5) 100px"
 * ```
 */
export function toCss(ir: Type.ColorStop): string {
	if (ir.position) {
		const { value, unit } = ir.position;
		return `${ir.color} ${value}${unit}`;
	}

	return ir.color;
}


=== File: src/generate/gradient/index.ts ===
// b_path:: src/generate/gradient/index.ts

export * as ColorStop from "./color-stop";
export * as Radial from "./radial";


=== File: src/generate/gradient/radial.ts ===
// b_path:: src/generate/gradient/radial.ts

import type * as Type from "../../core/types";
import * as ColorStop from "./color-stop";

/**
 * Generate CSS position string from Position2D IR.
 *
 * @param position - Position2D IR object
 * @returns CSS position string (e.g., "center", "left top", "50% 50%")
 *
 * @internal
 */
function positionToCss(position: Type.Position2D): string {
	const h =
		typeof position.horizontal === "string"
			? position.horizontal
			: `${position.horizontal.value}${position.horizontal.unit}`;
	const v =
		typeof position.vertical === "string" ? position.vertical : `${position.vertical.value}${position.vertical.unit}`;
	return `${h} ${v}`;
}

/**
 * Generate CSS radial gradient size string from IR.
 *
 * @param size - RadialGradientSize IR object
 * @returns CSS size string
 *
 * @internal
 */
function sizeToCss(size: Type.RadialGradientSize): string {
	if (size.kind === "keyword") {
		return size.value;
	}

	if (size.kind === "circle-explicit") {
		return `${size.radius.value}${size.radius.unit}`;
	}

	// ellipse-explicit
	return `${size.radiusX.value}${size.radiusX.unit} ${size.radiusY.value}${size.radiusY.unit}`;
}

/**
 * Generate CSS radial gradient function string from IR.
 *
 * Converts radial gradient IR into a valid CSS radial-gradient() or
 * repeating-radial-gradient() function string.
 *
 * @param ir - RadialGradient IR object
 * @returns CSS gradient function string
 *
 * @public
 *
 * @example
 * ```typescript
 * import * as Gradient from "@/ast/generate/gradient";
 *
 * // Simple gradient
 * const css1 = Gradient.Radial.toCss({
 *   kind: "radial",
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * // Returns: "radial-gradient(red, blue)"
 *
 * // With shape and size
 * const css2 = Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "keyword", value: "closest-side" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * // Returns: "radial-gradient(circle closest-side, red, blue)"
 *
 * // With position
 * const css3 = Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "ellipse",
 *   position: { horizontal: "left", vertical: "top" },
 *   colorStops: [{ color: "red" }, { color: "blue" }],
 *   repeating: false
 * });
 * // Returns: "radial-gradient(ellipse at left top, red, blue)"
 *
 * // With explicit size and color interpolation
 * const css4 = Gradient.Radial.toCss({
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "circle-explicit", radius: { value: 100, unit: "px" } },
 *   position: { horizontal: "center", vertical: "center" },
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: "red", position: { value: 0, unit: "%" } },
 *     { color: "blue", position: { value: 100, unit: "%" } }
 *   ],
 *   repeating: false
 * });
 * // Returns: "radial-gradient(circle 100px at center center in oklch, red 0%, blue 100%)"
 * ```
 */
export function toCss(ir: Type.RadialGradient): string {
	const parts: string[] = [];
	const shapeAndSize: string[] = [];

	// Build shape and size part
	if (ir.shape) {
		shapeAndSize.push(ir.shape);
	}

	if (ir.size) {
		shapeAndSize.push(sizeToCss(ir.size));
	}

	// Combine shape/size with position
	const shapeAndSizeStr = shapeAndSize.join(" ");
	if (ir.position) {
		const posStr = positionToCss(ir.position);
		if (shapeAndSizeStr) {
			parts.push(`${shapeAndSizeStr} at ${posStr}`);
		} else {
			parts.push(`at ${posStr}`);
		}
	} else if (shapeAndSizeStr) {
		parts.push(shapeAndSizeStr);
	}

	// Add color interpolation if present
	if (ir.colorSpace) {
		if (parts.length > 0) {
			// Append to last part without comma
			parts[parts.length - 1] = `${parts[parts.length - 1]} in ${ir.colorSpace}`;
		} else {
			parts.push(`in ${ir.colorSpace}`);
		}
	}

	// Add color stops
	const stopStrings = ir.colorStops.map((stop) => ColorStop.toCss(stop));
	parts.push(...stopStrings);

	// Generate function
	const functionName = ir.repeating ? "repeating-radial-gradient" : "radial-gradient";
	return `${functionName}(${parts.join(", ")})`;
}


=== File: src/generate/index.ts ===
// b_path:: src/generate/index.ts

export * as Gradient from "./gradient";


=== File: src/index.ts ===
// b_path:: src/index.ts

// Core types, units, keywords
export * as Core from "./core";
// Generate IR → CSS
export * as Generate from "./generate";
// Parse CSS → IR
export * as Parse from "./parse";


=== File: src/parse/gradient/color-stop.ts ===
// b_path:: src/parse/gradient/color-stop.ts
import * as csstree from "css-tree";
import { err, ok, type Result } from "../../core/result";
import type * as Type from "../../core/types";

/**
 * Parse color stop from CSS AST nodes.
 *
 * A color stop consists of a color value and an optional position.
 * Per CSS spec: <color-stop> = <color> [ <length-percentage> ]?
 *
 * @param nodes - Array of CSS AST nodes (color and optional position)
 * @returns Result containing ColorStop IR or error message
 *
 * @example
 * ```typescript
 * // Color only: red
 * const result1 = fromNodes([colorNode]);
 *
 * // Color with percentage: red 50%
 * const result2 = fromNodes([colorNode, percentageNode]);
 *
 * // Color with length: blue 100px
 * const result3 = fromNodes([colorNode, lengthNode]);
 * ```
 *
 * @internal
 */
export function fromNodes(nodes: csstree.CssNode[]): Result<Type.ColorStop, string> {
	if (nodes.length === 0) {
		return err("Color stop requires at least a color value");
	}

	const firstNode = nodes[0];
	if (!firstNode) {
		return err("Color stop requires at least a color value");
	}

	// Extract color value
	let color: string;
	try {
		color = csstree.generate(firstNode).toLowerCase();
	} catch (error) {
		return err(`Failed to generate color value: ${error instanceof Error ? error.message : String(error)}`);
	}

	// Check for optional position (second node)
	if (nodes.length >= 2) {
		const posNode = nodes[1];
		if (!posNode) {
			return ok({ color });
		}

		// Parse position as length or percentage
		if (posNode.type === "Percentage") {
			const value = Number.parseFloat(posNode.value);
			return ok({
				color,
				position: { value, unit: "%" },
			});
		}

		if (posNode.type === "Dimension") {
			const value = Number.parseFloat(posNode.value);
			const unit = posNode.unit.toLowerCase();
			// Type assertion needed for unit validation
			return ok({
				color,
				position: { value, unit } as Type.LengthPercentage,
			});
		}

		return err(`Invalid position type: ${posNode.type}`);
	}

	// Color only
	return ok({ color });
}


=== File: src/parse/gradient/index.ts ===
// b_path:: src/parse/gradient/index.ts

export * as ColorStop from "./color-stop";
export * as Radial from "./radial";


=== File: src/parse/gradient/radial.test.ts ===
// b_path:: src/parse/gradient/radial.test.ts

import { describe, expect, it } from "vitest";
import * as RadialGenerator from "../../generate/gradient/radial";
import * as RadialParser from "./radial";

describe("Radial Gradient - Parse & Generate", () => {
	describe("parsing", () => {
		it("should parse simple radial gradient", () => {
			const css = "radial-gradient(red, blue)";
			const result = RadialParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.kind).toBe("radial");
				expect(result.value.repeating).toBe(false);
				expect(result.value.colorStops).toHaveLength(2);
				expect(result.value.colorStops[0]?.color).toBe("red");
				expect(result.value.colorStops[1]?.color).toBe("blue");
			}
		});

		it("should parse radial gradient with shape", () => {
			const css = "radial-gradient(circle, red, blue)";
			const result = RadialParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shape).toBe("circle");
			}
		});

		it("should parse radial gradient with size keyword", () => {
			const css = "radial-gradient(circle closest-side, red, blue)";
			const result = RadialParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.size).toEqual({
					kind: "keyword",
					value: "closest-side",
				});
			}
		});

		it("should parse radial gradient with position", () => {
			const css = "radial-gradient(at center, red, blue)";
			const result = RadialParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.position).toEqual({
					horizontal: "center",
					vertical: "center",
				});
			}
		});

		it("should parse radial gradient with color stops having positions", () => {
			const css = "radial-gradient(red 0%, blue 100%)";
			const result = RadialParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.colorStops[0]?.position).toEqual({
					value: 0,
					unit: "%",
				});
				expect(result.value.colorStops[1]?.position).toEqual({
					value: 100,
					unit: "%",
				});
			}
		});

		it("should parse repeating radial gradient", () => {
			const css = "repeating-radial-gradient(red, blue 20px)";
			const result = RadialParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.repeating).toBe(true);
			}
		});

		it("should parse complex radial gradient", () => {
			const css = "radial-gradient(ellipse farthest-corner at 30% 30%, red 0%, blue 100%)";
			const result = RadialParser.parse(css);

			expect(result.ok).toBe(true);
			if (result.ok) {
				expect(result.value.shape).toBe("ellipse");
				expect(result.value.size).toEqual({
					kind: "keyword",
					value: "farthest-corner",
				});
				expect(result.value.position).toEqual({
					horizontal: { value: 30, unit: "%" },
					vertical: { value: 30, unit: "%" },
				});
			}
		});
	});

	describe("generation", () => {
		it("should generate simple radial gradient", () => {
			const ir = {
				kind: "radial" as const,
				colorStops: [{ color: "red" }, { color: "blue" }],
				repeating: false,
			};

			const css = RadialGenerator.toCss(ir);
			expect(css).toBe("radial-gradient(red, blue)");
		});

		it("should generate radial gradient with shape", () => {
			const ir = {
				kind: "radial" as const,
				shape: "circle" as const,
				colorStops: [{ color: "red" }, { color: "blue" }],
				repeating: false,
			};

			const css = RadialGenerator.toCss(ir);
			expect(css).toBe("radial-gradient(circle, red, blue)");
		});

		it("should generate radial gradient with size", () => {
			const ir = {
				kind: "radial" as const,
				shape: "circle" as const,
				size: { kind: "keyword" as const, value: "closest-side" as const },
				colorStops: [{ color: "red" }, { color: "blue" }],
				repeating: false,
			};

			const css = RadialGenerator.toCss(ir);
			expect(css).toBe("radial-gradient(circle closest-side, red, blue)");
		});

		it("should generate radial gradient with position", () => {
			const ir = {
				kind: "radial" as const,
				position: {
					horizontal: "left" as const,
					vertical: "top" as const,
				},
				colorStops: [{ color: "red" }, { color: "blue" }],
				repeating: false,
			};

			const css = RadialGenerator.toCss(ir);
			expect(css).toBe("radial-gradient(at left top, red, blue)");
		});

		it("should generate repeating radial gradient", () => {
			const ir = {
				kind: "radial" as const,
				colorStops: [{ color: "red" }, { color: "blue", position: { value: 20, unit: "px" as const } }],
				repeating: true,
			};

			const css = RadialGenerator.toCss(ir);
			expect(css).toBe("repeating-radial-gradient(red, blue 20px)");
		});
	});

	describe("round-trip", () => {
		it("should round-trip simple gradient", () => {
			const original = "radial-gradient(red, blue)";
			const parsed = RadialParser.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = RadialGenerator.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("should round-trip gradient with shape and size", () => {
			const original = "radial-gradient(circle closest-side, red, blue)";
			const parsed = RadialParser.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = RadialGenerator.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("should round-trip gradient with position", () => {
			const original = "radial-gradient(at center center, red, blue)";
			const parsed = RadialParser.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = RadialGenerator.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});

		it("should round-trip repeating gradient", () => {
			const original = "repeating-radial-gradient(red, blue 20px)";
			const parsed = RadialParser.parse(original);

			expect(parsed.ok).toBe(true);
			if (parsed.ok) {
				const generated = RadialGenerator.toCss(parsed.value);
				expect(generated).toBe(original);
			}
		});
	});
});


=== File: src/parse/gradient/radial.ts ===
// b_path:: src/parse/gradient/radial.ts
import type * as csstree from "css-tree";
import type * as Type from "@//core/types";
import type * as Keyword from "@/core/keywords";
import { err, ok, type Result } from "@/core/result";
import * as ColorStop from "./color-stop";

/**
 * Parse position from nodes (at keyword followed by position values).
 *
 * Syntax: at <position>
 * Example: at center, at left top, at 50% 50%, at 100px 200px
 *
 * @param nodes - Array of CSS nodes starting with "at" keyword
 * @param startIdx - Index to start parsing from
 * @returns Result with Position2D and next index, or error
 *
 * @internal
 */
function parsePosition(
	nodes: csstree.CssNode[],
	startIdx: number,
): Result<{ position: Type.Position2D; nextIdx: number }, string> {
	let idx = startIdx;

	// Should start with "at" keyword
	const atNode = nodes[idx];
	if (!atNode || atNode.type !== "Identifier" || atNode.name.toLowerCase() !== "at") {
		return err("Expected 'at' keyword for position");
	}
	idx++;

	// Parse position values (1 or 2 values: horizontal and vertical)
	const positionValues: Type.PositionValue[] = [];

	// Collect position value nodes until we hit comma or end
	while (idx < nodes.length) {
		const node = nodes[idx];
		if (!node) break;

		if (node.type === "Operator" && "value" in node && node.value === ",") {
			break;
		}

		if (node.type === "Identifier") {
			const keyword = node.name.toLowerCase();
			// Position keywords
			if (["center", "left", "right", "top", "bottom"].includes(keyword)) {
				positionValues.push(keyword as Type.PositionValue);
				idx++;
			} else {
				break;
			}
		} else if (node.type === "Dimension" || node.type === "Percentage") {
			// Length or percentage value
			const value =
				node.type === "Dimension"
					? { value: Number.parseFloat(node.value), unit: node.unit as "px" | "em" | "rem" | "%" }
					: { value: Number.parseFloat(node.value), unit: "%" as const };
			positionValues.push(value);
			idx++;
		} else {
			break;
		}
	}

	if (positionValues.length === 0) {
		return err("Expected position values after 'at'");
	}

	// Convert 1-2 values into Position2D
	let position: Type.Position2D;

	if (positionValues.length === 1) {
		const val = positionValues[0];
		if (!val) {
			return err("Invalid position value");
		}
		// Single value is treated as horizontal, vertical defaults to center
		if (typeof val === "string") {
			// Keyword: if it's top/bottom, it's vertical; otherwise horizontal
			if (val === "top" || val === "bottom") {
				position = { horizontal: "center", vertical: val };
			} else {
				position = { horizontal: val, vertical: "center" };
			}
		} else {
			position = { horizontal: val, vertical: "center" };
		}
	} else {
		// Two values: horizontal then vertical
		const h = positionValues[0];
		const v = positionValues[1];
		if (!h || !v) {
			return err("Invalid position values");
		}
		position = { horizontal: h, vertical: v };
	}

	return ok({ position, nextIdx: idx });
}

/**
 * Parse radial gradient size from nodes.
 *
 * Handles keyword sizes (closest-side, etc.) and explicit sizes.
 *
 * @param nodes - Array of CSS nodes
 * @param startIdx - Index to start parsing from
 * @param _shape - Shape parameter (reserved for future use)
 * @returns Result with size and next index, or error
 *
 * @internal
 */
function parseSize(
	nodes: csstree.CssNode[],
	startIdx: number,
	_shape?: Type.RadialGradientShape,
): Result<{ size: Type.RadialGradientSize; nextIdx: number }, string> {
	let idx = startIdx;
	const node = nodes[idx];

	if (!node) {
		return err("Expected size value");
	}

	// Check for keyword size
	if (node.type === "Identifier") {
		const keyword = node.name.toLowerCase();
		if (["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(keyword)) {
			return ok({
				size: {
					kind: "keyword",
					value: keyword as "closest-side" | "farthest-side" | "closest-corner" | "farthest-corner",
				},
				nextIdx: idx + 1,
			});
		}
	}

	// Check for explicit size (length or percentage)
	if (node.type === "Dimension" || node.type === "Percentage") {
		const firstValue =
			node.type === "Dimension"
				? { value: Number.parseFloat(node.value), unit: node.unit as "px" | "em" | "rem" | "%" }
				: { value: Number.parseFloat(node.value), unit: "%" as const };

		idx++;

		// Check if there's a second value (for ellipse)
		const nextNode = nodes[idx];
		if (nextNode && (nextNode.type === "Dimension" || nextNode.type === "Percentage")) {
			const secondValue =
				nextNode.type === "Dimension"
					? { value: Number.parseFloat(nextNode.value), unit: nextNode.unit as "px" | "em" | "rem" | "%" }
					: { value: Number.parseFloat(nextNode.value), unit: "%" as const };

			return ok({
				size: {
					kind: "ellipse-explicit",
					radiusX: firstValue,
					radiusY: secondValue,
				},
				nextIdx: idx + 1,
			});
		}

		// Single value - circle
		return ok({
			size: {
				kind: "circle-explicit",
				radius: firstValue,
			},
			nextIdx: idx,
		});
	}

	return err("Invalid size value");
}

/**
 * Parse radial gradient from CSS function AST.
 *
 * Handles radial-gradient() and repeating-radial-gradient() functions.
 * Supports optional shape, size, position, color interpolation, and color stops.
 *
 * Syntax: radial-gradient([ <shape> || <size> ]? [ at <position> ]? [, in <color-space>]?, <color-stop-list>)
 *
 * @param fn - CSS Function AST node
 * @returns Result containing RadialGradient IR or error message
 *
 * @example
 * ```typescript
 * // Parse: radial-gradient(red, blue)
 * // Parse: radial-gradient(circle, red, blue)
 * // Parse: radial-gradient(closest-side, red, blue)
 * // Parse: radial-gradient(circle at center, red, blue)
 * // Parse: radial-gradient(100px at left top, red, blue)
 * // Parse: repeating-radial-gradient(circle, red, blue 20px)
 * ```
 *
 * @internal
 */
export function fromFunction(fn: csstree.FunctionNode): Result<Type.RadialGradient, string> {
	const functionName = fn.name.toLowerCase();
	const isRepeating = functionName === "repeating-radial-gradient";

	if (!isRepeating && functionName !== "radial-gradient") {
		return err(`Expected radial-gradient or repeating-radial-gradient, got: ${functionName}`);
	}

	// Get all children nodes
	const children = fn.children.toArray();
	if (children.length === 0) {
		return err("radial-gradient requires at least 2 color stops");
	}

	let shape: Type.RadialGradientShape | undefined;
	let size: Type.RadialGradientSize | undefined;
	let position: Type.Position2D | undefined;
	let colorSpace: Keyword.ColorInterpolationKeyword | undefined;
	const colorStopNodes: csstree.CssNode[][] = [];
	let currentStopNodes: csstree.CssNode[] = [];

	let idx = 0;

	// Parse optional shape and/or size
	const firstNode = children[idx];
	if (firstNode?.type === "Identifier") {
		const keyword = firstNode.name.toLowerCase();

		// Check for shape keyword
		if (keyword === "circle" || keyword === "ellipse") {
			shape = keyword;
			idx++;

			// Check for size after shape
			const nextNode = children[idx];
			if (nextNode && nextNode.type !== "Identifier") {
				// Could be explicit size
				const sizeResult = parseSize(children, idx, shape);
				if (sizeResult.ok) {
					size = sizeResult.value.size;
					idx = sizeResult.value.nextIdx;
				}
			} else if (
				nextNode?.type === "Identifier" &&
				["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(nextNode.name.toLowerCase())
			) {
				// Keyword size
				const sizeResult = parseSize(children, idx, shape);
				if (sizeResult.ok) {
					size = sizeResult.value.size;
					idx = sizeResult.value.nextIdx;
				}
			}
		}
		// Check for size keyword without shape
		else if (["closest-side", "farthest-side", "closest-corner", "farthest-corner"].includes(keyword)) {
			const sizeResult = parseSize(children, idx);
			if (sizeResult.ok) {
				size = sizeResult.value.size;
				idx = sizeResult.value.nextIdx;
			}
		}
	}
	// Check for explicit size without shape keyword
	else if (firstNode && (firstNode.type === "Dimension" || firstNode.type === "Percentage")) {
		const sizeResult = parseSize(children, idx);
		if (sizeResult.ok) {
			size = sizeResult.value.size;
			idx = sizeResult.value.nextIdx;
		}
	}

	// Parse optional position: "at <position>"
	const atNode = children[idx];
	if (atNode?.type === "Identifier" && atNode.name.toLowerCase() === "at") {
		const posResult = parsePosition(children, idx);
		if (posResult.ok) {
			position = posResult.value.position;
			idx = posResult.value.nextIdx;
		}
	}

	// Skip comma after shape/size/position if present
	const commaNode = children[idx];
	if (commaNode && commaNode.type === "Operator" && "value" in commaNode && commaNode.value === ",") {
		idx++;
	}

	// Parse optional color interpolation: "in <color-space>"
	if (idx < children.length) {
		const node = children[idx];
		if (node?.type === "Identifier" && node.name.toLowerCase() === "in") {
			idx++;
			const spaceNode = children[idx];
			if (spaceNode?.type === "Identifier") {
				const space = spaceNode.name.toLowerCase();
				// Validate it's a valid color space keyword
				const validSpaces = [
					"srgb",
					"srgb-linear",
					"display-p3",
					"display-p3-linear",
					"a98-rgb",
					"prophoto-rgb",
					"rec2020",
					"lab",
					"oklab",
					"xyz",
					"xyz-d50",
					"xyz-d65",
					"hsl",
					"hwb",
					"lch",
					"oklch",
					"shorter",
					"longer",
					"increasing",
					"decreasing",
				];
				if (validSpaces.includes(space)) {
					colorSpace = space as Keyword.ColorInterpolationKeyword;
					idx++;
				}
			}

			// Skip comma after color space if present
			const spaceCommaNode = children[idx];
			if (
				spaceCommaNode &&
				spaceCommaNode.type === "Operator" &&
				"value" in spaceCommaNode &&
				spaceCommaNode.value === ","
			) {
				idx++;
			}
		}
	}

	// Parse color stops (remaining arguments, comma-separated)
	for (; idx < children.length; idx++) {
		const node = children[idx];
		if (!node) continue;

		if (node.type === "Operator" && "value" in node && node.value === ",") {
			// End of current color stop, start new one
			if (currentStopNodes.length > 0) {
				colorStopNodes.push(currentStopNodes);
				currentStopNodes = [];
			}
		} else {
			currentStopNodes.push(node);
		}
	}

	// Push last color stop
	if (currentStopNodes.length > 0) {
		colorStopNodes.push(currentStopNodes);
	}

	// Parse each color stop
	const colorStops: Type.ColorStop[] = [];
	for (const stopNodes of colorStopNodes) {
		const stopResult = ColorStop.fromNodes(stopNodes);
		if (stopResult.ok) {
			colorStops.push(stopResult.value);
		} else {
			return err(`Invalid color stop: ${stopResult.error}`);
		}
	}

	if (colorStops.length < 2) {
		return err("radial-gradient requires at least 2 color stops");
	}

	return ok({
		kind: "radial",
		shape,
		size,
		position,
		colorSpace,
		colorStops,
		repeating: isRepeating,
	});
}

/**
 * Parse CSS radial gradient string to IR.
 *
 * Convenience wrapper that parses a CSS string containing a radial gradient.
 *
 * @param css - CSS string containing radial-gradient() function
 * @returns Result with RadialGradient IR or error message
 *
 * @public
 *
 * @example
 * ```typescript
 * import * as Radial from "./parse/gradient/radial";
 *
 * const result = Radial.parse("radial-gradient(red, blue)");
 * if (result.ok) {
 *   console.log(result.value.colorStops);
 * }
 * ```
 */
export function parse(css: string): Result<Type.RadialGradient, string> {
	const csstree = require("css-tree");

	try {
		// Parse as a value
		const ast = csstree.parse(css, { context: "value" });

		// Find the function node
		let funcNode: csstree.FunctionNode | null = null;
		csstree.walk(ast, {
			visit: "Function",
			enter(node: csstree.FunctionNode) {
				if (node.name === "radial-gradient" || node.name === "repeating-radial-gradient") {
					funcNode = node;
				}
			},
		});

		if (!funcNode) {
			return err("No radial-gradient function found in CSS string");
		}

		return fromFunction(funcNode);
	} catch (e) {
		return err(`Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`);
	}
}


=== File: src/parse/index.ts ===
// b_path:: src/parse/index.ts

export * as Gradient from "./gradient";


