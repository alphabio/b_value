Excluding patterns: 
Documentation for LLMs
Excluding patterns: 
Excluding patterns: -not -path */__pycache__/* -not -path */.venv/* -not -path */.next/* -not -path */venv/* -not -path */node_modules/* -not -path */build/* -not -path */dist/* -not -path */.git/* -not -path */.idea/* -not -path */.vscode/*
=== File: src/index.ts ===
// b_path:: src/index.ts
export * from "./types";
export * from "./utils";


=== File: src/types/index.ts ===
// b_path:: src/types/index.ts
export * from "./schemas";


=== File: src/types/schemas.ts ===
// b_path:: src/types/schemas.ts
import { z } from "zod";

/**
 * Zod-First Class Schema Examples
 *
 * This file demonstrates the Zod-First Class pattern for schema-driven development.
 * All schemas are defined first, then types are derived using z.infer<typeof Schema>.
 */

// ==================== Basic Schemas ====================

/**
 * User status enumeration schema
 */
export const UserStatusSchema = z.enum(["active", "inactive", "pending", "suspended"]);

/**
 * User role schema with union type
 */
export const UserRoleSchema = z.enum(["admin", "moderator", "user", "guest"]);

/**
 * Email validation schema
 */
export const EmailSchema = z.string().email("Invalid email format");

/**
 * Phone number schema (basic validation)
 */
export const PhoneSchema = z.string().regex(/^\+?[\d\s\-()]+$/, "Invalid phone number format");

// ==================== Complex Object Schemas ====================

/**
 * User profile schema - demonstrates nested objects and optional fields
 */
export const UserProfileSchema = z.object({
	id: z.number().positive("ID must be positive"),
	email: EmailSchema,
	firstName: z.string().min(1, "First name is required").max(50, "First name too long"),
	lastName: z.string().min(1, "Last name is required").max(50, "Last name too long"),
	status: UserStatusSchema,
	role: UserRoleSchema,
	avatar: z.string().url("Avatar must be a valid URL").optional(),
	phone: PhoneSchema.optional(),
	createdAt: z.string().datetime("Invalid creation date"),
	updatedAt: z.string().datetime("Invalid update date"),
	preferences: z
		.object({
			theme: z.enum(["light", "dark", "auto"]).default("auto"),
			notifications: z.boolean().default(true),
			language: z.string().default("en"),
		})
		.optional(),
});

/**
 * Address schema - demonstrates optional nested objects
 */
export const AddressSchema = z.object({
	street: z.string().min(1, "Street address is required"),
	city: z.string().min(1, "City is required"),
	state: z.string().min(2, "State must be at least 2 characters").max(50, "State too long"),
	zipCode: z.string().regex(/^\d{5}(-\d{4})?$/, "Invalid ZIP code format"),
	country: z.string().length(2, "Country must be 2-letter code (e.g., US, CA)"),
});

/**
 * Complete user schema with optional address
 */
export const UserSchema = UserProfileSchema.extend({
	addresses: z.array(AddressSchema).optional(),
	metadata: z.record(z.string(), z.unknown()).optional(),
});

// ==================== API Schemas ====================

/**
 * Pagination parameters schema
 */
export const PaginationParamsSchema = z.object({
	page: z.number().min(1, "Page must be at least 1").default(1),
	limit: z.number().min(1, "Limit must be at least 1").max(100, "Limit cannot exceed 100").default(10),
	sortBy: z.string().optional(),
	sortOrder: z.enum(["asc", "desc"]).default("asc"),
});

/**
 * API response wrapper schema
 */
export const ApiResponseSchema = <T extends z.ZodType>(dataSchema: T) =>
	z.object({
		data: dataSchema,
		message: z.string().optional(),
		success: z.boolean(),
		timestamp: z.string().datetime(),
		errors: z.array(z.string()).optional(),
	});

// ==================== Utility Schemas ====================

/**
 * Range schema for numeric validation
 */
export const RangeSchema = (min: number, max: number) =>
	z.number().min(min, `Value must be at least ${min}`).max(max, `Value must be at most ${max}`);

/**
 * Non-empty string schema
 */
export const NonEmptyStringSchema = z.string().min(1, "String cannot be empty");

/**
 * UUID schema
 */
export const UUIDSchema = z.string().uuid("Invalid UUID format");

/**
 * URL schema with optional protocol validation
 */
export const URLSchema = z.string().url("Invalid URL format");

// ==================== Derived Types (Zod-First) ====================

/**
 * All types are derived from schemas using z.infer
 * This ensures type safety and consistency with runtime validation
 */

// Basic derived types
export type UserStatus = z.infer<typeof UserStatusSchema>;
export type UserRole = z.infer<typeof UserRoleSchema>;
export type Email = z.infer<typeof EmailSchema>;
export type Phone = z.infer<typeof PhoneSchema>;

// Complex object types
export type UserProfile = z.infer<typeof UserProfileSchema>;
export type Address = z.infer<typeof AddressSchema>;
export type User = z.infer<typeof UserSchema>;

// API types
export type PaginationParams = z.infer<typeof PaginationParamsSchema>;
export type ApiResponse<T> = {
	data: T;
	message?: string;
	success: boolean;
	timestamp: string;
	errors?: string[];
};

// Utility types
export type Range = z.infer<ReturnType<typeof RangeSchema>>;
export type NonEmptyString = z.infer<typeof NonEmptyStringSchema>;
export type UUID = z.infer<typeof UUIDSchema>;
export type URL = z.infer<typeof URLSchema>;

// ==================== Schema Exports for Consumers ====================

/**
 * Export schemas for runtime validation
 * Consumers can use these for their own validation needs
 */
export {
	UserStatusSchema as userStatusSchema,
	UserRoleSchema as userRoleSchema,
	EmailSchema as emailSchema,
	PhoneSchema as phoneSchema,
	UserProfileSchema as userProfileSchema,
	AddressSchema as addressSchema,
	UserSchema as userSchema,
	PaginationParamsSchema as paginationParamsSchema,
	ApiResponseSchema as apiResponseSchema,
	RangeSchema as rangeSchema,
	NonEmptyStringSchema as nonEmptyStringSchema,
	UUIDSchema as uuidSchema,
	URLSchema as urlSchema,
};

// ==================== Validation Helper Functions ====================

/**
 * Type-safe validation helper
 * @param schema - Zod schema to validate against
 * @param data - Data to validate
 * @returns Parsed data or throws validation error
 */
export function validate<T>(schema: z.ZodSchema<T>, data: unknown): T {
	return schema.parse(data);
}

/**
 * Safe validation helper (doesn't throw)
 * @param schema - Zod schema to validate against
 * @param data - Data to validate
 * @returns Result object with success/error
 */
export function safeValidate<T>(schema: z.ZodSchema<T>, data: unknown) {
	const result = schema.safeParse(data);
	return result;
}

/**
 * Create API response schema for specific data type
 * @param dataSchema - Schema for the response data
 * @returns Complete API response schema
 */
export function createApiResponseSchema<T extends z.ZodType>(dataSchema: T) {
	return ApiResponseSchema(dataSchema);
}


=== File: src/utils/index.ts ===
// b_path:: src/utils/index.ts
export * from "./math";
export * from "./string";


=== File: src/utils/math.test.ts ===
// b_path:: src/utils/math.test.ts
import { describe, expect, it } from "vitest";
import { add, divide, multiply, subtract } from "./math";

describe("Math Utilities", () => {
	describe("add", () => {
		it("should add two positive numbers correctly", () => {
			expect(add(2, 3)).toBe(5);
			expect(add(10, 15)).toBe(25);
			expect(add(0.1, 0.2)).toBeCloseTo(0.3);
		});

		it("should add negative numbers correctly", () => {
			expect(add(-2, -3)).toBe(-5);
			expect(add(-10, 5)).toBe(-5);
			expect(add(10, -5)).toBe(5);
		});

		it("should handle zero correctly", () => {
			expect(add(0, 0)).toBe(0);
			expect(add(0, 5)).toBe(5);
			expect(add(5, 0)).toBe(5);
		});

		it("should handle decimal numbers correctly", () => {
			expect(add(1.5, 2.5)).toBe(4);
			expect(add(0.1, 0.2)).toBeCloseTo(0.3);
			expect(add(-1.5, 1.5)).toBe(0);
		});

		it("should handle large numbers correctly", () => {
			expect(add(1000000, 2000000)).toBe(3000000);
			expect(add(Number.MAX_SAFE_INTEGER, 0)).toBe(Number.MAX_SAFE_INTEGER);
		});
	});

	describe("subtract", () => {
		it("should subtract two positive numbers correctly", () => {
			expect(subtract(5, 3)).toBe(2);
			expect(subtract(10, 5)).toBe(5);
			expect(subtract(100, 50)).toBe(50);
		});

		it("should subtract negative numbers correctly", () => {
			expect(subtract(-5, -3)).toBe(-2);
			expect(subtract(-10, 5)).toBe(-15);
			expect(subtract(10, -5)).toBe(15);
		});

		it("should handle zero correctly", () => {
			expect(subtract(0, 0)).toBe(0);
			expect(subtract(0, 5)).toBe(-5);
			expect(subtract(5, 0)).toBe(5);
		});

		it("should handle decimal numbers correctly", () => {
			expect(subtract(2.5, 1.5)).toBe(1);
			expect(subtract(0.3, 0.1)).toBeCloseTo(0.2);
			expect(subtract(-1.5, 1.5)).toBe(-3);
		});

		it("should handle large numbers correctly", () => {
			expect(subtract(2000000, 1000000)).toBe(1000000);
			expect(subtract(Number.MAX_SAFE_INTEGER, 1)).toBe(Number.MAX_SAFE_INTEGER - 1);
		});
	});

	describe("multiply", () => {
		it("should multiply two positive numbers correctly", () => {
			expect(multiply(2, 3)).toBe(6);
			expect(multiply(10, 5)).toBe(50);
			expect(multiply(7, 8)).toBe(56);
		});

		it("should multiply negative numbers correctly", () => {
			expect(multiply(-2, -3)).toBe(6);
			expect(multiply(-10, 5)).toBe(-50);
			expect(multiply(10, -5)).toBe(-50);
		});

		it("should handle zero correctly", () => {
			expect(multiply(0, 0)).toBe(0);
			expect(multiply(0, 5)).toBe(0);
			expect(multiply(5, 0)).toBe(0);
		});

		it("should handle decimal numbers correctly", () => {
			expect(multiply(1.5, 2)).toBe(3);
			expect(multiply(0.1, 0.2)).toBeCloseTo(0.02);
			expect(multiply(-1.5, 2)).toBe(-3);
		});

		it("should handle large numbers correctly", () => {
			expect(multiply(1000, 1000)).toBe(1000000);
			expect(multiply(Number.MAX_SAFE_INTEGER, 1)).toBe(Number.MAX_SAFE_INTEGER);
		});

		it("should handle fractional results correctly", () => {
			expect(multiply(0.5, 0.5)).toBe(0.25);
			expect(multiply(1 / 3, 3)).toBeCloseTo(1);
		});
	});

	describe("divide", () => {
		it("should divide two positive numbers correctly", () => {
			expect(divide(6, 3)).toBe(2);
			expect(divide(10, 5)).toBe(2);
			expect(divide(100, 4)).toBe(25);
		});

		it("should divide negative numbers correctly", () => {
			expect(divide(-6, -3)).toBe(2);
			expect(divide(-10, 5)).toBe(-2);
			expect(divide(10, -5)).toBe(-2);
		});

		it("should handle decimal results correctly", () => {
			expect(divide(5, 2)).toBe(2.5);
			expect(divide(1, 3)).toBeCloseTo(0.3333333333333333);
			expect(divide(0.1, 0.2)).toBeCloseTo(0.5);
		});

		it("should handle division by 1 correctly", () => {
			expect(divide(5, 1)).toBe(5);
			expect(divide(-5, 1)).toBe(-5);
			expect(divide(0, 1)).toBe(0);
		});

		it("should handle large numbers correctly", () => {
			expect(divide(1000000, 1000)).toBe(1000);
			expect(divide(Number.MAX_SAFE_INTEGER, 1)).toBe(Number.MAX_SAFE_INTEGER);
		});

		it("should throw error when dividing by zero", () => {
			expect(() => divide(5, 0)).toThrow("Division by zero is not allowed");
			expect(() => divide(-5, 0)).toThrow("Division by zero is not allowed");
			expect(() => divide(0, 0)).toThrow("Division by zero is not allowed");
		});

		it("should handle very small numbers correctly", () => {
			expect(divide(1, 1000000)).toBe(0.000001);
			expect(divide(0.000001, 1)).toBe(0.000001);
		});
	});
});


=== File: src/utils/math.ts ===
// b_path:: src/utils/math.ts
/**
 * Math utility functions
 */

/**
 * Add two numbers
 * @param a - First number
 * @param b - Second number
 * @returns Sum of a and b
 */
export function add(a: number, b: number): number {
	return a + b;
}

/**
 * Subtract two numbers
 * @param a - First number
 * @param b - Second number
 * @returns Difference of a and b
 */
export function subtract(a: number, b: number): number {
	return a - b;
}

/**
 * Multiply two numbers
 * @param a - First number
 * @param b - Second number
 * @returns Product of a and b
 */
export function multiply(a: number, b: number): number {
	return a * b;
}

/**
 * Divide two numbers
 * @param a - Dividend
 * @param b - Divisor
 * @returns Quotient of a and b
 * @throws Error if divisor is zero
 */
export function divide(a: number, b: number): number {
	if (b === 0) {
		throw new Error("Division by zero is not allowed");
	}
	return a / b;
}


=== File: src/utils/string.test.ts ===
// b_path:: src/utils/string.test.ts
import { describe, expect, it } from "vitest";
import { camelCase, capitalize, kebabCase, truncate } from "./string";

describe("String Utilities", () => {
	describe("capitalize", () => {
		it("should capitalize the first letter of a lowercase string", () => {
			expect(capitalize("hello")).toBe("Hello");
			expect(capitalize("world")).toBe("World");
			expect(capitalize("typescript")).toBe("Typescript");
		});

		it("should handle already capitalized strings", () => {
			expect(capitalize("Hello")).toBe("Hello");
			expect(capitalize("WORLD")).toBe("World");
			expect(capitalize("TypeScript")).toBe("Typescript");
		});

		it("should handle mixed case strings", () => {
			expect(capitalize("hELLO")).toBe("Hello");
			expect(capitalize("WorLD")).toBe("World");
		});

		it("should handle empty string", () => {
			expect(capitalize("")).toBe("");
		});

		it("should handle single character strings", () => {
			expect(capitalize("a")).toBe("A");
			expect(capitalize("Z")).toBe("Z");
		});

		it("should handle strings with numbers and special characters", () => {
			expect(capitalize("hello123")).toBe("Hello123");
			expect(capitalize("test-world")).toBe("Test-world");
			expect(capitalize("hello world")).toBe("Hello world");
		});

		it("should handle unicode characters", () => {
			expect(capitalize("ñoño")).toBe("Ñoño");
			expect(capitalize("αβγ")).toBe("Αβγ");
		});
	});

	describe("camelCase", () => {
		it("should convert space-separated words to camelCase", () => {
			expect(camelCase("hello world")).toBe("helloWorld");
			expect(camelCase("foo bar baz")).toBe("fooBarBaz");
			expect(camelCase("test case")).toBe("testCase");
		});

		it("should not convert hyphen-separated words to camelCase", () => {
			expect(camelCase("hello-world")).toBe("hello-World");
			expect(camelCase("foo-bar-baz")).toBe("foo-Bar-Baz");
		});

		it("should not convert underscore-separated words to camelCase", () => {
			expect(camelCase("hello_world")).toBe("hello_world");
			expect(camelCase("foo_bar_baz")).toBe("foo_bar_baz");
		});

		it("should handle mixed separators", () => {
			expect(camelCase("hello-world_test")).toBe("hello-World_test");
			expect(camelCase("foo bar-baz_test")).toBe("fooBar-Baz_test");
		});

		it("should handle already camelCase strings", () => {
			expect(camelCase("helloWorld")).toBe("helloWorld");
			expect(camelCase("fooBarBaz")).toBe("fooBarBaz");
		});

		it("should handle empty string", () => {
			expect(camelCase("")).toBe("");
		});

		it("should handle single word", () => {
			expect(camelCase("hello")).toBe("hello");
			expect(camelCase("WORLD")).toBe("wORLD");
		});

		it("should handle strings with numbers", () => {
			expect(camelCase("test 123 case")).toBe("test123Case");
			expect(camelCase("hello-world-123")).toBe("hello-World-123");
		});

		it("should handle multiple consecutive separators", () => {
			expect(camelCase("hello  world")).toBe("helloWorld");
			expect(camelCase("foo--bar")).toBe("foo--Bar");
			expect(camelCase("baz__test")).toBe("baz__test");
		});

		it("should handle leading/trailing separators", () => {
			expect(camelCase(" hello world")).toBe("helloWorld");
			expect(camelCase("hello world ")).toBe("helloWorld");
			expect(camelCase("-hello-world-")).toBe("-Hello-World-");
		});
	});

	describe("kebabCase", () => {
		it("should convert space-separated words to kebab-case", () => {
			expect(kebabCase("hello world")).toBe("hello-world");
			expect(kebabCase("foo bar baz")).toBe("foo-bar-baz");
			expect(kebabCase("test case")).toBe("test-case");
		});

		it("should convert camelCase to kebab-case", () => {
			expect(kebabCase("helloWorld")).toBe("hello-world");
			expect(kebabCase("fooBarBaz")).toBe("foo-bar-baz");
			expect(kebabCase("testCase")).toBe("test-case");
		});

		it("should convert underscore-separated words to kebab-case", () => {
			expect(kebabCase("hello_world")).toBe("hello-world");
			expect(kebabCase("foo_bar_baz")).toBe("foo-bar-baz");
		});

		it("should handle mixed separators", () => {
			expect(kebabCase("hello world_test")).toBe("hello-world-test");
			expect(kebabCase("foo-bar baz_test")).toBe("foo-bar-baz-test");
		});

		it("should handle already kebab-case strings", () => {
			expect(kebabCase("hello-world")).toBe("hello-world");
			expect(kebabCase("foo-bar-baz")).toBe("foo-bar-baz");
		});

		it("should handle empty string", () => {
			expect(kebabCase("")).toBe("");
		});

		it("should handle single word", () => {
			expect(kebabCase("hello")).toBe("hello");
			expect(kebabCase("WORLD")).toBe("world");
		});

		it("should handle strings with numbers", () => {
			expect(kebabCase("testCase123")).toBe("test-case123");
			expect(kebabCase("hello world 123")).toBe("hello-world-123");
		});

		it("should handle multiple consecutive separators", () => {
			expect(kebabCase("hello  world")).toBe("hello-world");
			expect(kebabCase("foo__bar")).toBe("foo-bar");
			expect(kebabCase("baz--test")).toBe("baz--test");
		});

		it("should handle leading/trailing separators", () => {
			expect(kebabCase(" hello world")).toBe("hello-world");
			expect(kebabCase("hello world ")).toBe("hello-world");
			expect(kebabCase("-hello-world-")).toBe("-hello-world-");
		});

		it("should convert uppercase letters correctly", () => {
			expect(kebabCase("HelloWorld")).toBe("hello-world");
			expect(kebabCase("XMLHttpRequest")).toBe("xmlhttp-request");
		});
	});

	describe("truncate", () => {
		it("should truncate string longer than specified length", () => {
			expect(truncate("hello world", 5)).toBe("he...");
			expect(truncate("typescript", 4)).toBe("t...");
			expect(truncate("hello world this is a long string", 10)).toBe("hello w...");
		});

		it("should not truncate string shorter than or equal to specified length", () => {
			expect(truncate("hello", 5)).toBe("hello");
			expect(truncate("hello", 10)).toBe("hello");
			expect(truncate("hi", 2)).toBe("hi");
		});

		it("should use custom suffix", () => {
			expect(truncate("hello world", 5, "***")).toBe("he***");
			expect(truncate("typescript", 4, ">>")).toBe("ty>>");
			expect(truncate("hello world this is a long string", 10, "...more")).toBe("hel...more");
		});

		it("should handle empty string", () => {
			expect(truncate("", 5)).toBe("");
			expect(truncate("", 0)).toBe("");
		});

		it("should handle zero length", () => {
			expect(truncate("hello world", 0)).toBe("hello wo...");
			expect(truncate("test", 0, "***")).toBe("t***");
		});

		it("should handle suffix longer than length", () => {
			expect(truncate("hello world", 2)).toBe("hello worl...");
			expect(truncate("test", 1)).toBe("te...");
		});

		it("should handle exact length match with suffix", () => {
			expect(truncate("hello", 2)).toBe("hell...");
			expect(truncate("test", 1)).toBe("te...");
		});

		it("should handle unicode characters", () => {
			expect(truncate("héllo wörld", 5)).toBe("hé...");
			expect(truncate("αβγδε", 3)).toBe("...");
		});

		it("should handle strings with special characters", () => {
			expect(truncate("hello-world!", 5)).toBe("he...");
			expect(truncate("test@example.com", 8)).toBe("test@...");
		});

		it("should handle very long strings", () => {
			const longString = "a".repeat(1000);
			expect(truncate(longString, 10)).toBe(`${"a".repeat(7)}...`);
			expect(truncate(longString, 100)).toBe(`${"a".repeat(97)}...`);
		});
	});
});


=== File: src/utils/string.ts ===
// b_path:: src/utils/string.ts
/**
 * String utility functions
 */

/**
 * Capitalize the first letter of a string
 * @param str - String to capitalize
 * @returns Capitalized string
 */
export function capitalize(str: string): string {
	if (!str) return str;
	return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

/**
 * Convert string to camelCase
 * @param str - String to convert
 * @returns camelCase string
 */
export function camelCase(str: string): string {
	return str
		.trim()
		.replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => {
			return index === 0 ? word.toLowerCase() : word.toUpperCase();
		})
		.replace(/\s+/g, "");
}

/**
 * Convert string to kebab-case
 * @param str - String to convert
 * @returns kebab-case string
 */
export function kebabCase(str: string): string {
	return str
		.trim()
		.replace(/([a-z])([A-Z])/g, "$1-$2")
		.replace(/[\s_]+/g, "-")
		.toLowerCase();
}

/**
 * Truncate string to specified length
 * @param str - String to truncate
 * @param length - Maximum length
 * @param suffix - Suffix to add when truncated (default: '...')
 * @returns Truncated string
 */
export function truncate(str: string, length: number, suffix: string = "..."): string {
	if (str.length <= length) return str;
	return str.slice(0, length - suffix.length) + suffix;
}


